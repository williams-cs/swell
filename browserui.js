(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Scope_1 = require("./lib/structural/Scope");
exports.Scope = Scope_1.Scope;
/* BINARY OPS */
var AssignOp_1 = require("./lib/binops/AssignOp");
exports.AssignOp = AssignOp_1.AssignOp;
var BinaryOperation_1 = require("./lib/binops/BinaryOperation");
exports.BinaryOperation = BinaryOperation_1.BinaryOperation;
var DivOp_1 = require("./lib/binops/DivOp");
exports.DivOp = DivOp_1.DivOp;
var MinusOp_1 = require("./lib/binops/MinusOp");
exports.MinusOp = MinusOp_1.MinusOp;
var MulOp_1 = require("./lib/binops/MulOp");
exports.MulOp = MulOp_1.MulOp;
var PlusOp_1 = require("./lib/binops/PlusOp");
exports.PlusOp = PlusOp_1.PlusOp;
var GreaterThan_1 = require("./lib/logic/GreaterThan");
exports.GreaterThan = GreaterThan_1.GreaterThan;
var GreaterThanEq_1 = require("./lib/logic/GreaterThanEq");
exports.GreaterThanEq = GreaterThanEq_1.GreaterThanEq;
var LessThan_1 = require("./lib/logic/LessThan");
exports.LessThan = LessThan_1.LessThan;
var LessThanEq_1 = require("./lib/logic/LessThanEq");
exports.LessThanEq = LessThanEq_1.LessThanEq;
var DeclareOp_1 = require("./lib/binops/DeclareOp");
exports.DeclareOp = DeclareOp_1.DeclareOp;
var And_1 = require("./lib/logic/And");
exports.And = And_1.And;
var Or_1 = require("./lib/logic/Or");
exports.Or = Or_1.Or;
var Equals_1 = require("./lib/logic/Equals");
exports.Equals = Equals_1.Equals;
var NotEqual_1 = require("./lib/logic/NotEqual");
exports.NotEqual = NotEqual_1.NotEqual;
var Increment_1 = require("./lib/binops/Increment");
exports.Increment = Increment_1.Increment;
var Decrement_1 = require("./lib/binops/Decrement");
exports.Decrement = Decrement_1.Decrement;
/* UNARY OPS */
var UnaryOperation_1 = require("./lib/unops/UnaryOperation");
exports.UnaryOperation = UnaryOperation_1.UnaryOperation;
var NegOp_1 = require("./lib/unops/NegOp");
exports.NegOp = NegOp_1.NegOp;
var Not_1 = require("./lib/logic/Not");
exports.Not = Not_1.Not;
/* DATA TYPES */
var ListNode_1 = require("./lib/lists/ListNode");
exports.ListNode = ListNode_1.ListNode;
var NumberNode_1 = require("./lib/prims/NumberNode");
exports.NumberNode = NumberNode_1.NumberNode;
var StringNode_1 = require("./lib/prims/StringNode");
exports.StringNode = StringNode_1.StringNode;
var BooleanNode_1 = require("./lib/prims/BooleanNode");
exports.BooleanNode = BooleanNode_1.BooleanNode;
var NOP_1 = require("./lib/prims/NOP");
exports.NOP = NOP_1.NOP;
/* VARIABLES */
var VariableNode_1 = require("./lib/vars/VariableNode");
exports.VariableNode = VariableNode_1.VariableNode;
/* CONTROL CONSTRUCTS */
var Conditional_1 = require("./lib/conditionals/Conditional");
exports.Conditional = Conditional_1.Conditional;
var FunApp_1 = require("./lib/funhouse/FunApp");
exports.FunApp = FunApp_1.FunApp;
var FunDef_1 = require("./lib/funhouse/FunDef");
exports.FunDef = FunDef_1.FunDef;
var SequenceNode_1 = require("./lib/structural/SequenceNode");
exports.SequenceNode = SequenceNode_1.SequenceNode;
var RepeatNode_1 = require("./lib/loops/RepeatNode");
exports.RepeatNode = RepeatNode_1.RepeatNode;
var WhileNode_1 = require("./lib/loops/WhileNode");
exports.WhileNode = WhileNode_1.WhileNode;
var ForNode_1 = require("./lib/loops/ForNode");
exports.ForNode = ForNode_1.ForNode;
/* BUILTIN FUNCTIONS */
var ColorNode_1 = require("./lib/shapes/ColorNode");
exports.ColorNode = ColorNode_1.ColorNode;
var EllipseNode_1 = require("./lib/shapes/EllipseNode");
exports.EllipseNode = EllipseNode_1.EllipseNode;
var RectangleNode_1 = require("./lib/shapes/RectangleNode");
exports.RectangleNode = RectangleNode_1.RectangleNode;
var LineNode_1 = require("./lib/shapes/LineNode");
exports.LineNode = LineNode_1.LineNode;
var CurveNode_1 = require("./lib/shapes/CurveNode");
exports.CurveNode = CurveNode_1.CurveNode;
var EphNode_1 = require("./lib/shapes/EphNode");
exports.EphNode = EphNode_1.EphNode;
var EmojiNode_1 = require("./lib/shapes/EmojiNode");
exports.EmojiNode = EmojiNode_1.EmojiNode;
var PrintNode_1 = require("./lib/structural/PrintNode");
exports.PrintNode = PrintNode_1.PrintNode;
var Return_1 = require("./lib/structural/Return");
exports.Return = Return_1.Return;
var ReturnError_1 = require("./lib/structural/ReturnError");
exports.ReturnError = ReturnError_1.ReturnError;
var EllipseEffect_1 = require("./lib/effects/EllipseEffect");
exports.EllipseEffect = EllipseEffect_1.EllipseEffect;
var NumberEffect_1 = require("./lib/effects/NumberEffect");
exports.NumberEffect = NumberEffect_1.NumberEffect;
var StringEffect_1 = require("./lib/effects/StringEffect");
exports.StringEffect = StringEffect_1.StringEffect;
var Dimensions_1 = require("./lib/structural/Dimensions");
exports.Dimensions = Dimensions_1.Dimensions;
var RectangleEffect_1 = require("./lib/effects/RectangleEffect");
exports.RectangleEffect = RectangleEffect_1.RectangleEffect;
var LineEffect_1 = require("./lib/effects/LineEffect");
exports.LineEffect = LineEffect_1.LineEffect;
var CurveEffect_1 = require("./lib/effects/CurveEffect");
exports.CurveEffect = CurveEffect_1.CurveEffect;
var EphEffect_1 = require("./lib/effects/EphEffect");
exports.EphEffect = EphEffect_1.EphEffect;
var EmojiEffect_1 = require("./lib/effects/EmojiEffect");
exports.EmojiEffect = EmojiEffect_1.EmojiEffect;
/* EVENTS */
var LogEvent_1 = require("./lib/logging/LogEvent");
exports.LogEvent = LogEvent_1.LogEvent;
var ClearEvent_1 = require("./lib/logging/ClearEvent");
exports.ClearEvent = ClearEvent_1.ClearEvent;
var DragEvent_1 = require("./lib/logging/DragEvent");
exports.DragEvent = DragEvent_1.DragEvent;
var PaintEvent_1 = require("./lib/logging/PaintEvent");
exports.PaintEvent = PaintEvent_1.PaintEvent;
var ResizeEvent_1 = require("./lib/logging/ResizeEvent");
exports.ResizeEvent = ResizeEvent_1.ResizeEvent;
var SelectEvent_1 = require("./lib/logging/SelectEvent");
exports.SelectEvent = SelectEvent_1.SelectEvent;
var IDEvent_1 = require("./lib/logging/IDEvent");
exports.IDEvent = IDEvent_1.IDEvent;
/* MODULES */
var Module_1 = require("./lib/modules/Module");
exports.Module = Module_1.Module;
var ModuleGenerator_1 = require("./lib/modules/ModuleGenerator");
exports.ModuleGenerator = ModuleGenerator_1.ModuleGenerator;
var LessonOneCpOne_1 = require("./lib/modules/LessonOneCpOne");
exports.LessonOneCpOne = LessonOneCpOne_1.LessonOneCpOne;
var LessonOneCpTwo_1 = require("./lib/modules/LessonOneCpTwo");
exports.LessonOneCpTwo = LessonOneCpTwo_1.LessonOneCpTwo;
var LessonOneCpThree_1 = require("./lib/modules/LessonOneCpThree");
exports.LessonOneCpThree = LessonOneCpThree_1.LessonOneCpThree;
var LessonOneCpFour_1 = require("./lib/modules/LessonOneCpFour");
exports.LessonOneCpFour = LessonOneCpFour_1.LessonOneCpFour;
var LessonTwoCpOne_1 = require("./lib/modules/LessonTwoCpOne");
exports.LessonTwoCpOne = LessonTwoCpOne_1.LessonTwoCpOne;
var LessonTwoCpTwo_1 = require("./lib/modules/LessonTwoCpTwo");
exports.LessonTwoCpTwo = LessonTwoCpTwo_1.LessonTwoCpTwo;
var LessonTwoCpThree_1 = require("./lib/modules/LessonTwoCpThree");
exports.LessonTwoCpThree = LessonTwoCpThree_1.LessonTwoCpThree;
var LessonTwoCpFour_1 = require("./lib/modules/LessonTwoCpFour");
exports.LessonTwoCpFour = LessonTwoCpFour_1.LessonTwoCpFour;
var LessonTwoCpFive_1 = require("./lib/modules/LessonTwoCpFive");
exports.LessonTwoCpFive = LessonTwoCpFive_1.LessonTwoCpFive;
var LessonTwoCpSix_1 = require("./lib/modules/LessonTwoCpSix");
exports.LessonTwoCpSix = LessonTwoCpSix_1.LessonTwoCpSix;
var LessonTwoCpSeven_1 = require("./lib/modules/LessonTwoCpSeven");
exports.LessonTwoCpSeven = LessonTwoCpSeven_1.LessonTwoCpSeven;
var LessonThreeCpOne_1 = require("./lib/modules/LessonThreeCpOne");
exports.LessonThreeCpOne = LessonThreeCpOne_1.LessonThreeCpOne;
var LessonThreeCpTwo_1 = require("./lib/modules/LessonThreeCpTwo");
exports.LessonThreeCpTwo = LessonThreeCpTwo_1.LessonThreeCpTwo;
var LessonThreeCpThree_1 = require("./lib/modules/LessonThreeCpThree");
exports.LessonThreeCpThree = LessonThreeCpThree_1.LessonThreeCpThree;
var LessonThreeCpFour_1 = require("./lib/modules/LessonThreeCpFour");
exports.LessonThreeCpFour = LessonThreeCpFour_1.LessonThreeCpFour;
var LessonThreeCpFive_1 = require("./lib/modules/LessonThreeCpFive");
exports.LessonThreeCpFive = LessonThreeCpFive_1.LessonThreeCpFive;
var LessonThreeCpSix_1 = require("./lib/modules/LessonThreeCpSix");
exports.LessonThreeCpSix = LessonThreeCpSix_1.LessonThreeCpSix;
var LessonFourCpOne_1 = require("./lib/modules/LessonFourCpOne");
exports.LessonFourCpOne = LessonFourCpOne_1.LessonFourCpOne;
var LessonFourCpTwo_1 = require("./lib/modules/LessonFourCpTwo");
exports.LessonFourCpTwo = LessonFourCpTwo_1.LessonFourCpTwo;
/* PARSER */
var parser_1 = require("./lib/parser/parser");
exports.Parser = parser_1.Parser;

},{"./lib/binops/AssignOp":2,"./lib/binops/BinaryOperation":3,"./lib/binops/DeclareOp":4,"./lib/binops/Decrement":5,"./lib/binops/DivOp":6,"./lib/binops/Increment":7,"./lib/binops/MinusOp":8,"./lib/binops/MulOp":9,"./lib/binops/PlusOp":10,"./lib/conditionals/Conditional":11,"./lib/effects/CurveEffect":12,"./lib/effects/EllipseEffect":13,"./lib/effects/EmojiEffect":14,"./lib/effects/EphEffect":15,"./lib/effects/LineEffect":16,"./lib/effects/NumberEffect":17,"./lib/effects/RectangleEffect":18,"./lib/effects/StringEffect":19,"./lib/funhouse/FunApp":20,"./lib/funhouse/FunDef":21,"./lib/lists/ListNode":22,"./lib/logging/ClearEvent":23,"./lib/logging/DragEvent":25,"./lib/logging/IDEvent":26,"./lib/logging/LogEvent":27,"./lib/logging/PaintEvent":28,"./lib/logging/ResizeEvent":29,"./lib/logging/SelectEvent":30,"./lib/logic/And":31,"./lib/logic/Equals":32,"./lib/logic/GreaterThan":33,"./lib/logic/GreaterThanEq":34,"./lib/logic/LessThan":35,"./lib/logic/LessThanEq":36,"./lib/logic/Not":37,"./lib/logic/NotEqual":38,"./lib/logic/Or":39,"./lib/loops/ForNode":40,"./lib/loops/RepeatNode":41,"./lib/loops/WhileNode":42,"./lib/modules/LessonFourCpOne":44,"./lib/modules/LessonFourCpTwo":45,"./lib/modules/LessonOneCpFour":46,"./lib/modules/LessonOneCpOne":47,"./lib/modules/LessonOneCpThree":48,"./lib/modules/LessonOneCpTwo":49,"./lib/modules/LessonThreeCpFive":50,"./lib/modules/LessonThreeCpFour":51,"./lib/modules/LessonThreeCpOne":52,"./lib/modules/LessonThreeCpSix":53,"./lib/modules/LessonThreeCpThree":54,"./lib/modules/LessonThreeCpTwo":55,"./lib/modules/LessonTwoCpFive":56,"./lib/modules/LessonTwoCpFour":57,"./lib/modules/LessonTwoCpOne":58,"./lib/modules/LessonTwoCpSeven":59,"./lib/modules/LessonTwoCpSix":60,"./lib/modules/LessonTwoCpThree":61,"./lib/modules/LessonTwoCpTwo":62,"./lib/modules/Module":63,"./lib/modules/ModuleGenerator":64,"./lib/parser/parser":65,"./lib/prims/BooleanNode":66,"./lib/prims/NOP":67,"./lib/prims/NumberNode":68,"./lib/prims/StringNode":69,"./lib/shapes/ColorNode":70,"./lib/shapes/CurveNode":71,"./lib/shapes/EllipseNode":72,"./lib/shapes/EmojiNode":73,"./lib/shapes/EphNode":74,"./lib/shapes/LineNode":75,"./lib/shapes/RectangleNode":76,"./lib/structural/Dimensions":77,"./lib/structural/PrintNode":78,"./lib/structural/Return":79,"./lib/structural/ReturnError":80,"./lib/structural/Scope":81,"./lib/structural/SequenceNode":82,"./lib/unops/NegOp":84,"./lib/unops/UnaryOperation":85,"./lib/vars/VariableNode":86}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const VariableNode_1 = require("../vars/VariableNode");
// left side is variable, right side is val
// Reassign new value to var
class AssignOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for an assignment operation
     * @param left The left side of the assignment (the var)
     * @param right The right side of the assignment (the value)
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        if (!(left instanceof VariableNode_1.VariableNode)) {
            throw new Error("The left hand side of the assignment must be a variable.");
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates assign op by assigning value to var
     * @param context The current context
     */
    eval(context) {
        if (this.left instanceof VariableNode_1.VariableNode) {
            let r = this.right.eval(context);
            context.assign(this.left.name, r);
            return r;
        }
        throw new Error("HALP (in AssignOp)");
    }
    /**
     * Returns a string representation of the AssignOp
     */
    toString() {
        return this._ws + this.left.toString() + ' = ' + this.right.toString();
    }
    /**
     * AssignOps can't be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on AssignOp
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.AssignOp = AssignOp;

},{"../vars/VariableNode":86,"./BinaryOperation":3}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BinaryOperation {
    /**
     * Constructor for the BinOp abstract class
     * @param _left The left side of the binary operation
     * @param _right The right side of the binary operation
     */
    constructor(_left, _right) {
        this._left = _left;
        this._right = _right;
        this._newLine = false;
    }
    ;
    /**
     * Draws the binary operation, if applicable
     * @param context The current program context
     * @param dims The dimensions
     * @param ast The AST
     */
    draw(context, dims, ast) { }
    /**
     * Checks if equal to another expression
     * @param right The right side of the equality
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on BinOp");
    }
    /**
     * Returns a string representation of the binary operation
     */
    toString() { return ""; }
    ;
    /**
     * Gets left side of the binary operation
     */
    get left() {
        return this._left;
    }
    /**
     * Sets left side of the binary operation
     */
    set left(left) {
        this._left = left;
    }
    /**
     * Gets right side of the binary operation
     */
    get right() {
        return this._right;
    }
    /**
     * Sets right side of the binary operation
     */
    set right(right) {
        this._right = right;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.BinaryOperation = BinaryOperation;

},{}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const VariableNode_1 = require("../vars/VariableNode");
// left side is variable, right side is val
// Declares new val
class DeclareOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the declare operation, which declares a variable for the first time
     * @param left The left side of the declare op (the variable)
     * @param right The right side of the op (the value)
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        if (!(left instanceof VariableNode_1.VariableNode)) {
            throw new Error("The left hand side of the assignment must be a variable.");
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the declaration by declaring the variable in the context and assigning the value
     * @param context The current program context
     */
    eval(context) {
        if (this.left instanceof VariableNode_1.VariableNode) {
            context.declare(this.left.name);
            let r = this.right.eval(context);
            context.assign(this.left.name, r);
            return r;
        }
        throw new Error("HALP (in DeclareOp)");
    }
    /**
     * Returns a string representation of the declare op
     */
    toString() {
        return this._ws + "var " + this.left.toString() + ' = ' + this.right.toString();
    }
    /**
     * DeclareOps cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called direcly on a DeclareOp
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.DeclareOp = DeclareOp;

},{"../vars/VariableNode":86,"./BinaryOperation":3}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const MinusOp_1 = require("./MinusOp");
const AssignOp_1 = require("./AssignOp");
const VariableNode_1 = require("../vars/VariableNode");
class Decrement {
    /**
     * Constructor for the decrement operation
     * @param variable The expression to be decremented
     * @param ws Preceding whitespace
     */
    constructor(variable, ws) {
        this.expr = variable;
        if (variable instanceof VariableNode_1.VariableNode) {
            this.innerRep = new AssignOp_1.AssignOp(variable, new MinusOp_1.MinusOp(variable, new NumberNode_1.NumberNode(1)));
        }
        else {
            this.innerRep = new MinusOp_1.MinusOp(variable, new NumberNode_1.NumberNode(1));
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the decrement op to a NumberNode
     * @param context The current program context
     */
    eval(context) {
        return this.innerRep.eval(context);
    }
    /**
     * Returns a string representation of the decrement op
     */
    toString() {
        return this._ws + this.expr.toString() + "--";
    }
    /**
     * Decrement ops can't be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on decrement
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.Decrement = Decrement;

},{"../prims/NumberNode":68,"../vars/VariableNode":86,"./AssignOp":2,"./MinusOp":8}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
class DivOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the division operation
     * @param left The dividend
     * @param right The divisor
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the division and evaluates into a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val / this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Division ops can't be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on a division op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the division
     */
    toString() {
        return this._ws + this.left.toString() + ' / ' + this.right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.DivOp = DivOp;

},{"../prims/NumberNode":68,"../structural/Scope":81,"./BinaryOperation":3}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PlusOp_1 = require("./PlusOp");
const AssignOp_1 = require("./AssignOp");
const VariableNode_1 = require("../vars/VariableNode");
class Increment {
    /**
     * Constructor for Increment
     * @param variable The expression to increment
     * @param ws Tracks preceding whitespace
     */
    constructor(variable, ws) {
        this.expr = variable;
        if (variable instanceof VariableNode_1.VariableNode) {
            this.innerRep = new AssignOp_1.AssignOp(variable, new PlusOp_1.PlusOp(variable, new NumberNode_1.NumberNode(1)));
        }
        else {
            this.innerRep = new PlusOp_1.PlusOp(variable, new NumberNode_1.NumberNode(1, ""));
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates increment into a number node
     * @param context The function scope
     */
    eval(context) {
        return this.innerRep.eval(context);
    }
    /**
     * Increments cannot be drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Cannot call equals directly on binops
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the increment expression
     */
    toString() {
        return this._ws + this.expr.toString() + "++";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.Increment = Increment;

},{"../prims/NumberNode":68,"../vars/VariableNode":86,"./AssignOp":2,"./PlusOp":10}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
class MinusOp extends BinaryOperation_1.BinaryOperation {
    /**
     * The constructor for the subtraction operation
     * @param left The minuend
     * @param right The subrahend
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the subtraction and evaluates to a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val - this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Subtraction ops can't be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on subtraction
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the subtraction op
     */
    toString() {
        return this._ws + this.left.toString() + ' - ' + this.right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.MinusOp = MinusOp;

},{"../prims/NumberNode":68,"../structural/Scope":81,"./BinaryOperation":3}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
class MulOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the multiplication operation
     * @param left The multiplicand
     * @param right The multiplier
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the multiplication and returns a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val * this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Returns a string representation of the multiplication op
     */
    toString() {
        return this._ws + this.left.toString() + ' * ' + this.right.toString();
    }
    /**
     * Multiplication ops cannot be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a multiplicaiton operation
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.MulOp = MulOp;

},{"../prims/NumberNode":68,"../structural/Scope":81,"./BinaryOperation":3}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
// left and right are both expressions
class PlusOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the addition operation
     * @param left The first addend
     * @param right The second addend
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the addition and returns a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val + this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Addition ops cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on an addition op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the addition op
     */
    toString() {
        return this._ws + this.left.toString() + ' + ' + this.right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.PlusOp = PlusOp;

},{"../prims/NumberNode":68,"../structural/Scope":81,"./BinaryOperation":3}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const BooleanNode_1 = require("../prims/BooleanNode");
const space_lift_1 = require("space-lift");
class Conditional {
    /**
     * The constructor for conditionals (if, else if, and else statements)
     * @param test The condition of the statement
     * @param trueBranch The branch to follow if the condition evaluates to true
     * @param falseBranch The branch to follow if the condition evaluates to false
     */
    constructor(test, trueBranch, falseBranch) {
        this._newLine = true;
        this._test = test;
        this._trueBranch = trueBranch;
        this._falseBranch = falseBranch;
    }
    /**
     * Checks the test result and returns the result of the true or false branch, depending on the test
     * @param context The current program context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        let res = this._test.eval(childCtx);
        if (!(res instanceof BooleanNode_1.BooleanNode)) {
            throw new Error("The condition must be a boolean expression.");
        }
        if (res.val) {
            return this._trueBranch.eval(childCtx);
        }
        else if (this._falseBranch != null) { // check if else/else if is null or undefined
            return this._falseBranch.eval(childCtx); // possibly a bad idea
        }
    }
    /**
     * Returns a string representation of the conditional statement
     */
    toString() {
        let res = 'if(' + this._test.toString() + ") {\n " + this._trueBranch.toString() + "}";
        if (this._falseBranch !== undefined) {
            res += '\nelse {\n ' + this._falseBranch.toString() + '}';
        }
        return res;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the true branch of the conditional
     */
    get trueBranch() {
        return this._trueBranch;
    }
    /**
     * Returns the false branch of the conditional
     */
    get falseBranch() {
        return this._falseBranch;
    }
    /**
     * Conditionals cannot be drawn directly
     */
    draw() {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a conditional
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on conditionals");
    }
}
exports.Conditional = Conditional;

},{"../prims/BooleanNode":66,"../structural/Scope":81,"space-lift":96}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class CurveEffect {
    constructor(curve) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._curve = curve;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        let curvature = this.curvature;
        this._ctx.beginPath();
        this._ctx.moveTo(x, y);
        let v = this.perpendicularVector(width, height);
        this._ctx.quadraticCurveTo((x + width / 2) + curvature * v[0], (y + height / 2) + curvature * v[1], x + width, y + height);
        this._ctx.strokeStyle = "#673AB7";
        this._ctx.stroke();
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    //a * w + b * h = 0
    perpendicularVector(w, h) {
        if (w == 0 && h == 0) {
            return [0, 0];
        }
        else if (w == 0) {
            return [1, 0];
        }
        else if (h == 0) {
            return [0, 1];
        }
        return [1, (-w) / h];
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) { // a corner guide is selected
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) { // a middle guide is selected
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else { //if no guides are selected, colors everything white
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition(event);
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._curve.dx = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._curve.dy = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._curve.dy = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._curve.dx = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._curve.dx = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._curve.dy = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._curve.dx = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._curve.dy = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.h > 10) { //as long as the height is > 10
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10) { // as long as width is > 10
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) { // sets the offsets depending on which corner is selected
                case 1: // top left
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w; // offset is bottom right
                    this._dragoffy = y + h;
                    break;
                case 2: // top right
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h; // offset is bottom left, etc
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) { // sets the offsets depending on which middle guide is selected
                case 5: // top middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2; // offset is bottom middle
                    this._dragoffy = y + h;
                    break;
                case 6: //right middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2; // offset is left middle etc
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) { // dragging
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) { // not selected
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     * NOTE: in Firefox, window.event is not global. Need to be passed in here as a paramater.
     * @param event the mousedown event
     */
    getMousePosition(event) {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isChangingDims = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a rectangle paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("rectangle", this.x, this.y);
    }
    /**
     * Logs a rectangle resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("rectangle with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs a rectangle click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("rectangle with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the rect
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the rect
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the rect
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the rect
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the curvature of the curve
     */
    get curvature() {
        return this._dims.curvature.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the rect is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the rect
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the rect has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the rect has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the rect is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " rectangle with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("rectangle with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to rectangle at " + this.x + ", " + this.y);
    }
}
exports.CurveEffect = CurveEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":24,"../logging/PaintEvent":28,"../logging/ResizeEvent":29,"../prims/NumberNode":68}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const NumberNode_1 = require("../prims/NumberNode");
const ClickEvent_1 = require("../logging/ClickEvent");
class EllipseEffect {
    constructor(circle) {
        this._corner = 0;
        this._isSelected = false; // Private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false; // Has this object just been dragged?
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._circle = circle;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        // logging
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        this._ctx.beginPath();
        this._ctx.ellipse(x, y, w / 2, h / 2, 0, 0, Math.PI * 2, false);
        //this._ctx.strokeStyle = "black";
        //this._ctx.stroke();
        this._ctx.fillStyle = "#D5B8FF";
        this._ctx.shadowColor = "#6C6C6C";
        this._ctx.shadowBlur = 15;
        //this._ctx.shadowOffsetX = 2;
        //this._ctx.shadowOffsetY = 2;
        this._ctx.fill();
        if (this._isSelected) {
            this.drawGuides(x - w / 2, y - h / 2, w, h, this._corner);
        }
    }
    /*
        private mouseMove = this.onMouseMove.bind(this);
        private mouseDown = this.onMouseDown.bind(this);
        private mouseUp = this.onMouseUp.bind(this);
        private shiftDown = this.onShiftDown.bind(this);
        private shiftUp = this.onShiftUp.bind(this);
        private mouseOutside = this.isMouseOutside.bind(this);
        private selectStart = function(e:any) { e.preventDefault(); return false; };
    */
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    removeEventListeners() {
        /*
        console.log("removing EventListners");
          this._canvas.removeEventListener('mousemove', this.mouseMove); // bind in order to maintain the meaning of 'this'
          this._canvas.removeEventListener('mousedown', this.mouseDown);
          this._canvas.removeEventListener('mouseup', this.mouseUp);
          window.removeEventListener('keydown', this.shiftDown);
          window.removeEventListener('keyup', this.shiftUp);
          window.removeEventListener('mousedown', this.mouseOutside);
          //makes it so that double clicking doesn't select text on the page
          this._canvas.removeEventListener('selectstart', this.selectStart, false);
          */
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        return Math.pow(mx - x, 2) / Math.pow(w / 2, 2) + Math.pow(my - y, 2) / Math.pow(h / 2, 2) <= 1;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - (x - w / 2);
        let ydif = my - (y - h / 2);
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - (x - w / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - x;
        ydif = my - (y - h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - (x - w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) {
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0 && corner > 4) {
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else {
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition(event);
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 14, this.h < 14);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 14, this.h < 14);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        //console.log("I'm an ellipse!");
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //console.log("ellipse dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 14 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     * @param widthTooSmall true if the width dimension is < 14
     * @param heightTooSmall true if the height dimension is < 14
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 14;
            this._circle.width = new NumberNode_1.NumberNode(14); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 14 / this._ratio;
            this._circle.height = new NumberNode_1.NumberNode(Math.round(14 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._initDistance = newDistance;
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 14;
            this._circle.height = new NumberNode_1.NumberNode(14); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 14 * this._ratio;
            this._circle.width = new NumberNode_1.NumberNode(Math.round(14 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._initDistance = newDistance;
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
            this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
            this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
            this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
            this._initDistance = newDistance;
        }
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (this._corner == 5 || this._corner == 7) { // if modifying height
            if (!heightTooSmall) {
                this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._initDistance = newDistance;
                this._ratio = this.w / this.h; // setting width/height ratio = to the new ratio
            }
            else {
                this._dims.height.eval(this._context).val = 14;
                this._circle.height = new NumberNode_1.NumberNode(14);
                this._ratio = this.w / this.h;
                if (newDistance - this._initDistance > 0) {
                    this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                    this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                    this._initDistance = newDistance;
                    this._ratio = this.w / this.h;
                }
            }
        }
        else { // modifying width
            if (!widthTooSmall) {
                this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._initDistance = newDistance;
                this._ratio = this.w / this.h;
            }
            else {
                this._dims.width.eval(this._context).val = 14;
                this._circle.width = new NumberNode_1.NumberNode(14);
                this._ratio = this.w / this.h;
                if (newDistance - this._initDistance > 0) {
                    this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                    this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                    this._initDistance = newDistance;
                    this._ratio = this.w / this.h;
                }
            }
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
            else {
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 || contains) {
            let effects = this._context.effects;
            let curID = this.getID();
            for (let effect of effects) {
                let effectID = effect.getID();
                if (effectID == curID) {
                    continue;
                }
                else if (effectID > curID && (effect.guideContains(this._mouse.x, this._mouse.y) > 0 || effect.contains(this._mouse.x, this._mouse.y))) {
                    this._isSelected = false;
                    this._isDragging = false;
                    return;
                }
            }
            if (guideContains > 0 && guideContains <= 4) { //resizing
                this._isSelected = true;
                this._isResizing = true;
                this._context.eventLog.push(this.logClick());
                this._corner = guideContains;
                this._dragoffx = this.x;
                this._dragoffy = this.y;
                this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
                this._width1 = this.w;
                this._height1 = this.h;
                //this._size1 = Math.sqrt(Math.pow(this.w,2) + Math.pow(this.h,2)); // saving old size
            }
            else if (guideContains > 4) { //changing shape dimensions
                this._isSelected = true;
                this._isChangingDims = true;
                this._corner = guideContains;
                this._dragoffx = this.x;
                this._dragoffy = this.y;
                this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
            }
            else if (contains) { //simply selecting the shape or dragging
                this._x1 = this.x; // Saving original x and y
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._context.eventLog.push(this.logClick());
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) { // probs only need dragging but oh well | isSel || selMul?
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
                //this._context.eventLog.push(this.logMove());
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            //console.log("resizing ellipse");
            this._isResizing = false;
            //let size2 = Math.sqrt(Math.pow(this.w,2) + Math.pow(this.h,2));
            //console.log("Size diff: " + Math.abs(this._size1 - size2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        // if(this._isSelectingMultiple){
        //     if(Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
        //         this._context.eventLog.push(this.logMove());
        //     }
        // }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     * NOTE: in Firefox, window.event is not global. Need to be passed in here as a paramater.
     * @param event the mousedown event
     */
    getMousePosition(event) {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("ellipse", this.x, this.y);
    }
    /**
     * Logs a resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("ellipse with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
        //Math.round(this._size1*100)/100, Math.round((Math.sqrt(Math.pow(this.w,2) + Math.pow(this.h,2))*100))/100);
    }
    /**
     * Logs a click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("ellipse with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the ellipse
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the ellipse
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the ellipse
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the ellipse
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the ellipse is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the ellipse
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the ellipse has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the ellipse has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the ellipse is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return (" ellipse with ID " + this.getID().toString() + " at " + this.x + ", " + this.y);
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("ellipse with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to ellipse at " + this.x + ", " + this.y);
    }
}
exports.EllipseEffect = EllipseEffect;
/**
 * Get's the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":24,"../logging/PaintEvent":28,"../logging/ResizeEvent":29,"../prims/NumberNode":68}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class EmojiEffect {
    constructor(emoji) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._emoji = emoji;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._emojiImg = new Image();
            this._emojiImg.src = './pics/' + this._emoji.name.eval(this._context).val + '.svg';
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        //var imgObj = new Image();
        //let ctx = this._canvas.getContext('2d');
        // this._emojiImg = new Image();
        // this._emojiImg.src = './pics/demoncow.png';
        //imgObj.onload = function(){
        //this._emojiImg.onload = function(){
        this._ctx.drawImage(this._emojiImg, this.x, this.y, width, height);
        //this._emojiImg.onload = function(){
        // this._emojiImg.width = width;
        // this._emojiImg.height = height;
        //}
        //}
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) {
            switch (corner) { //colors the corner guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) {
            switch (corner) { //colors the coremoji guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else {
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition(event);
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * @param event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //console.log("angle dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._emoji.width = new NumberNode_1.NumberNode(10);
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._emoji.height = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._emoji.height = new NumberNode_1.NumberNode(10);
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._emoji.width = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._emoji.width = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._emoji.height = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._emoji.width = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._emoji.height = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.w > 10 && this.h > 10) {
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._emoji.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._emoji.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._emoji.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10 && this.h > 10) {
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._emoji.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) {
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) {
                case 1:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h;
                    break;
                case 2:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h;
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
            //this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h / 2);
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) {
                case 5:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y + h;
                    break;
                case 6:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2;
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) {
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     * NOTE: in Firefox, window.event is not global. Need to be passed in here as a paramater.
     * @param event the mousedown event
     */
    getMousePosition(event) {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let emoji = this._canvas.getBoundingClientRect();
        if (mouseX < emoji.left || mouseX > emoji.right || mouseY < emoji.top || mouseY > emoji.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs an emoji paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("emoji", this.x, this.y);
    }
    /**
     * Logs an emoji resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("emoji with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs an emoji click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("emoji with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Not implemented");
    }
    updateAST() {
        throw new Error("Not implemented");
    }
    /**
     * Returns the x position of the emoji
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the emoji
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the emoji
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the emoji
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the emoji is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the image
     */
    get image() {
        return this._emojiImg;
    }
    /**
     * Returns the ID of the emoji
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the emoji has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the emoji has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the emoji is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " emoji with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("emoji with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to emoji at " + this.x + ", " + this.y);
    }
}
exports.EmojiEffect = EmojiEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let emoji = canvas.getBoundingClientRect();
    return {
        x: event.clientX - emoji.left,
        y: event.clientY - emoji.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":24,"../logging/PaintEvent":28,"../logging/ResizeEvent":29,"../prims/NumberNode":68}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class EphEffect {
    constructor(eph) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._eph = eph;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ephImg = new Image();
            this._ephImg.src = './pics/demoncow.png';
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        //var imgObj = new Image();
        //let ctx = this._canvas.getContext('2d');
        // this._ephImg = new Image();
        // this._ephImg.src = './pics/demoncow.png';
        //imgObj.onload = function(){
        //this._ephImg.onload = function(){
        this._ctx.drawImage(this._ephImg, this.x, this.y, width, height);
        //this._ephImg.onload = function(){
        // this._ephImg.width = width;
        // this._ephImg.height = height;
        //}
        //}
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) {
            switch (corner) { //colors the coreph guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) {
            switch (corner) { //colors the coreph guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else {
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition(event);
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * @param event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //console.log("ephangle dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._eph.width = new NumberNode_1.NumberNode(10);
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._eph.height = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._eph.height = new NumberNode_1.NumberNode(10);
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._eph.width = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._eph.width = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._eph.height = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._eph.width = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._eph.height = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.w > 10 && this.h > 10) {
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._eph.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._eph.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._eph.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10 && this.h > 10) {
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._eph.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) {
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) {
                case 1:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h;
                    break;
                case 2:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h;
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
            //this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h / 2);
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) {
                case 5:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y + h;
                    break;
                case 6:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2;
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) {
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     * NOTE: in Firefox, window.event is not global. Need to be passed in here as a paramater.
     * @param event the mousedown event
     */
    getMousePosition(event) {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let eph = this._canvas.getBoundingClientRect();
        if (mouseX < eph.left || mouseX > eph.right || mouseY < eph.top || mouseY > eph.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs an eph paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("eph", this.x, this.y);
    }
    /**
     * Logs an eph resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("eph with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs an eph click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("eph with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Not implemented");
    }
    updateAST() {
        throw new Error("Not implemented");
    }
    /**
     * Returns the x position of the eph
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the eph
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the eph
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the eph
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the eph is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the image
     */
    get image() {
        return this._ephImg;
    }
    /**
     * Returns the ID of the eph
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the eph has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the eph has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the eph is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " eph with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("eph with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to eph at " + this.x + ", " + this.y);
    }
}
exports.EphEffect = EphEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let eph = canvas.getBoundingClientRect();
    return {
        x: event.clientX - eph.left,
        y: event.clientY - eph.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":24,"../logging/PaintEvent":28,"../logging/ResizeEvent":29,"../prims/NumberNode":68}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class LineEffect {
    constructor(line) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._line = line;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        this._ctx.moveTo(x, y);
        this._ctx.lineTo(x + width, y + height);
        this._ctx.strokeStyle = "#673AB7";
        this._ctx.stroke();
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) { // a corner guide is selected
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) { // a middle guide is selected
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else { //if no guides are selected, colors everything white
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition(event);
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._line.dx = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._line.dy = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._line.dy = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._line.dx = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._line.dx = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._line.dy = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._line.dx = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._line.dy = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.h > 10) { //as long as the height is > 10
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._line.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._line.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._line.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10) { // as long as width is > 10
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._line.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) { // sets the offsets depending on which corner is selected
                case 1: // top left
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w; // offset is bottom right
                    this._dragoffy = y + h;
                    break;
                case 2: // top right
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h; // offset is bottom left, etc
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) { // sets the offsets depending on which middle guide is selected
                case 5: // top middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2; // offset is bottom middle
                    this._dragoffy = y + h;
                    break;
                case 6: //right middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2; // offset is left middle etc
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) { // dragging
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) { // not selected
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     * NOTE: in Firefox, window.event is not global. Need to be passed in here as a paramater.
     * @param event the mousedown event
     */
    getMousePosition(event) {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isChangingDims = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a rectangle paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("rectangle", this.x, this.y);
    }
    /**
     * Logs a rectangle resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("rectangle with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs a rectangle click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("rectangle with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the rect
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the rect
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the rect
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the rect
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the rect is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the rect
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the rect has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the rect has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the rect is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " rectangle with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("rectangle with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to rectangle at " + this.x + ", " + this.y);
    }
}
exports.LineEffect = LineEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":24,"../logging/PaintEvent":28,"../logging/ResizeEvent":29,"../prims/NumberNode":68}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class NumberEffect {
    constructor(num) {
        this._fontSize = 20;
        this._corner = 0;
        this._isEditing = false;
        this._isListening = false;
        this._isDragging = false;
        this._isResizing = false;
        this._isSelectingMultiple = false;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._numberMetrics = {
            width: 0,
            height: 0,
            interval: 0,
            str: "",
            initMousePos: 0,
            cursorPos: 0
        };
        this._num = num;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas != undefined) {
            this._context = context;
            this._canvas = context.canvas.get();
            this._dims = dims;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this.update();
            // logging
            this._context.eventLog.push(this.logPaint()); // this.context or context?
            context.effects.push(this);
            this.addEventListeners();
        }
        else {
            console.log("canvas is NOT defined");
        }
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let fontDeets = this._fontSize + "px Courier New";
        this._ctx.font = fontDeets;
        this._ctx.fillStyle = "#673AB7";
        let str = this._num.toString();
        this._ctx.fillText(str, this.x, this.y);
        let numberDims = this._ctx.measureText(str);
        this._numberMetrics.width = numberDims.width;
        this._numberMetrics.height = this._fontSize;
        this._numberMetrics.str = str;
        this._numberMetrics.interval = this._numberMetrics.width / this._numberMetrics.str.length;
        if (this._isSelected) {
            this.drawTextGuides(this.x, this.y - this._fontSize, this._numberMetrics.width, this._numberMetrics.height, this._corner);
        }
        if (this._isEditing) {
            this.modifyTextCursor();
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        return (this.x <= mx) && (this.x + this._numberMetrics.width >= mx) &&
            (this.y - this._fontSize <= my) && (this.y >= my);
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let xdif = mx - (this.x + this._numberMetrics.width);
        let ydif = my - (this.y - this._fontSize);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) {
            this._isEditing = false;
            return 2;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawTextGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0) {
            switch (corner) { //colors the guide blue if selected
                case 2:
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue');
                    break;
            }
        }
        else {
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white');
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /* Event listener functions */
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition(event);
        if (this._isSelected && this._isDragging) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this._fontSize < 15);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        if (!this._isSelectingMultiple && this._isSelected && this.contains(this._mouse.x, this._mouse.y)) { //text editing
            if (!this._isListening) {
                window.addEventListener('keydown', this.modifyText.bind(this));
            }
            this._isListening = true;
            this._isEditing = true;
            this._isDragging = false;
            this._numberMetrics.initMousePos = this._mouse.x;
            this.modifyTextCursor();
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isEditing = false;
        }
        else {
            this._isEditing = false;
        }
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y) > 0, this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //("string dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Creates and moves the text edit cursor based on where the mouse is clicked
     */
    modifyTextCursor() {
        let leftWall = this.x; // the x position of the left most side of the bounding rectangle
        let xDif = this._numberMetrics.initMousePos - leftWall; // difference between mouse x and left wall
        let interval = this._numberMetrics.interval; // the text width divided by the length of the string
        let moveFactor = 0;
        if (xDif >= interval / 2 && xDif <= interval) {
            moveFactor = leftWall + interval;
            this._numberMetrics.cursorPos = interval;
        }
        else if (xDif <= interval / 2) {
            moveFactor = leftWall;
            this._numberMetrics.cursorPos = 0;
        }
        else if (xDif % interval >= interval / 2) {
            moveFactor = leftWall + interval * Math.ceil(xDif / interval);
            this._numberMetrics.cursorPos = interval * Math.ceil(xDif / interval);
        }
        else if (xDif % interval < interval / 2) {
            moveFactor = leftWall + interval * Math.floor(xDif / interval);
            this._numberMetrics.cursorPos = interval * Math.floor(xDif / interval);
        }
        this._ctx.moveTo(moveFactor, this.y - this._fontSize);
        this._ctx.lineTo(moveFactor, this.y);
        this._ctx.strokeStyle = "grey";
        this._ctx.stroke();
    }
    /**
     * This edits the string when editing text
     * @param event keydown event
     */
    modifyText(event) {
        if (this._isEditing) {
            let firstHalf;
            let secondHalf;
            let str = this._num.toString();
            let breakPoint = this._numberMetrics.cursorPos / this._numberMetrics.interval;
            firstHalf = str.substring(0, breakPoint);
            secondHalf = str.substring(breakPoint);
            if (event.keyCode == 37 && this._numberMetrics.initMousePos > this.x + this._numberMetrics.interval / 2) {
                this._numberMetrics.initMousePos -= this._numberMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 39 && this._numberMetrics.initMousePos < this.x + this._numberMetrics.width) {
                this._numberMetrics.initMousePos += this._numberMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 8 && str.length > 0) {
                firstHalf = firstHalf.substring(0, firstHalf.length - 1);
                str = firstHalf + secondHalf;
                this._num.val = Number(str);
                this._numberMetrics.initMousePos -= this._numberMetrics.interval;
                this.modifyTextCursor();
            }
            else {
                let keyName = event.key;
                if (keyName.length == 1) {
                    firstHalf += keyName;
                    str = firstHalf + secondHalf;
                    this._num.val = Number(str);
                    this._numberMetrics.initMousePos += this._numberMetrics.interval;
                    this.modifyTextCursor();
                }
            }
        }
    }
    /**
     * Modifies the font size of the text
     * If the text font is smaller than 15pt, it set's it equal to 15pt
     * @param isTooSmall true if the font size is < 15
     */
    modifyResize(isTooSmall) {
        if (isTooSmall) {
            this._fontSize = 15;
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._fontSize += (newDistance - this._initDistance) * 0.2;
                this._initDistance = newDistance;
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this._fontSize += (newDistance - this._initDistance) * 0.2;
            this._initDistance = newDistance;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x = this.x;
                this._y = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
            else {
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
                this._isDragging = true;
            }
            // if(this._context.mulSelected.mulSel){
            //     console.log("string effect mulSelected: " + this._context.mulSelected.mulSel);
            //     //if(this._context.mulSelected.val){
            //     this._context.eventLog.push(this.logSelected());
            //     //this.logSelected();
            // }
        }
        else if (guideContains) { //if the corner guides contain the mouse we are resizing
            this._isSelected = true;
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._context.eventLog.push(this.logClick());
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
            this._isResizing = true;
            this._size1 = this._fontSize; // saving old font size
        }
        else if (contains) {
            this._x = this.x; // Saving original x and y
            this._y = this.y;
            this._isSelected = true;
            this._context.eventLog.push(this.logClick());
            this._dragoffx = this._mouse.x - this.x;
            this._dragoffy = this._mouse.y - this.y;
            if (!this._isEditing) {
                this._isDragging = true;
            }
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
            this._isEditing = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x - this.x) > 1 || Math.abs(this._y - this.y) > 1) {
                this._justDragged = true;
                //this._context.eventLog.push(this.logMove());
            }
        }
        else if (this._isResizing && this._isSelected) {
            this._isResizing = false;
            if (Math.abs(this._size1 - this._fontSize) > 0) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._corner = 0;
        // console.log("string effect mulSelected: " + this._context.mulSelected.val);
        // if(this._context.mulSelected.val){
        //     this.logSelected();
        // }
        // if(this.isMultipleSelected){
        //     context.eventLog.push(new SelectEvent(selectedElems));
        //     masterLog.push(context.eventLog[context.eventLog.length - 1]);
        //     //console.log("multiple selected");
        // }
        // //this._context.eventLog.push(this.logMove());
    }
    /**
     * Gets the current x and y coordinates of the mouse
     * NOTE: in Firefox, window.event is not global. Need to be passed in here as a paramater.
     * @param event the mousedown event
     */
    getMousePosition(event) {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._isEditing = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent(this._num.toString(), this.x, this.y);
    }
    /**
     * Logs a resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent(this._num.toString() + " with ID " + this.getID().toString(), Math.round(this._size1 * 100) / 100, Math.round(this._fontSize * 100) / 100);
    }
    /**
     * Logs a click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent(this._num.toString() + " with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id, };
    }
    /**
     * Returns the canvas
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Sets the canvas
     * @param canvas The canvas to be assigned
     */
    set canvas(canvas) {
        this._canvas = canvas;
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the number
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the number
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
    * Returns whether or not the ellipse has just been dragged
    */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the ellipse has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the ellipse is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Returns whether or not this is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the number
     */
    get num() {
        return this._num.val;
    }
    /**
     * Returns the object ID
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " " + this._num.toString() + " with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return (this._num.toString() + " with ID " + this.getID().toString() + " from " + this._x + ", " + this._y + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to " + this._num.toString() + " at " + this.x + ", " + this.y);
    }
}
exports.NumberEffect = NumberEffect;
/**
 * Get's the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":24,"../logging/PaintEvent":28,"../logging/ResizeEvent":29}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class RectangleEffect {
    constructor(rect) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._rect = rect;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        this._ctx.rect(x, y, width, height);
        //this._ctx.strokeStyle = "black";
        //this._ctx.stroke();
        this._ctx.fillStyle = "#d5b8ff";
        this._ctx.shadowColor = "#6C6C6C";
        this._ctx.shadowBlur = 15;
        //this._ctx.shadowOffsetX = 2;
        //this._ctx.shadowOffsetY = 2;
        this._ctx.fill();
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) { // a corner guide is selected
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) { // a middle guide is selected
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else { //if no guides are selected, colors everything white
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition(event);
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._rect.width = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._rect.height = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._rect.height = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._rect.width = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._rect.width = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._rect.height = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._rect.width = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._rect.height = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.h > 10) { //as long as the height is > 10
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._rect.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._rect.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._rect.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10) { // as long as width is > 10
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._rect.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) { // sets the offsets depending on which corner is selected
                case 1: // top left
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w; // offset is bottom right
                    this._dragoffy = y + h;
                    break;
                case 2: // top right
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h; // offset is bottom left, etc
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) { // sets the offsets depending on which middle guide is selected
                case 5: // top middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2; // offset is bottom middle
                    this._dragoffy = y + h;
                    break;
                case 6: //right middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2; // offset is left middle etc
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) { // dragging
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) { // not selected
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     * NOTE: in Firefox, window.event is not global. Need to be passed in here as a paramater.
     * @param event the mousedown event
     */
    getMousePosition(event) {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isChangingDims = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a rectangle paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("rectangle", this.x, this.y);
    }
    /**
     * Logs a rectangle resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("rectangle with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs a rectangle click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("rectangle with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the rect
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the rect
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the rect
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the rect
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the rect is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the rect
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the rect has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the rect has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the rect is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " rectangle with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("rectangle with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to rectangle at " + this.x + ", " + this.y);
    }
}
exports.RectangleEffect = RectangleEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":24,"../logging/PaintEvent":28,"../logging/ResizeEvent":29,"../prims/NumberNode":68}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class StringEffect {
    constructor(str) {
        this._fontSize = 20;
        //private _size2: number;
        this._corner = 0;
        this._isSelected = false; // Private bools
        this._isEditing = false;
        this._isListening = false;
        this._isDragging = false;
        this._isResizing = false;
        this._isSelectingMultiple = false;
        this._justDragged = false; // Has this object just been dragged?
        //private _log: string[];
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._textMetrics = {
            width: 0,
            interval: 0,
            initMousePos: 0,
            cursorPos: 0
        };
        this._str = str;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas != undefined) {
            this._context = context;
            this._canvas = context.canvas.get();
            this._dims = dims;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this.update();
            // logging
            this._context.eventLog.push(this.logPaint()); // this.context or context?
            context.effects.push(this);
            this.addEventListeners();
        }
        else {
            console.log("canvas is NOT defined");
        }
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let fontDeets = this._fontSize + "px Courier New";
        this._ctx.font = fontDeets;
        this._ctx.fillStyle = "#673AB7";
        this._ctx.fillText(this._str.val, this.x, this.y);
        this._textMetrics.width = this._ctx.measureText(this._str.val).width;
        this._textMetrics.interval = this._textMetrics.width != 0 ? this._textMetrics.width / this._str.val.length : 0;
        if (this._isSelected) {
            this.drawTextGuides(this.x, this.y - this._fontSize, this._textMetrics.width, this._fontSize, this._corner);
        }
        if (this._isEditing) {
            this.modifyTextCursor();
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        return (this.x <= mx) && (this.x + this._textMetrics.width >= mx) &&
            (this.y - this._fontSize <= my) && (this.y >= my);
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let xdif = mx - (this.x + this._textMetrics.width);
        let ydif = my - (this.y - this._fontSize);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) {
            this._isEditing = false;
            return 2;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawTextGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0) {
            switch (corner) { //colors the guide blue if selected
                case 2:
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue');
                    break;
            }
        }
        else {
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white');
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /* Event listener functions */
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition(event);
        if (this._isSelected && this._isDragging) {
            //console.log(this._str.val + " is being dragged.");
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this._fontSize < 15);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        if (!this._isSelectingMultiple && this._isSelected && this.contains(this._mouse.x, this._mouse.y)) { //text editing
            if (!this._isListening) {
                window.addEventListener('keydown', this.modifyText.bind(this));
            }
            this._isListening = true;
            this._isEditing = true;
            this._isDragging = false;
            //console.log(this._str.val + " is setting dragging to false");
            this._textMetrics.initMousePos = this._mouse.x;
            this.modifyTextCursor();
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isEditing = false;
        }
        else {
            this._isEditing = false;
        }
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y) > 0, this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //("string dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Creates and moves the text edit cursor based on where the mouse is clicked
     */
    modifyTextCursor() {
        let xDif = this._textMetrics.initMousePos - this.x; // difference between mouse x and left wall
        let interval = this._textMetrics.interval;
        this._textMetrics.cursorPos = interval != 0 ? interval * Math.round(xDif / interval) : 0;
        let moveFactor = this._textMetrics.cursorPos + this.x;
        this._ctx.moveTo(moveFactor, this.y - this._fontSize);
        this._ctx.lineTo(moveFactor, this.y);
        this._ctx.strokeStyle = "grey";
        this._ctx.stroke();
    }
    /**
     * This edits the string when editing text
     * @param event keydown event
     */
    modifyText(event) {
        if (!this._isEditing) {
            return;
        }
        let interval = this._textMetrics.interval;
        let breakPoint = interval != 0 ? this._textMetrics.cursorPos / interval : 0;
        let firstHalf = this._str.val.substring(0, breakPoint);
        let secondHalf = this._str.val.substring(breakPoint);
        switch (event.keyCode) {
            case 37: // Arrow left
                if (this._textMetrics.initMousePos > this.x + interval / 2) {
                    this._textMetrics.initMousePos -= interval;
                    this.modifyTextCursor();
                }
                break;
            case 39: // Arrow right
                if (this._textMetrics.initMousePos < this.x + this._textMetrics.width) {
                    this._textMetrics.initMousePos += interval;
                    this.modifyTextCursor();
                }
                break;
            case 8: // Backspace
                if (this._textMetrics.cursorPos > 0) {
                    firstHalf = firstHalf.substring(0, firstHalf.length - 1);
                    this._str.str = firstHalf + secondHalf;
                    this._textMetrics.initMousePos -= interval;
                    this.modifyTextCursor();
                }
                event.preventDefault(); // Backspacing on Firefox will go back to a previous page
                break;
            case 46: // Del
                secondHalf = secondHalf.substring(1, secondHalf.length);
                this._str.str = firstHalf + secondHalf;
                break;
            default:
                let keyName = event.key;
                if (keyName.length == 1) {
                    firstHalf += keyName;
                    this._str.str = firstHalf + secondHalf;
                    if (interval == 0) {
                        interval = this._ctx.measureText(this._str.val).width / this._str.val.length;
                    }
                    this._textMetrics.initMousePos += interval;
                    this.modifyTextCursor();
                }
        }
    }
    /**
     * Modifies the font size of the text
     * If the text font is smaller than 15pt, it set's it equal to 15pt
     * @param isTooSmall true if the font size is < 15
     */
    modifyResize(isTooSmall) {
        if (isTooSmall) {
            this._fontSize = 15;
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._fontSize += (newDistance - this._initDistance) * 0.2;
                this._initDistance = newDistance;
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this._fontSize += (newDistance - this._initDistance) * 0.2;
            this._initDistance = newDistance;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
            else {
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
                this._isDragging = true;
            }
            // if(this._context.mulSelected.mulSel){
            //     console.log("string effect mulSelected: " + this._context.mulSelected.mulSel);
            //     //if(this._context.mulSelected.val){
            //     this._context.eventLog.push(this.logSelected());
            //     //this.logSelected();
            // }
        }
        else if (guideContains) { //if the corner guides contain the mouse we are resizing
            this._isSelected = true;
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._context.eventLog.push(this.logClick());
            //console.log(this._str.val + "is selected?" + this._selected);
            //console.log("state selection is " + this._str.val);
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
            this._isResizing = true;
            this._size1 = this._fontSize; // saving old font size
        }
        else if (contains) {
            this._x1 = this.x; // Saving original x and y
            this._y1 = this.y;
            this._isSelected = true;
            this._context.eventLog.push(this.logClick());
            //console.log(this._str.val + "is selected?" + this._selected);
            //console.log("state selection is " + this._str.val);
            this._dragoffx = this._mouse.x - this.x;
            this._dragoffy = this._mouse.y - this.y;
            if (!this._isEditing) {
                this._isDragging = true;
                //console.log(this._str.val + " is dragging? " + this._isDragging);
            }
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
            this._isEditing = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            //console.log(this._str.val + " logging drag");
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
                //this._context.eventLog.push(this.logMove());
            }
        }
        else if (this._isResizing && this._isSelected) {
            //console.log(this._str.val + " logging resize");
            this._isResizing = false;
            if (Math.abs(this._size1 - this._fontSize) > 0) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._corner = 0;
        // console.log("string effect mulSelected: " + this._context.mulSelected.val);
        // if(this._context.mulSelected.val){
        //     this.logSelected();
        // }
        // if(this.isMultipleSelected){
        //     context.eventLog.push(new SelectEvent(selectedElems));
        //     masterLog.push(context.eventLog[context.eventLog.length - 1]);
        //     //console.log("multiple selected");
        // }
        // //this._context.eventLog.push(this.logMove());
    }
    /**
     * Gets the current x and y coordinates of the mouse
     * NOTE: in Firefox, window.event is not global. Need to be passed in here as a paramater.
     * @param event the mousedown event
     */
    getMousePosition(event) {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._isEditing = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent(this._str.val, this.x, this.y);
    }
    /**
     * Logs a resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent(this._str.val + " with ID " + this.getID().toString(), Math.round(this._size1 * 100) / 100, Math.round(this._fontSize * 100) / 100);
    }
    /**
     * Logs a click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent(this._str.val + " with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id, };
    }
    /**
     * Returns the canvas
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Sets the canvas
     * @param canvas The canvas to be assigned
     */
    set canvas(canvas) {
        this._canvas = canvas;
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the ellipse
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the ellipse
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
    * Returns whether or not the ellipse has just been dragged
    */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the ellipse has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the ellipse is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Returns whether or not this is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the string
     */
    get str() {
        return this._str.val;
    }
    /**
     * Returns the object ID
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " " + this._str.val + " with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return (this._str.val + " with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to " + this._str.val + " at " + this.x + ", " + this.y);
    }
}
exports.StringEffect = StringEffect;
/**
 * Get's the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":24,"../logging/PaintEvent":28,"../logging/ResizeEvent":29}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ReturnError_1 = require("../structural/ReturnError");
const space_lift_1 = require("space-lift");
// Application of a function. Assumes arg values passed in same order as FunDef args
class FunApp {
    /**
     * The constructor for a function application
     * @param name The name of the function
     * @param args Function arguments, if applicable
     * @param ws Preceding whitespace
     * @param defaultValue The default return value of the function, if any
     */
    constructor(name, args, ws, defaultValue) {
        this._defaultValue = undefined;
        this._newLine = false;
        this._name = name;
        this._args = args;
        this._defaultValue = defaultValue;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the function application
     * @param context
     */
    eval(context) {
        let fundef = context.lookup(this._name, context); // looking up function
        //let child = new Scope(fundef.scope); // avoiding overwrite; need to toss after returning
        let child = fundef.scope.copy(); // Copying definition scope
        // Assigns arg values to definition arguments
        if (this._args != null) {
            for (let i = 0; i < this._args.length; i++) { //lookups?
                //child.declare(this._funct.args[i]); // redeclare?
                child.assign(fundef.args[i], this._args[i]);
            }
        }
        let id = context.globalFunID; // Assigns an ID to the function
        context.globalFunID++;
        child.retValID = space_lift_1.Some(id); // new method
        // we only return a value with function application
        // if it is explicitly returned using a return statement;
        // we abuse JS exceptions for this purpose
        try {
            child.hadFunEval = true;
            fundef.body.eval(child);
            return this._defaultValue;
        }
        catch (e) {
            // make sure that we catch only the error intended for us
            if (e instanceof ReturnError_1.ReturnError && parseInt(e.ID) == id) {
                return e.retVal;
            }
            // error was not intended for us; rethrow
            throw e;
        }
        //return fundef.body.eval(child);
    }
    /**
     * Returns a string representation of the function application
     */
    toString() {
        let argsList = '';
        if (this._args.length > 0) {
            for (let i = 0; i < this._args.length - 1; i++) {
                argsList += this._args[i].toString() + ", ";
            }
            argsList += this._args[this._args.length - 1].toString();
        }
        return this._ws + this.name + '(' + argsList + ")";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Function applications cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a function application
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on functions");
    }
    /**
     * Returns the name of the function
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the arguments of the function
     */
    get args() {
        return this._args;
    }
}
exports.FunApp = FunApp;

},{"../structural/ReturnError":80,"space-lift":96}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
class FunDef {
    constructor(name, body, args, ws) {
        this._newLine = true;
        this._name = name;
        this._body = body;
        this._args = args;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    ;
    // Binds args in context of definition; no values
    // Binds name to parent context (cur context is new context)
    eval(context) {
        this._funScope = new Scope_1.Scope(context); // ************* copy????
        this._funScope.canvas = context.canvas;
        this._funScope.eventLog = context.eventLog;
        this._funScope.effects = context.effects;
        /*
        if(this._args != null){
            for(let entry of this._args){
                this._funScope.declare(entry);
            }
        }
        */
        context.declare(this._name); // assign with val function
        context.assign(this._name, this); // parent or current?
        return null;
    }
    newLine() {
        return this._newLine;
    }
    toString() {
        let argsList = '';
        if (this._args.length > 0) {
            for (let i = 0; i < this._args.length - 1; i++) {
                argsList += this._args[i] + ", ";
            }
            argsList += this._args[this._args.length - 1];
        }
        return this._ws + "fun " + this._name + "(" + argsList + ')' + ' {\n ' + this._body.toString() + '}';
    }
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    equalsVal(right) {
        throw new Error("Cannot call equals directly on functions");
    }
    // Get methods
    get name() {
        return this._name;
    }
    get body() {
        return this._body;
    }
    get args() {
        return this._args;
    }
    get scope() {
        return this._funScope;
    }
}
exports.FunDef = FunDef;

},{"../structural/Scope":81}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ListNode {
    /**
     * Constructor for an array-like list
     * @param list The list, stored in a TS array
     * @param ws Preceding whitespace
     */
    constructor(list, ws) {
        this._newLine = false;
        this._list = list;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates each element of the list and pushes it onto the internal representation
     * @param context
     */
    eval(context) {
        let evalList = [];
        for (let expr of this._list) {
            evalList.push(expr.eval(context));
        }
        return new ListNode(evalList);
    }
    /**
     * Returns a string representation of the list
     */
    toString() {
        let list = '';
        for (let i = 0; i < this._list.length - 1; i++) {
            list += this._list[i].toString() + ", ";
        }
        list += this._list[this._list.length - 1].toString();
        return this._ws + '[' + list + ']';
    }
    /**
     * Returns whether the list equals another list
     * @param right The right side of the equality (must be a ListNode)
     */
    equalsVal(right) {
        if (right instanceof ListNode) {
            for (let i = 0; i < this.list.length; i++) {
                if (!(this.list[i].equalsVal(right.list[i]))) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Draw cannot be called directly on a list
     */
    draw() {
        throw new Error("Cannot draw a ListNode");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the internal representation of the list
     */
    get list() {
        return this._list;
    }
}
exports.ListNode = ListNode;

},{}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class ClearEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for the Clear Event, which logs when the canvas is cleared
     * @param toLog What to log (spoiler: nothing)
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "clear";
    }
    /**
     * Assembles and returns message "Console cleared" with date and time attached
     */
    assembleLog() {
        let toPrint = "Console cleared";
        return this.logItem(toPrint);
    }
    eventType() {
        return "ClearEvent";
    }
    toJSON() {
        return "{}";
    }
}
exports.ClearEvent = ClearEvent;

},{"./LogEvent":27}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class ClickEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Click Event, which logs when an object on the canvas is clicked
     * @param toLog The string representation of the object to log
     * @param x1 The x coordinate of the object to log
     * @param y1 The y coordinate of the object to log
     */
    constructor(toLog, x1, y1) {
        super(toLog, x1, y1);
        this.tag = "click";
    }
    /**
     * Assembles and returns message of form "Clicked on obj at x, y" with date and time attached
     */
    assembleLog() {
        let toPrint = "Clicked on " + this.toLog + " at " + this.x1.toString() + ", " + this.y1.toString();
        return this.logItem(toPrint);
    }
    eventType() {
        return "ClickEvent";
    }
    toJSON() {
        return "{ on: '" + this.toLog + "', x: '" + this.x1 + "', y: '" + this.y1 + "' }";
    }
}
exports.ClickEvent = ClickEvent;

},{"./LogEvent":27}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class DragEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Drag Event, which logs when an object on the canvas is dragged
     * @param toLog The effect to log
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "drag";
        this._toPrint = this.assembleString();
    }
    /**
     * Assembles a log string using the Effect's toDragString() method
     */
    assembleString() {
        this._toPrint = this.toLog.toDragString();
        return this._toPrint;
    }
    /**
     * Assembles and returns final log message of form "Dragged obj from x1, y1 to x2, y2"
     * with date and time attached
     */
    assembleLog() {
        let print = "Dragged " + this._toPrint;
        return this.logItem(print);
    }
    eventType() {
        return "DragEvent";
    }
    toJSON() {
        return "{ on: '" + this.toLog.toDragString() + "' }";
    }
}
exports.DragEvent = DragEvent;

},{"./LogEvent":27}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class IDEvent extends LogEvent_1.LogEvent {
    /**
     * A constructor for an ID event, used when an object gets assigned an ID
     * @param toLog The effect to log
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "ID";
        this._toPrint = this.assembleString();
    }
    /**
     * Assembles string using the effect's toIDString() method
     */
    assembleString() {
        this._toPrint = this.toLog.toIDString();
        return this._toPrint;
    }
    /**
     * Assembles message of form "Assigned ID # to obj at x, y" with date and time attached
     */
    assembleLog() {
        let print = "Assigned ID " + this._toPrint;
        return this.logItem(print);
    }
    eventType() {
        return "IDEvent";
    }
    toJSON() {
        return "{ on: '" + this.toLog.toIDString() + "' }";
    }
}
exports.IDEvent = IDEvent;

},{"./LogEvent":27}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class LogEvent {
    /**
     * Abstract class constructor for a Log Event. Registers event time.
     * @param toLog The string, object, or array of objects to be logged
     * @param x1 Initial x position, if applicable
     * @param y1 Initial y position, if applicable
     * @param x2 Final x position, if applicable
     * @param y2 Final y position, if applicable
     */
    constructor(toLog, x1, y1, x2, y2) {
        let today = new Date();
        this._date = today.getFullYear() + '-' + (today.getMonth() + 1) + '-' + today.getDate();
        this._time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds();
        this._dateTime = this._date + ' ' + this._time;
        this._toLog = toLog;
        //this._toLogArray = toLogArray;
        this._x1 = x1;
        this._y1 = y1;
        this._x2 = x2;
        this._y2 = y2;
    }
    /**
     * Attaches date and time to log message
     * @param toLog The log message
     */
    logItem(toLog) {
        return " " + this._dateTime + ": " + toLog;
    }
    /**
     * Returns date-time string
     */
    get dateTime() {
        return this._dateTime;
    }
    /**
     * Returns string or effect(s) to be logged
     */
    get toLog() {
        return this._toLog;
    }
    /**
     * Returns event tag
     */
    get tag() {
        return this._tag;
    }
    /**
     * Sets tag string
     */
    set tag(tag) {
        this._tag = tag;
    }
    /**
     * Returns x1
     */
    get x1() {
        return this._x1;
    }
    /**
     * Returns y1
     */
    get y1() {
        return this._y1;
    }
    /**
     * Returns x2
     */
    get x2() {
        return this._x2;
    }
    /**
     * Returns y2
     */
    get y2() {
        return this._y2;
    }
    /**
     * Logs to a remote server.
     */
    static logToRemoteServer(eventtype, uid, data) {
        // modified from: https://stackoverflow.com/a/10073788/480764
        function pad(n, width) {
            let padWith = '0';
            let nstr = n.toString();
            return nstr.length >= width ? nstr : new Array(width - nstr.length + 1).join(padWith) + nstr;
        }
        let date = new Date();
        let year = date.getFullYear().toString();
        let month = pad(date.getMonth() + 1, 2);
        let day = pad(date.getDay(), 2);
        let hour = pad(date.getHours(), 2);
        let minutes = pad(date.getMinutes(), 2);
        let seconds = pad(date.getSeconds(), 2);
        let payload = new FormData();
        payload.append('uid', uid);
        payload.append('data', data);
        payload.append('eventtype', eventtype);
        // MUST USE THE FOLLOWING DATE FORMAT
        // payload.append('time', '2019-01-01 16:36:00');
        payload.append('time', year + '-' + month + '-' + day + ' ' + hour + ':' + minutes + ':' + seconds);
        let xhr = new XMLHttpRequest();
        xhr.open("POST", "http://camembert.cs.williams.edu:8080/events", true);
        xhr.send(payload);
    }
}
exports.LogEvent = LogEvent;

},{}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class PaintEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Paint Event, used when an object is painted on the canvas
     * @param toLog The string representation of the object to be logged
     * @param x1 The x position of the object
     * @param y1 The y position of the object
     */
    constructor(toLog, x1, y1) {
        super(toLog, x1, y1);
        this.tag = "paint";
    }
    /**
     * Assembles and returns message of form "Painted obj at x, y" with date and time attached
     */
    assembleLog() {
        let toPrint = "Painted " + this.toLog + " at " + this.x1.toString() + ", " + this.y1.toString();
        return this.logItem(toPrint);
    }
    eventType() {
        return "PaintEvent";
    }
    toJSON() {
        return "{ on: '" + this.toLog + "', x: '" + this.x1 + "', y: '" + this.y1 + "' }";
    }
}
exports.PaintEvent = PaintEvent;

},{"./LogEvent":27}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class ResizeEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for Resize Event, used when an object on the canvas is resized
     * @param toLog String representation of the object to be logged
     * @param x1 Initial x dimension of the object, or initial font size
     * @param y1 Initial y dimension of the object, or final font size
     * @param x2 Final x dimension of the object
     * @param y2 Final y dimension of the object
     */
    constructor(toLog, x1, y1, x2, y2) {
        super(toLog, x1, y1, x2, y2);
        this.tag = "resize";
    }
    /**
     * Assembles log message of form "Resized obj from size x1, y1 to size x2, y2" for rects and ellipses
     * or of form "Resized obj from size x1 to size y1" for strings
     * Has date and time attached
     */
    assembleLog() {
        if (this.x2 != undefined && this.y2 != undefined) {
            this.toPrint = "Resized " + this.toLog + " from size " + this.x1.toString() + " by " + this.y1.toString()
                + " to size " + this.x2.toString() + " by " + this.y2.toString();
        }
        else {
            this.toPrint = "Resized " + this.toLog + " from size " + this.x1.toString() + " to size " + this.y1.toString();
        }
        return this.logItem(this.toPrint);
    }
    eventType() {
        return "ResizeEvent";
    }
    toJSON() {
        if (this.x2 != undefined && this.y2 != undefined) {
            return "{ on: '" + this.toLog + "', from_x: '" + this.x1 + "', from_y: '" + this.y1 + "', to_x: '" + this.x2 + "', to_y: '" + this.y2 + "' }";
        }
        else {
            // I don't understand this. Why this.y1?
            return "{ on: '" + this.toLog + "', from_x: '" + this.x1 + "', to_y: '" + this.y1 + "' }";
        }
    }
}
exports.ResizeEvent = ResizeEvent;

},{"./LogEvent":27}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class SelectEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Selection Event, used when multiple objects on the canvas are selected
     * @param toLog The array of objects selected
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "select";
        this._toPrint = this.assembleStrings();
    }
    /**
     * Assembles and returns a string representation of all the objects selected
     */
    assembleStrings() {
        let logStrings = [];
        for (let elem of this.toLog) {
            logStrings.push(elem.toSelString());
        }
        return "Selected" + logStrings;
    }
    /**
     * Returns the message with date and time attached
     */
    assembleLog() {
        return this.logItem(this._toPrint);
    }
    eventType() {
        return "SelectEvent";
    }
    toJSON() {
        return "{ on: '" + this.logItem(this._toPrint) + "' }";
    }
}
exports.SelectEvent = SelectEvent;

},{"./LogEvent":27}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class And {
    /**
     * Constructor for logical 'and' (&&) operation
     * @param left The left side of the operation
     * @param right The right side of the operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the operation and returns a boolean of the result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof BooleanNode_1.BooleanNode && rhs instanceof BooleanNode_1.BooleanNode) {
            return new BooleanNode_1.BooleanNode(lhs.val && rhs.val);
        }
        else {
            throw new Error("The arguments to the 'and' operator must be booleans.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + ' and ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on the 'and' op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * The 'and' operation cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns the left side of the op
     */
    get left() {
        return this._left;
    }
    /**
     * Returns the right side of the op
     */
    get right() {
        return this._right;
    }
}
exports.And = And;

},{"../prims/BooleanNode":66}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class Equals {
    /**
     * Constructor for equality (==) operation
     * @param left The left side of the equality
     * @param right The right side of the equality
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the comparison and evaluates to a BooleanNode
     * @param context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        return new BooleanNode_1.BooleanNode(lhs.equalsVal(rhs));
    }
    /**
     * Returns a string representation of the equality op
     */
    toString() {
        return this._ws + this._left.toString() + ' equals ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals can't be called directly on an equality op
     * @param right
     */
    equalsVal(right) {
        throw new Error("well this is meta");
    }
    /**
     * Equality ops can't be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.Equals = Equals;

},{"../prims/BooleanNode":66}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class GreaterThan {
    /**
     * Constructor for GreaterThan (>) op
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs GreaterThan comparison and returns BooleanNode representation of result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val > rhs.val));
        }
        else {
            throw new Error("The arguments to the > operator must be numeric.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + " > " + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on GreaterThan op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * GreaterThan op cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.GreaterThan = GreaterThan;

},{"../prims/BooleanNode":66,"../prims/NumberNode":68}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class GreaterThanEq {
    /**
     * Constructor for GreaterThanEq (greater than or equal to, >=) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs GreaterThanEq operation and returns BooleanNode with result
     * @param context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val >= rhs.val));
        }
        else {
            throw new Error("The arguments to the >= operator must be numeric.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + ' >= ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on GreaterThanEq op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * GreaterThanEq op cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.GreaterThanEq = GreaterThanEq;

},{"../prims/BooleanNode":66,"../prims/NumberNode":68}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class LessThan {
    /**
     * Constructor for LessThan (<) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the LessThan comparison and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        //console.log(this._left.eval(context) + " is less than " + this._right.eval(context));
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            //console.log("They're both number nodes");
            //console.log(lhs.val + "<" + rhs.val);
            //let bool: boolean = lhs.val < rhs.val;
            //console.log("bool: " + bool);
            return (new BooleanNode_1.BooleanNode(lhs.val < rhs.val));
        }
        else {
            throw new Error("Arguments to less than must produce numeric values.");
        }
    }
    /**
     * Returns string representation of operation
     */
    toString() {
        return this._left.toString() + ' < ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on LessThan op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * LessThan op cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.LessThan = LessThan;

},{"../prims/BooleanNode":66,"../prims/NumberNode":68}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class LessThanEq {
    /**
     * Constructor for LessThanEq (less than or equal to, <=) operation
     * @param left The left side of the operation
     * @param right The right side of the operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the LessThanEq comparison and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val <= rhs.val));
        }
        else {
            throw new Error("The arguments to the <= operator must be numeric.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + " <= " + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on LessThanEq op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * LessThanEq ops cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.LessThanEq = LessThanEq;

},{"../prims/BooleanNode":66,"../prims/NumberNode":68}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class Not {
    /**
     * Constructor for the logical Not (!) operation
     * @param expr The expression to be operated on (must be a BooleanNode)
     * @param ws Preceding whitespace
     */
    constructor(expr, ws) {
        this._newLine = false;
        this._expr = expr;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the Not operation and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        let e = this._expr.eval(context);
        if (e instanceof BooleanNode_1.BooleanNode) {
            return new BooleanNode_1.BooleanNode(!e.val);
        }
        else {
            throw new Error("The argument to the ! operator must be boolean.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + "not " + this._expr.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on a Not op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * Not operations cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns expression to be operated on
     */
    get expr() {
        return this._expr;
    }
}
exports.Not = Not;

},{"../prims/BooleanNode":66}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class NotEqual {
    /**
     * Constructor for NotEqual (!=) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs NotEqual operation and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val !== rhs.val));
        }
        else {
            throw new Error("The arguments to the != operator must be numeric.");
        }
    }
    /**
     * Returns string representation of operation
     */
    toString() {
        return this._ws + this._left.toString() + " not equals " + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on a NotEqual op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * NotEqual ops cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.NotEqual = NotEqual;

},{"../prims/BooleanNode":66,"../prims/NumberNode":68}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class Or {
    /**
     * Constructor for logical 'or' (||) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs Or operation and returns BooleanNode with result
     * @param context Current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof BooleanNode_1.BooleanNode && rhs instanceof BooleanNode_1.BooleanNode) {
            return new BooleanNode_1.BooleanNode(lhs.val || rhs.val);
        }
        else {
            throw new Error("The arguments to the 'or' operator must be booleans.");
        }
    }
    /**
     * Returns string representation of operation
     */
    toString() {
        return this._ws + this._left.toString() + ' or ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on Or operation
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * Or operations cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.Or = Or;

},{"../prims/BooleanNode":66}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const BooleanNode_1 = require("../prims/BooleanNode");
const space_lift_1 = require("space-lift");
class ForNode {
    /**
     * Constructor for a For loop
     * @param init Initializes the variable used in the condition
     * @param cond The condition (must evaluate to BooleanNode)
     * @param post The postevaluation condition
     * @param body The body of the loop
     * @param ws Preceding whitespace
     */
    constructor(init, cond, post, body, ws) {
        this._newLine = true;
        this._init = init;
        this._cond = cond;
        this._post = post;
        this._body = body;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the For loop
     * @param context The current program context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        this._init.eval(childCtx); // initialize var
        let res = this._cond.eval(childCtx);
        if (!(res instanceof BooleanNode_1.BooleanNode)) {
            throw new Error("The condition must be a boolean expression.");
        }
        let ret;
        while (res.val) {
            ret = this._body.eval(childCtx);
            this._post.eval(childCtx);
            res = this._cond.eval(childCtx);
        }
        return ret;
    }
    /**
     * Equals cannot be called directly on ForNode
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on For loop");
    }
    /**
     * ForNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        return "Cannot call draw on For loop";
    }
    /**
     * Returns a string representation of the for loop
     */
    toString() {
        return this._ws + 'for(' + this._init.toString() + ", " + this._cond.toString() + ", " + this._post.toString() + ") {\n "
            + this._body.toString() + "}";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.ForNode = ForNode;

},{"../prims/BooleanNode":66,"../structural/Scope":81,"space-lift":96}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
const space_lift_1 = require("space-lift");
class RepeatNode {
    /**
     * The constructor for repeat(n){}
     * @param n The number of times to repeat the loop's scope
     * @param body The enclosed body of the loop
     * @param ws Preceding whitespace
     */
    constructor(n, body) {
        this._newLine = true;
        this._n = n;
        this._body = body;
        console.log(this._body.toString());
    }
    /**
     * Evaluates the repeat loop
     * @param context The current program context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        let res = this._n.eval(childCtx);
        if (!(res instanceof NumberNode_1.NumberNode)) {
            throw new Error("The parameter for repeat() must be a number expression.");
        }
        let ret;
        for (var i = 0; i < res.val; i++) {
            ret = this._body.eval(childCtx);
        }
        return ret;
    }
    /**
     * Returns a string representation of the repeat statement
     */
    toString() {
        return 'repeat(' + this._n.toString() + ") {\n " + this._body.toString() + "}";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the body of the repeat loop
     */
    get body() {
        return this._body;
    }
    /**
     * RepeatNodes cannot be drawn directly
     */
    draw() {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a repeat
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on repeats");
    }
}
exports.RepeatNode = RepeatNode;

},{"../prims/NumberNode":68,"../structural/Scope":81,"space-lift":96}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const BooleanNode_1 = require("../prims/BooleanNode");
const space_lift_1 = require("space-lift");
class WhileNode {
    /**
     * Constructor for a While loop
     * @param cond The While loop condition
     * @param body The body of the loop
     * @param ws Preceding whitespace
     */
    constructor(cond, body, ws) {
        this._newLine = true;
        this._cond = cond;
        this._body = body;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the body of the loop while the condition is true
     * @param context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        let res = this._cond.eval(childCtx);
        if (!(res instanceof BooleanNode_1.BooleanNode)) {
            throw new Error("The condition must be a boolean expression.");
        }
        let ret;
        while (res.val) {
            ret = this._body.eval(childCtx);
            res = this._cond.eval(childCtx);
        }
        return ret;
    }
    /**
     * Equals cannot be called directly on WhileNodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on While loop");
    }
    /**
     * WhileNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        return "Cannot call draw on While loop";
    }
    /**
     * Returns a string representation of the While loop
     */
    toString() {
        return this._ws + "while(" + this._cond.toString() + ") {\n " + this._body.toString() + "}";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.WhileNode = WhileNode;

},{"../prims/BooleanNode":66,"../structural/Scope":81,"space-lift":96}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Instruction {
    constructor(location, content, top, left) {
        this._location = location;
        this._content = content;
        this._top = top;
        this._left = left;
    }
}
exports.Instruction = Instruction;

},{}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonFourCpOne extends Module_1.Module {
    constructor() {
        super(...arguments);
        this._name = "l4c1";
        this._nextModule = 'l4c2';
        this._constraint = 'none';
        this._instructions = `<p> You've made it to the FINAL CHALLENGES! Complete these challenges to earn ETERNAL GLORY! </p>
    <p> Throughout this Hour of Code, you have learned: </p>
    <p> - How to print a word, circle, rectangle, and curve. </p>
    <p> - How to store any of the value above in a variable. </p>
    <p> - How to use if/else statement to check a condition about a variable. </p>
    <p> Each of the following challenges will test these concepts. Let's dive right in! </p>
    <p> Print a circle and put its height and width in one of the boxes to the side. Then print a rectangle and put its height and width in the box. </p>
    <p> CHALLENGE: Print a circle and rectangle. Put their respective width and height in the boxes provided. </p>`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = this.editor.getValue();
        let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
        let match = code.match(regex);
        codeIsCorrect = match != null && match.length > 0;
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
}
exports.LessonFourCpOne = LessonFourCpOne;

},{"../effects/EllipseEffect":13,"./Module":63}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonFourCpTwo extends Module_1.Module {
    constructor() {
        super(...arguments);
        this._name = "l4c2";
        this._nextModule = 'l4c2';
        this._constraint = 'none';
        this._instructions = `<p> Yes! You got this! </p>
    <p> Now let's put those skills in if/else statements to work! </p>
    <p> Create a pair of if/else statements to print out to the CANVAS a claim of whether the circle is positioned ABOVE or BELOW the rectangle. </p>
    <p> CHALLENGE: Print a claim that states whether circle is ABOVE or BELOW the rectangle. </p>
    <p> HINT: Remember that the numbers in the print() statements determine the position of the shapes being printed. </p>`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = this.editor.getValue();
        let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
        let match = code.match(regex);
        codeIsCorrect = match != null && match.length > 0;
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
}
exports.LessonFourCpTwo = LessonFourCpTwo;

},{"../effects/EllipseEffect":13,"./Module":63}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpFour extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l1c4";
        this._prevModule = 'l1c2';
        this._nextModule = 'l2c1';
        this._constraint = 'canvas';
        this._instructions = `<p> CHALLENGE: Print the word "moo" on the CANVAS, and put it inside the box at the center of the CANVAS. </p>`;
        this._latestInstrIndex = 3;
        this.square_size = 100;
        this.font_size = 20;
        this.x = Math.round((ctx.canvas.width - this.square_size) / 2);
        this.y = Math.round((ctx.canvas.height - this.square_size) / 2);
        let content = "In real life, computer scientists often can only change their CODE to affect the CANVAS, instead of interacting with the CANVAS directly.";
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "30%", "10%"));
        content = "Anyone, including you, is cut out to be a computer scientist! Let's have a challenge.";
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = "The CANVAS is temporarily frozen. You can no longer interact with objects drawn on it.";
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "80%", "10%"));
        content = "Can you figure out how to write CODE to print the word 'moo' inside the box at the center of the CANVAS?";
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "80%", "10%"));
        content = "Congratulations! You finished your first coding challenge!";
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "80%", "10%"));
    }
    drawGuides() {
        this.ctx.beginPath();
        this.ctx.rect(this.x, this.y, this.square_size, this.square_size);
        this.ctx.strokeStyle = '#6C6C6C';
        this.ctx.stroke();
        this.ctx.font = this.font_size + "px Courier New";
        this.ctx.fillStyle = '#6C6C6C';
        this.ctx.fillText("Put word", this.x, this.y - 2 * this.font_size);
        this.ctx.fillText("in here", this.x, this.y - this.font_size);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        switch (this._latestInstrIndex) {
            case 3:
                for (let effect of effects) {
                    if (effect instanceof StringEffect_1.StringEffect && effect.str === "moo") {
                        if ((effect.x > this.x && effect.x < this.x + this.square_size) && (effect.y > this.y && effect.y < this.y + this.square_size)) {
                            this._latestInstrIndex++;
                            this.renderLatestInstruction(document);
                        }
                    }
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonOneCpFour = LessonOneCpFour;

},{"../effects/StringEffect":19,"./Instruction":43,"./Module":63}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
class LessonOneCpOne extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l1c1";
        this._nextModule = 'l1c2';
        this._constraint = 'none';
        this._instructions = `<p> GOAL: Write 'Hello' on the CANVAS. </p>`;
        this._latestInstrIndex = 0;
        let content = "First, let's tell the computer to print something on the CANVAS. Click on the CODE box.";
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "70%", "10%"));
        content = 'Great! Now type <span class="inline-code">print("Hello");</span> in this CODE box.';
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = 'Notice that what you typed causes the computer to print the word "Hello" on the CANVAS here. Congratulations! You just wrote your first line of code!';
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "65%", "10%"));
    }
    /**
     * A lesson to print a string
     * goals: write any string on CANVAS
     * @param document The HTML document
     * @param effects the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        switch (this._latestInstrIndex) {
            case 0:
                if (document.activeElement === this.editor.getInputField() && this._latestInstrIndex == 0) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            case 1:
                let regex = /print\s*\(\s*\"Hello\"\s*\)/;
                let match = this.editor.getValue().match(regex);
                if (match != null && match.length > 0) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonOneCpOne = LessonOneCpOne;

},{"./Instruction":43,"./Module":63}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpThree extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l1c3";
        this._prevModule = 'l1c2';
        this._nextModule = 'l1c4';
        this._constraint = 'canvas';
        this._instructions = `<p> GOAL: Move the word around the CANVAS solely by changing your CODE. </p>`;
        this._starterCode = `print("Hello", 100, 100)`;
        this._latestInstrIndex = 0;
        this.y = 10;
        this.square_size = 100;
        this.font_size = 20;
        this.x = ctx.canvas.width - this.square_size - this.y;
        let content = `Moving things on the CANVAS changes the CODE. What if we change the CODE? In the <span class="inline-code">print</span> statement above, change the first <span class="inline-code">100</span> to <span class="inline-code">200</span>. Observe the CANVAS.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "30%", "10%"));
        content = "Changing those numbers in the CODE moves the word on CANVAS! Now, try move this word inside the top-right box by changing your CODE alone.";
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "70%", "10%"));
        content = "Yay! You've learned how to tell the computer to write for you!";
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
    }
    drawGuides() {
        this.ctx.beginPath();
        this.ctx.rect(this.x, this.y, this.square_size, this.square_size);
        this.ctx.strokeStyle = '#6C6C6C';
        this.ctx.stroke();
        this.ctx.font = this.font_size + "px Courier New";
        this.ctx.fillStyle = '#6C6C6C';
        this.ctx.fillText("Put word", this.x, this.y - 2 * this.font_size);
        this.ctx.fillText("in here", this.x, this.y - this.font_size);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        switch (this._latestInstrIndex) {
            case 0:
                let regex = /print\s*\(\s*\".*\"\s*,\s*200\s*,\s*100\s*\)/;
                let match = this.editor.getValue().match(regex);
                if (match != null && match.length > 0) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            case 1:
                for (let effect of effects) {
                    if (effect instanceof StringEffect_1.StringEffect && effect.str !== "") {
                        if (effect.x > this.x && effect.x < this.x + this.square_size && effect.y > this.y && effect.y < this.y + this.square_size) {
                            this._latestInstrIndex++;
                            this.renderLatestInstruction(document);
                        }
                    }
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonOneCpThree = LessonOneCpThree;

},{"../effects/StringEffect":19,"./Instruction":43,"./Module":63}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpTwo extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l1c2";
        this._prevModule = 'l1c2';
        this._nextModule = 'l1c3';
        this._constraint = 'code';
        this._instructions = `<p> GOAL: Move the words you just created to explore how it affects your code. </p>`;
        this._starterCode = `print("Hello", 100, 100)`;
        this._latestInstrIndex = 1;
        this.y = 10;
        this.square_size = 100;
        this.font_size = 20;
        this.x = ctx.canvas.width - this.square_size - this.y;
        let content = `Notice the numbers added inside the brackets <span class="inline-code">()</span> of your <span class="inline-code">print</span> statement? They specify where your computer should write the word on the CANVAS.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "30%", "10%"));
        content = "To understand what they do, first click on the word currently on the CANVAS and drag it around.";
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "70%", "10%"));
        content = "Now drag the word into the top-right box on the CANVAS.";
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "80%", "10%"));
        content = `Did you notice that the numbers inside the <span class="inline-code">print</span> statement change? Now drag the word into the top-left box on the CANVAS.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "30%", "10%"));
        content = 'These numbers indicate the location on the CANVAS where the computer should draw the word! The first number changes when the word moves left and right. The second number changes when the word moves up and down.';
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "30%", "10%"));
    }
    drawGuides() {
        this.ctx.beginPath();
        this.ctx.rect(this.x, this.y, this.square_size, this.square_size);
        this.ctx.strokeStyle = '#6C6C6C';
        this.ctx.stroke();
        this.ctx.font = this.font_size + "px Courier New";
        this.ctx.fillStyle = '#6C6C6C';
        this.ctx.fillText("Put word", this.x, this.y + this.square_size + this.font_size);
        this.ctx.fillText("in here", this.x, this.y + this.square_size + 2 * this.font_size);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        switch (this._latestInstrIndex) {
            case 0:
                return false;
            case 1:
                for (let effect of effects) {
                    if (effect instanceof StringEffect_1.StringEffect && effect.str !== "" && effect.selected) {
                        this._latestInstrIndex++;
                        this.renderLatestInstruction(document);
                    }
                }
                return false;
            case 2:
                for (let effect of effects) {
                    if (effect instanceof StringEffect_1.StringEffect && effect.str !== "") {
                        if (effect.x > this.x && effect.x < this.x + this.square_size && effect.y > this.y && effect.y < this.y + this.square_size) {
                            this.x = 10;
                            this._latestInstrIndex++;
                            this.renderLatestInstruction(document);
                        }
                    }
                }
                return false;
            case 3:
                for (let effect of effects) {
                    if (effect instanceof StringEffect_1.StringEffect && effect.str !== "") {
                        if (effect.x > this.x && effect.x < this.x + this.square_size && effect.y > this.y && effect.y < this.y + this.square_size) {
                            this._latestInstrIndex++;
                            this.renderLatestInstruction(document);
                        }
                    }
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonOneCpTwo = LessonOneCpTwo;

},{"../effects/StringEffect":19,"./Instruction":43,"./Module":63}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpFive extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l3c5";
        this._nextModule = 'l3c6';
        this._constraint = 'none';
        this._instructions = `<p> GOAL: Change the value of c around to see when "c is NOT equal to 8." would be printed on the CANVAS. </p>`;
        this._starterCode = `c = 8;
if(c == 8) {
\tprint("c is equal to 8.", 103, 143);
} else {
\tprint("c is NOT equal to 8.", 103, 143);
}`;
        this._latestInstrIndex = 2;
        let content = `Now, what if we want to print another message, <span class="inline-code">c is not equal to 8</span> any time <span class="inline-code">c</span> is not equal to 8?`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = `Observe the CODE above. When the condition inside the brackets of <span class="inline-code">if()</span> is satisfied, the code block inside the braces <span class="inline-code">{}</span> right after it would run.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = `What would happen if we change the value of <span class="inline-code">c</span>? In the CODE above, change the value of <span class="inline-code">c</span> to <span class="inline-code">5</span> and observe what happens.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = `Did you notice the claim printed here changed? When the condition inside the <span class="inline-code">if</span> statement is not satisfied, the second code block inside the braces <span class="inline-code">{}</span> after the <span class="inline-code">else</span> statement would run instead!`;
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "70%", "10%"));
        content = `To get a better idea, change the value of <span class="inline-code">c</span> back to <span class="inline-code">8</span>.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = `Did you see the claim changed again? Now, change the value of <span class="inline-code">c</span> to <span class="inline-code">17</span>.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = `Hope you get the hang of what an <span class="inline-code">else</span> statement does by this point! As long as the condition inside the <span class="inline-code">if</span> statement is not satisfied, the code block inside the second braces <span class="inline-code">else{}</span> would run instead of the first code block.`;
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "70%", "10%"));
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document the HTML document
     * @param effects the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        let codeIsCorrect = false;
        let canvasIsCorrect = false;
        let code = this.editor.getValue();
        let regex;
        let match;
        switch (this._latestInstrIndex) {
            case 2:
                //check for correct CODE
                //let regex = /c\s*=\s*[^8]\s*/;
                regex = /c\s*=\s*5\s*/;
                match = code.match(regex);
                codeIsCorrect = match != null && match.length > 0;
                //check for correct CANVAS effects
                for (let effect of effects) {
                    if (effect instanceof StringEffect_1.StringEffect && effect.str === "c is NOT equal to 8.") {
                        canvasIsCorrect = true;
                        break;
                    }
                }
                if (codeIsCorrect && canvasIsCorrect) {
                    this._latestInstrIndex = 4;
                    this.renderNextInstruction(document);
                }
                return false;
            case 4:
                //check for correct CODE
                regex = /c\s*=\s*8\s*/;
                match = code.match(regex);
                codeIsCorrect = match != null && match.length > 0;
                //check for correct CANVAS effects
                for (let effect of effects) {
                    if (effect instanceof StringEffect_1.StringEffect && effect.str === "c is equal to 8.") {
                        canvasIsCorrect = true;
                        break;
                    }
                }
                if (codeIsCorrect && canvasIsCorrect) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            case 5:
                //check for correct CODE
                regex = /c\s*=\s*17\s*/;
                match = code.match(regex);
                codeIsCorrect = match != null && match.length > 0;
                //check for correct CANVAS effects
                for (let effect of effects) {
                    if (effect instanceof StringEffect_1.StringEffect && effect.str === "c is NOT equal to 8.") {
                        canvasIsCorrect = true;
                        break;
                    }
                }
                if (codeIsCorrect && canvasIsCorrect) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonThreeCpFive = LessonThreeCpFive;

},{"../effects/StringEffect":19,"./Instruction":43,"./Module":63}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpFour extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l3c4";
        this._nextModule = 'l3c5';
        this._constraint = 'none';
        this._instructions = `<p> GOAL: Change the value of c so that the line "c is equal to 8." is printed on the CANVAS. </p>`;
        this._starterCode = `c = 100;
if(c == 8) {
\tprint("c is equal to 8.", 103, 143);
}`;
        this._latestInstrIndex = 2;
        let content = `You can put an inequality condition inside the brackets of <span class="inline-code">if()</span>, such as <span class="inline-code">a < 5</span> or <span class="inline-code">b > 20</span>.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = `You can also use an equality condition. Observe the CODE above with <span class="inline-code">c == 8</span>. The 2 equal signs <span class="inline-code">==</span> mean that you are checking whether <span class="inline-code">c</span> is EXACTLY EQUAL to <span class="inline-code">8</span> or not.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = `Let's have a small challenge: Can you change the value of <span class="inline-code">c</span> so that the claim <span class="inline-code">c is equal to 8.</span> is printed on the CANVAS?`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = `That's correct! the code inside the braces <span class="inline-code">{}</span> of the <span class="inline-code">if</span> statement only runs when <span class="inline-code">c</span> is exactly equal to 8!`;
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "70%", "10%"));
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document the HTML document
     * @param effects the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        switch (this._latestInstrIndex) {
            case 2:
                //check for correct CODE
                let codeIsCorrect = false;
                let code = this.editor.getValue();
                let regex = /c\s*=\s*8\s*/;
                let match = code.match(regex);
                codeIsCorrect = match != null && match.length > 0;
                //check for correct CANVAS effects
                let canvasIsCorrect = false;
                for (let effect of effects) {
                    if (effect instanceof StringEffect_1.StringEffect && effect.str === "c is equal to 8.") {
                        canvasIsCorrect = true;
                        break;
                    }
                }
                if (codeIsCorrect && canvasIsCorrect) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonThreeCpFour = LessonThreeCpFour;

},{"../effects/StringEffect":19,"./Instruction":43,"./Module":63}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpOne extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l3c1";
        this._nextModule = 'l3c2';
        this._constraint = 'none';
        this._instructions = `<p> GOAL: Change the value of a to 12. </p>`;
        this._starterCode = `a = 5;
print(a, 118, 63);
print("a is less than 10", 103, 143);`;
        this._latestInstrIndex = 3;
        let content = "We learned to tell the computer to print a lot of things. Now, let's teach it to make some decisions on its own.";
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = 'Look at the CODE above. We let <span class="inline-code">a = 5</span>, then we print the value of <span class="inline-code">a</span> to the CANVAS. Then we print the line <span class="inline-code">a is less than 10</span>.';
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = `Since <span class="inline-code">a</span> is 5, and 5 < 10, we know that <span class="inline-code">a</span> is less than 10. But what would happen if we change the value of a to, say, 12?`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = `Change the value of <span class="inline-code">a</span> to <span class="inline-code">12</span>. Observe what happens on the CANVAS.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = 'Do you notice the claim that <span class="inline-code">a is less than 10</span> did not change? <span class="inline-code">a</span> is now 12 and clearly greater than 10! Yet our computer does not know to not print the wrong claim!';
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "70%", "10%"));
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document the HTML document
     * @param effects the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        switch (this._latestInstrIndex) {
            case 3:
                //check for correct CODE
                let codeIsCorrect = false;
                let code = this.editor.getValue();
                let regex = /a\s*=\s*12\s*/;
                let match = code.match(regex);
                codeIsCorrect = match != null && match.length > 0;
                //check for correct CANVAS effects
                let canvasIsCorrect = false;
                for (let effect of effects) {
                    if (effect instanceof StringEffect_1.StringEffect && effect.str === "a is less than 10") {
                        canvasIsCorrect = true;
                        break;
                    }
                }
                if (codeIsCorrect && canvasIsCorrect) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonThreeCpOne = LessonThreeCpOne;

},{"../effects/StringEffect":19,"./Instruction":43,"./Module":63}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const EllipseEffect_1 = require("../effects/EllipseEffect");
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpSix extends Module_1.Module {
    constructor(ctx, editor) {
        //setting up the CODE and CANVAS
        super(ctx, editor);
        this._name = "l3c6";
        this._nextModule = 'l3c6';
        this._constraint = 'none';
        this._instructions = `<p> GOAL: Create an if/else statement to print the correct claim about the sizes of the 2 circles. </p>`;
        this._latestInstrIndex = 3;
        this.font_size = 20;
        this.a_size = Math.round(Math.min(ctx.canvas.width, ctx.canvas.height) * 0.4);
        this.b_size = Math.round(this.a_size / 2);
        this.square_size = this.a_size + Math.round(Math.min(ctx.canvas.width, ctx.canvas.height) * 0.1);
        this.yA = Math.round((ctx.canvas.height - this.square_size) / 2);
        this.yB = this.yA;
        this.xA = Math.round(ctx.canvas.width / 2) - this.square_size - 10;
        this.xB = this.xA + this.square_size + 10;
        let square_mid = Math.round(this.square_size / 2);
        let circ_xA = this.xA + square_mid;
        let circ_yA = this.yA + square_mid;
        let circ_xB = this.xB + square_mid;
        let circ_yB = this.yB + square_mid;
        this._starterCode =
            `a = ${this.a_size};
print(a, ${this.xA}, ${this.yA - 2 * this.font_size});
print(ellipse(a, a), ${circ_xA}, ${circ_yA});
b = ${this.b_size};
print(b, ${this.xB}, ${this.yA - 2 * this.font_size});
print(ellipse(b, b), ${circ_xB}, ${circ_yB});
print("Circle A is smaller than circle B.", ${this.xA}, ${this.yA + this.square_size + this.font_size});`;
        //setting up the Instructions
        let content = `Now that you know how to use <span class="inline-code">if/else</span> statements, let's put them all together!`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = 'Above we have the CODE to draw 2 circles: circle A has height and width <span class="inline-code">a</span>, and circle B has height and width <span class="inline-code">b</span>.';
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = `However, currently the claim that <span class="inline-code">Circle A is smaller than circle B.</span> is printed regardless of the circles' actual sizes.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = `Here's a challenge for you: Create an <span class="inline-code">if/else</span> statement to print <span class="inline-code">Circle A is smaller than circle B.</span> when it is actually so, and print <span class="inline-code">Circle A is bigger than circle B.</span> otherwise.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "80%", "10%"));
        content = 'Congratulations! You just successfully wrote a complicated <span class="inline-code">if/else</span> statement!';
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "70%", "10%"));
    }
    drawGuides() {
        this.ctx.beginPath();
        this.ctx.rect(this.xA, this.yA, this.square_size, this.square_size);
        this.ctx.strokeStyle = '#6C6C6C';
        this.ctx.stroke();
        this.ctx.font = this.font_size + "px Courier New";
        this.ctx.fillStyle = '#6C6C6C';
        this.ctx.fillText("Circle A", this.xA, this.yA - this.font_size);
        this.ctx.beginPath();
        this.ctx.rect(this.xB, this.yB, this.square_size, this.square_size);
        this.ctx.stroke();
        this.ctx.fillText("Circle B", this.xB, this.yB - this.font_size);
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document the HTML document
     * @param effects the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        switch (this._latestInstrIndex) {
            case 3:
                //check for correct CODE
                let codeIsCorrect = false;
                let code = this.editor.getValue();
                let regex1 = /if\s*\(\s*a\s*[<>]\s*b\s*\)/;
                let regex2 = /if\s*\(\s*b\s*[<>]\s*a\s*\)/;
                let match1 = code.match(regex1);
                let match2 = code.match(regex2);
                codeIsCorrect = (match1 != null && match1.length > 0) || (match2 != null && match2.length > 0);
                //check for correct CANVAS effects
                let canvasIsCorrect = false;
                let circleA = null;
                let circleB = null;
                //look for circles A and B
                for (let effect of effects) {
                    if (effect instanceof EllipseEffect_1.EllipseEffect) {
                        if (effect.x > this.xA && effect.x < this.xA + this.square_size && effect.y > this.yA && effect.y < this.yA + this.square_size) {
                            circleA = effect;
                        }
                        else if (effect.x > this.xB && effect.x < this.xB + this.square_size && effect.y > this.yB && effect.y < this.yB + this.square_size) {
                            circleB = effect;
                        }
                    }
                }
                if (circleA != null && circleB != null) {
                    for (let effect of effects) {
                        if (effect instanceof StringEffect_1.StringEffect) {
                            let str = effect.str;
                            if ((str === "Circle A is smaller than circle B." && circleA.w < circleB.w && circleA.h < circleB.h)
                                || (str === "Circle A is bigger than circle B." && circleA.w > circleB.w && circleA.h > circleB.h)) {
                                canvasIsCorrect = true;
                                break;
                            }
                        }
                    }
                }
                if (codeIsCorrect && canvasIsCorrect) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonThreeCpSix = LessonThreeCpSix;

},{"../effects/EllipseEffect":13,"../effects/StringEffect":19,"./Instruction":43,"./Module":63}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpThree extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l3c3";
        this._nextModule = 'l3c4';
        this._constraint = 'none';
        this._instructions = `<p> GOAL: Make the line "b is greater than 20" only be printed on the CANVAS when b is actually greater than 20. </p>`;
        this._starterCode = `b = 8;
if(b < 10) {
\tprint("b is greater than 20.", 103, 143);
}`;
        this._latestInstrIndex = 1;
        let content = `<span class="inline-code">if</span> statements allow you to run a block of code inside the curly braces <span class="inline-code">{}</span> ONLY when the condition inside the brackets <span class="inline-code">if()</span> is true.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = `Let's have a quick challenge: observe the CODE above. Change the code inside the brackets <span class="inline-code">if()</span> so that the claim <span class="inline-code">b is greater than 20</span> is only printed on the CANVAS when <span class="inline-code">b</span> is actually greater than 20.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = `Your CODE seems correct! Now change the value of <span class="inline-code">b</span> to <span class="inline-code">50</span> to test that it runs correctly.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = 'The claim is printed with the correct value of <span class="inline-code">b</span>! Good job!';
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "70%", "10%"));
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document the HTML document
     * @param effects the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        let codeIsCorrect = false;
        let canvasIsCorrect = false;
        let code = this.editor.getValue();
        let regex;
        let match;
        switch (this._latestInstrIndex) {
            case 1:
                //check for correct CODE
                regex = /if\s*\(\s*b\s*>\s*20\s*\)/;
                match = code.match(regex);
                if (match != null && match.length > 0) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            case 2:
                //check for correct CODE
                regex = /if\s*\(\s*b\s*>\s*20\s*\)/;
                match = code.match(regex);
                let assign = /b\s*=\s*50\s*/;
                let matchAssign = code.match(assign);
                codeIsCorrect = match != null && match.length > 0 && matchAssign != null && matchAssign.length > 0;
                //check for correct CANVAS effects
                for (let effect of effects) {
                    if (effect instanceof StringEffect_1.StringEffect && effect.str === "b is greater than 20.") {
                        canvasIsCorrect = true;
                        break;
                    }
                }
                if (codeIsCorrect && canvasIsCorrect) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonThreeCpThree = LessonThreeCpThree;

},{"../effects/StringEffect":19,"./Instruction":43,"./Module":63}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpTwo extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l3c2";
        this._nextModule = 'l3c3';
        this._constraint = 'none';
        this._instructions = `<p> GOAL: Change the value of a around and observe what happens. </p>`;
        this._starterCode = `a = 12;
print(a, 118, 63);
if(a < 10) {
\tprint("a is less than 10", 103, 143);
}`;
        this._latestInstrIndex = 2;
        let content = `Let's teach the computer to print the sentence <span class="inline-code">a is less than 10</span> ONLY when <span class="inline-code">a</span> is truly less than 10.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = 'We will use something called an <span class="inline-code">if</span> statement. Observe the CODE above. All we added was an <span class="inline-code">if</span> statement that checks whether <span class="inline-code">a < 10</span>. If a is less than 10, the code inside the curly braces <span class="inline-code">{}</span> will be executed.';
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = `Let's investigate what this statement does. First, change the value of <span class="inline-code">a</span> to <span class="inline-code">8</span>. Observe what happens.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = `Did you see the correct claim is printed on the CANVAS? Now let's change the value of <span class="inline-code">a</span> to, say, <span class="inline-code">25</span>.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = 'The claim about <span class="inline-code">a</span> disappears! Finally, change the value of <span class="inline-code">a</span> to <span class="inline-code">0</span>.';
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "70%", "10%"));
        content = 'The claim appears again! The <span class="inline-code">if</span> statement makes the computer constantly check the value of <span class="inline-code">a</span>, and only print the claim when the condition inside the brackets <span class="inline-code">()</span> is satisfied!';
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document the HTML document
     * @param effects the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        let codeIsCorrect = false;
        let canvasIsCorrect = false;
        let code = this.editor.getValue();
        let regex;
        let match;
        switch (this._latestInstrIndex) {
            case 2:
                //check for correct CODE
                regex = /a\s*=\s*8\s*/;
                match = code.match(regex);
                codeIsCorrect = match != null && match.length > 0;
                //check for correct CANVAS effects
                for (let effect of effects) {
                    if (effect instanceof StringEffect_1.StringEffect && effect.str === "a is less than 10") {
                        canvasIsCorrect = true;
                        break;
                    }
                }
                if (codeIsCorrect && canvasIsCorrect) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            case 3:
                //check for correct CODE
                regex = /a\s*=\s*25\s*/;
                match = code.match(regex);
                codeIsCorrect = match != null && match.length > 0;
                //check for correct CANVAS effects
                for (let effect of effects) {
                    if (effect instanceof StringEffect_1.StringEffect && effect.str === "a is less than 10") {
                        canvasIsCorrect = true;
                        break;
                    }
                }
                if (codeIsCorrect && !canvasIsCorrect) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            case 4:
                //check for correct CODE
                regex = /a\s*=\s*0\s*/;
                match = code.match(regex);
                codeIsCorrect = match != null && match.length > 0;
                //check for correct CANVAS effects
                for (let effect of effects) {
                    if (effect instanceof StringEffect_1.StringEffect && effect.str === "a is less than 10") {
                        canvasIsCorrect = true;
                        break;
                    }
                }
                if (codeIsCorrect && canvasIsCorrect) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonThreeCpTwo = LessonThreeCpTwo;

},{"../effects/StringEffect":19,"./Instruction":43,"./Module":63}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpFive extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l2c5";
        this._nextModule = 'l2c6';
        this._constraint = 'none';
        this._instructions = `<p> GOAL: Create a variable c referring to an ellipse(75, 75), then write 2 print statements to print c. </p>`;
        this._starterCode = `a = "moo moo";
b = ellipse(100, 100);
print(b, 100, 100);`;
        this._latestInstrIndex = 0;
        let content = `Let's take this one step further: Create a new variable <span class="inline-code">c</span>, and make it refer to an <span class="inline-code">ellipse(75, 75)</span>.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = `Now change the <span class="inline-code">print</span> statement to print <span class="inline-code">c</span> instead of <span class="inline-code">b</span>.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = `Finally, write <span class="inline-code">print(c, 300, 100);</span> underneath the existing <span class="inline-code">print</span> statement.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = 'Awesome, You are getting good at using variables! What you just did is to draw 2 circles, both named <span class="inline-code">c</span>!';
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "70%", "10%"));
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document the HTML document
     * @param effects the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        let codeIsCorrect = false;
        let ellipseCount = 0;
        let code = this.editor.getValue();
        let assignment = /c\s*=\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*/g;
        let matchAssign;
        let print = /print\s*\(\s*c\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)/g;
        let matchPrint;
        switch (this._latestInstrIndex) {
            case 0:
                //check for correct CODE
                matchAssign = code.match(assignment);
                if (matchAssign != null && matchAssign.length > 0) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            case 1:
                //check for correct CODE
                matchAssign = code.match(assignment);
                matchPrint = code.match(print);
                codeIsCorrect = matchAssign != null && matchAssign.length > 0 && matchPrint != null && matchPrint.length >= 1;
                //check for correct CANVAS effects
                for (let effect of effects) {
                    if (effect instanceof EllipseEffect_1.EllipseEffect) {
                        ellipseCount += 1;
                    }
                }
                if (codeIsCorrect && ellipseCount >= 1) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            case 2:
                //check for correct CODE
                matchAssign = code.match(assignment);
                matchPrint = code.match(print);
                codeIsCorrect = matchAssign != null && matchAssign.length > 0 && matchPrint != null && matchPrint.length >= 2;
                //check for correct CANVAS effects
                for (let effect of effects) {
                    if (effect instanceof EllipseEffect_1.EllipseEffect) {
                        ellipseCount += 1;
                    }
                }
                if (codeIsCorrect && ellipseCount >= 2) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonTwoCpFive = LessonTwoCpFive;

},{"../effects/EllipseEffect":13,"./Instruction":43,"./Module":63}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpFour extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l2c4";
        this._nextModule = 'l2c5';
        this._constraint = 'none';
        this._instructions = `<p> GOAL: Change a to b in the print statement. </p>`;
        this._starterCode = `a = "moo moo";
b = ellipse(100, 100);
print(a, 100, 100);`;
        this._latestInstrIndex = 2;
        let content = "Time to take your coding to the next level. Let's learn about variables!";
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = "Variables are simply names you give to the things that you draw.";
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = `For example, take a look at the code above. Change the <span class="inline-code">a</span> in the <span class="inline-code">print</span> statement to <span class="inline-code">b</span>, and observe what happened on the CANVAS.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = 'Did you see the CANVAS changed? In our code, we make variable <span class="inline-code">a</span> refer to the words <span class="inline-code">"moo moo"</span>, and variable <span class="inline-code">b</span> refer to an <span class="inline-code">ellipse(100, 100)</span>.';
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = 'As a result, when we tell the computer to print <span class="inline-code">a</span>, it will print "moo moo", and when we tell the computer to print <span class="inline-code">b</span>, it will print a circle!';
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "70%", "10%"));
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document the HTML document
     * @param effects the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        switch (this._latestInstrIndex) {
            case 2:
                //check for correct CODE
                let codeIsCorrect = false;
                let code = this.editor.getValue();
                let regex = /print\s*\(\s*b\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
                let match = code.match(regex);
                codeIsCorrect = match != null && match.length > 0;
                //check for correct CANVAS effects
                let canvasIsCorrect = true;
                for (let effect of effects) {
                    if (!canvasIsCorrect && effect instanceof EllipseEffect_1.EllipseEffect) {
                        canvasIsCorrect = true;
                        break;
                    }
                }
                if (codeIsCorrect && canvasIsCorrect) {
                    this._latestInstrIndex = 4;
                    this.renderNextInstruction(document);
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonTwoCpFour = LessonTwoCpFour;

},{"../effects/EllipseEffect":13,"./Instruction":43,"./Module":63}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const EllipseEffect_1 = require("../effects/EllipseEffect");
const RectangleEffect_1 = require("../effects/RectangleEffect");
const LineEffect_1 = require("../effects/LineEffect");
class LessonTwoCpOne extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l2c1";
        this._nextModule = 'l2c2';
        this._constraint = 'none';
        this._instructions = `<p> GOAL: replace "moo" in the print statement to draw different shapes. </p>`;
        this._starterCode = `print("moo", 100, 100)`;
        this._latestInstrIndex = 0;
        let content = `Now let's learn to print shapes on the CANVAS! In the <span class="inline-code">print</span> statement above, replace <span class="inline-code">moo</span> with <span class="inline-code">ellipse(100,100)</span>. Observe what happened on the CANVAS.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "30%", "10%"));
        content = `Yep! You told the computer to draw a circle on the CANVAS. Now in the <span class="inline-code">print</span> statement, replace the word <span class="inline-code">ellipse</span> with <span class="inline-code">rect</span>.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "30%", "10%"));
        content = `Finally, replace the word <span class="inline-code">rect</span> with <span class="inline-code">line</span>.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "30%", "10%"));
        content = `By putting different things inside the <span class="inline-code">print</span> statement, you can tell the computer to draw different things on the CANVAS. Remember this lesson!`;
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "70%", "10%"));
    }
    /**
     *
     * @param document The HTML document
     * @param effects the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        let code = this.editor.getValue();
        switch (this._latestInstrIndex) {
            case 0:
                if (this.checkCodeAndCanvasEffect(code, "ellipse", effects)) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            case 1:
                if (this.checkCodeAndCanvasEffect(code, "rect", effects)) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            case 2:
                if (this.checkCodeAndCanvasEffect(code, "line", effects)) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            default:
                return true;
        }
    }
    checkCodeAndCanvasEffect(code, f, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let regex = new RegExp('print\\s*\\(\\s*' + f + '\\s*\\(\\s*[1-9][0-9]*\\s*,\\s*[1-9][0-9]*\\s*\\)\\s*,\\s*[1-9][0-9]*\\s*,\\s*[1-9][0-9]*\\s*\\)');
        let match = code.match(regex);
        codeIsCorrect = match != null && match.length > 0;
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        switch (f) {
            case "ellipse":
                for (let effect of effects) {
                    if (effect instanceof EllipseEffect_1.EllipseEffect) {
                        canvasIsCorrect = true;
                        break;
                    }
                }
                break;
            case "rect":
                for (let effect of effects) {
                    if (effect instanceof RectangleEffect_1.RectangleEffect) {
                        canvasIsCorrect = true;
                        break;
                    }
                }
                break;
            case "line":
                for (let effect of effects) {
                    if (effect instanceof LineEffect_1.LineEffect) {
                        canvasIsCorrect = true;
                        break;
                    }
                }
                break;
        }
        if (codeIsCorrect && canvasIsCorrect) {
            console.log("moving on to next instruction");
        }
        return codeIsCorrect && canvasIsCorrect;
    }
}
exports.LessonTwoCpOne = LessonTwoCpOne;

},{"../effects/EllipseEffect":13,"../effects/LineEffect":16,"../effects/RectangleEffect":18,"./Instruction":43,"./Module":63}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const NumberEffect_1 = require("../effects/NumberEffect");
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpSeven extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l2c7";
        this._nextModule = 'l3c1';
        this._constraint = 'none';
        this._instructions = `<p> CHALLENGE: Create a circle and print out its size. </p>`;
        this._starterCode = `a = 50;
print(ellipse(100, 100), 125, 175);`;
        this._latestInstrIndex = 1;
        this.x = 10;
        this.square_size = 250;
        this.font_size = 20;
        this.y = ctx.canvas.height - this.square_size - this.x;
        let content = `Let's learn one final thing about variables. Observe the code above: we connect the variable <span class="inline-code">a</span> to the number <span class="inline-code">50</span>, and we also have a <span class="inline-code">print</span> statement to print an ellipse.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = `Replace the two numbers <span class="inline-code">100</span> inside the <span class="inline-code">print</span> statement with the letter <span class="inline-code">a</span>. Observe what happens.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = `Did you see the circle on CANVAS become smaller? The variable <span class="inline-code">a</span> is tied to the number <span class="inline-code">50</span>, so now the circle has dimension <span class="inline-code">a</span>!`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = `Let's add one last bit of CODE: write something to print the value of <span class="inline-code">a</span> on the CANVAS.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = "That's correct! Finally, click on the circle on the CANVAS, and make it bigger than the box provided. Observe what happened to the printed number.";
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = "Did you see the printed number change? You have successfully connected 2 elements on the CANVAS together - a circle and a number - by a variable! Remember this lesson about variables in the future when you need to link different things on CANVAS together!";
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "70%", "10%"));
    }
    drawGuides() {
        this.ctx.beginPath();
        this.ctx.rect(this.x, this.y, this.square_size, this.square_size);
        this.ctx.strokeStyle = '#6C6C6C';
        this.ctx.stroke();
        this.ctx.font = this.font_size + "px Courier New";
        this.ctx.fillStyle = '#6C6C6C';
        this.ctx.fillText("Make circle", this.x, this.y + this.font_size);
        this.ctx.fillText("bigger than this box", this.x, this.y + 2 * this.font_size);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document the HTML document
     * @param effects the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        let codeIsCorrect = false;
        let canvasIsCorrect = false;
        let code = this.editor.getValue();
        switch (this._latestInstrIndex) {
            case 1:
                //check for correct CODE
                let regex = new RegExp('print\\s*\\(\\s*ellipse\\s*\\(\\s*a\\s*,\\s*a\\s*\\)\\s*,\\s*[1-9][0-9]*\\s*,\\s*[1-9][0-9]*\\s*\\)');
                let match = code.match(regex);
                codeIsCorrect = match != null && match.length > 0;
                //check for correct CANVAS effects
                for (let effect of effects) {
                    if (effect instanceof EllipseEffect_1.EllipseEffect) {
                        canvasIsCorrect = true;
                        break;
                    }
                }
                if (codeIsCorrect && canvasIsCorrect) {
                    this._latestInstrIndex = 3;
                    this.renderNextInstruction(document);
                }
                return false;
            case 3:
                for (let effect of effects) {
                    if (effect instanceof NumberEffect_1.NumberEffect && effect.num != null) {
                        let val = effect.num;
                        for (let effect2 of effects) {
                            if (effect2 instanceof EllipseEffect_1.EllipseEffect && (val == effect2.w || val == effect2.h)) {
                                this._latestInstrIndex++;
                                this.renderLatestInstruction(document);
                            }
                        }
                    }
                }
                return false;
            case 4:
                let circle;
                for (let effect of effects) {
                    if (effect instanceof NumberEffect_1.NumberEffect && effect.num != null) {
                        let val = effect.num;
                        for (let effect2 of effects) {
                            if (effect2 instanceof EllipseEffect_1.EllipseEffect && (val == effect2.w || val == effect2.h) && val > this.square_size) {
                                this._latestInstrIndex++;
                                this.renderLatestInstruction(document);
                            }
                        }
                    }
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonTwoCpSeven = LessonTwoCpSeven;

},{"../effects/EllipseEffect":13,"../effects/NumberEffect":17,"./Instruction":43,"./Module":63}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpSix extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l2c6";
        this._nextModule = 'l2c7';
        this._constraint = 'code';
        this._instructions = `<p> GOAL: Enlarge one of the circles referred to by c on the CANVAS. </p>`;
        this._starterCode = `a = "moo moo";
b = ellipse(100, 100);
c = ellipse(75, 75);
print(c, 100, 100);
print(c, 300, 100)`;
        this._latestInstrIndex = 1;
        //put box at top-left of CANVAS
        this.x = 25;
        this.y = 25;
        this.square_size = 250;
        this.font_size = 20;
        let content = `Now that you have drawn 2 circles both are called <span class="inline-code">c</span>, let's see what happens when you try to modify one of them.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = `Click on one of the circles on the CANVAS, and try make it bigger. Observe what happens to your declaration of <span class="inline-code">c</span>.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "70%", "10%"));
        content = `Did you see what happened? Changing one circle changes what <span class="inline-code">c</span> is in your CODE!`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = 'Furthermore, that change also affected the other circle on the CANVAS! The 2 circle referred to by <span class="inline-code">c</span> are always identical, no matter what!';
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "70%", "10%"));
    }
    drawGuides() {
        this.ctx.beginPath();
        this.ctx.rect(this.x, this.y, this.square_size, this.square_size);
        this.ctx.strokeStyle = '#6C6C6C';
        this.ctx.stroke();
        this.ctx.font = this.font_size + "px Courier New";
        this.ctx.fillStyle = '#6C6C6C';
        this.ctx.fillText("Make circle", this.x, this.y + this.font_size);
        this.ctx.fillText("bigger than this box", this.x, this.y + 2 * this.font_size);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document the HTML document
     * @param effects the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        switch (this._latestInstrIndex) {
            case 1:
                for (let effect of effects) {
                    if (effect instanceof EllipseEffect_1.EllipseEffect) {
                        if (effect.w > 250 && effect.h > 250) {
                            this._latestInstrIndex = 3;
                            this.renderNextInstruction(document);
                            break;
                        }
                    }
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonTwoCpSix = LessonTwoCpSix;

},{"../effects/EllipseEffect":13,"./Instruction":43,"./Module":63}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const EllipseEffect_1 = require("../effects/EllipseEffect");
const StringEffect_1 = require("../effects/StringEffect");
class LessonTwoCpThree extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l2c3";
        this._nextModule = 'l2c4';
        this._constraint = 'none';
        this._instructions = `<p> GOAL: Draw 2 circles and a word on the CANVAS. </p>`;
        this._starterCode = `print(ellipse(100, 100), 120, 150);\n`;
        this._latestInstrIndex = 1;
        let content = "What if we want to draw more than only 1 circle?";
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = `First copy the <span class="inline-code">print</span> statement on the first line and paste it on the second line above.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "40%", "10%"));
        content = `Hm, that should have created a second circle right? Let's try to fix this by changing the <span class="inline-code">120</span> above to <span class="inline-code">200</span>.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = "Yep! One circle was on top of the other this entire time! In the future, be mindful of this.";
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = "Now let's have a quick challenge: in addition to the 2 circles, write a word on the canvas. Do you remember how to print a word?";
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = `There's no limit to how many <span class="inline-code">print</span> statements the computer can understand, so you can write 1000 <span class="inline-code">print</span> statements, and the computer will draw 1000 things on the CANVAS for you!`;
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "70%", "10%"));
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document the HTML document
     * @param effects the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        let circleCount = 0;
        switch (this._latestInstrIndex) {
            case 1:
                for (let effect of effects) {
                    if (effect instanceof EllipseEffect_1.EllipseEffect) {
                        circleCount += 1;
                    }
                }
                if (circleCount >= 2) {
                    this._latestInstrIndex++;
                    this.renderLatestInstruction(document);
                }
                return false;
            case 2:
                let moved = false;
                for (let effect of effects) {
                    if (effect instanceof EllipseEffect_1.EllipseEffect) {
                        if (effect.x == 200) {
                            moved = true;
                        }
                        circleCount += 1;
                    }
                }
                if ((circleCount >= 2) && moved) {
                    this._latestInstrIndex += 2;
                    this.renderNextInstruction(document);
                }
                return false;
            case 4:
                let stringExists = false;
                for (let effect of effects) {
                    if (!stringExists) {
                        stringExists = effect instanceof StringEffect_1.StringEffect && effect.str !== "";
                    }
                    if (effect instanceof EllipseEffect_1.EllipseEffect) {
                        circleCount += 1;
                    }
                }
                if ((circleCount >= 2) && stringExists) {
                    this._latestInstrIndex += 1;
                    this.renderLatestInstruction(document);
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonTwoCpThree = LessonTwoCpThree;

},{"../effects/EllipseEffect":13,"../effects/StringEffect":19,"./Instruction":43,"./Module":63}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Module_1 = require("./Module");
const Instruction_1 = require("./Instruction");
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpTwo extends Module_1.Module {
    constructor(ctx, editor) {
        super(ctx, editor);
        this._name = "l2c2";
        this._nextModule = 'l2c3';
        this._constraint = 'none';
        this._instructions = `<p> GOAL: Fit the circle inside the given box. </p>`;
        this._starterCode = `print(ellipse(100, 100), 120, 150);`;
        this._latestInstrIndex = 0;
        this.y = 10;
        this.rect_h = 50;
        this.rect_w = 100;
        this.font_size = 20;
        this.x = Math.round((ctx.canvas.width - this.rect_w) / 2);
        let content = `What are the numbers <span class="inline-code">(100, 100)</span> next to <span class="inline-code">ellipse</span> for? Let's find out by first clicking on the circle on the CANVAS.`;
        this._instrBoxes.push(new Instruction_1.Instruction('canvas-container', content, "80%", "10%"));
        content = "Now drag the 8 tips around the circle to resize it. Try to fit the circle entirely inside the given box. Observe the CODE above.";
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
        content = `Yep! Those numbers inside <span class="inline-code">ellipse(_,_)</span> change the dimension of the circle! Note that you can also directly retype these numbers in the CODE area, without touching the CANVAS.`;
        this._instrBoxes.push(new Instruction_1.Instruction('code-editor', content, "50%", "10%"));
    }
    drawGuides() {
        this.ctx.beginPath();
        this.ctx.rect(this.x, this.y, this.rect_w, this.rect_h);
        this.ctx.strokeStyle = '#6C6C6C';
        this.ctx.stroke();
        this.ctx.font = this.font_size + "px Courier New";
        this.ctx.fillStyle = '#6C6C6C';
        this.ctx.fillText("Fit circle", this.x, this.y - 2 * this.font_size);
        this.ctx.fillText("in here", this.x, this.y - this.font_size);
    }
    /**
     *
     * @param document The HTML document
     * @param effects the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        switch (this._latestInstrIndex) {
            case 0:
                for (let effect of effects) {
                    if (effect instanceof EllipseEffect_1.EllipseEffect && effect.selected) {
                        this._latestInstrIndex++;
                        this.renderLatestInstruction(document);
                    }
                }
                return false;
            case 1:
                for (let effect of effects) {
                    if (effect instanceof EllipseEffect_1.EllipseEffect) {
                        if (effect.x > this.x && effect.x < this.x + this.rect_w
                            && effect.y > this.y && effect.y < this.y + this.rect_h
                            && effect.w < this.rect_w && effect.h < this.rect_h) {
                            this._latestInstrIndex++;
                            this.renderLatestInstruction(document);
                        }
                    }
                }
                return false;
            default:
                return true;
        }
    }
}
exports.LessonTwoCpTwo = LessonTwoCpTwo;

},{"../effects/EllipseEffect":13,"./Instruction":43,"./Module":63}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Module {
    constructor(ctx, editor) {
        this._instrBoxes = []; //series of tutorial instructions
        this._instrIndex = 0; //index of current instruction being displayed
        this._latestInstrIndex = 0; //furthest instruction reached within this checkpoint
        this.ctx = ctx;
        this.editor = editor;
    }
    /**
     * Create guides to help lesson instructions
     * @param ctx the canvas 2D context
     */
    drawGuides() { }
    ;
    renderLatestInstruction(document) {
        this._instrIndex = this._latestInstrIndex;
        this.renderInstruction(document);
    }
    renderNextInstruction(document) {
        this._instrIndex = (this._instrIndex + 1 < this._instrBoxes.length) ? this._instrIndex + 1 : this._instrIndex;
        console.log("current instr: " + this._instrIndex);
        this.renderInstruction(document);
    }
    renderPrevInstruction(document) {
        this._instrIndex = (this._instrIndex - 1 >= 0) ? this._instrIndex - 1 : this._instrIndex;
        this.renderInstruction(document);
    }
    /**
     * render the current instruction of this checkpoint
     * @param document The HTML document
     */
    renderInstruction(document) {
        let curInstruction = document.getElementById("instruction");
        if (curInstruction != null) {
            curInstruction.remove();
        }
        console.log("instrIndex " + this._instrIndex);
        let instruction = this._instrBoxes[this._instrIndex];
        //render the instruction content
        let div = document.createElement("div");
        div.className = "instruction";
        div.id = 'instruction';
        div.innerHTML = instruction._content;
        div.style.top = instruction._top;
        div.style.left = instruction._left;
        div.style.display = "block";
        //render the buttons
        let innerDiv = document.createElement("div");
        let prevInstr = document.createElement("button");
        prevInstr.id = 'previous-instruction';
        prevInstr.innerText = "<";
        let thisModule = this;
        prevInstr.onclick = function () {
            thisModule.renderPrevInstruction(document);
        };
        if (this._instrIndex == 0) {
            prevInstr.style.background = "#D8D8D8";
            prevInstr.disabled = true;
        }
        innerDiv.appendChild(prevInstr);
        let nextInstr = document.createElement("button");
        nextInstr.id = 'next-instruction';
        nextInstr.innerText = ">";
        nextInstr.onclick = function () {
            thisModule.renderNextInstruction(document);
        };
        if (this._instrIndex == this._instrBoxes.length || this._instrIndex == this._latestInstrIndex) {
            nextInstr.style.background = "#D8D8D8";
            nextInstr.disabled = true;
        }
        innerDiv.appendChild(nextInstr);
        div.appendChild(innerDiv);
        document.getElementById(instruction._location).appendChild(div);
    }
    get numInstructions() {
        return this._instrBoxes.length;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.Module = Module;

},{}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../../index");
const index_2 = require("../../index");
const index_3 = require("../../index");
const index_4 = require("../../index");
class ModuleGenerator {
    constructor() {
        this.curConstructors = new Map([
            ['l1c1', (ctx, editor) => new index_1.LessonOneCpOne(ctx, editor)],
            ['l1c2', (ctx, editor) => new index_1.LessonOneCpTwo(ctx, editor)],
            ['l1c3', (ctx, editor) => new index_1.LessonOneCpThree(ctx, editor)],
            ['l1c4', (ctx, editor) => new index_1.LessonOneCpFour(ctx, editor)],
            ['l2c1', (ctx, editor) => new index_2.LessonTwoCpOne(ctx, editor)],
            ['l2c2', (ctx, editor) => new index_2.LessonTwoCpTwo(ctx, editor)],
            ['l2c3', (ctx, editor) => new index_2.LessonTwoCpThree(ctx, editor)],
            ['l2c4', (ctx, editor) => new index_2.LessonTwoCpFour(ctx, editor)],
            ['l2c5', (ctx, editor) => new index_2.LessonTwoCpFive(ctx, editor)],
            ['l2c6', (ctx, editor) => new index_2.LessonTwoCpSix(ctx, editor)],
            ['l2c7', (ctx, editor) => new index_2.LessonTwoCpSeven(ctx, editor)],
            ['l3c1', (ctx, editor) => new index_3.LessonThreeCpOne(ctx, editor)],
            ['l3c2', (ctx, editor) => new index_3.LessonThreeCpTwo(ctx, editor)],
            ['l3c3', (ctx, editor) => new index_3.LessonThreeCpThree(ctx, editor)],
            ['l3c4', (ctx, editor) => new index_3.LessonThreeCpFour(ctx, editor)],
            ['l3c5', (ctx, editor) => new index_3.LessonThreeCpFive(ctx, editor)],
            ['l3c6', (ctx, editor) => new index_3.LessonThreeCpSix(ctx, editor)],
            ['l4c1', (ctx, editor) => new index_4.LessonFourCpOne(ctx, editor)],
            ['l4c2', (ctx, editor) => new index_4.LessonFourCpTwo(ctx, editor)]
        ]);
        this.checkpoints = new Map([
            ['l1c1', null],
            ['l1c2', null],
            ['l1c3', null],
            ['l1c4', null],
            ['l2c1', null],
            ['l2c2', null],
            ['l2c3', null],
            ['l2c4', null],
            ['l2c5', null],
            ['l2c6', null],
            ['l2c7', null],
            ['l3c1', null],
            ['l3c2', null],
            ['l3c3', null],
            ['l3c4', null],
            ['l3c5', null],
            ['l3c6', null],
            ['l4c1', null],
            ['l4c2', null]
        ]);
    }
    createModule(cp, ctx, editor) {
        let checkpoint = this.checkpoints.get(cp);
        if (checkpoint != null) {
            return checkpoint;
        }
        checkpoint = this.curConstructors.get(cp)(ctx, editor);
        this.checkpoints.set(cp, checkpoint);
        return checkpoint;
    }
}
exports.ModuleGenerator = ModuleGenerator;

},{"../../index":1}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pants_1 = require("pants");
const index_1 = require("../../index");
const space_lift_1 = require("space-lift");
var Parser;
(function (Parser) {
    /**
     * to be moved to Pants
     * number parses numbers by repeatedly applying the digit parser
     */
    function number() {
        return (istream) => {
            const o = pants_1.Primitives.many1(pants_1.Primitives.digit())(istream);
            switch (o.tag) {
                case "success":
                    let s = "";
                    for (let digit of o.result) {
                        s += digit.toString();
                    }
                    return new pants_1.Primitives.Success(o.inputstream, parseFloat(s));
                case "failure":
                    return o;
            }
        };
    }
    Parser.number = number;
    /**
     * to be moved to Pants
     * string is an arbitrary string parser that repeatedly applies the letter primitive
     * returns a CharStream representing the entire parsed string
     */
    function string() {
        let p = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.many1(pants_1.Primitives.letter()));
        let f = (xs) => pants_1.CharUtil.CharStream.concat(xs);
        return pants_1.Primitives.appfun(p)(f);
    }
    Parser.string = string;
    /**
     * to be moved to Pants
     * punctuation parses all possible punctuation characters
     */
    function punctuation() {
        return pants_1.Primitives.sat(x => x == "!"
            || x == "."
            || x == ','
            || x == ";"
            || x == '?'
            || x == "-"
            || x == "&"
            || x == '$'
            || x == ':'
            || x == '/'
            || x == '|'
            || x == '%'
            || x == '#'
            || x == "@"
            || x == "~"
            || x == '`'
            || x == '*'
            || x == '^'
            || x == '{'
            || x == '}'
            || x == "["
            || x == ']'
            || x == '('
            || x == ")"
            || x == "'"
            || x == "_");
    }
    Parser.punctuation = punctuation;
    let id = (x) => x;
    //let effects: Effect<any>[] = [];
    /**
     * parse is a function that wraps the input text in a CharStream
     * and passes it to the upper-level parse function
     * @param program a string representing program text
     */
    function parse(program) {
        program += "\n";
        z = 0;
        //printOffset = -1;
        //this.effects = effects;
        let o = Parser.ExpressionParser(new pants_1.CharUtil.CharStream(program));
        switch (o.tag) {
            case "success":
                return space_lift_1.Some(o.result);
            case "failure":
                return space_lift_1.None;
        }
    }
    Parser.parse = parse;
    /**
     * Expression parser first searches for the first expression of a sequence and either
     * another expression or the end of the program (NOP) and returns a sequence node
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParser = i => {
        let f = (tup) => {
            return new index_1.SequenceNode(tup[0], tup[1]);
        };
        let p = pants_1.Primitives.seq(Parser.ExpressionParserNoSeq)(pants_1.Primitives.right(pants_1.Primitives.choice(pants_1.Primitives.char(';'))(pants_1.Primitives.nl()))(pants_1.Primitives.choice(pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser))(pants_1.Primitives.appfun(pants_1.Primitives.ws())(_ => new index_1.NOP()))))(f);
        return p(i);
    };
    /**
     * Searches through all possible expressions except for sequences
     * used to avoid infinite looping in upper level parse
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParserNoSeq = i => {
        let p1 = pants_1.Primitives.choice(lNumber())(lstring2());
        let p2 = pants_1.Primitives.choice(varNameParse())(p1);
        let p3 = pants_1.Primitives.choice(BoolParse())(p2);
        let p4 = pants_1.Primitives.choice(varDecParse())(p3);
        let p5 = pants_1.Primitives.choice(Parser.unOpsExpr)(p4);
        let p6 = pants_1.Primitives.choice(Declare())(p5);
        let p7 = pants_1.Primitives.choice(Parser.binOpExpr)(p6);
        let p8 = pants_1.Primitives.choice(LogicExpr())(p7);
        let p9 = pants_1.Primitives.choice(Parser.ListHead)(p8);
        let p10 = pants_1.Primitives.choice(Parser.funApp)(p9);
        let p11 = pants_1.Primitives.choice(Parser.returnParser)(p10);
        let p12 = pants_1.Primitives.choice(Parser.condParse)(p11);
        let p13 = pants_1.Primitives.choice(Parser.WhileLoop)(p12);
        let p14 = pants_1.Primitives.choice(Parser.ForLoop)(p13);
        let p15 = pants_1.Primitives.choice(Parser.funDef)(p14);
        let p16 = pants_1.Primitives.choice(Parser.loopParse)(p15);
        return p16(i);
    };
    /**
     * Searches through all possible expressions except for binOp expressions
     * used to avoid infinite looping in the binary expression parser
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParserNoBinOp = i => {
        let p1 = pants_1.Primitives.choice(lNumber())(lstring2());
        let p2 = pants_1.Primitives.choice(varNameParse())(p1);
        let p3 = pants_1.Primitives.choice(BoolParse())(p2);
        let p4 = pants_1.Primitives.choice(varDecParse())(p3);
        let p5 = pants_1.Primitives.choice(Parser.unOpsExpr)(p4);
        let p6 = pants_1.Primitives.choice(Declare())(p5);
        let p7 = pants_1.Primitives.choice(Parser.ListHead)(p6);
        let p8 = pants_1.Primitives.choice(Parser.funApp)(p7);
        let p9 = pants_1.Primitives.choice(Parser.returnParser)(p8);
        let p10 = pants_1.Primitives.choice(Parser.condParse)(p9);
        let p11 = pants_1.Primitives.choice(Parser.WhileLoop)(p10);
        let p12 = pants_1.Primitives.choice(Parser.ForLoop)(p11);
        let p13 = pants_1.Primitives.choice(Parser.funDef)(p12);
        let p14 = pants_1.Primitives.choice(Parser.loopParse)(p13);
        return p14(i);
    };
    /**
     * Searches through all possible expressions except for logical expressions
     * used to avoid infinite looping in the logical expression parser
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParserNoLogic = i => {
        let p1 = pants_1.Primitives.choice(lNumber())(lstring2());
        let p2 = pants_1.Primitives.choice(varNameParse())(p1);
        let p3 = pants_1.Primitives.choice(BoolParse())(p2);
        let p4 = pants_1.Primitives.choice(varDecParse())(p3);
        let p5 = pants_1.Primitives.choice(Parser.unOpsExpr)(p4);
        let p6 = pants_1.Primitives.choice(Declare())(p5);
        let p7 = pants_1.Primitives.choice(Parser.binOpExpr)(p6);
        let p8 = pants_1.Primitives.choice(Parser.ListHead)(p7);
        let p9 = pants_1.Primitives.choice(Parser.funApp)(p8);
        let p10 = pants_1.Primitives.choice(Parser.returnParser)(p9);
        let p11 = pants_1.Primitives.choice(Parser.condParse)(p10);
        let p12 = pants_1.Primitives.choice(Parser.WhileLoop)(p11);
        let p13 = pants_1.Primitives.choice(Parser.ForLoop)(p12);
        let p14 = pants_1.Primitives.choice(Parser.funDef)(p13);
        let p15 = pants_1.Primitives.choice(Parser.loopParse)(p14);
        return p15(i);
    };
    /**
     * lNumber is used to wrap parsed numbers in NumberNodes for the AST
     */
    function lNumber() {
        return (istream) => {
            let o = number()(istream);
            switch (o.tag) {
                case "success":
                    return new pants_1.Primitives.Success(o.inputstream, new index_1.NumberNode(o.result));
                case "failure":
                    return o;
            }
        };
    }
    Parser.lNumber = lNumber;
    /**
     * binOpsChar parses all possible binary operators, such as + or -
     */
    function binOpsChar() {
        return (istream) => {
            return pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.sat(x => x == "+"
                || x == "-"
                || x == "/"
                || x == "="
                || x == "*"))(istream);
        };
    }
    Parser.binOpsChar = binOpsChar;
    /**
     * binOpsShort returns a tuple where the first element is the binary operator (CharStream)
     * and the second element is the expression to the right of the operator (Expression<{}>)
     */
    function binOpShort() {
        return pants_1.Primitives.seq(binOpsChar())(Parser.ExpressionParserNoSeq)((x) => x);
    }
    Parser.binOpShort = binOpShort;
    /**
     * binOpExpr parses all possible binary operation expressions and returns the
     * corresponding AST node construct (also parses postfix increments/decrements like i++)
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.binOpExpr = i => {
        var f = (tup) => {
            let lhs = tup[0];
            let op = tup[1][0];
            let rhs = tup[1][1];
            switch (op.toString()) {
                case "+":
                    return new index_1.PlusOp(lhs, rhs, ws);
                case "-":
                    return new index_1.MinusOp(lhs, rhs, ws);
                case "/":
                    return new index_1.DivOp(lhs, rhs, ws);
                case "*":
                    return new index_1.MulOp(lhs, rhs, ws);
                case "=":
                    return new index_1.AssignOp(lhs, rhs, ws);
                default:
                    throw new Error("Binary Operation not supported");
            }
        };
        let p1 = pants_1.Primitives.choice(Parser.ExpressionParserNoBinOp)(varDecParse());
        let p2 = binOpShort();
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let postPlus = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.ExpressionParserNoBinOp))(pants_1.Primitives.str('++'))(tup => { return new index_1.Increment(tup[0], ws); });
        let postMinus = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.ExpressionParserNoBinOp))(pants_1.Primitives.str('--'))(tup => { return new index_1.Decrement(tup[0], ws); });
        let binOp = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(p1))(p2)(f);
        return pants_1.Primitives.choice(binOp)(pants_1.Primitives.choice(postPlus)(postMinus))(i);
    };
    /**
     * unOpsChar parses all possible unary operators
     * Only negations are supported, but more can be added as needed
     * @param i nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.unOpsChar = i => {
        return pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char("-"))(i);
    };
    /**
     * unOpsExpr wraps a unary operation expression in the corresponding
     * AST node and returns it
     * @param i nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.unOpsExpr = i => {
        var f = (tup) => {
            return new index_1.NegOp(tup[1], ws);
        };
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        return pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.unOpsChar))(Parser.ExpressionParserNoSeq)(f)(i);
    };
    /**
     * lstring parses valid strings in the SWELL language
     * a valid string is surrounded by quotations and consists of letters, numbers, punctuation, and/or whitespace
     */
    function lstring() {
        let p1 = pants_1.Primitives.choice(pants_1.Primitives.choice(pants_1.Primitives.letter())(pants_1.Primitives.ws1()))(pants_1.Primitives.digit());
        //let p1 = Primitives.choice(Primitives.letter())(Primitives.ws1());
        let p = pants_1.Primitives.between(pants_1.Primitives.str("\""))(pants_1.Primitives.str("\""))(pants_1.Primitives.many(pants_1.Primitives.choice(p1)(punctuation())));
        let f = (xs) => pants_1.CharUtil.CharStream.concat(xs);
        return pants_1.Primitives.appfun(p)(f);
    }
    Parser.lstring = lstring;
    /**
     * lstring2 wraps strings parsed by lstring in StrinNode objects and returns them
     */
    function lstring2() {
        return (istream) => {
            let ws = "";
            let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
            let o = pants_1.Primitives.right(precedingWS)(lstring())(istream);
            switch (o.tag) {
                case "success":
                    return new pants_1.Primitives.Success(o.inputstream, new index_1.StringNode(o.result.toString(), ws));
                case "failure":
                    return o;
            }
        };
    }
    Parser.lstring2 = lstring2;
    /**
     * varNameParse parses valid variable names
     * variable names in SWELL begin with a lowercase char and are followed
     * by letters or digits
     */
    function varNameParse() {
        var f = (tup) => {
            return new index_1.VariableNode(tup[0].toString() + pants_1.CharUtil.CharStream.concat(tup[1]).toString(), ws);
        };
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let firstChar = pants_1.Primitives.right(precedingWS)(pants_1.Primitives.lower());
        let nextChars = pants_1.Primitives.many(pants_1.Primitives.choice(pants_1.Primitives.digit())(pants_1.Primitives.letter()));
        return pants_1.Primitives.seq(firstChar)(nextChars)(f);
    }
    Parser.varNameParse = varNameParse;
    /**
     * varDecParse parses valid variable declarations in the form "var x"
     * the parser then wraps the parsed value in a variable node for the AST
     */
    function varDecParse() {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str("var"));
        let varName = pants_1.Primitives.between(pants_1.Primitives.ws1())(pants_1.Primitives.ws())(varNameParse());
        let p = pants_1.Primitives.seq(p1)(varName)(tup => tup[1]);
        return p;
    }
    Parser.varDecParse = varDecParse;
    /**
     * Declare parses variable declarations in the form "var x = 2"
     * and returns a DeclareOp node
     */
    function Declare() {
        let eq = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('='));
        let p1 = pants_1.Primitives.left(varDecParse())(eq);
        return pants_1.Primitives.seq(p1)(Parser.ExpressionParserNoSeq)(tup => { return new index_1.DeclareOp(tup[0], tup[1]); });
    }
    Parser.Declare = Declare;
    /**
     * ListHead parses all lists in the SWELL language, including empty lists
     * Lists are surrounded by square brackets and each element is separated by a comma
     * returns a listNode object
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.ListHead = i => {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p0 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let p1 = pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.char('[')))(p0);
        var f = (tup) => {
            let hd = tup[0];
            let res = [hd];
            let tail = tup[1];
            for (let elem of tail) {
                res.push(elem);
            }
            return new index_1.ListNode(res, ws);
        };
        let p2 = pants_1.Primitives.seq(p1)(ListTail())(f);
        let p3 = pants_1.Primitives.appfun(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('[]')))(_ => new index_1.ListNode([], ws));
        return pants_1.Primitives.choice(p3)(p2)(i);
    };
    /**
     * List Tail parses second through last elements of a list, each separated by a comma
     * returns an array of Expressions that will be accessed by ListHead
     */
    function ListTail() {
        let p0 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char(','))(p0);
        let p2 = pants_1.Primitives.left(pants_1.Primitives.many(p1))(pants_1.Primitives.char(']'));
        return p2;
    }
    Parser.ListTail = ListTail;
    /**
     * funDefArgList parses argument lists for function definitions,
     * surrounded by parens and separated by commas
     * returns an array of the parameters
     */
    function funDefArgList() {
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char('('))(string());
        var f = (tup) => {
            let hd = tup[0].toString();
            let res = [hd];
            let tail = tup[1];
            for (let elem of tail) {
                res.push(elem.toString());
            }
            return res;
        };
        let p2 = pants_1.Primitives.seq(p1)(funDefArgListTail())(f);
        let p3 = pants_1.Primitives.appfun(pants_1.Primitives.str('()'))(_ => []);
        return pants_1.Primitives.choice(p3)(p2);
    }
    Parser.funDefArgList = funDefArgList;
    /**
     * funDefArgListTail parses the second through last elements of a function definition parameter list
     * parameters are separated by commas and end with a closing parens
     * returns an array of parameters, which is accessed by funDefArgList
     */
    function funDefArgListTail() {
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char(','))(string());
        let p2 = pants_1.Primitives.left(pants_1.Primitives.many(p1))(pants_1.Primitives.char(')'));
        return p2;
    }
    /**
     * funAppArgList parses argument lists for function applications, including empty args lists
     * the parser returns an array of Expression objects that represent the arguments
     */
    function funAppArgList() {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char('('))(expr);
        var f = (tup) => {
            let hd = tup[0];
            let res = [hd];
            let tail = tup[1];
            for (let elem of tail) {
                res.push(elem);
            }
            return res;
        };
        let p2 = pants_1.Primitives.seq(p1)(funAppArgListTail())(f);
        let p3 = pants_1.Primitives.appfun(pants_1.Primitives.str('()'))(_ => []);
        return pants_1.Primitives.choice(p3)(p2);
    }
    Parser.funAppArgList = funAppArgList;
    /**
     * funAppArgListTail parses the second through last elements of an argument list
     * each element is separated by a comma
     * returns an array of Expression objects, later accessed by funAppArgsList
     */
    function funAppArgListTail() {
        let comma = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char(','));
        let p1 = pants_1.Primitives.right(comma)(Parser.ExpressionParserNoSeq);
        let p2 = pants_1.Primitives.left(pants_1.Primitives.many(p1))(pants_1.Primitives.right(pants_1.Primitives.ws())(pants_1.Primitives.char(')')));
        return p2;
    }
    /**
     * returnParser parses valid return statements in the form "return x"
     * wraps the parsed value in a Return node for the AST
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.returnParser = i => {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p = pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('return')))(expr);
        var f = (e) => { return new index_1.Return(e, ws); };
        return pants_1.Primitives.appfun(p)(f)(i);
    };
    /**
     * funDef parses valid function definitions in the form "fun functionName(argList){ body;}"
     * the parser returns a funDef node for the AST
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.funDef = i => {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        return pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('fun')))(pants_1.Primitives.seq(
        /* function name */
        pants_1.Primitives.appfun(string())(cs => cs.toString()))(pants_1.Primitives.seq(
        /* function arguments */
        funDefArgList())(pants_1.Primitives.right(
        /* function body */
        pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{')))(pants_1.Primitives.left(pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser))(pants_1.Primitives.char('}'))))(id))(
        // create the AST node
        (tup) => {
            let fname = tup[0];
            let args = tup[1][0];
            let body = tup[1][1];
            return new index_1.FunDef(fname, body, args, ws);
        }))(i);
    };
    //let printOffset = -1;
    //let boundingRects = [];
    let z = 0;
    //TODO
    function getNonOverlappingCoords() {
        return [0, 0];
    }
    Parser.getNonOverlappingCoords = getNonOverlappingCoords;
    /**
     * funApp parses valid function applications in the form "functionName(argsList)" and returns a funApp node
     * parser checks for built-in functions, like print, ellipse, and rect; and returns the valid AST node
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.funApp = i => {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        return pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(string()))(funAppArgList())(tup => {
            let fname = tup[0].toString();
            switch (fname) {
                case "print":
                    console.log("z coordinate: " + z);
                    if (tup[1].length == 3) {
                        //boundingRects.push([tup[1][0].width, tup[1][0].height, tup[1][1], tup[1][2]]);
                        return new index_1.PrintNode(tup[1][0], true, new index_1.Dimensions(tup[1][1], tup[1][2], new index_1.NumberNode(z++), new index_1.NumberNode(1)), ws);
                    }
                    //printOffset = (printOffset + 1) % 12;
                    return new index_1.PrintNode(tup[1][0], true, new index_1.Dimensions(new index_1.NumberNode(100), new index_1.NumberNode(100), new index_1.NumberNode(z++), new index_1.NumberNode(1)), ws);
                //return new PrintNode(tup[1][0], false);
                case "ellipse":
                    if (tup[1].length == 2) {
                        return new index_1.EllipseNode(tup[1][0], tup[1][1], ws);
                    }
                case "rect":
                    if (tup[1].length == 2) {
                        return new index_1.RectangleNode(tup[1][0], tup[1][1], ws);
                    }
                case "line":
                    if (tup[1].length == 2) {
                        return new index_1.LineNode(tup[1][0], tup[1][1], ws);
                    }
                case "curve":
                    if (tup[1].length == 3) {
                        return new index_1.CurveNode(tup[1][0], tup[1][1], tup[1][2], ws);
                    }
                case "eph":
                    if (tup[1].length == 2) {
                        return new index_1.EphNode(tup[1][0], tup[1][1], ws);
                    }
                case "emoji":
                    if (tup[1].length == 3) {
                        return new index_1.EmojiNode(tup[1][0], tup[1][1], tup[1][2], ws);
                    }
            }
            let args = tup[1];
            return new index_1.FunApp(fname, args, ws);
        })(i);
    };
    /**
     * BoolParse parses valid booleans, true and false, and returns a BooleanNode
     */
    function BoolParse() {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.appfun(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('true')))(_ => new index_1.BooleanNode(true, ws));
        let p2 = pants_1.Primitives.appfun(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('false')))(_ => new index_1.BooleanNode(false, ws));
        return pants_1.Primitives.choice(p1)(p2);
    }
    Parser.BoolParse = BoolParse;
    /**
     * logicChar parses all logical operators in the SWELL language and returns the consumed operator
     */
    function logicChar() {
        var logicChar = ["equals", '==', 'and', '>', '<', 'not equals', 'or'];
        var logicChar2 = ['>=', '<='];
        let p1 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.strSat(logicChar));
        let p2 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.strSat(logicChar2));
        return pants_1.Primitives.choice(p2)(p1);
    }
    Parser.logicChar = logicChar;
    /**
     * logicShort returns a tuple, where the first element represents the logical operator and
     * the second element is the expression to the right of the operator
     */
    function logicShort() {
        return pants_1.Primitives.seq(logicChar())(Parser.ExpressionParserNoSeq)((x) => x);
    }
    Parser.logicShort = logicShort;
    /**
     * logicExpr parses logical expressions and returns the corresponding AST node
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    function LogicExpr() {
        // TODO: Dan (2018-11-19), shouldn't parameterized type be BooleanNode?
        var f = (tup) => {
            let lhs = tup[0];
            let op = tup[1][0];
            let rhs = tup[1][1];
            switch (op.toString()) {
                case "equals":
                    return new index_1.Equals(lhs, rhs, ws);
                case "==":
                    return new index_1.Equals(lhs, rhs, ws);
                case "and":
                    return new index_1.And(lhs, rhs, ws);
                case ">":
                    return new index_1.GreaterThan(lhs, rhs, ws);
                case "<":
                    return new index_1.LessThan(lhs, rhs, ws);
                case ">=":
                    return new index_1.GreaterThanEq(lhs, rhs, ws);
                case "<=":
                    return new index_1.LessThanEq(lhs, rhs, ws);
                case "or":
                    return new index_1.Or(lhs, rhs, ws);
                case "not equals":
                    return new index_1.NotEqual(lhs, rhs, ws);
                default:
                    throw new Error("Logical expression not supported");
            }
        };
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let not = pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('not'));
        let p1 = pants_1.Primitives.right(not)(Parser.ExpressionParserNoSeq);
        let notExpr = pants_1.Primitives.appfun(p1)(x => new index_1.Not(x, ws));
        let logicExpr = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.ExpressionParserNoLogic))(logicShort())(f);
        return pants_1.Primitives.choice(notExpr)(logicExpr);
    }
    Parser.LogicExpr = LogicExpr;
    /**
     * IfParse parses valid if statements in the form "if(condition){ body; }"
     * returns an array where the first elem is the condition and the second is the body
     */
    function IfParse() {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let bodyParse = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let p1 = pants_1.Primitives.seq(pants_1.Primitives.str('if'))(pants_1.Primitives.char('('))(x => x);
        let cond = pants_1.Primitives.between(p1)(pants_1.Primitives.char(')'))(expr);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(bodyParse);
        return pants_1.Primitives.seq(cond)(body)(x => x);
    }
    Parser.IfParse = IfParse;
    /**
      * IfElseParse parses valid if else statements in the form "if(condition){ body; } else{ body2;}"
      * returns an array where the first elem is the condition and the second is the first body and the third is body2
      */
    function IfElseParse() {
        let e = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.str('else'));
        let body = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let body2 = pants_1.Primitives.between(pants_1.Primitives.str('{'))(pants_1.Primitives.str('}'))(body);
        let elseParse = pants_1.Primitives.right(e)(body2);
        var f = (tup) => {
            tup[0].push(tup[1]);
            return tup[0];
        };
        return pants_1.Primitives.seq(IfParse())(elseParse)(f);
    }
    Parser.IfElseParse = IfElseParse;
    /**
     * condParse parses possible conditional statements, including if and if/else statements
     * returns a Conditional node
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.condParse = i => {
        var f = (tup) => {
            if (tup.length == 3) {
                return new index_1.Conditional(tup[0], tup[1], tup[2]);
            }
            else {
                return new index_1.Conditional(tup[0], tup[1]);
            }
        };
        return pants_1.Primitives.appfun(pants_1.Primitives.choice(IfElseParse())(IfParse()))(f)(i);
    };
    /**
     * RepeatLoop parses valid repeat statement of the form "repeat(n){ body; }"
     * returns an array where the first elem is number of repeats and the second is the body
     */
    function RepeatLoop() {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let bodyParse = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let p1 = pants_1.Primitives.seq(pants_1.Primitives.str('repeat'))(pants_1.Primitives.char('('))(x => x);
        let n = pants_1.Primitives.between(p1)(pants_1.Primitives.char(')'))(expr);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(bodyParse);
        return pants_1.Primitives.seq(n)(body)(x => x);
    }
    Parser.RepeatLoop = RepeatLoop;
    /**
     * loopParse parses possible loop statements, is a helper for RepeatLoop
     * returns a RepeatNode
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.loopParse = i => {
        var f = (tup) => {
            if (tup.length == 2) {
                return new index_1.RepeatNode(tup[0], tup[1]);
            }
        };
        return pants_1.Primitives.appfun(RepeatLoop())(f)(i);
    };
    /**
     * WhileLoop parses valid while loops in the form "while(condition) { body;}"
     * returns a WhileNode for the AST
     */
    Parser.WhileLoop = i => {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let bodyParse = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str("while")))(pants_1.Primitives.char('('))(x => x);
        let cond = pants_1.Primitives.between(p1)(pants_1.Primitives.char(')'))(expr);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(bodyParse);
        var f = (tup) => { return new index_1.WhileNode(tup[0], tup[1], ws); };
        return pants_1.Primitives.seq(cond)(body)(f)(i);
    };
    /**
     * ForLoop parses valid for loops in the form "for(initial, condition, post) { body;}" and returns a ForNode
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.ForLoop = i => {
        let args = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(funAppArgList());
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('for')))(args);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let expr = pants_1.Primitives.between(pants_1.Primitives.choice(pants_1.Primitives.ws())(pants_1.Primitives.nl()))(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(expr);
        var f = (tup) => {
            let init = tup[0][0];
            let cond = tup[0][1];
            let post = tup[0][2];
            let body = tup[1];
            return new index_1.ForNode(init, cond, post, body, ws);
        };
        return pants_1.Primitives.seq(p1)(body)(f)(i);
    };
    function singleComment() {
        let p1 = pants_1.Primitives.many1(pants_1.Primitives.item());
        let p2 = pants_1.Primitives.appfun(p1)(xs => pants_1.CharUtil.CharStream.concat(xs));
        return pants_1.Primitives.between(pants_1.Primitives.str('//'))(pants_1.Primitives.nl())(p2);
        //return Primitives.seq<CharUtil.CharStream, CharUtil.CharStream, CharUtil.CharStream[]>(Primitives.str('//'))(Primitives.nl())(x=>x);
    }
    Parser.singleComment = singleComment;
    function multiLineComment() {
        let p1 = pants_1.Primitives.many1(pants_1.Primitives.item());
        let p2 = pants_1.Primitives.appfun(p1)(xs => pants_1.CharUtil.CharStream.concat(xs));
        return pants_1.Primitives.between(pants_1.Primitives.str('\/**'))(pants_1.Primitives.str('*\/'))(p2);
    }
    Parser.multiLineComment = multiLineComment;
})(Parser = exports.Parser || (exports.Parser = {}));

},{"../../index":1,"pants":90,"space-lift":96}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BooleanNode {
    /**
     * Constructor for BooleanNode, a node representing a boolean
     * @param val The boolean value of the BooleanNode
     * @param ws Preceding white space
     */
    constructor(val, ws) {
        this._newLine = false;
        this._val = val;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    ;
    /**
     * Returns the BooleanNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * BooleanNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Returns whether this BooleanNode equals another
     * @param right The right side of the equality
     */
    equalsVal(right) {
        if (right instanceof BooleanNode) {
            return this.val === right.val;
        }
        return false;
    }
    /**
     * Returns a string representation of the BooleanNode
     */
    toString() {
        return this._ws + this._val;
    }
    /**
     * Returns the boolean value
     */
    get val() {
        return this._val;
    }
    /**
     * Sets the boolean value
     */
    set val(value) {
        this._val = value;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.BooleanNode = BooleanNode;

},{}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class NOP {
    constructor() {
        /* A NOP is a placeholder operation that evaluates to nothing */
        this._newLine = true;
    }
    /**
     * Returns the NOP
     * @param context
     */
    eval(context) {
        return this;
    }
    /**
     * NOPs cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("NOPs cannot be drawn.");
    }
    /**
     * Returns a string representation of the NOP
     */
    toString() {
        return "";
    }
    /**
     * Returns whether this NOP equals another (spoiler: it doesn't)
     * @param right
     */
    equalsVal(right) {
        return false;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.NOP = NOP;

},{}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberEffect_1 = require("../effects/NumberEffect");
// Nodes representing numbers
// Should abstract Node class implement Expression?
class NumberNode {
    /**
     * Constructor for a NumberNode, a node representing a number
     * @param val The number value
     * @param ws Preceding whitespace
     */
    constructor(val, ws) {
        this._newLine = false;
        this._val = val;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    ;
    /**
     * Returns this NumberNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * NumberNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        let e = new NumberEffect_1.NumberEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this NumberNode equals another NumberNode
     * @param right The right side of the equality (must be a NumberNode)
     */
    equalsVal(right) {
        if (right instanceof NumberNode) {
            return this.val === right.val;
        }
        return false;
    }
    /**
     * Returns a string representation of the NumberNode
     */
    toString() {
        return this._ws + this._val;
    }
    /**
     * Returns the number stored in the node
     */
    get val() {
        return this._val;
    }
    /**
     * Sets the value of the number stored in the node
     */
    set val(value) {
        this._val = value;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.NumberNode = NumberNode;

},{"../effects/NumberEffect":17}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class StringNode {
    /**
     * Constructor for a StringNode, a node representing a string
     * @param str The string stored in the node
     * @param ws Preceding whitespace
     */
    constructor(str, ws) {
        this._newLine = false;
        this._str = str;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this StringNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the String using StringEffect
     * @param context The current program context
     * @param dims The dimensions of the string to be drawn
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        let e = new StringEffect_1.StringEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this StringNode equals another StringNode
     * @param right The right side of the equality, must be a StringNode
     */
    equalsVal(right) {
        if (right instanceof StringNode) {
            return this.val === right.val;
        }
        return false;
    }
    /**
     * Returns a string representation of the StringNode
     */
    toString() {
        return this._ws + '\"' + this._str + '\"';
    }
    /**
     * Sets the string stored in the node
     */
    set str(value) {
        this._str = value;
    }
    /**
     * Returns the string stored in the node
     */
    get val() {
        return this._str;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.StringNode = StringNode;

},{"../effects/StringEffect":19}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ColorNode {
    /**
     * Constructor for a ColorNode, a node representing an RGB color
     */
    constructor(red, green, blue) {
        this._newLine = false;
        this._red = red;
        this._green = green;
        this._blue = blue;
    }
    ;
    /**
     * Evaluates into a string RGB value
     * @param context The current program context
     */
    eval(context) {
        return this._red + " " + this._green + " " + this._blue;
    }
    /**
     * ColorNodes cannot currently be drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Returns whether this ColorNode equals another ColorNode
     * @param right The right side of the equality (must be a BooleanNode)
     */
    equalsVal(right) {
        if (right instanceof ColorNode) {
            return (this.red === right.red && this.green === right.green && this.blue === right.blue);
        }
        return false;
    }
    /**
     * Returns a string representation of the ColorNode
     */
    toString() {
        return "";
    }
    /**
     * Returns the red value
     */
    get red() {
        return this._red;
    }
    /**
     * Sets the red value
     */
    set red(red) {
        this._red = red;
    }
    /**
     * Returns the green value
     */
    get green() {
        return this._green;
    }
    /**
     * Sets the green value
     */
    set green(green) {
        this._green = green;
    }
    /**
     * Returns the blue value
     */
    get blue() {
        return this._blue;
    }
    /**
     * Sets the blue value
     */
    set blue(blue) {
        this._blue = blue;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.ColorNode = ColorNode;

},{}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const CurveEffect_1 = require("../effects/CurveEffect");
class CurveNode {
    /**
     * Constructor for a CurveNode, a node representing a curve
     * @param dx the run of the curve
     * @param dy the rise of the curve
     * @param curvature how much the curve, umm, curves
     * @param ws Preceding whitespace
     */
    constructor(dx, dy, curvature, ws) {
        this._newLine = false;
        this._dx = dx;
        this._dy = dy;
        this._curvature = curvature;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this CurveNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the curve using CurveEffect
     * @param context The current program context
     * @param dims The line dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._dx.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._dy.eval(context).val, "");
        dims.curvature = new NumberNode_1.NumberNode(this._curvature.eval(context).val, "");
        let e = new CurveEffect_1.CurveEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this CurveNode equals another (if their dx, dy, and curvature are equal)
     * @param right The right side of the equality (must be a CurveNode)
     */
    equalsVal(right) {
        if (right instanceof CurveNode) {
            return (this.dx.equalsVal(right.dx) && this.dy.equalsVal(right.dy) && this.curvature.equalsVal(right.curvature));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the curve
     */
    toString() {
        return this._ws + "curve(" + this._dx.toString() + ", " + this._dy.toString() + ", " + this._curvature.toString() + ")";
    }
    /**
     * Returns the run of the curve
     */
    get dx() {
        return this._dx;
    }
    /**
     * Sets the run of the curve
     */
    set dx(dx) {
        this._dx = dx;
    }
    /**
     * Returns the rise of the curve
     */
    get dy() {
        return this._dy;
    }
    /**
     * Sets the rise of the curve
     */
    set dy(dy) {
        this._dy = dy;
    }
    /**
     * Returns the curvature of the curve
     */
    get curvature() {
        return this._curvature;
    }
    /**
     * Sets the curvature of the curve
     */
    set curvature(curvature) {
        this._curvature = curvature;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.CurveNode = CurveNode;

},{"../effects/CurveEffect":12,"../prims/NumberNode":68}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class EllipseNode {
    /**
     * Constructor for an EllipseNode, a node representing an ellipse
     * @param width The width of the ellipse
     * @param height The height of the ellipse
     * @param ws Preceding whitespace
     */
    constructor(width, height, ws) {
        this._newLine = false;
        this._width = width;
        this._height = height;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this EllipseNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the ellipse on the canvas using EllipseEffect
     * @param context The current program context
     * @param dims The dimensions of the ellipse
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = this._width;
        dims.height = this._height;
        let e = new EllipseEffect_1.EllipseEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this EllipseNode equals another EllipseNode (if their widths and heights are equal)
     * @param right The right side of the equality (must be an EllipseNode)
     */
    equalsVal(right) {
        if (right instanceof EllipseNode) {
            return (this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    /**
     * Returns a string representation of the ellipse
     */
    toString() {
        return this._ws + "ellipse(" + this._width.toString() + ", " + this._height.toString() + ")";
    }
    move() { }
    /**
     * Returns the ellipse width
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the ellipse width
     */
    set width(width) {
        this._width = width;
    }
    /**
    * Returns the ellipse height
    */
    get height() {
        return this._height;
    }
    /**
     * Sets the ellipse height
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.EllipseNode = EllipseNode;

},{"../effects/EllipseEffect":13}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const EmojiEffect_1 = require("../effects/EmojiEffect");
class EmojiNode {
    /**
     * Constructor for an Emoji Node
     * @param name The name of the EmojiNode
     * @param width The width of the EmojiNode
     * @param height The height of the EmojiNode
     * @param ws Preceding whitespace
     */
    constructor(name, width, height, ws) {
        this._newLine = false;
        this._width = width;
        this._height = height;
        this._name = name;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this EmojiNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the rectangle using EmojiEffect
     * @param context The current program context
     * @param dims The rectangle dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._width.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._height.eval(context).val, "");
        let e = new EmojiEffect_1.EmojiEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this EmojiNode equals another (if their widths and heights are equal)
     * @param right The right side of the equality (must be an EmojiNode)
     */
    equalsVal(right) {
        if (right instanceof EmojiNode) {
            return (this.name.equalsVal(right.name) && this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the EmojiNode
     */
    toString() {
        return this._ws + "emoji(" + this._name.toString() + ", " + this._width.toString() + ", " + this._height.toString() + ")";
    }
    /**
     * Returns the name of the EmojiNode
     */
    get name() {
        return this._name;
    }
    /**
     * Sets the name of the EmojiNode
     */
    set name(width) {
        this._name = name;
    }
    /**
     * Returns the width of the EmojiNode
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the EmojiNode
     */
    set width(width) {
        this._width = width;
    }
    /**
     * Returns the height of the EmojiNode
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the EmojiNode
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.EmojiNode = EmojiNode;

},{"../effects/EmojiEffect":14,"../prims/NumberNode":68}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const EphEffect_1 = require("../effects/EphEffect");
class EphNode {
    /**
     * Constructor for an EphNode, a node representing something very special
     * @param width The width of the EphNode
     * @param height The height of the EphNode
     * @param ws Preceding whitespace
     */
    constructor(width, height, ws) {
        this._newLine = false;
        //this._image = image;
        this._width = width;
        this._height = height;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this EphNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the rectangle using EphEffect
     * @param context The current program context
     * @param dims The rectangle dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._width.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._height.eval(context).val, "");
        let e = new EphEffect_1.EphEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this EphNode equals another (if their widths and heights are equal)
     * @param right The right side of the equality (must be an EphNode)
     */
    equalsVal(right) {
        if (right instanceof EphNode) {
            return (this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the EphNode
     */
    toString() {
        return this._ws + "eph(" + this._width.toString() + ", " + this._height.toString() + ")";
    }
    /**
     * Returns the width of the EphNode
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the EphNode
     */
    set width(width) {
        this._width = width;
    }
    /**
     * Returns the height of the EphNode
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the EphNode
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.EphNode = EphNode;

},{"../effects/EphEffect":15,"../prims/NumberNode":68}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const LineEffect_1 = require("../effects/LineEffect");
class LineNode {
    /**
     * Constructor for a LineNode, a node representing a line
     * @param dx the run of the line
     * @param dy the rise of the line
     * @param ws Preceding whitespace
     */
    constructor(dx, dy, ws) {
        this._newLine = false;
        this._dx = dx;
        this._dy = dy;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this LineNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the line using LineEffect
     * @param context The current program context
     * @param dims The line dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._dx.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._dy.eval(context).val, "");
        let e = new LineEffect_1.LineEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this LineNode equals another (if their dx and dy are equal)
     * @param right The right side of the equality (must be a LineNode)
     */
    equalsVal(right) {
        if (right instanceof LineNode) {
            return (this.dx.equalsVal(right.dx) && this.dy.equalsVal(right.dy));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the line
     */
    toString() {
        return this._ws + "line(" + this._dx.toString() + ", " + this._dy.toString() + ")";
    }
    /**
     * Returns the run of the line
     */
    get dx() {
        return this._dx;
    }
    /**
     * Sets the run of the line
     */
    set dx(dx) {
        this._dx = dx;
    }
    /**
     * Returns the rise of the line
     */
    get dy() {
        return this._dy;
    }
    /**
     * Sets the rise of the line
     */
    set dy(dy) {
        this._dy = dy;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.LineNode = LineNode;

},{"../effects/LineEffect":16,"../prims/NumberNode":68}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const RectangleEffect_1 = require("../effects/RectangleEffect");
class RectangleNode {
    /**
     * Constructor for a RectangleNode, a node representing a rectangle
     * @param width The width of the rectangle
     * @param height The height of the rectangle
     * @param ws Preceding whitespace
     */
    constructor(width, height, ws) {
        this._newLine = false;
        this._width = width;
        this._height = height;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this RectangleNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the rectangle using RectangleEffect
     * @param context The current program context
     * @param dims The rectangle dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._width.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._height.eval(context).val, "");
        let e = new RectangleEffect_1.RectangleEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this RectangleNode equals another (if their widths and heights are equal)
     * @param right The right side of the equality (must be a RectangleNode)
     */
    equalsVal(right) {
        if (right instanceof RectangleNode) {
            return (this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the rectangle
     */
    toString() {
        return this._ws + "rect(" + this._width.toString() + ", " + this._height.toString() + ")";
    }
    /**
     * Returns the width of the rectangle
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the rectangle
     */
    set width(width) {
        this._width = width;
    }
    /**
     * Returns the height of the rectangle
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the rectangle
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.RectangleNode = RectangleNode;

},{"../effects/RectangleEffect":18,"../prims/NumberNode":68}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
class Dimensions {
    /**
     * Constructor for Dimensions, which stores object dimensions
     * @param x The x coordinate of the object
     * @param y The y coordinate of the object
     * @param z The z coordinate of the object
     * @param scale The scale of the object
     * @param radius The radius of the object
     */
    constructor(x, y, z, scale, radius) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._scale = scale;
        this._radius = radius || new NumberNode_1.NumberNode(30, "");
    }
    /**
     * Returns a string representation of the dimensions
     */
    toString() {
        return this.x.toString() + ", " + this.y.toString();
    }
    /**
     * Returns the x coordinate of the object
     */
    get x() {
        return this._x;
    }
    /**
     * Sets the x coordinate of the object
     */
    set x(val) {
        this._x = val;
    }
    /**
     * Returns the y coordinate of the object
     */
    get y() {
        return this._y;
    }
    /**
     * Sets the y coordinate of the object
     */
    set y(val) {
        this._y = val;
    }
    /**
     * Returns the z coordinate of the object
     */
    get z() {
        return this._z;
    }
    /**
     * Sets the z coordinate of the object
     */
    set z(val) {
        this._z = val;
    }
    /**
     * Returns the radius of the object
     */
    get radius() {
        return this._radius;
    }
    /**
     * Sets the radius of the object
     */
    set radius(val) {
        this._radius = val;
    }
    /**
     * Returns the scale of the object
     */
    get scale() {
        return this._scale;
    }
    /**
     * Sets the scale of the object
     */
    set scale(val) {
        this._scale = val;
    }
    /**
     * Returns the width of the object
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the object
     */
    set width(val) {
        this._width = val;
    }
    /**
     * Returns the height of the object
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the object
     */
    set height(val) {
        this._height = val;
    }
    /**
     * Returns the curvature of the object
     */
    get curvature() {
        return this._curvature;
    }
    /**
     * Sets the curvature of the object
     */
    set curvature(val) {
        this._curvature = val;
    }
}
exports.Dimensions = Dimensions;

},{"../prims/NumberNode":68}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class PrintNode {
    /**
     * Constructor for a PrintNode, representing an object to be printed
     * @param toPrint The object to be printed
     * @param coordsGiven Whether the xy coordinates to print the object is given
     * @param dimensions The dimensions of the object to be printed
     * @param ws Preceding whitespace
     */
    constructor(toPrint, coordsGiven, dimensions, ws) {
        this._scale = 1;
        this._newLine = false;
        this._toPrint = toPrint;
        this._coordsGiven = coordsGiven;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
        this._dims = dimensions || null;
    }
    /**
     * Returns a string representation of the object to be printed
     */
    toString() {
        return this._ws + "print(" + this.toPrint.toString() + ", " + this.dims.toString() + ")";
    }
    /**
     * Equals cannot be called directly on a PrintNode
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on PrintNode");
    }
    /**
     * PrintNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw() on printOp");
    }
    /**
     * Evaluates the object to be printed and draws it
     * @param context
     */
    eval(context) {
        let res = this._toPrint.eval(context);
        if (this._coordsGiven) {
            res.draw(context, this._dims, this);
            //check if the effects array already has some elements
        } /*() else if (context.effects.length > 0) {

        }*/
        return res;
    }
    /**
     * Returns the object to be printed
     */
    get toPrint() {
        return this._toPrint;
    }
    /**
     * Returns the dimensions of the object to be printed
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.PrintNode = PrintNode;

},{}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ReturnError_1 = require("./ReturnError");
class Return {
    /**
     * Constructor for a Return object, representing something to be returned in a function
     * @param expr The expression to be returned
     * @param ws Preceding whitespace
     */
    constructor(expr, ws) {
        this._newLine = false;
        this._expr = expr;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the expression to be returned and returns via a ReturnErro
     * @param context The current program context
     */
    eval(context) {
        // If return val is a var, returns that var's value
        let result = this._expr.eval(context);
        throw new ReturnError_1.ReturnError(result, context.retIDLookup());
    }
    /**
     * Equals cannot be called directly on Return nodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on Return");
    }
    /**
     * Returns a string representation of the Return node
     */
    toString() {
        return this._ws + "return " + this._expr.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Return nodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw on Return");
    }
}
exports.Return = Return;

},{"./ReturnError":80}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ReturnError extends Error {
    /**
     * Constructor for ReturnError, a custom error class that we abuse to return values
     * @param retVal The value to be returned
     * @param ID The ID of the value to be returned
     */
    constructor(retVal, ID) {
        super(ID);
        this.retVal = retVal;
        this.ID = ID;
        Object.setPrototypeOf(this, ReturnError.prototype);
    }
}
exports.ReturnError = ReturnError;

},{}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const space_lift_1 = require("space-lift");
class Scope {
    /**
     * Constructor for Scope, an object keeping track of objects within a particular context
     * @param parent The parent Scope
     * @param effects Effects within this Scope
     * @param myState The scope state
     * @param eventLog The log of events that occurred
     */
    constructor(parent, effects, eventLog) {
        this._retValID = space_lift_1.None;
        this._canvas = space_lift_1.None;
        this._eventLog = []; // The event log
        this._hadFunEval = false; // Was this created in a function?
        //public globalFunID = Math.random();
        this.globalFunID = 10000000; // The global ID for functions in this context
        this._varBindings = new Map();
        this._parent = parent;
        this._effects = effects || null;
        this._eventLog = eventLog;
        if (this._parent != null && this._parent._hadFunEval)
            this._hadFunEval = true; // copy function eval flag from parent
    }
    /**
     * Copies information from this Scope into another Scope and returns the new Scope
     */
    copy() {
        let s = new Scope(this._parent, this._effects, this._eventLog);
        s.varBindings = new Map(this._varBindings);
        s.canvas = this.canvas;
        s.eventLog = this.eventLog;
        return s;
    }
    /**
     * Declares a new variable
     * @param name The name of the variable to be declared
     */
    declare(name) {
        if (this._varBindings.has(name)) {
            throw new Error("Scope already has var with name " + name);
        }
        this._varBindings.set(name, space_lift_1.None);
    }
    /**
     * Assigns a value to a variable in this Context
     * @param name The name of the variable
     * @param val The value of the variable
     */
    assign(name, val) {
        this._varBindings.set(name, space_lift_1.Some(val)); //Some(val)?
    }
    /**
     * Looks up a value within the Scope and all its ancestor Scopes
     * @param name The name of the value
     * @param context The context to search within
     */
    lookup(name, context) {
        if (context.varBindings.has(name)) {
            if (context.varBindings.get(name).isDefined()) {
                return (context.varBindings.get(name).get()); //extra get to manage Some()
            }
        }
        if (!(context.parent == null)) {
            return this.lookup(name, context.parent);
        }
        throw new Error("Variable could not be found.");
    }
    /**
     * Looks up and returns the return ID value
     */
    retIDLookup() {
        if (this._retValID.isDefined()) {
            return this._retValID.get();
        }
        else {
            if (this._parent) {
                return this._parent.retIDLookup();
            }
            else {
                throw new Error("Unknown caller.");
            }
        }
    }
    /**
     * Returns the Map of variable bindings
     */
    get varBindings() {
        return this._varBindings;
    }
    /**
     * Sets the Map of variable bindings
     */
    set varBindings(m) {
        this._varBindings = m;
    }
    /**
     * Returns the parent Scope
     */
    get parent() {
        return this._parent;
    }
    /**
     * Returns the return value ID
     */
    get retValID() {
        return this._retValID;
    }
    /**
     * Sets the return value ID
     */
    set retValID(val) {
        this._retValID = val;
    }
    /**
     * Returns the HTML canvas
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Sets the HTML canvas
     */
    set canvas(val) {
        this._canvas = val;
    }
    /**
     * Returns the effects array
     */
    get effects() {
        return this._effects;
    }
    /**
     * Sets the effects array
     */
    set effects(arr) {
        this._effects = arr;
    }
    /**
     * Returns the event log
     */
    get eventLog() {
        return this._eventLog;
    }
    /**
     * Sets the event log
     */
    set eventLog(update) {
        this._eventLog = update;
    }
    /**
     * Returns the array of effects
     */
    get mulSelArray() {
        return this._mulSelArray;
    }
    /**
     * Sets the array of effects
     */
    set mulSelArray(update) {
        this._mulSelArray = update;
    }
    /**
     * Returns whether this Scope was created in a function
     */
    get hadFunEval() {
        return this._hadFunEval;
    }
    /**
     * Sets whether this Scope was created in a function
     */
    set hadFunEval(val) {
        this._hadFunEval = val;
    }
}
exports.Scope = Scope;

},{"space-lift":96}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("./Scope");
const space_lift_1 = require("space-lift");
class SequenceNode {
    /**
     * Constructor for a SequenceNode, the building block of the AST
     * @param left The left side of the Sequence
     * @param right The right side of the Sequence
     */
    constructor(left, right) {
        this._newLine = true;
        this._left = left;
        this._right = right;
    }
    /**
     * Evaluates the children in postorder (left, right, parent)
     * @param context The current program context
     */
    eval(context) {
        let leftScope = new Scope_1.Scope(context, context.effects, context.eventLog);
        leftScope.canvas = space_lift_1.Some(context.canvas.get());
        //throwing away after evaling
        this._leftVal = this._left.eval(leftScope);
        this._rightVal = this._right.eval(leftScope); // leftScope may be modified now
    }
    /**
     * SequenceNodes cannot be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw() on SequenceNodes");
    }
    /**
     * Equals cannot be directly called on SequenceNodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on SequenceNode");
    }
    /**
     * Returns a string representation of the AST
     */
    toString() {
        let result = this._left.toString();
        if (this._left.newLine() == true) {
            result += '\n';
        }
        else {
            result += ";\n";
        }
        if (this._right.newLine() == false) {
            result += this._right.toString() + ";";
        }
        else {
            result += this._right.toString();
        }
        return result;
    }
    /**
     * Returns the left child
     */
    set left(left) {
        this._left = left;
    }
    /**
     * Sets the left child
     */
    get left() {
        return this._left;
    }
    /**
     * Returns the right child
     */
    set right(right) {
        this._right = right;
    }
    /**
     * Sets the right child
     */
    get right() {
        return this._right;
    }
    /**
     * Returns the value of the left chile
     */
    get leftVal() {
        return this._leftVal;
    }
    /**
     * Returns the value of the right chile
     */
    get rightVal() {
        return this._rightVal;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.SequenceNode = SequenceNode;

},{"./Scope":81,"space-lift":96}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../../index");
const index_2 = require("../../index");
const space_lift_1 = require("space-lift");
const diff_1 = require("diff");
(function () {
    let editor = ((e) => { return e.CodeMirror; })(document.getElementById("input"));
    let editorWrapper = editor.getWrapperElement();
    let canvas = document.querySelector("canvas");
    let popUp = document.getElementById("popup");
    let ctx = canvas.getContext("2d");
    let lastCursorPos = editor.getCursor();
    let lastProgram = ""; // Used for comparing and highlighting diffs
    let effects = [];
    let ast;
    let context;
    let masterLog = [];
    let alreadyLogged = false;
    let numLogged = 0;
    let selectedElems = [];
    let selected = 0; // the number of selected effects if multiply selecting
    let isCanvasSelected = false; // Check if mouse is clicked on canvas
    let isDoingDM = false; // Check if direct manipulating effects
    let checkpoint = null;
    let modGen = new index_2.ModuleGenerator();
    let checkpointIsActive = false;
    let canvasIsDisabled = false;
    let globalID = 1;
    let highlightTimer = null;
    let parseTimer = null;
    /* Logging, parsing & rendering */
    function printLog() {
        console.log("Log: ");
        for (let elem of masterLog) {
            console.log(elem.assembleLog());
            // this is just sample usage;
            // you should replace parameters with real values
            // this might not even be the right place to put this
            index_2.LogEvent.logToRemoteServer(elem.eventType(), "someUUID", elem.toJSON());
        }
    }
    function parse() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let inputText = editor.getValue();
        let astOpt = index_1.Parser.parse(inputText);
        effects.length = 0; // slightly sketch clearing method to maintain reference to original array
        if (astOpt.isDefined()) {
            ast = astOpt.get();
            context = new index_2.Scope(null, effects, masterLog);
            context.canvas = space_lift_1.Some(canvas);
            ast.eval(context); //this is where we draw the objects to the screen
        }
        else {
            ast = undefined;
        }
        printLog();
    }
    /**
     * The animation function that basically recursively calls itself, clearing and
     * redrawing to the canvas at 60fps.
     */
    function animate() {
        requestAnimationFrame(animate);
        ctx.clearRect(0, 0, canvas.width, canvas.height); //clears canvas
        selected = 0;
        for (let i = 0; i < effects.length; i++) {
            effects[i].update();
            if (effects[i].selected) {
                selectedElems.push(effects[i]);
                selected++;
            }
            if (effects[i].getJustDragged()) { // Logs drag event
                context.eventLog.push(new index_2.DragEvent(effects[i]));
                masterLog.push(context.eventLog[context.eventLog.length - 1]);
                effects[i].setJustDragged(false);
            }
            if (effects[i].idObj == undefined) { // Gives object an ID if it doesn't have one
                effects[i].initID(globalID);
                context.eventLog.push(new index_2.IDEvent(effects[i])); // Logs ID
                globalID++;
            }
        }
        // at this point, have iterated through all effects and have complete list to log
        if (selected != numLogged) { // if selections have changed, should log again
            alreadyLogged = false;
        }
        if (!alreadyLogged && selected >= 2) { // logs if hasn't already
            numLogged = selected;
            context.eventLog.push(new index_2.SelectEvent(selectedElems));
            masterLog.push(context.eventLog[context.eventLog.length - 1]);
            alreadyLogged = true;
        }
        selectedElems = [];
        updateProgramText(); // ProDirect Manipulation
        // Draw check points
        if (checkpointIsActive) {
            checkpointChecksGoal();
        }
        if (checkpoint != null && checkpoint.drawGuides != null) {
            checkpoint.drawGuides();
        }
    }
    /**
     * Update the program text and highlight all the changes
    **/
    function updateProgramText() {
        if (!ast || !isDoingDM) {
            return;
        }
        let newProgram = ast.toString();
        if (lastProgram != newProgram) {
            editor.setValue(newProgram);
            highlightDiff(newProgram);
            lastProgram = newProgram;
        }
        else if (!isCanvasSelected) {
            isDoingDM = false;
        }
    }
    /**
     * Highlight diffs in editor
     * @param newProgram New program text to highlight
     * @param update Whether or not to update last program with new program
     */
    function highlightDiff(newProgram, update) {
        let curLine = 0;
        let curChar = 0;
        diff_1.diffChars(lastProgram, newProgram).forEach((result) => {
            let lines = result.value.split(/\r?\n/g);
            let endLine = result.removed ? curLine : curLine + lines.length - 1;
            let endChar = result.removed ? curChar :
                ((endLine == curLine ? curChar : 0) + lines[lines.length - 1].length);
            if (result.added || result.removed) {
                // Extends the highlighted section all the way to the left
                let startHighlightChar = curChar;
                let firstLine = editor.getLine(curLine);
                while (startHighlightChar >= 1) {
                    // Check if alphanumeric
                    if (!/^[a-z0-9]+$/i.test(firstLine[startHighlightChar - 1])) {
                        break;
                    }
                    startHighlightChar--;
                }
                // Extends to the right
                let endHightLightChar = endChar;
                let lastLine = editor.getLine(endLine);
                while (endHightLightChar < lastLine.length) {
                    if (!/^[a-z0-9]+$/i.test(lastLine[endHightLightChar])) {
                        break;
                    }
                    endHightLightChar++;
                }
                editor.markText(// Highlight text
                { line: curLine, ch: startHighlightChar }, // Starting point
                { line: endLine, ch: endHightLightChar }, // Inclusive line, exclusive char
                { className: "highlighted-text" });
            }
            curLine = endLine;
            curChar = endChar;
        });
        // Set the clear highlight timer
        if (highlightTimer != null) {
            clearTimeout(highlightTimer);
        }
        highlightTimer = setTimeout(function () {
            editor.getAllMarks().forEach((mark) => {
                mark.clear();
            });
            // user stopped doing DM; log now
            printLog();
        }, 500);
        // Update last program if necessary
        if (update) {
            lastProgram = newProgram;
        }
    }
    /* Event listeners */
    editor.on("keyup", function () {
        // Check if editor has been modified, only parses if modified
        if (editor.isClean()) {
            return;
        }
        else {
            editor.markClean();
        }
        if (parseTimer != null) {
            clearTimeout(parseTimer);
        }
        parseTimer = setTimeout(parse, 200);
    });
    editor.on("blur", function () {
        lastCursorPos = editor.getCursor();
    });
    // Window event
    window.addEventListener('mousedown', function (event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        // Check if canvas is selected
        let rect = canvas.getBoundingClientRect();
        if (canvasIsDisabled && mouseX > rect.left && mouseX < rect.right &&
            mouseY > rect.top && mouseY < rect.bottom) {
            popUp.style.display = 'block';
        }
        else {
            popUp.style.display = 'none';
        }
    });
    window.addEventListener("keydown", function (event) {
        if (!editor.hasFocus()) {
            isDoingDM = true;
        }
    });
    window.addEventListener("keyup", function (event) {
        isDoingDM = false;
    });
    // Canvas mouse events
    canvas.addEventListener("mousedown", function () {
        isCanvasSelected = true;
        isDoingDM = true;
    });
    canvas.addEventListener("mouseup", function () {
        isCanvasSelected = false;
    });
    /* Palette */
    let paletteButtons = [
        "ellipse", "rect", "string", "number",
        "line", "curve",
        "happy", "sad", "angry", "cool"
    ];
    for (let buttonName of paletteButtons) {
        let paletteButton = document.getElementById(buttonName);
        paletteButton.onclick = () => insertNode(buttonName);
    }
    /**
     * Insert new node at the current cursor position and update the cursor
     **/
    function insertNode(buttonName) {
        let newNode = "";
        switch (buttonName) {
            case "ellipse":
                newNode = "print(ellipse(100, 100));\n";
                break;
            case "rect":
                newNode = "print(rect(100, 100));\n";
                break;
            case "string":
                newNode = 'print("newWord");\n';
                break;
            case "number":
                newNode = "print(10);\n";
                break;
            case "line":
                newNode = "print(line(100, 100));\n";
                break;
            case "curve":
                newNode = "print(curve(100, 100, 100));\n";
                break;
            case "happy":
            case "sad":
            case "angry":
            case "cool":
                newNode = 'print(emoji("' + buttonName + '", 100, 100));\n';
                break;
            default:
                console.log("Problem with " + buttonName);
                return;
        }
        // Insert at cursor position & highlight changes
        editor.replaceRange(newNode, lastCursorPos);
        highlightDiff(editor.getValue(), true);
        // Update cursor & refocus editor
        lastCursorPos.line++;
        lastCursorPos.ch = 0;
        editor.focus();
        editor.setCursor(lastCursorPos);
        // Parse
        parse();
    }
    //reset checkpoint
    // let resetButton = document.getElementById('reset');
    // resetButton.onclick = function() {
    //     if (checkpoint._starterCode != null) {
    //         editor.setValue(checkpoint._starterCode);
    //         parse();
    //     }
    //     context.eventLog.push(new ClearEvent());
    //     masterLog.push(context.eventLog[context.eventLog.length - 1]); // Does this actually work?
    //     printLog();
    // };
    /* Modules */
    /* --- for non-DM modules, will be fully implemented in a day or 2 - Quan, 1/2/2018 --- */
    /*
    <div class="row">
        <button id="l2c1" class="checkpoint btn btn-block">Checkpoint 1</button>
    </div>
    */
    //set up Checkpoints sidebar
    let lesson = document.getElementById('one');
    if (lesson != null) {
        var div = document.createElement('div');
        div.className = 'row';
        var btn = document.createElement('button');
        btn.id = "l1c1";
        btn.className = "checkpoint btn btn-block";
        btn.innerHTML = "Checkpoint 1";
        div.appendChild(btn);
        lesson.appendChild(div);
    }
    /* ---------------------------------------------------------- */
    let instructions = document.getElementById('goal');
    let rewardBox = document.getElementById('reward-container');
    let instrLabel = document.getElementById('instr-label');
    //Map maintaining code last used at a checkpoint
    let cpCode = new Map([
        ['l1c1', ""],
        ['l1c2', ""],
        ['l1c3', ""],
        ['l1c4', ""],
        ['l2c1', ""],
        ['l2c2', ""],
        ['l2c3', ""],
        ['l2c4', ""],
        ['l2c5', ""],
        ['l2c6', ""],
        ['l2c7', ""],
        ['l3c1', ""],
        ['l3c2', ""],
        ['l3c3', ""],
        ['l3c4', ""],
        ['l3c5', ""],
        ['l3c6', ""],
        ['l4c1', ""],
        ['l4c2', ""]
    ]);
    //Map maintaining whether a checkpoint has been completed
    let cpCompletion = new Map([
        ['l1c1', false],
        ['l1c2', false],
        ['l1c3', false],
        ['l1c4', false],
        ['l2c1', false],
        ['l2c2', false],
        ['l2c3', false],
        ['l2c4', false],
        ['l2c5', false],
        ['l2c6', false],
        ['l2c7', false],
        ['l3c1', false],
        ['l3c2', false],
        ['l3c3', false],
        ['l3c4', false],
        ['l3c5', false],
        ['l3c6', false],
        ['l4c1', false],
        ['l4c2', false]
    ]);
    /* keeping track of and displaying user's progress */
    let starCount = 0;
    let starBox = document.getElementById("achievement");
    updateStarBox();
    let cpNames = [
        'l1c1', 'l1c2', 'l1c3', 'l1c4',
        'l2c1', 'l2c2', 'l2c3', 'l2c4', 'l2c5', 'l2c6', 'l2c7',
        'l3c1', 'l3c2', 'l3c3', 'l3c4', 'l3c5', 'l3c6'
    ];
    //this is for testing tutorials
    let workingCp = [
        'l1c1', 'l1c2', 'l1c3', 'l1c4', 'l2c1'
    ];
    for (let cp of cpNames) {
        let cpButton = document.getElementById(cp);
        cpButton.onclick = function () {
            lastProgram = "";
            initCheckpoint(cp);
        };
    }
    /**
     * Creates a module corresponding to a checkpoint passed in.
     * Sets up the instruction, CODE area, and goal box accordingly.
     * @param cp the name of the checkpoint
     */
    function initCheckpoint(cp) {
        //store code written of old checkpoint
        if (checkpoint != null) {
            cpCode.set(checkpoint._name, editor.getValue());
        }
        console.log("Initiating checkpoint " + cp);
        checkpoint = modGen.createModule(cp, ctx, editor);
        instrLabel.innerHTML = cp + " - GOAL";
        instructions.innerHTML = checkpoint._instructions;
        //freeze/unfreeze the CODE and CANVAS areas
        if (checkpoint._constraint == 'code') {
            editor.setOption("readOnly", true);
            editorWrapper.style.opacity = '0.5';
            canvas.style.pointerEvents = "auto";
            canvas.style.background = 'white';
            canvasIsDisabled = false;
        }
        else if (checkpoint._constraint == 'canvas') {
            editor.setOption("readOnly", false);
            editorWrapper.style.opacity = '1.0';
            canvas.style.pointerEvents = "none";
            canvas.style.background = '#C0C0C0';
            canvasIsDisabled = true;
        }
        else {
            editor.setOption("readOnly", false);
            editorWrapper.style.opacity = '1.0';
            canvas.style.pointerEvents = "auto";
            canvas.style.background = 'white';
            canvasIsDisabled = false;
        }
        //restore previous code written in this checkpoint
        if (cpCode.get(checkpoint._name) !== "") {
            editor.setValue(cpCode.get(checkpoint._name));
            parse();
        }
        //restore latest instruction at this checkpoint
        popUp.style.display = 'none';
        let curInstruction = document.getElementById("instruction");
        if (curInstruction != null) {
            curInstruction.remove();
        }
        if (checkpoint.numInstructions > 0) {
            checkpoint.renderInstruction(document);
        }
        //set up the instruction and goal boxes
        if (cpCompletion.get(cp)) {
            updateRewardBox();
        }
        else {
            //initialize starter code if this is the first time this checkpoint is reached
            if (checkpoint._starterCode != null && cpCode.get(checkpoint._name) === "") {
                editor.setValue(checkpoint._starterCode);
                parse();
            }
            //set up the instruction and goal boxes
            rewardBox.style.background = '#C0C0C0';
            let reward = document.getElementById('reward-text');
            reward.style.color = 'black';
            reward.innerHTML = 'Complete goal to earn a star!';
            let rewardImg = document.getElementById('reward-image');
            rewardImg.src = 'pics/greystar.svg';
            rewardImg.alt = 'a star to be earned';
            let nextBtn = document.getElementById('next');
            nextBtn.style.display = 'none';
            instructions.scrollTop = 0;
            checkpointIsActive = true;
        }
    }
    function checkpointChecksGoal() {
        if (checkpoint.checkGoal(document, effects)) {
            updateRewardBox();
            cpCompletion.set(checkpoint._name, true);
            updateStarBox();
        }
    }
    function updateRewardBox() {
        rewardBox.style.background = '#673AB7';
        console.log(document);
        let rewardText = document.getElementById('reward-text');
        rewardText.style.color = '#D8D8D8';
        rewardText.innerHTML = "Goal met! Click 'Next' to go to next checkpoint!";
        let rewardImg = document.getElementById('reward-image');
        rewardImg.src = 'pics/star.svg';
        rewardImg.alt = 'star earned';
        let nextBtn = document.getElementById('next');
        nextBtn.style.display = 'block';
        instructions.scrollTop = instructions.scrollHeight;
        checkpointIsActive = false;
    }
    let nextButton = document.getElementById('next');
    nextButton.onclick = function () {
        let nextModule = checkpoint._nextModule;
        if (nextModule != '') {
            initCheckpoint(nextModule);
        }
    };
    let prevButton = document.getElementById('prev');
    prevButton.onclick = function () {
        let prevModule = checkpoint._prevModule;
        if (prevModule != '') {
            initCheckpoint(prevModule);
        }
    };
    function updateStarBox() {
        starCount = 0;
        for (var val of cpCompletion.values()) {
            if (val) {
                starCount++;
            }
        }
        starBox.innerHTML = starCount + "/" + cpCompletion.size;
    }
    //call to animate
    animate();
})();

},{"../../index":1,"diff":87,"space-lift":96}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const UnaryOperation_1 = require("./UnaryOperation");
const NumberNode_1 = require("../prims/NumberNode");
class NegOp extends UnaryOperation_1.UnaryOperation {
    /**
     * Constructor for a NegationOperation
     * @param val The value to be negated (must be a NumberNode)
     * @param ws Preceding whitespace
     */
    constructor(val, ws) {
        super(val);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the value into the negative version
     * @param context The current program context
     */
    eval(context) {
        let v = this.val.eval(context);
        return new NumberNode_1.NumberNode(-v.val, "");
    }
    /**
     * NegOps cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Negation ops cannot be drawn directly");
    }
    /**
     * Equals cannot be called directly on a NegOp
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on NegOp");
    }
    /**
     * Returns a string representation of the NegOp
     */
    toString() {
        return this._ws + "-" + this.val;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.NegOp = NegOp;

},{"../prims/NumberNode":68,"./UnaryOperation":85}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class UnaryOperation {
    /**
     * Abstract class constructor for Unary Operations
     * @param _val The object to be operated on
     */
    constructor(_val) {
        this._val = _val;
        this._newLine = false;
    }
    ;
    /**
     * Abstract draw method for undrawable UnaryOps
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Unary Operations cannot be drawn directly");
    }
    /**
     * Equals cannot be called directly on UnaryOps
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on UnaryOp");
    }
    ;
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the UnaryOp value
     */
    get val() {
        return this._val;
    }
    /**
     * Sets the UnaryOp value
     */
    set val(value) {
        this._val = value;
    }
}
exports.UnaryOperation = UnaryOperation;

},{}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class VariableNode {
    /**
     * Constructor for a VariableNode, a node representing a variable
     * @param name The variable name
     * @param ws Preceding whitespace
     */
    constructor(name, ws) {
        this._newLine = false;
        this._name = name;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Looks up the value of the variable in the context
     * @param context The current program context
     */
    eval(context) {
        return context.lookup(this._name, context);
    }
    /**
     * VariableNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw on variable nodes");
    }
    /**
     * Equals cannot be called directly on VariableNodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot directly compare vars, eval first");
    }
    /**
     * Returns a string representation of the VariableNode
     */
    toString() {
        return this._ws + this._name;
    }
    /**
     * Returns the name of the variable
     */
    get name() {
        return this._name;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.VariableNode = VariableNode;

},{}],87:[function(require,module,exports){
/*!

 diff v3.5.0

Software License Agreement (BSD License)

Copyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>

All rights reserved.

Redistribution and use of this software in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of Kevin Decker nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@license
*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["JsDiff"] = factory();
	else
		root["JsDiff"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.merge = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffArrays = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined;

	/*istanbul ignore end*/var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	/*istanbul ignore end*/var /*istanbul ignore start*/_character = __webpack_require__(2) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_word = __webpack_require__(3) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_sentence = __webpack_require__(6) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_css = __webpack_require__(7) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_json = __webpack_require__(8) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_array = __webpack_require__(9) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_apply = __webpack_require__(10) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_merge = __webpack_require__(13) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_create = __webpack_require__(14) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_dmp = __webpack_require__(16) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_xml = __webpack_require__(17) /*istanbul ignore end*/;

	/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/* See LICENSE file for terms of use */

	/*
	 * Text diff implementation.
	 *
	 * This library supports the following APIS:
	 * JsDiff.diffChars: Character by character diff
	 * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace
	 * JsDiff.diffLines: Line based diff
	 *
	 * JsDiff.diffCss: Diff targeted at CSS content
	 *
	 * These methods are based on the implementation proposed in
	 * "An O(ND) Difference Algorithm and its Variations" (Myers, 1986).
	 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927
	 */
	exports. /*istanbul ignore end*/Diff = _base2['default'];
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffChars = _character.diffChars;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWords = _word.diffWords;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = _word.diffWordsWithSpace;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffLines = _line.diffLines;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = _line.diffTrimmedLines;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffSentences = _sentence.diffSentences;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffCss = _css.diffCss;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffJson = _json.diffJson;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffArrays = _array.diffArrays;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/structuredPatch = _create.structuredPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = _create.createTwoFilesPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = _create.createPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatch = _apply.applyPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = _apply.applyPatches;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/parsePatch = _parse.parsePatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/merge = _merge.merge;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToDMP = _dmp.convertChangesToDMP;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToXML = _xml.convertChangesToXML;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = _json.canonicalize;



/***/ }),
/* 1 */
/***/ (function(module, exports) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports['default'] = /*istanbul ignore end*/Diff;
	function Diff() {}

	Diff.prototype = {
	  /*istanbul ignore start*/ /*istanbul ignore end*/diff: function diff(oldString, newString) {
	    /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	    var callback = options.callback;
	    if (typeof options === 'function') {
	      callback = options;
	      options = {};
	    }
	    this.options = options;

	    var self = this;

	    function done(value) {
	      if (callback) {
	        setTimeout(function () {
	          callback(undefined, value);
	        }, 0);
	        return true;
	      } else {
	        return value;
	      }
	    }

	    // Allow subclasses to massage the input prior to running
	    oldString = this.castInput(oldString);
	    newString = this.castInput(newString);

	    oldString = this.removeEmpty(this.tokenize(oldString));
	    newString = this.removeEmpty(this.tokenize(newString));

	    var newLen = newString.length,
	        oldLen = oldString.length;
	    var editLength = 1;
	    var maxEditLength = newLen + oldLen;
	    var bestPath = [{ newPos: -1, components: [] }];

	    // Seed editLength = 0, i.e. the content starts with the same values
	    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
	    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
	      // Identity per the equality and tokenizer
	      return done([{ value: this.join(newString), count: newString.length }]);
	    }

	    // Main worker method. checks all permutations of a given edit length for acceptance.
	    function execEditLength() {
	      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
	        var basePath = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
	        var addPath = bestPath[diagonalPath - 1],
	            removePath = bestPath[diagonalPath + 1],
	            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
	        if (addPath) {
	          // No one else is going to attempt to use this value, clear it
	          bestPath[diagonalPath - 1] = undefined;
	        }

	        var canAdd = addPath && addPath.newPos + 1 < newLen,
	            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
	        if (!canAdd && !canRemove) {
	          // If this path is a terminal then prune
	          bestPath[diagonalPath] = undefined;
	          continue;
	        }

	        // Select the diagonal that we want to branch from. We select the prior
	        // path whose position in the new string is the farthest from the origin
	        // and does not pass the bounds of the diff graph
	        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
	          basePath = clonePath(removePath);
	          self.pushComponent(basePath.components, undefined, true);
	        } else {
	          basePath = addPath; // No need to clone, we've pulled it from the list
	          basePath.newPos++;
	          self.pushComponent(basePath.components, true, undefined);
	        }

	        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);

	        // If we have hit the end of both strings, then we are done
	        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
	          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
	        } else {
	          // Otherwise track this path as a potential candidate and continue.
	          bestPath[diagonalPath] = basePath;
	        }
	      }

	      editLength++;
	    }

	    // Performs the length of edit iteration. Is a bit fugly as this has to support the
	    // sync and async mode which is never fun. Loops over execEditLength until a value
	    // is produced.
	    if (callback) {
	      (function exec() {
	        setTimeout(function () {
	          // This should not happen, but we want to be safe.
	          /* istanbul ignore next */
	          if (editLength > maxEditLength) {
	            return callback();
	          }

	          if (!execEditLength()) {
	            exec();
	          }
	        }, 0);
	      })();
	    } else {
	      while (editLength <= maxEditLength) {
	        var ret = execEditLength();
	        if (ret) {
	          return ret;
	        }
	      }
	    }
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/pushComponent: function pushComponent(components, added, removed) {
	    var last = components[components.length - 1];
	    if (last && last.added === added && last.removed === removed) {
	      // We need to clone here as the component clone operation is just
	      // as shallow array clone
	      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed };
	    } else {
	      components.push({ count: 1, added: added, removed: removed });
	    }
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
	    var newLen = newString.length,
	        oldLen = oldString.length,
	        newPos = basePath.newPos,
	        oldPos = newPos - diagonalPath,
	        commonCount = 0;
	    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
	      newPos++;
	      oldPos++;
	      commonCount++;
	    }

	    if (commonCount) {
	      basePath.components.push({ count: commonCount });
	    }

	    basePath.newPos = newPos;
	    return oldPos;
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/equals: function equals(left, right) {
	    if (this.options.comparator) {
	      return this.options.comparator(left, right);
	    } else {
	      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
	    }
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/removeEmpty: function removeEmpty(array) {
	    var ret = [];
	    for (var i = 0; i < array.length; i++) {
	      if (array[i]) {
	        ret.push(array[i]);
	      }
	    }
	    return ret;
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/castInput: function castInput(value) {
	    return value;
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/tokenize: function tokenize(value) {
	    return value.split('');
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/join: function join(chars) {
	    return chars.join('');
	  }
	};

	function buildValues(diff, components, newString, oldString, useLongestToken) {
	  var componentPos = 0,
	      componentLen = components.length,
	      newPos = 0,
	      oldPos = 0;

	  for (; componentPos < componentLen; componentPos++) {
	    var component = components[componentPos];
	    if (!component.removed) {
	      if (!component.added && useLongestToken) {
	        var value = newString.slice(newPos, newPos + component.count);
	        value = value.map(function (value, i) {
	          var oldValue = oldString[oldPos + i];
	          return oldValue.length > value.length ? oldValue : value;
	        });

	        component.value = diff.join(value);
	      } else {
	        component.value = diff.join(newString.slice(newPos, newPos + component.count));
	      }
	      newPos += component.count;

	      // Common case
	      if (!component.added) {
	        oldPos += component.count;
	      }
	    } else {
	      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
	      oldPos += component.count;

	      // Reverse add and remove so removes are output first to match common convention
	      // The diffing algorithm is tied to add then remove output and this is the simplest
	      // route to get the desired output with minimal overhead.
	      if (componentPos && components[componentPos - 1].added) {
	        var tmp = components[componentPos - 1];
	        components[componentPos - 1] = components[componentPos];
	        components[componentPos] = tmp;
	      }
	    }
	  }

	  // Special case handle for when one terminal is ignored (i.e. whitespace).
	  // For this case we merge the terminal into the prior string and drop the change.
	  // This is only available for string mode.
	  var lastComponent = components[componentLen - 1];
	  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
	    components[componentLen - 2].value += lastComponent.value;
	    components.pop();
	  }

	  return components;
	}

	function clonePath(path) {
	  return { newPos: path.newPos, components: path.components.slice(0) };
	}



/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.characterDiff = undefined;
	exports. /*istanbul ignore end*/diffChars = diffChars;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var characterDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/characterDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
	function diffChars(oldStr, newStr, options) {
	  return characterDiff.diff(oldStr, newStr, options);
	}



/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.wordDiff = undefined;
	exports. /*istanbul ignore end*/diffWords = diffWords;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = diffWordsWithSpace;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	/*istanbul ignore end*/var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;

	/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/ // Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode
	//
	// Ranges and exceptions:
	// Latin-1 Supplement, 0080–00FF
	//  - U+00D7  × Multiplication sign
	//  - U+00F7  ÷ Division sign
	// Latin Extended-A, 0100–017F
	// Latin Extended-B, 0180–024F
	// IPA Extensions, 0250–02AF
	// Spacing Modifier Letters, 02B0–02FF
	//  - U+02C7  ˇ &#711;  Caron
	//  - U+02D8  ˘ &#728;  Breve
	//  - U+02D9  ˙ &#729;  Dot Above
	//  - U+02DA  ˚ &#730;  Ring Above
	//  - U+02DB  ˛ &#731;  Ogonek
	//  - U+02DC  ˜ &#732;  Small Tilde
	//  - U+02DD  ˝ &#733;  Double Acute Accent
	// Latin Extended Additional, 1E00–1EFF
	var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;

	var reWhitespace = /\S/;

	var wordDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/wordDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
	wordDiff.equals = function (left, right) {
	  if (this.options.ignoreCase) {
	    left = left.toLowerCase();
	    right = right.toLowerCase();
	  }
	  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
	};
	wordDiff.tokenize = function (value) {
	  var tokens = value.split(/(\s+|\b)/);

	  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.
	  for (var i = 0; i < tokens.length - 1; i++) {
	    // If we have an empty string in the next field and we have only word chars before and after, merge
	    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
	      tokens[i] += tokens[i + 2];
	      tokens.splice(i + 1, 2);
	      i--;
	    }
	  }

	  return tokens;
	};

	function diffWords(oldStr, newStr, options) {
	  options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(options, { ignoreWhitespace: true });
	  return wordDiff.diff(oldStr, newStr, options);
	}

	function diffWordsWithSpace(oldStr, newStr, options) {
	  return wordDiff.diff(oldStr, newStr, options);
	}



/***/ }),
/* 4 */
/***/ (function(module, exports) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/generateOptions = generateOptions;
	function generateOptions(options, defaults) {
	  if (typeof options === 'function') {
	    defaults.callback = options;
	  } else if (options) {
	    for (var name in options) {
	      /* istanbul ignore else */
	      if (options.hasOwnProperty(name)) {
	        defaults[name] = options[name];
	      }
	    }
	  }
	  return defaults;
	}



/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.lineDiff = undefined;
	exports. /*istanbul ignore end*/diffLines = diffLines;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = diffTrimmedLines;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	/*istanbul ignore end*/var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;

	/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var lineDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/lineDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
	lineDiff.tokenize = function (value) {
	  var retLines = [],
	      linesAndNewlines = value.split(/(\n|\r\n)/);

	  // Ignore the final empty token that occurs if the string ends with a new line
	  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
	    linesAndNewlines.pop();
	  }

	  // Merge the content and line separators into single tokens
	  for (var i = 0; i < linesAndNewlines.length; i++) {
	    var line = linesAndNewlines[i];

	    if (i % 2 && !this.options.newlineIsToken) {
	      retLines[retLines.length - 1] += line;
	    } else {
	      if (this.options.ignoreWhitespace) {
	        line = line.trim();
	      }
	      retLines.push(line);
	    }
	  }

	  return retLines;
	};

	function diffLines(oldStr, newStr, callback) {
	  return lineDiff.diff(oldStr, newStr, callback);
	}
	function diffTrimmedLines(oldStr, newStr, callback) {
	  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });
	  return lineDiff.diff(oldStr, newStr, options);
	}



/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.sentenceDiff = undefined;
	exports. /*istanbul ignore end*/diffSentences = diffSentences;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var sentenceDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/sentenceDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
	sentenceDiff.tokenize = function (value) {
	  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
	};

	function diffSentences(oldStr, newStr, callback) {
	  return sentenceDiff.diff(oldStr, newStr, callback);
	}



/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.cssDiff = undefined;
	exports. /*istanbul ignore end*/diffCss = diffCss;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var cssDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/cssDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
	cssDiff.tokenize = function (value) {
	  return value.split(/([{}:;,]|\s+)/);
	};

	function diffCss(oldStr, newStr, callback) {
	  return cssDiff.diff(oldStr, newStr, callback);
	}



/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.jsonDiff = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports. /*istanbul ignore end*/diffJson = diffJson;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = canonicalize;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	/*istanbul ignore end*/var /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;

	/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var objectPrototypeToString = Object.prototype.toString;

	var jsonDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/jsonDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
	// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
	// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:
	jsonDiff.useLongestToken = true;

	jsonDiff.tokenize = /*istanbul ignore start*/_line.lineDiff /*istanbul ignore end*/.tokenize;
	jsonDiff.castInput = function (value) {
	  /*istanbul ignore start*/var _options = /*istanbul ignore end*/this.options,
	      undefinedReplacement = _options.undefinedReplacement,
	      _options$stringifyRep = _options.stringifyReplacer,
	      stringifyReplacer = _options$stringifyRep === undefined ? function (k, v) /*istanbul ignore start*/{
	    return (/*istanbul ignore end*/typeof v === 'undefined' ? undefinedReplacement : v
	    );
	  } : _options$stringifyRep;


	  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
	};
	jsonDiff.equals = function (left, right) {
	  return (/*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'))
	  );
	};

	function diffJson(oldObj, newObj, options) {
	  return jsonDiff.diff(oldObj, newObj, options);
	}

	// This function handles the presence of circular references by bailing out when encountering an
	// object that is already on the "stack" of items being processed. Accepts an optional replacer
	function canonicalize(obj, stack, replacementStack, replacer, key) {
	  stack = stack || [];
	  replacementStack = replacementStack || [];

	  if (replacer) {
	    obj = replacer(key, obj);
	  }

	  var i = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

	  for (i = 0; i < stack.length; i += 1) {
	    if (stack[i] === obj) {
	      return replacementStack[i];
	    }
	  }

	  var canonicalizedObj = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

	  if ('[object Array]' === objectPrototypeToString.call(obj)) {
	    stack.push(obj);
	    canonicalizedObj = new Array(obj.length);
	    replacementStack.push(canonicalizedObj);
	    for (i = 0; i < obj.length; i += 1) {
	      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
	    }
	    stack.pop();
	    replacementStack.pop();
	    return canonicalizedObj;
	  }

	  if (obj && obj.toJSON) {
	    obj = obj.toJSON();
	  }

	  if ( /*istanbul ignore start*/(typeof /*istanbul ignore end*/obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {
	    stack.push(obj);
	    canonicalizedObj = {};
	    replacementStack.push(canonicalizedObj);
	    var sortedKeys = [],
	        _key = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
	    for (_key in obj) {
	      /* istanbul ignore else */
	      if (obj.hasOwnProperty(_key)) {
	        sortedKeys.push(_key);
	      }
	    }
	    sortedKeys.sort();
	    for (i = 0; i < sortedKeys.length; i += 1) {
	      _key = sortedKeys[i];
	      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
	    }
	    stack.pop();
	    replacementStack.pop();
	  } else {
	    canonicalizedObj = obj;
	  }
	  return canonicalizedObj;
	}



/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.arrayDiff = undefined;
	exports. /*istanbul ignore end*/diffArrays = diffArrays;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var arrayDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/arrayDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
	arrayDiff.tokenize = function (value) {
	  return value.slice();
	};
	arrayDiff.join = arrayDiff.removeEmpty = function (value) {
	  return value;
	};

	function diffArrays(oldArr, newArr, callback) {
	  return arrayDiff.diff(oldArr, newArr, callback);
	}



/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/applyPatch = applyPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = applyPatches;

	var /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_distanceIterator = __webpack_require__(12) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _distanceIterator2 = _interopRequireDefault(_distanceIterator);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/function applyPatch(source, uniDiff) {
	  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  if (typeof uniDiff === 'string') {
	    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);
	  }

	  if (Array.isArray(uniDiff)) {
	    if (uniDiff.length > 1) {
	      throw new Error('applyPatch only works with a single input.');
	    }

	    uniDiff = uniDiff[0];
	  }

	  // Apply the diff to the input
	  var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
	      delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
	      hunks = uniDiff.hunks,
	      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/{
	    return (/*istanbul ignore end*/line === patchContent
	    );
	  },
	      errorCount = 0,
	      fuzzFactor = options.fuzzFactor || 0,
	      minLine = 0,
	      offset = 0,
	      removeEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,
	      addEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

	  /**
	   * Checks if the hunk exactly fits on the provided location
	   */
	  function hunkFits(hunk, toPos) {
	    for (var j = 0; j < hunk.lines.length; j++) {
	      var line = hunk.lines[j],
	          operation = line.length > 0 ? line[0] : ' ',
	          content = line.length > 0 ? line.substr(1) : line;

	      if (operation === ' ' || operation === '-') {
	        // Context sanity check
	        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
	          errorCount++;

	          if (errorCount > fuzzFactor) {
	            return false;
	          }
	        }
	        toPos++;
	      }
	    }

	    return true;
	  }

	  // Search best fit offsets for each hunk based on the previous ones
	  for (var i = 0; i < hunks.length; i++) {
	    var hunk = hunks[i],
	        maxLine = lines.length - hunk.oldLines,
	        localOffset = 0,
	        toPos = offset + hunk.oldStart - 1;

	    var iterator = /*istanbul ignore start*/(0, _distanceIterator2['default']) /*istanbul ignore end*/(toPos, minLine, maxLine);

	    for (; localOffset !== undefined; localOffset = iterator()) {
	      if (hunkFits(hunk, toPos + localOffset)) {
	        hunk.offset = offset += localOffset;
	        break;
	      }
	    }

	    if (localOffset === undefined) {
	      return false;
	    }

	    // Set lower text limit to end of the current hunk, so next ones don't try
	    // to fit over already patched text
	    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
	  }

	  // Apply patch hunks
	  var diffOffset = 0;
	  for (var _i = 0; _i < hunks.length; _i++) {
	    var _hunk = hunks[_i],
	        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
	    diffOffset += _hunk.newLines - _hunk.oldLines;

	    if (_toPos < 0) {
	      // Creating a new file
	      _toPos = 0;
	    }

	    for (var j = 0; j < _hunk.lines.length; j++) {
	      var line = _hunk.lines[j],
	          operation = line.length > 0 ? line[0] : ' ',
	          content = line.length > 0 ? line.substr(1) : line,
	          delimiter = _hunk.linedelimiters[j];

	      if (operation === ' ') {
	        _toPos++;
	      } else if (operation === '-') {
	        lines.splice(_toPos, 1);
	        delimiters.splice(_toPos, 1);
	        /* istanbul ignore else */
	      } else if (operation === '+') {
	        lines.splice(_toPos, 0, content);
	        delimiters.splice(_toPos, 0, delimiter);
	        _toPos++;
	      } else if (operation === '\\') {
	        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
	        if (previousOperation === '+') {
	          removeEOFNL = true;
	        } else if (previousOperation === '-') {
	          addEOFNL = true;
	        }
	      }
	    }
	  }

	  // Handle EOFNL insertion/removal
	  if (removeEOFNL) {
	    while (!lines[lines.length - 1]) {
	      lines.pop();
	      delimiters.pop();
	    }
	  } else if (addEOFNL) {
	    lines.push('');
	    delimiters.push('\n');
	  }
	  for (var _k = 0; _k < lines.length - 1; _k++) {
	    lines[_k] = lines[_k] + delimiters[_k];
	  }
	  return lines.join('');
	}

	// Wrapper that supports multiple file patches via callbacks.
	function applyPatches(uniDiff, options) {
	  if (typeof uniDiff === 'string') {
	    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);
	  }

	  var currentIndex = 0;
	  function processIndex() {
	    var index = uniDiff[currentIndex++];
	    if (!index) {
	      return options.complete();
	    }

	    options.loadFile(index, function (err, data) {
	      if (err) {
	        return options.complete(err);
	      }

	      var updatedContent = applyPatch(data, index, options);
	      options.patched(index, updatedContent, function (err) {
	        if (err) {
	          return options.complete(err);
	        }

	        processIndex();
	      });
	    });
	  }
	  processIndex();
	}



/***/ }),
/* 11 */
/***/ (function(module, exports) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/parsePatch = parsePatch;
	function parsePatch(uniDiff) {
	  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
	      delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
	      list = [],
	      i = 0;

	  function parseIndex() {
	    var index = {};
	    list.push(index);

	    // Parse diff metadata
	    while (i < diffstr.length) {
	      var line = diffstr[i];

	      // File header found, end parsing diff metadata
	      if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
	        break;
	      }

	      // Diff index
	      var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
	      if (header) {
	        index.index = header[1];
	      }

	      i++;
	    }

	    // Parse file headers if they are defined. Unified diff requires them, but
	    // there's no technical issues to have an isolated hunk without file header
	    parseFileHeader(index);
	    parseFileHeader(index);

	    // Parse hunks
	    index.hunks = [];

	    while (i < diffstr.length) {
	      var _line = diffstr[i];

	      if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
	        break;
	      } else if (/^@@/.test(_line)) {
	        index.hunks.push(parseHunk());
	      } else if (_line && options.strict) {
	        // Ignore unexpected content unless in strict mode
	        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
	      } else {
	        i++;
	      }
	    }
	  }

	  // Parses the --- and +++ headers, if none are found, no lines
	  // are consumed.
	  function parseFileHeader(index) {
	    var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);
	    if (fileHeader) {
	      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
	      var data = fileHeader[2].split('\t', 2);
	      var fileName = data[0].replace(/\\\\/g, '\\');
	      if (/^".*"$/.test(fileName)) {
	        fileName = fileName.substr(1, fileName.length - 2);
	      }
	      index[keyPrefix + 'FileName'] = fileName;
	      index[keyPrefix + 'Header'] = (data[1] || '').trim();

	      i++;
	    }
	  }

	  // Parses a hunk
	  // This assumes that we are at the start of a hunk.
	  function parseHunk() {
	    var chunkHeaderIndex = i,
	        chunkHeaderLine = diffstr[i++],
	        chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);

	    var hunk = {
	      oldStart: +chunkHeader[1],
	      oldLines: +chunkHeader[2] || 1,
	      newStart: +chunkHeader[3],
	      newLines: +chunkHeader[4] || 1,
	      lines: [],
	      linedelimiters: []
	    };

	    var addCount = 0,
	        removeCount = 0;
	    for (; i < diffstr.length; i++) {
	      // Lines starting with '---' could be mistaken for the "remove line" operation
	      // But they could be the header for the next file. Therefore prune such cases out.
	      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
	        break;
	      }
	      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];

	      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
	        hunk.lines.push(diffstr[i]);
	        hunk.linedelimiters.push(delimiters[i] || '\n');

	        if (operation === '+') {
	          addCount++;
	        } else if (operation === '-') {
	          removeCount++;
	        } else if (operation === ' ') {
	          addCount++;
	          removeCount++;
	        }
	      } else {
	        break;
	      }
	    }

	    // Handle the empty block count case
	    if (!addCount && hunk.newLines === 1) {
	      hunk.newLines = 0;
	    }
	    if (!removeCount && hunk.oldLines === 1) {
	      hunk.oldLines = 0;
	    }

	    // Perform optional sanity checking
	    if (options.strict) {
	      if (addCount !== hunk.newLines) {
	        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
	      }
	      if (removeCount !== hunk.oldLines) {
	        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
	      }
	    }

	    return hunk;
	  }

	  while (i < diffstr.length) {
	    parseIndex();
	  }

	  return list;
	}



/***/ }),
/* 12 */
/***/ (function(module, exports) {

	/*istanbul ignore start*/"use strict";

	exports.__esModule = true;

	exports["default"] = /*istanbul ignore end*/function (start, minLine, maxLine) {
	  var wantForward = true,
	      backwardExhausted = false,
	      forwardExhausted = false,
	      localOffset = 1;

	  return function iterator() {
	    if (wantForward && !forwardExhausted) {
	      if (backwardExhausted) {
	        localOffset++;
	      } else {
	        wantForward = false;
	      }

	      // Check if trying to fit beyond text length, and if not, check it fits
	      // after offset location (or desired location on first iteration)
	      if (start + localOffset <= maxLine) {
	        return localOffset;
	      }

	      forwardExhausted = true;
	    }

	    if (!backwardExhausted) {
	      if (!forwardExhausted) {
	        wantForward = true;
	      }

	      // Check if trying to fit before text beginning, and if not, check it fits
	      // before offset location
	      if (minLine <= start - localOffset) {
	        return -localOffset++;
	      }

	      backwardExhausted = true;
	      return iterator();
	    }

	    // We tried to fit hunk before text beginning and beyond text length, then
	    // hunk can't fit on the text. Return undefined
	  };
	};



/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/calcLineCount = calcLineCount;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/merge = merge;

	var /*istanbul ignore start*/_create = __webpack_require__(14) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_array = __webpack_require__(15) /*istanbul ignore end*/;

	/*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	/*istanbul ignore end*/function calcLineCount(hunk) {
	  /*istanbul ignore start*/var _calcOldNewLineCount = /*istanbul ignore end*/calcOldNewLineCount(hunk.lines),
	      oldLines = _calcOldNewLineCount.oldLines,
	      newLines = _calcOldNewLineCount.newLines;

	  if (oldLines !== undefined) {
	    hunk.oldLines = oldLines;
	  } else {
	    delete hunk.oldLines;
	  }

	  if (newLines !== undefined) {
	    hunk.newLines = newLines;
	  } else {
	    delete hunk.newLines;
	  }
	}

	function merge(mine, theirs, base) {
	  mine = loadPatch(mine, base);
	  theirs = loadPatch(theirs, base);

	  var ret = {};

	  // For index we just let it pass through as it doesn't have any necessary meaning.
	  // Leaving sanity checks on this to the API consumer that may know more about the
	  // meaning in their own context.
	  if (mine.index || theirs.index) {
	    ret.index = mine.index || theirs.index;
	  }

	  if (mine.newFileName || theirs.newFileName) {
	    if (!fileNameChanged(mine)) {
	      // No header or no change in ours, use theirs (and ours if theirs does not exist)
	      ret.oldFileName = theirs.oldFileName || mine.oldFileName;
	      ret.newFileName = theirs.newFileName || mine.newFileName;
	      ret.oldHeader = theirs.oldHeader || mine.oldHeader;
	      ret.newHeader = theirs.newHeader || mine.newHeader;
	    } else if (!fileNameChanged(theirs)) {
	      // No header or no change in theirs, use ours
	      ret.oldFileName = mine.oldFileName;
	      ret.newFileName = mine.newFileName;
	      ret.oldHeader = mine.oldHeader;
	      ret.newHeader = mine.newHeader;
	    } else {
	      // Both changed... figure it out
	      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
	      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
	      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
	      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
	    }
	  }

	  ret.hunks = [];

	  var mineIndex = 0,
	      theirsIndex = 0,
	      mineOffset = 0,
	      theirsOffset = 0;

	  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
	    var mineCurrent = mine.hunks[mineIndex] || { oldStart: Infinity },
	        theirsCurrent = theirs.hunks[theirsIndex] || { oldStart: Infinity };

	    if (hunkBefore(mineCurrent, theirsCurrent)) {
	      // This patch does not overlap with any of the others, yay.
	      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
	      mineIndex++;
	      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
	    } else if (hunkBefore(theirsCurrent, mineCurrent)) {
	      // This patch does not overlap with any of the others, yay.
	      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
	      theirsIndex++;
	      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
	    } else {
	      // Overlap, merge as best we can
	      var mergedHunk = {
	        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
	        oldLines: 0,
	        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
	        newLines: 0,
	        lines: []
	      };
	      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
	      theirsIndex++;
	      mineIndex++;

	      ret.hunks.push(mergedHunk);
	    }
	  }

	  return ret;
	}

	function loadPatch(param, base) {
	  if (typeof param === 'string') {
	    if (/^@@/m.test(param) || /^Index:/m.test(param)) {
	      return (/*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(param)[0]
	      );
	    }

	    if (!base) {
	      throw new Error('Must provide a base reference or pass in a patch');
	    }
	    return (/*istanbul ignore start*/(0, _create.structuredPatch) /*istanbul ignore end*/(undefined, undefined, base, param)
	    );
	  }

	  return param;
	}

	function fileNameChanged(patch) {
	  return patch.newFileName && patch.newFileName !== patch.oldFileName;
	}

	function selectField(index, mine, theirs) {
	  if (mine === theirs) {
	    return mine;
	  } else {
	    index.conflict = true;
	    return { mine: mine, theirs: theirs };
	  }
	}

	function hunkBefore(test, check) {
	  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
	}

	function cloneHunk(hunk, offset) {
	  return {
	    oldStart: hunk.oldStart, oldLines: hunk.oldLines,
	    newStart: hunk.newStart + offset, newLines: hunk.newLines,
	    lines: hunk.lines
	  };
	}

	function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
	  // This will generally result in a conflicted hunk, but there are cases where the context
	  // is the only overlap where we can successfully merge the content here.
	  var mine = { offset: mineOffset, lines: mineLines, index: 0 },
	      their = { offset: theirOffset, lines: theirLines, index: 0 };

	  // Handle any leading content
	  insertLeading(hunk, mine, their);
	  insertLeading(hunk, their, mine);

	  // Now in the overlap content. Scan through and select the best changes from each.
	  while (mine.index < mine.lines.length && their.index < their.lines.length) {
	    var mineCurrent = mine.lines[mine.index],
	        theirCurrent = their.lines[their.index];

	    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
	      // Both modified ...
	      mutualChange(hunk, mine, their);
	    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
	      /*istanbul ignore start*/var _hunk$lines;

	      /*istanbul ignore end*/ // Mine inserted
	      /*istanbul ignore start*/(_hunk$lines = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(mine)));
	    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
	      /*istanbul ignore start*/var _hunk$lines2;

	      /*istanbul ignore end*/ // Theirs inserted
	      /*istanbul ignore start*/(_hunk$lines2 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(their)));
	    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
	      // Mine removed or edited
	      removal(hunk, mine, their);
	    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
	      // Their removed or edited
	      removal(hunk, their, mine, true);
	    } else if (mineCurrent === theirCurrent) {
	      // Context identity
	      hunk.lines.push(mineCurrent);
	      mine.index++;
	      their.index++;
	    } else {
	      // Context mismatch
	      conflict(hunk, collectChange(mine), collectChange(their));
	    }
	  }

	  // Now push anything that may be remaining
	  insertTrailing(hunk, mine);
	  insertTrailing(hunk, their);

	  calcLineCount(hunk);
	}

	function mutualChange(hunk, mine, their) {
	  var myChanges = collectChange(mine),
	      theirChanges = collectChange(their);

	  if (allRemoves(myChanges) && allRemoves(theirChanges)) {
	    // Special case for remove changes that are supersets of one another
	    if ( /*istanbul ignore start*/(0, _array.arrayStartsWith) /*istanbul ignore end*/(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
	      /*istanbul ignore start*/var _hunk$lines3;

	      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines3 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));
	      return;
	    } else if ( /*istanbul ignore start*/(0, _array.arrayStartsWith) /*istanbul ignore end*/(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
	      /*istanbul ignore start*/var _hunk$lines4;

	      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines4 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines4 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges));
	      return;
	    }
	  } else if ( /*istanbul ignore start*/(0, _array.arrayEqual) /*istanbul ignore end*/(myChanges, theirChanges)) {
	    /*istanbul ignore start*/var _hunk$lines5;

	    /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines5 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines5 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));
	    return;
	  }

	  conflict(hunk, myChanges, theirChanges);
	}

	function removal(hunk, mine, their, swap) {
	  var myChanges = collectChange(mine),
	      theirChanges = collectContext(their, myChanges);
	  if (theirChanges.merged) {
	    /*istanbul ignore start*/var _hunk$lines6;

	    /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines6 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines6 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges.merged));
	  } else {
	    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
	  }
	}

	function conflict(hunk, mine, their) {
	  hunk.conflict = true;
	  hunk.lines.push({
	    conflict: true,
	    mine: mine,
	    theirs: their
	  });
	}

	function insertLeading(hunk, insert, their) {
	  while (insert.offset < their.offset && insert.index < insert.lines.length) {
	    var line = insert.lines[insert.index++];
	    hunk.lines.push(line);
	    insert.offset++;
	  }
	}
	function insertTrailing(hunk, insert) {
	  while (insert.index < insert.lines.length) {
	    var line = insert.lines[insert.index++];
	    hunk.lines.push(line);
	  }
	}

	function collectChange(state) {
	  var ret = [],
	      operation = state.lines[state.index][0];
	  while (state.index < state.lines.length) {
	    var line = state.lines[state.index];

	    // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.
	    if (operation === '-' && line[0] === '+') {
	      operation = '+';
	    }

	    if (operation === line[0]) {
	      ret.push(line);
	      state.index++;
	    } else {
	      break;
	    }
	  }

	  return ret;
	}
	function collectContext(state, matchChanges) {
	  var changes = [],
	      merged = [],
	      matchIndex = 0,
	      contextChanges = false,
	      conflicted = false;
	  while (matchIndex < matchChanges.length && state.index < state.lines.length) {
	    var change = state.lines[state.index],
	        match = matchChanges[matchIndex];

	    // Once we've hit our add, then we are done
	    if (match[0] === '+') {
	      break;
	    }

	    contextChanges = contextChanges || change[0] !== ' ';

	    merged.push(match);
	    matchIndex++;

	    // Consume any additions in the other block as a conflict to attempt
	    // to pull in the remaining context after this
	    if (change[0] === '+') {
	      conflicted = true;

	      while (change[0] === '+') {
	        changes.push(change);
	        change = state.lines[++state.index];
	      }
	    }

	    if (match.substr(1) === change.substr(1)) {
	      changes.push(change);
	      state.index++;
	    } else {
	      conflicted = true;
	    }
	  }

	  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
	    conflicted = true;
	  }

	  if (conflicted) {
	    return changes;
	  }

	  while (matchIndex < matchChanges.length) {
	    merged.push(matchChanges[matchIndex++]);
	  }

	  return {
	    merged: merged,
	    changes: changes
	  };
	}

	function allRemoves(changes) {
	  return changes.reduce(function (prev, change) {
	    return prev && change[0] === '-';
	  }, true);
	}
	function skipRemoveSuperset(state, removeChanges, delta) {
	  for (var i = 0; i < delta; i++) {
	    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
	    if (state.lines[state.index + i] !== ' ' + changeContent) {
	      return false;
	    }
	  }

	  state.index += delta;
	  return true;
	}

	function calcOldNewLineCount(lines) {
	  var oldLines = 0;
	  var newLines = 0;

	  lines.forEach(function (line) {
	    if (typeof line !== 'string') {
	      var myCount = calcOldNewLineCount(line.mine);
	      var theirCount = calcOldNewLineCount(line.theirs);

	      if (oldLines !== undefined) {
	        if (myCount.oldLines === theirCount.oldLines) {
	          oldLines += myCount.oldLines;
	        } else {
	          oldLines = undefined;
	        }
	      }

	      if (newLines !== undefined) {
	        if (myCount.newLines === theirCount.newLines) {
	          newLines += myCount.newLines;
	        } else {
	          newLines = undefined;
	        }
	      }
	    } else {
	      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
	        newLines++;
	      }
	      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
	        oldLines++;
	      }
	    }
	  });

	  return { oldLines: oldLines, newLines: newLines };
	}



/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/structuredPatch = structuredPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = createTwoFilesPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = createPatch;

	var /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;

	/*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	/*istanbul ignore end*/function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
	  if (!options) {
	    options = {};
	  }
	  if (typeof options.context === 'undefined') {
	    options.context = 4;
	  }

	  var diff = /*istanbul ignore start*/(0, _line.diffLines) /*istanbul ignore end*/(oldStr, newStr, options);
	  diff.push({ value: '', lines: [] }); // Append an empty value to make cleanup easier

	  function contextLines(lines) {
	    return lines.map(function (entry) {
	      return ' ' + entry;
	    });
	  }

	  var hunks = [];
	  var oldRangeStart = 0,
	      newRangeStart = 0,
	      curRange = [],
	      oldLine = 1,
	      newLine = 1;

	  /*istanbul ignore start*/var _loop = function _loop( /*istanbul ignore end*/i) {
	    var current = diff[i],
	        lines = current.lines || current.value.replace(/\n$/, '').split('\n');
	    current.lines = lines;

	    if (current.added || current.removed) {
	      /*istanbul ignore start*/var _curRange;

	      /*istanbul ignore end*/ // If we have previous context, start with that
	      if (!oldRangeStart) {
	        var prev = diff[i - 1];
	        oldRangeStart = oldLine;
	        newRangeStart = newLine;

	        if (prev) {
	          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
	          oldRangeStart -= curRange.length;
	          newRangeStart -= curRange.length;
	        }
	      }

	      // Output our changes
	      /*istanbul ignore start*/(_curRange = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/lines.map(function (entry) {
	        return (current.added ? '+' : '-') + entry;
	      })));

	      // Track the updated file position
	      if (current.added) {
	        newLine += lines.length;
	      } else {
	        oldLine += lines.length;
	      }
	    } else {
	      // Identical context lines. Track line changes
	      if (oldRangeStart) {
	        // Close out any changes that have been output (or join overlapping)
	        if (lines.length <= options.context * 2 && i < diff.length - 2) {
	          /*istanbul ignore start*/var _curRange2;

	          /*istanbul ignore end*/ // Overlapping
	          /*istanbul ignore start*/(_curRange2 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines)));
	        } else {
	          /*istanbul ignore start*/var _curRange3;

	          /*istanbul ignore end*/ // end the range and output
	          var contextSize = Math.min(lines.length, options.context);
	          /*istanbul ignore start*/(_curRange3 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines.slice(0, contextSize))));

	          var hunk = {
	            oldStart: oldRangeStart,
	            oldLines: oldLine - oldRangeStart + contextSize,
	            newStart: newRangeStart,
	            newLines: newLine - newRangeStart + contextSize,
	            lines: curRange
	          };
	          if (i >= diff.length - 2 && lines.length <= options.context) {
	            // EOF is inside this hunk
	            var oldEOFNewline = /\n$/.test(oldStr);
	            var newEOFNewline = /\n$/.test(newStr);
	            if (lines.length == 0 && !oldEOFNewline) {
	              // special case: old has no eol and no trailing context; no-nl can end up before adds
	              curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
	            } else if (!oldEOFNewline || !newEOFNewline) {
	              curRange.push('\\ No newline at end of file');
	            }
	          }
	          hunks.push(hunk);

	          oldRangeStart = 0;
	          newRangeStart = 0;
	          curRange = [];
	        }
	      }
	      oldLine += lines.length;
	      newLine += lines.length;
	    }
	  };

	  for (var i = 0; i < diff.length; i++) {
	    /*istanbul ignore start*/_loop( /*istanbul ignore end*/i);
	  }

	  return {
	    oldFileName: oldFileName, newFileName: newFileName,
	    oldHeader: oldHeader, newHeader: newHeader,
	    hunks: hunks
	  };
	}

	function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
	  var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);

	  var ret = [];
	  if (oldFileName == newFileName) {
	    ret.push('Index: ' + oldFileName);
	  }
	  ret.push('===================================================================');
	  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
	  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

	  for (var i = 0; i < diff.hunks.length; i++) {
	    var hunk = diff.hunks[i];
	    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
	    ret.push.apply(ret, hunk.lines);
	  }

	  return ret.join('\n') + '\n';
	}

	function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
	  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
	}



/***/ }),
/* 15 */
/***/ (function(module, exports) {

	/*istanbul ignore start*/"use strict";

	exports.__esModule = true;
	exports. /*istanbul ignore end*/arrayEqual = arrayEqual;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/arrayStartsWith = arrayStartsWith;
	function arrayEqual(a, b) {
	  if (a.length !== b.length) {
	    return false;
	  }

	  return arrayStartsWith(a, b);
	}

	function arrayStartsWith(array, start) {
	  if (start.length > array.length) {
	    return false;
	  }

	  for (var i = 0; i < start.length; i++) {
	    if (start[i] !== array[i]) {
	      return false;
	    }
	  }

	  return true;
	}



/***/ }),
/* 16 */
/***/ (function(module, exports) {

	/*istanbul ignore start*/"use strict";

	exports.__esModule = true;
	exports. /*istanbul ignore end*/convertChangesToDMP = convertChangesToDMP;
	// See: http://code.google.com/p/google-diff-match-patch/wiki/API
	function convertChangesToDMP(changes) {
	  var ret = [],
	      change = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,
	      operation = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
	  for (var i = 0; i < changes.length; i++) {
	    change = changes[i];
	    if (change.added) {
	      operation = 1;
	    } else if (change.removed) {
	      operation = -1;
	    } else {
	      operation = 0;
	    }

	    ret.push([operation, change.value]);
	  }
	  return ret;
	}



/***/ }),
/* 17 */
/***/ (function(module, exports) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/convertChangesToXML = convertChangesToXML;
	function convertChangesToXML(changes) {
	  var ret = [];
	  for (var i = 0; i < changes.length; i++) {
	    var change = changes[i];
	    if (change.added) {
	      ret.push('<ins>');
	    } else if (change.removed) {
	      ret.push('<del>');
	    }

	    ret.push(escapeHTML(change.value));

	    if (change.added) {
	      ret.push('</ins>');
	    } else if (change.removed) {
	      ret.push('</del>');
	    }
	  }
	  return ret.join('');
	}

	function escapeHTML(s) {
	  var n = s;
	  n = n.replace(/&/g, '&amp;');
	  n = n.replace(/</g, '&lt;');
	  n = n.replace(/>/g, '&gt;');
	  n = n.replace(/"/g, '&quot;');

	  return n;
	}



/***/ })
/******/ ])
});
;
},{}],88:[function(require,module,exports){
"use strict";
//--------------------------------------
//  Shallow update
//--------------------------------------
exports.__esModule = true;
/** Performs a shallow update of an object using a partial object of the same shape. A new object is returned. */
function update(host, spec) {
    var result = clone(host);
    for (var key in spec) {
        var specValue = spec[key];
        if (specValue === exports.DELETE) {
            delete result[key];
        }
        else {
            result[key] = specValue;
        }
    }
    return result;
}
exports.update = update;
// We lie about the public type so that only a property that is optional or that can be assigned to undefined can be DELETE'd
/** Marker used to delete a key */
exports.DELETE = {};
var _Updater = /** @class */ (function () {
    function _Updater(data) {
        this.data = data;
    }
    _Updater.prototype.at = function (keyOrIndex) {
        return new _Updater({ type: 'at', parent: this, field: keyOrIndex });
    };
    _Updater.prototype.set = function (value) {
        var _this = this;
        var doSet = function (target) {
            var result = _this.cloneForUpdate(target);
            if (result.name === 'aborted')
                return target;
            var clonedTarget = result.clonedTarget, leafHost = result.leafHost, field = result.field;
            value === exports.DELETE ? delete leafHost[field] : leafHost[field] = value;
            return clonedTarget;
        };
        var boundTarget = this.findBoundTarget();
        return boundTarget
            ? doSet(boundTarget)
            : doSet;
    };
    _Updater.prototype.modify = function (modifier) {
        var _this = this;
        var doModify = function (target) {
            var result = _this.cloneForUpdate(target);
            if (result.name === 'aborted')
                return target;
            var clonedTarget = result.clonedTarget, leafHost = result.leafHost, field = result.field;
            var value = modifier(leafHost[field]);
            value === exports.DELETE ? delete leafHost[field] : leafHost[field] = value;
            return clonedTarget;
        };
        var boundTarget = this.findBoundTarget();
        return boundTarget
            ? doModify(boundTarget)
            : doModify;
    };
    _Updater.prototype.withDefault = function (value) {
        return new _Updater({ type: 'withDefault', parent: this, defaultValue: value });
    };
    _Updater.prototype.abortIfUndef = function () {
        return new _Updater({ type: 'abortIfUndef', parent: this });
    };
    _Updater.prototype.findBoundTarget = function () {
        var current = this;
        while (true) {
            if (current.data.type === 'root')
                return current.data.boundTarget;
            current = current.data.parent;
        }
    };
    _Updater.prototype.parentUpdaters = function () {
        var updaters = [this];
        var parentUpdater = this.data.parent;
        // Ignore the root updater
        while (parentUpdater && parentUpdater.data.parent) {
            updaters.unshift(parentUpdater);
            parentUpdater = parentUpdater.data.parent;
        }
        return updaters;
    };
    _Updater.prototype.getNextValue = function (previousHost, host, field, isLast) {
        if (this.data.type === 'at') {
            var newField = this.data.field;
            var value_1 = host[newField];
            var nextValue = isObjectOrArray(value_1) ? clone(value_1) : value_1;
            var newHost_1 = isLast ? host : nextValue;
            host[this.data.field] = nextValue;
            return { host: newHost_1, field: newField };
        }
        var value = previousHost[field];
        if (this.data.type === 'abortIfUndef' && value === undefined) {
            return { host: host, field: field, aborted: true };
        }
        if (this.data.type === 'withDefault' && value === undefined) {
            var nextValue = this.data.defaultValue;
            var newHost_2 = isLast ? previousHost : nextValue;
            previousHost[field] = nextValue;
            return { host: newHost_2, field: field };
        }
        var newHost = isLast ? previousHost : host;
        return { host: newHost, field: field };
    };
    _Updater.prototype.cloneForUpdate = function (target) {
        var updaters = this.parentUpdaters();
        var obj = clone(target);
        var previousHost = obj;
        var host = obj;
        var field = '';
        for (var i = 0; i < updaters.length; i++) {
            var result = updaters[i].getNextValue(previousHost, host, field, i === updaters.length - 1);
            if (result.aborted)
                return { name: 'aborted' };
            previousHost = host;
            host = result.host;
            field = result.field;
        }
        return {
            name: 'result',
            clonedTarget: obj,
            leafHost: host,
            field: field
        };
    };
    return _Updater;
}());
function isObjectOrArray(obj) {
    return obj !== null && typeof obj === 'object';
}
function clone(obj) {
    if (Array.isArray(obj))
        return obj.slice();
    var cloned = {};
    Object.keys(obj).forEach(function (key) { cloned[key] = obj[key]; });
    return cloned;
}
function deepUpdate(target) {
    return new _Updater({ type: 'root', boundTarget: target });
}
exports.deepUpdate = deepUpdate;

},{}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CharUtil;
(function (CharUtil) {
    class CharStream {
        constructor(s, startpos, endpos, hasEOF) {
            this.hasEOF = true;
            this.input = s;
            if (hasEOF != undefined) {
                this.hasEOF = hasEOF;
            }
            if (startpos == undefined) {
                this.startpos = 0; // not specified; set default
            }
            else if (startpos > s.length) {
                this.startpos = s.length; // seek too far; set EOF
            }
            else {
                this.startpos = startpos; // specified and in bounds
            }
            if (endpos == undefined) {
                this.endpos = s.length; // not specified; set default
            }
            else if (endpos > s.length) {
                this.endpos = s.length; // seek too far; set EOF
            }
            else {
                this.endpos = endpos; // specified and in bounds
            }
            if (this.startpos > this.endpos) {
                this.startpos = this.endpos; // if the user flipped positions
            }
        }
        /**
         * Returns true of the end of the input has been reached.
         */
        isEOF() {
            return this.hasEOF && this.startpos == this.input.length;
        }
        /**
         * Returns a Javscript primitive string of the slice of input
         * represented by this CharStream.
         */
        toString() {
            return this.input.substring(this.startpos, this.endpos);
        }
        /**
         * Returns a new CharStream representing the input from the
         * current start position to an end position num chars from
         * the current start position.  If startpos + num > endpos,
         * the current CharStream is returned.
         * @param num
         */
        peek(num) {
            if (this.startpos + num > this.endpos) {
                return this;
            }
            else {
                let newHasEOF = this.startpos + num == this.endpos && this.hasEOF;
                return new CharStream(this.input, this.startpos, this.startpos + num, newHasEOF);
            }
        }
        /**
         * Returns a new CharStream representing the string after
         * seeking num characters from the current position.
         * @param num
         */
        seek(num) {
            if (this.startpos + num > this.endpos) {
                return new CharStream(this.input, this.endpos, this.endpos, this.hasEOF);
            }
            else {
                return new CharStream(this.input, this.startpos + num, this.endpos, this.hasEOF);
            }
        }
        /**
         * Returns a new CharStream representing the head of the input at
         * the current position.  Throws an exception if the CharStream is
         * empty.
         */
        head() {
            if (!this.isEmpty()) {
                const newHasEOF = this.startpos + 1 == this.endpos && this.hasEOF;
                return new CharStream(this.input, this.startpos, this.startpos + 1, newHasEOF);
            }
            else {
                throw new Error("Cannot get the head of an empty string.");
            }
        }
        /**
         * Returns a new CharStream representing the tail of the input at
         * the current position.  Throws an exception if the CharStream is
         * empty.
         */
        tail() {
            if (!this.isEmpty()) {
                return new CharStream(this.input, this.startpos + 1, this.endpos, this.hasEOF);
            }
            else {
                throw new Error("Cannot get the tail of an empty string.");
            }
        }
        /**
         * Returns true if the input at the current position is empty. Note
         * that a CharStream at the end of the input contains an empty
         * string but that an empty string may not be the end-of-file (i.e.,
         * isEOF is false).
         */
        isEmpty() {
            return this.startpos == this.endpos;
        }
        /**
         * Returns the number of characters remaining at
         * the current position.
         */
        length() {
            return this.endpos - this.startpos;
        }
        /**
         * Returns the substring between start and end at the
         * current position.
         * @param start the start index of the substring, inclusive
         * @param end the end index of the substring, exclusive
         */
        substring(start, end) {
            const start2 = this.startpos + start;
            const end2 = this.startpos + end;
            const newHasEOF = this.endpos == end2 && this.hasEOF;
            return new CharStream(this.input, start2, end2, newHasEOF);
        }
        /**
         * Returns the concatenation of the current CharStream with
         * the given CharStream. Note: returned object does not
         * reuse original input string, and startpos and endpos
         * are reset. If the given CharStream contains EOF, the
         * concatenated CharStream will also contain EOF.
         * @param cs the CharStream to concat to this CharStream
         */
        concat(cs) {
            const s = this.toString() + cs.toString();
            return new CharStream(s, 0, s.length, cs.hasEOF);
        }
        /**
         * Concatenate an array of CharStream objects into a single
         * CharStream object.
         * @param css a CharStream[]
         */
        static concat(css) {
            if (css.length == 0) {
                return new CharStream("", 0, 0, false);
            }
            else {
                let cs = css[0];
                for (let i = 1; i < css.length; i++) {
                    cs = cs.concat(css[i]);
                }
                return cs;
            }
        }
    }
    CharUtil.CharStream = CharStream;
})(CharUtil = exports.CharUtil || (exports.CharUtil = {}));

},{}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var primitives_1 = require("./primitives");
exports.Primitives = primitives_1.Primitives;
var charstream_1 = require("./charstream");
exports.CharUtil = charstream_1.CharUtil;

},{"./charstream":89,"./primitives":91}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const charstream_1 = require("./charstream");
var Primitives;
(function (Primitives) {
    class EOFMark {
        constructor() { }
        static get Instance() {
            return this._instance || (this._instance = new this());
        }
    }
    Primitives.EOFMark = EOFMark;
    Primitives.EOF = EOFMark.Instance;
    /**
     * Represents a successful parse.
     */
    class Success {
        /**
         * Returns an object representing a successful parse.
         * @param istream The remaining string.
         * @param res The result of the parse
         */
        constructor(istream, res) {
            this.tag = "success";
            this.inputstream = istream;
            this.result = res;
        }
    }
    Primitives.Success = Success;
    /**
     * Represents a failed parse.
     */
    class Failure {
        /**
         * Returns an object representing a failed parse.
         * @param istream The string, unmodified, that was given to the parser.
         */
        constructor(istream) {
            this.tag = "failure";
            this.inputstream = istream;
        }
    }
    Primitives.Failure = Failure;
    /**
     * result succeeds without consuming any input, and returns v.
     * @param v The result of the parse.
     */
    function result(v) {
        return (istream) => new Success(istream, v);
    }
    Primitives.result = result;
    /**
     * zero fails without consuming any input.
     */
    function zero() {
        return (istream) => new Failure(istream);
    }
    Primitives.zero = zero;
    /**
     * item successfully consumes the first character if the input
     * string is non-empty, otherwise it fails.
     */
    function item() {
        return (istream) => {
            if (istream.isEmpty()) {
                return new Failure(istream);
            }
            else {
                return new Success(istream.tail(), istream.head());
            }
        };
    }
    Primitives.item = item;
    /**
     * bind is a curried function that takes a parser p and returns
     * a function that takes a parser f which returns the composition
     * of p and f.  If _any_ of the parsers fail, the original inputstream
     * is returned in the Failure object (i.e., bind backtracks).
     * @param p A parser
     */
    function bind(p) {
        return (f) => {
            return (istream) => {
                let r = p(istream);
                switch (r.tag) {
                    case "success":
                        let o = f(r.result)(r.inputstream);
                        switch (o.tag) {
                            case "success": return o;
                            case "failure":
                                // note: backtracks, returning original istream
                                return new Failure(istream);
                        }
                    case "failure": return new Failure(istream);
                }
            };
        };
    }
    Primitives.bind = bind;
    function delay(p) {
        return () => p;
    }
    Primitives.delay = delay;
    /**
     * seq is a curried function that takes a parser p, a parser q,
     * and a function f. It applies p to the input, passing the
     * remaining input stream to q; q is then applied.  The function
     * f takes the result of p and q, as a tuple, and returns
     * a single result.
     * @param p A parser
     */
    // export let seq = function<T,U,V>(p: IParser<T>) {
    //     return (q: IParser<U>) => {
    //         return (f: (e: [T,U]) => V) => {
    //             return bind<T,V>(p)((x) => {
    //                 return bind<U,V>(q)((y) => {
    //                     let tup : [T,U] = [x,y];
    //                     return result<V>(f(tup));
    //                 });
    //             });
    //         }
    //     };
    // }
    function seq(p) {
        return (q) => {
            return (f) => {
                return bind(p)((x) => {
                    return bind(q)((y) => {
                        let tup = [x, y];
                        return result(f(tup));
                    });
                });
            };
        };
    }
    Primitives.seq = seq;
    /**
     * sat takes a predicate and yields a parser that consumes a
     * single character if the character satisfies the predicate,
     * otherwise it fails.
     * @param pred a character predicate
     */
    function sat(pred) {
        let pred2 = (cs) => pred(cs.toString());
        let a = item();
        let b = (x) => {
            if (pred2(x)) {
                return result(x);
            }
            else {
                return zero();
            }
        };
        return bind(a)(b);
    }
    Primitives.sat = sat;
    /**
     * char takes a character and yields a parser that consume
     * that character. The returned parser succeeds if the next
     * character in the input stream is c, otherwise it fails.
     * @param c
     */
    function char(c) {
        if (c.length != 1) {
            throw new Error("char parser takes a string of length 1 (i.e., a char)");
        }
        return sat(x => x == c);
    }
    Primitives.char = char;
    /**
     * letter returns a parser that consumes a single alphabetic
     * character, from a-z, regardless of case.
     */
    function letter() {
        let contains_letter = (x) => {
            let a_letter = /[A-Za-z]/;
            return x.match(a_letter) != undefined;
        };
        return sat(contains_letter);
    }
    Primitives.letter = letter;
    /**
     * digit returns a parser that consumes a single numeric
     * character, from 0-9.  Note that the type of the result
     * is a string, not a number.
     */
    function digit() {
        return sat(x => x == "0"
            || x == "1"
            || x == "2"
            || x == "3"
            || x == "4"
            || x == "5"
            || x == "6"
            || x == "7"
            || x == "8"
            || x == "9");
    }
    Primitives.digit = digit;
    /**
     * upper returns a parser that consumes a single character
     * if that character is uppercase.
     */
    function upper() {
        return (istream) => {
            let o1 = letter()(istream);
            switch (o1.tag) {
                case "success":
                    let o2 = sat(x => x == x.toUpperCase())(o1.result);
                    switch (o2.tag) {
                        case "success":
                            return o1;
                        case "failure":
                            return new Failure(istream);
                    }
                    break;
                case "failure":
                    return o1;
            }
            throw new Error("never happens");
        };
    }
    Primitives.upper = upper;
    /**
     * lower returns a parser that consumes a single character
     * if that character is lowercase.
     */
    function lower() {
        return (istream) => {
            let o1 = letter()(istream);
            switch (o1.tag) {
                case "success":
                    let o2 = sat(x => x == x.toLowerCase())(o1.result);
                    switch (o2.tag) {
                        case "success":
                            return o1;
                        case "failure":
                            return new Failure(istream);
                    }
                    break;
                case "failure":
                    return o1;
            }
            throw new Error("never happens");
        };
    }
    Primitives.lower = lower;
    /**
     * choice specifies an ordered choice between two parsers,
     * p1 and p2. The returned parser will first apply
     * parser p1.  If p1 succeeds, p1's Outcome is returned.
     * If p1 fails, p2 is applied and the Outcome of p2 is returned.
     * Note that the input stream given to p1 and p2 is exactly
     * the same input stream.
     * @param p1 A parser.
     */
    function choice(p1) {
        return (p2) => {
            return (istream) => {
                let o = p1(istream);
                switch (o.tag) {
                    case "success":
                        return o;
                    case "failure":
                        return p2(istream);
                }
            };
        };
    }
    Primitives.choice = choice;
    /**
     * appfun allows the user to apply a function f to
     * the result of a parser p, assuming that p is successful.
     * @param p A parser.  This is the same as the |>>
     * function from FParsec.
     */
    function appfun(p) {
        return (f) => {
            return (istream) => {
                let o = p(istream);
                switch (o.tag) {
                    case "success":
                        return new Success(o.inputstream, f(o.result));
                    case "failure":
                        return o;
                }
            };
        };
    }
    Primitives.appfun = appfun;
    /**
     * many repeatedly applies the parser p until p fails. many always
     * succeeds, even if it matches nothing.  many tries to guard
     * against an infinite loop by raising an exception if p succeeds
     * without changing the parser state.
     * @param p
     */
    function many(p) {
        return (istream) => {
            let istream2 = istream;
            let outputs = [];
            let succeeds = true;
            while (!istream2.isEmpty() && succeeds) {
                let o = p(istream2);
                switch (o.tag) {
                    case "success":
                        if (istream2 == o.inputstream) {
                            throw new Error("Parser loops infinitely.");
                        }
                        istream2 = o.inputstream;
                        outputs.push(o.result);
                        break;
                    case "failure":
                        succeeds = false;
                        break;
                }
            }
            return new Success(istream2, outputs);
        };
    }
    Primitives.many = many;
    /**
     * many1 repeatedly applies the parser p until p fails. many1 must
     * succeed at least once.  many1 tries to guard against an infinite
     * loop by raising an exception if p succeeds without changing the
     * parser state.
     * @param p
     */
    function many1(p) {
        return (istream) => {
            return seq(p)(many(p))(tup => {
                let hd = tup["0"];
                let tl = tup["1"];
                tl.unshift(hd);
                return tl;
            })(istream);
        };
    }
    Primitives.many1 = many1;
    /**
     * str yields a parser for the given string.
     * @param s A string
     */
    // TODO: this should actually be a sequence of parsers constructed
    // from the string s
    function str(s) {
        return (istream) => {
            // escape regex metacharacters
            // (this likely needs work)
            let s2 = s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
            let re = new RegExp("^" + s2);
            if (istream.toString().match(re)) {
                const rem = istream.substring(s.length, istream.length());
                const res = istream.substring(0, s.length);
                return new Success(rem, res);
            }
            else {
                return new Failure(istream);
            }
        };
    }
    Primitives.str = str;
    /**
     * Returns a parser that succeeds only if the end of the
     * input has been reached.
     */
    function eof() {
        return (istream) => {
            if (istream.isEOF()) {
                return new Success(istream, Primitives.EOF);
            }
            else {
                return new Failure(istream);
            }
        };
    }
    Primitives.eof = eof;
    /**
     * fresult returns a parser that applies the parser p,
     * and if p succeeds, returns the value x.
     * @param p a parser
     */
    function fresult(p) {
        return (x) => {
            return (istream) => {
                return bind(p)((t) => result(x))(istream);
            };
        };
    }
    Primitives.fresult = fresult;
    /**
     * left returns a parser that applies the parser p,
     * then the parser q, and if both are successful,
     * returns the result of p.
     * @param p a parser
     */
    function left(p) {
        return (q) => {
            return (istream) => {
                return bind(p)((t) => fresult(q)(t))(istream);
            };
        };
    }
    Primitives.left = left;
    /**
     * right returns a parser that applies the parser p,
     * then the parser q, and if both are successful,
     * returns the result of q.
     * @param p a parser
     */
    function right(p) {
        return (q) => {
            return (istream) => {
                return bind(p)(_ => q)(istream);
            };
        };
    }
    Primitives.right = right;
    /**
     * between returns a parser that applies the parser
     * popen, p, and pclose in sequence, and if all are
     * successful, returns the result of p.
     * @param popen the first parser
     */
    function between(popen) {
        return (pclose) => {
            return (p) => {
                let l = left(p)(pclose);
                let r = right(popen)(l);
                return r;
            };
        };
    }
    Primitives.between = between;
    /**
     * The debug parser takes a parser p and a debug string,
     * printing the debug string as a side-effect before
     * applying p to the input.
     * @param p a parser
     */
    function debug(p) {
        return (label) => {
            return (istream) => {
                console.log("apply: " + label);
                let o = p(istream);
                switch (o.tag) {
                    case "success":
                        console.log("success: " + label + ", startpos: " + istream.startpos + ", endpos: " + istream.endpos);
                        break;
                    case "failure":
                        console.log("failure: " + label + ", startpos: " + istream.startpos + ", endpos: " + istream.endpos);
                        break;
                }
                return o;
            };
        };
    }
    Primitives.debug = debug;
    let wschars = choice(sat(c => c == ' ' || c == '\t'))(nl());
    /**
     * ws matches zero or more of the following whitespace characters:
     * ' ', '\t', '\n', or '\r\n'
     * ws returns matched whitespace in a single CharStream result.
     */
    function ws() {
        return (istream) => {
            let o = many(wschars)(istream);
            switch (o.tag) {
                case "success":
                    return new Success(o.inputstream, charstream_1.CharUtil.CharStream.concat(o.result));
                // ws never fails
            }
        };
    }
    Primitives.ws = ws;
    /**
     * ws1 matches one or more of the following whitespace characters:
     * ' ', '\t', '\n', or '\r\n'
     * ws1 returns matched whitespace in a single CharStream result.
     */
    function ws1() {
        return (istream) => {
            let o = many1(wschars)(istream);
            switch (o.tag) {
                case "success":
                    return new Success(o.inputstream, charstream_1.CharUtil.CharStream.concat(o.result));
                case "failure":
                    return o;
            }
        };
    }
    Primitives.ws1 = ws1;
    /**
     * nl matches and returns a newline.
     */
    function nl() {
        return Primitives.choice(Primitives.str("\n"))(Primitives.str("\r\n"));
    }
    Primitives.nl = nl;
    function groupBy(list, keyGetter) {
        let m = new Map();
        list.forEach((item) => {
            const key = keyGetter(item);
            if (!m.has(key)) {
                m.set(key, []);
            }
            let collection = m.get(key);
            collection.push(item);
        });
        return m;
    }
    function strSat(strs) {
        // sort strings first by length, and then lexicograpically;
        // slice() called here so as not to modify original array
        let smap = groupBy(strs, s => s.length);
        let sizes = [];
        // find size classes;
        // also sort each set of equivalent-length values
        smap.forEach((vals, key, m) => {
            sizes.push(key);
            vals.sort();
        });
        sizes.sort();
        return (istream) => {
            // start with the smallest size class       
            for (let peekIndex = 0; peekIndex < sizes.length; peekIndex++) {
                // for each size class, try matching all of
                // the strings; if one is found, return the
                // appropriate CharStream; if not, fail.
                let peek = istream.peek(sizes[peekIndex]);
                let tail = istream.seek(sizes[peekIndex]);
                let candidates = smap.get(sizes[peekIndex]);
                for (let cIndex = 0; cIndex < candidates.length; cIndex++) {
                    if (candidates[cIndex] === peek.toString()) {
                        return new Success(tail, peek);
                    }
                }
            }
            return new Failure(istream);
        };
    }
    Primitives.strSat = strSat;
})(Primitives = exports.Primitives || (exports.Primitives = {}));

},{"./charstream":89}],92:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
/**
 * Converts an Array-like object (such as an arguments or NodeList instance) to a regular Array
 */
function fromArrayLike(arrayLike) {
    return new lift_1.ArrayOps([].slice.call(arrayLike));
}
exports.fromArrayLike = fromArrayLike;

},{"../lift":97}],93:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
/*
* Returns a number[] wrapper with all numbers from start to stop (inclusive),
* incremented or decremented by step.
*/
function range(start, stop, step) {
    if (arguments.length === 1) {
        stop = arguments[0] - 1;
        start = 0;
    }
    step = step || 1;
    var result = [];
    var increasing = step > 0;
    var next = start;
    while ((increasing && next <= stop) || (!increasing && next >= stop)) {
        result.push(next);
        next = next + step;
    }
    return new lift_1.ArrayOps(result);
}
exports.range = range;

},{"../lift":97}],94:[function(require,module,exports){
"use strict";
exports.__esModule = true;
function tuple(arr) {
    return arr;
}
exports.tuple = tuple;

},{}],95:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var is_1 = require("../object/is");
var currentMemoId = 0;
/**
 * Memoizes a function of arbitrary arity.
 * This has two main uses:
 *   1) Reducing the CPU time taken by expensive calculations at the cost of some memory overhead
 *   2) Producing stable references for a given set of arguments. Useful when relying on reference equality.
 *
 * Memoized functions keep internal state. If you wish to clear that state entirely, you can recreate the function.
 */
function memoize(fun, options) {
    // The unique property name used by this memoize function instance.
    // This is used to store the id/reference of object arguments, as Weak maps/sets are very limited.
    var memoKey = "__memo__" + currentMemoId++;
    var lastArgKeys = [];
    var cacheSize = (options && options.cacheSize) || 30;
    var keyFunction = options && options.key;
    // The unique ids/references of objects inside the arityNCache cache
    var objId = 0;
    var arity0Cache;
    var arityNCache;
    var keyCache;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // 0 arguments edge-case
        if (args.length === 0) {
            if (!arity0Cache)
                arity0Cache = fun();
            return arity0Cache;
        }
        // custom key function
        else if (keyFunction) {
            keyCache = keyCache || {};
            var key = keyFunction.apply(null, args);
            var result = keyCache[key];
            if (!result) {
                lastArgKeys.push(key);
                limitCacheSize(keyCache, lastArgKeys, cacheSize);
                result = keyCache[key] = fun.apply(null, args);
            }
            return result;
        }
        // N arguments
        else {
            arityNCache = arityNCache || {};
            var key = '';
            for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                var argKey = void 0;
                if (is_1.object(arg)) {
                    argKey = arg[memoKey];
                    if (!argKey) {
                        // Non enumerable
                        Object.defineProperty(arg, memoKey, { value: "obj" + objId++ });
                        argKey = arg[memoKey];
                    }
                }
                else {
                    argKey = arg;
                }
                key += (argKey + '_');
            }
            var result = arityNCache[key];
            if (!result) {
                lastArgKeys.push(key);
                limitCacheSize(arityNCache, lastArgKeys, cacheSize);
                result = arityNCache[key] = fun.apply(null, args);
            }
            return result;
        }
    };
}
exports.memoize = memoize;
function limitCacheSize(cache, lastArgKeys, size) {
    if (lastArgKeys.length === size + 1) {
        var key = lastArgKeys.shift();
        delete cache[key];
    }
}

},{"../object/is":98}],96:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("./lift");
exports["default"] = lift_1["default"];
var lift_2 = require("./lift");
exports.ArrayOps = lift_2.ArrayOps;
exports.ObjectOps = lift_2.ObjectOps;
exports.NumberOps = lift_2.NumberOps;
exports.StringOps = lift_2.StringOps;
exports.DateOps = lift_2.DateOps;
exports.getValue = lift_2.getValue;
var immupdate_1 = require("immupdate");
exports.update = immupdate_1.update;
exports.deepUpdate = immupdate_1.deepUpdate;
exports.DELETE = immupdate_1.DELETE;
var option_1 = require("./option");
exports.Option = option_1.Option;
exports.None = option_1.None;
exports.Some = option_1.Some;
var result_1 = require("./result");
exports.Result = result_1.Result;
exports.Ok = result_1.Ok;
exports.Err = result_1.Err;
var range_1 = require("./array/range");
exports.range = range_1.range;
var fromArrayLike_1 = require("./array/fromArrayLike");
exports.fromArrayLike = fromArrayLike_1.fromArrayLike;
var tuple_1 = require("./array/tuple");
exports.tuple = tuple_1.tuple;
var set_1 = require("./object/set");
exports.Set = set_1.Set;
var memoize_1 = require("./function/memoize");
exports.memoize = memoize_1.memoize;
var isType = require("./object/is");
exports.is = isType;

},{"./array/fromArrayLike":92,"./array/range":93,"./array/tuple":94,"./function/memoize":95,"./lift":97,"./object/is":98,"./object/set":99,"./option":100,"./result":101,"immupdate":88}],97:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift = function (obj) {
    if (obj instanceof Array)
        return new exports.ArrayOps(obj);
    if (obj instanceof Date)
        return new exports.DateOps(obj);
    if (typeof obj === 'string')
        return new exports.StringOps(obj);
    if (typeof obj === 'number')
        return new exports.NumberOps(obj);
    return new exports.ObjectOps(obj);
};
exports["default"] = lift;
function getValue(input) {
    return input && input['_isLiftWrapper']
        ? input.value()
        : input;
}
exports.getValue = getValue;
function makeOps() {
    var Ops = /** @class */ (function () {
        function Ops(_value) {
            this._value = _value;
            this._isLiftWrapper = true;
        }
        Ops.prototype.value = function () { return this._value; };
        return Ops;
    }());
    return Ops;
}
exports.ArrayOps = makeOps();
exports.ObjectOps = makeOps();
exports.NumberOps = makeOps();
exports.StringOps = makeOps();
exports.DateOps = makeOps();

},{}],98:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/** Returns whether an object is an Array */
exports.array = Array.isArray;
/** Returns whether this object is a function */
function func(obj) {
    return (typeof obj === 'function');
}
exports.func = func;
/** Returns whether this object is a string */
function string(obj) {
    return (typeof obj === 'string');
}
exports.string = string;
/** Returns whether this object is a number */
function number(obj) {
    return (typeof obj === 'number');
}
exports.number = number;
/** Returns whether this object is a boolean */
function boolean(obj) {
    return (typeof obj === 'boolean');
}
exports.boolean = boolean;
/** Returns whether this value is an object (e.g not a primitive: dates, arrays, functions, objects, regexes, `new Number(0)`, and `new String('')) */
function object(obj) {
    var type = typeof obj;
    return (type == 'object' || type == 'function');
}
exports.object = object;

},{}],99:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
/**
 * Creates a Set-like object (string keys, true values) from a list of keys
 */
function Set() {
    var keys = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        keys[_i] = arguments[_i];
    }
    var result = {};
    keys.forEach(function (key) { return result[key] = true; });
    return new lift_1.ObjectOps(result);
}
exports.Set = Set;

},{"../lift":97}],100:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
// The Option factory / static object
var OptionObject = function (value) {
    return isDef(value) ? Some(value) : exports.None;
};
OptionObject.all = function (arr) {
    var values = [];
    for (var i = 0; i < arr.length; i++) {
        var value = arr[i];
        if (exports.Option.isOption(value))
            value = value.get();
        if (!isDef(value))
            return exports.None;
        values.push(value);
    }
    return Some(values);
};
OptionObject.isOption = function (value) {
    return !!value && (value.type === 'some' || value.type === 'none');
};
function makeNone() {
    var self = {};
    function returnNone() { return exports.None; }
    self.type = 'none';
    self.get = function () { return undefined; };
    self.isDefined = function () { return false; };
    self.forEach = function () { };
    self.map = returnNone;
    self.flatMap = returnNone;
    self.filter = returnNone;
    self.fold = function (ifEmpty) { return ifEmpty(); };
    self.orElse = function (alt) { return alt(); };
    self.getOrElse = function (alt) { return alt; };
    self.toArray = function () { return lift_1["default"]([]); };
    self.toString = function () { return 'None'; };
    self.toJSON = function () { return null; };
    return self;
}
function _Some(value) {
    this.value = value;
}
_Some.prototype = {
    type: 'some',
    get: function () {
        return this.value;
    },
    isDefined: function () {
        return true;
    },
    forEach: function (fn) {
        fn(this.value);
    },
    map: function (fn) {
        return exports.Option(lift_1.getValue(fn(this.value)));
    },
    flatMap: function (fn) {
        return fn(this.value);
    },
    filter: function (fn) {
        return fn(this.value) ? this : exports.None;
    },
    fold: function (ifEmpty, ifDefined) {
        return ifDefined(this.value);
    },
    orElse: function () {
        return this;
    },
    getOrElse: function () {
        return this.value;
    },
    toArray: function () {
        return lift_1["default"]([this.value]);
    },
    toString: function () {
        return "Some(" + this.value + ")";
    },
    toJSON: function () {
        return this.value;
    }
};
function isDef(value) {
    return value !== null && value !== undefined;
}
exports.Option = OptionObject;
/** Creates a new Some instance using a non nullable value */
// extends {} to prevent null and undefined being passed
function Some(value) {
    return new _Some(value);
}
exports.Some = Some;
exports.None = makeNone();

},{"../lift":97}],101:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
var ResultObject = {};
ResultObject.all = function (arr) {
    var okValues = [];
    var currentResult;
    for (var i = 0; i < arr.length; i++) {
        var currentResult_1 = arr[i];
        if (!currentResult_1.isOk())
            return currentResult_1;
        okValues.push(currentResult_1.get());
    }
    return Ok(okValues);
};
ResultObject.isResult = function (value) {
    return !!value && (value.type === 'ok' || value.type === 'err');
};
function _Ok(value) {
    this._value = value;
}
_Ok.prototype = {
    type: 'ok',
    isOk: function () {
        return true;
    },
    map: function (fn) {
        return Ok(lift_1.getValue(fn(this._value)));
    },
    mapError: function (fn) {
        return this;
    },
    flatMap: function (fn) {
        return fn(this._value);
    },
    fold: function (ifErr, ifOk) {
        return ifOk(this._value);
    },
    toString: function () {
        return "Ok(" + this._value + ")";
    },
    get: function () {
        return this._value;
    }
};
function _Err(error) {
    this._error = error;
}
_Err.prototype = {
    type: 'err',
    isOk: function () {
        return false;
    },
    map: function (fn) {
        return this;
    },
    mapError: function (fn) {
        return Err(fn(this._error));
    },
    flatMap: function (fn) {
        return this;
    },
    fold: function (ifErr, ifOk) {
        return ifErr(this._error);
    },
    toString: function () {
        return "Err(" + this._error + ")";
    },
    get: function () {
        return this._error;
    }
};
exports.Result = ResultObject;
function Ok(value) {
    return new _Ok(value);
}
exports.Ok = Ok;
function Err(error) {
    return new _Err(error);
}
exports.Err = Err;

},{"../lift":97}]},{},[83])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImRpc3QvaW5kZXguanMiLCJkaXN0L2xpYi9iaW5vcHMvQXNzaWduT3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvQmluYXJ5T3BlcmF0aW9uLmpzIiwiZGlzdC9saWIvYmlub3BzL0RlY2xhcmVPcC5qcyIsImRpc3QvbGliL2Jpbm9wcy9EZWNyZW1lbnQuanMiLCJkaXN0L2xpYi9iaW5vcHMvRGl2T3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvSW5jcmVtZW50LmpzIiwiZGlzdC9saWIvYmlub3BzL01pbnVzT3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvTXVsT3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvUGx1c09wLmpzIiwiZGlzdC9saWIvY29uZGl0aW9uYWxzL0NvbmRpdGlvbmFsLmpzIiwiZGlzdC9saWIvZWZmZWN0cy9DdXJ2ZUVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvRWxsaXBzZUVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvRW1vamlFZmZlY3QuanMiLCJkaXN0L2xpYi9lZmZlY3RzL0VwaEVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvTGluZUVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvTnVtYmVyRWZmZWN0LmpzIiwiZGlzdC9saWIvZWZmZWN0cy9SZWN0YW5nbGVFZmZlY3QuanMiLCJkaXN0L2xpYi9lZmZlY3RzL1N0cmluZ0VmZmVjdC5qcyIsImRpc3QvbGliL2Z1bmhvdXNlL0Z1bkFwcC5qcyIsImRpc3QvbGliL2Z1bmhvdXNlL0Z1bkRlZi5qcyIsImRpc3QvbGliL2xpc3RzL0xpc3ROb2RlLmpzIiwiZGlzdC9saWIvbG9nZ2luZy9DbGVhckV2ZW50LmpzIiwiZGlzdC9saWIvbG9nZ2luZy9DbGlja0V2ZW50LmpzIiwiZGlzdC9saWIvbG9nZ2luZy9EcmFnRXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL0lERXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL0xvZ0V2ZW50LmpzIiwiZGlzdC9saWIvbG9nZ2luZy9QYWludEV2ZW50LmpzIiwiZGlzdC9saWIvbG9nZ2luZy9SZXNpemVFdmVudC5qcyIsImRpc3QvbGliL2xvZ2dpbmcvU2VsZWN0RXZlbnQuanMiLCJkaXN0L2xpYi9sb2dpYy9BbmQuanMiLCJkaXN0L2xpYi9sb2dpYy9FcXVhbHMuanMiLCJkaXN0L2xpYi9sb2dpYy9HcmVhdGVyVGhhbi5qcyIsImRpc3QvbGliL2xvZ2ljL0dyZWF0ZXJUaGFuRXEuanMiLCJkaXN0L2xpYi9sb2dpYy9MZXNzVGhhbi5qcyIsImRpc3QvbGliL2xvZ2ljL0xlc3NUaGFuRXEuanMiLCJkaXN0L2xpYi9sb2dpYy9Ob3QuanMiLCJkaXN0L2xpYi9sb2dpYy9Ob3RFcXVhbC5qcyIsImRpc3QvbGliL2xvZ2ljL09yLmpzIiwiZGlzdC9saWIvbG9vcHMvRm9yTm9kZS5qcyIsImRpc3QvbGliL2xvb3BzL1JlcGVhdE5vZGUuanMiLCJkaXN0L2xpYi9sb29wcy9XaGlsZU5vZGUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0luc3RydWN0aW9uLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Gb3VyQ3BPbmUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvbkZvdXJDcFR3by5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uT25lQ3BGb3VyLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25PbmVDcE9uZS5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uT25lQ3BUaHJlZS5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uT25lQ3BUd28uanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BGaXZlLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25UaHJlZUNwRm91ci5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcE9uZS5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFNpeC5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFRocmVlLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25UaHJlZUNwVHdvLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Ud29DcEZpdmUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwRm91ci5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVHdvQ3BPbmUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwU2V2ZW4uanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwU2l4LmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFRocmVlLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFR3by5qcyIsImRpc3QvbGliL21vZHVsZXMvTW9kdWxlLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9Nb2R1bGVHZW5lcmF0b3IuanMiLCJkaXN0L2xpYi9wYXJzZXIvcGFyc2VyLmpzIiwiZGlzdC9saWIvcHJpbXMvQm9vbGVhbk5vZGUuanMiLCJkaXN0L2xpYi9wcmltcy9OT1AuanMiLCJkaXN0L2xpYi9wcmltcy9OdW1iZXJOb2RlLmpzIiwiZGlzdC9saWIvcHJpbXMvU3RyaW5nTm9kZS5qcyIsImRpc3QvbGliL3NoYXBlcy9Db2xvck5vZGUuanMiLCJkaXN0L2xpYi9zaGFwZXMvQ3VydmVOb2RlLmpzIiwiZGlzdC9saWIvc2hhcGVzL0VsbGlwc2VOb2RlLmpzIiwiZGlzdC9saWIvc2hhcGVzL0Vtb2ppTm9kZS5qcyIsImRpc3QvbGliL3NoYXBlcy9FcGhOb2RlLmpzIiwiZGlzdC9saWIvc2hhcGVzL0xpbmVOb2RlLmpzIiwiZGlzdC9saWIvc2hhcGVzL1JlY3RhbmdsZU5vZGUuanMiLCJkaXN0L2xpYi9zdHJ1Y3R1cmFsL0RpbWVuc2lvbnMuanMiLCJkaXN0L2xpYi9zdHJ1Y3R1cmFsL1ByaW50Tm9kZS5qcyIsImRpc3QvbGliL3N0cnVjdHVyYWwvUmV0dXJuLmpzIiwiZGlzdC9saWIvc3RydWN0dXJhbC9SZXR1cm5FcnJvci5qcyIsImRpc3QvbGliL3N0cnVjdHVyYWwvU2NvcGUuanMiLCJkaXN0L2xpYi9zdHJ1Y3R1cmFsL1NlcXVlbmNlTm9kZS5qcyIsImRpc3QvbGliL3VpL3VpLmpzIiwiZGlzdC9saWIvdW5vcHMvTmVnT3AuanMiLCJkaXN0L2xpYi91bm9wcy9VbmFyeU9wZXJhdGlvbi5qcyIsImRpc3QvbGliL3ZhcnMvVmFyaWFibGVOb2RlLmpzIiwibm9kZV9tb2R1bGVzL3NyYy9jb252ZXJ0L3htbC5qcyIsIm5vZGVfbW9kdWxlcy9pbW11cGRhdGUvY29tbW9uanMvaW1tdXBkYXRlLmpzIiwibm9kZV9tb2R1bGVzL3BhbnRzL2xpYi9jaGFyc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3BhbnRzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYW50cy9saWIvcHJpbWl0aXZlcy5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL2FycmF5L2Zyb21BcnJheUxpa2UuanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9hcnJheS9yYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL2FycmF5L3R1cGxlLmpzIiwibm9kZV9tb2R1bGVzL3NwYWNlLWxpZnQvY29tbW9uanMvZnVuY3Rpb24vbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NwYWNlLWxpZnQvY29tbW9uanMvbGlmdC5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL29iamVjdC9pcy5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL29iamVjdC9zZXQuanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9vcHRpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9yZXN1bHQvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2d0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3NCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3B3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2prQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3NCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0NDM0RnQixtQixHQUFBLG1CO0FBQVQsU0FBUyxtQkFBVCxDQUE2QixPQUE3QixFQUFzQztBQUMzQyxNQUFJLE1BQU0sRUFBVjtBQUNBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxRQUFRLE1BQTVCLEVBQW9DLEdBQXBDLEVBQXlDO0FBQ3ZDLFFBQUksU0FBUyxRQUFRLENBQVIsQ0FBYjtBQUNBLFFBQUksT0FBTyxLQUFYLEVBQWtCO0FBQ2hCLFVBQUksSUFBSixDQUFTLE9BQVQ7QUFDRCxLQUZELE1BRU8sSUFBSSxPQUFPLE9BQVgsRUFBb0I7QUFDekIsVUFBSSxJQUFKLENBQVMsT0FBVDtBQUNEOztBQUVELFFBQUksSUFBSixDQUFTLFdBQVcsT0FBTyxLQUFsQixDQUFUOztBQUVBLFFBQUksT0FBTyxLQUFYLEVBQWtCO0FBQ2hCLFVBQUksSUFBSixDQUFTLFFBQVQ7QUFDRCxLQUZELE1BRU8sSUFBSSxPQUFPLE9BQVgsRUFBb0I7QUFDekIsVUFBSSxJQUFKLENBQVMsUUFBVDtBQUNEO0FBQ0Y7QUFDRCxTQUFPLElBQUksSUFBSixDQUFTLEVBQVQsQ0FBUDtBQUNEOztBQUVELFNBQVMsVUFBVCxDQUFvQixDQUFwQixFQUF1QjtBQUNyQixNQUFJLElBQUksQ0FBUjtBQUNBLE1BQUksRUFBRSxPQUFGLENBQVUsSUFBVixFQUFnQixPQUFoQixDQUFKO0FBQ0EsTUFBSSxFQUFFLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLE1BQWhCLENBQUo7QUFDQSxNQUFJLEVBQUUsT0FBRixDQUFVLElBQVYsRUFBZ0IsTUFBaEIsQ0FBSjtBQUNBLE1BQUksRUFBRSxPQUFGLENBQVUsSUFBVixFQUFnQixRQUFoQixDQUFKOztBQUVBLFNBQU8sQ0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9oQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU2NvcGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zdHJ1Y3R1cmFsL1Njb3BlXCIpO1xuZXhwb3J0cy5TY29wZSA9IFNjb3BlXzEuU2NvcGU7XG4vKiBCSU5BUlkgT1BTICovXG52YXIgQXNzaWduT3BfMSA9IHJlcXVpcmUoXCIuL2xpYi9iaW5vcHMvQXNzaWduT3BcIik7XG5leHBvcnRzLkFzc2lnbk9wID0gQXNzaWduT3BfMS5Bc3NpZ25PcDtcbnZhciBCaW5hcnlPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL2xpYi9iaW5vcHMvQmluYXJ5T3BlcmF0aW9uXCIpO1xuZXhwb3J0cy5CaW5hcnlPcGVyYXRpb24gPSBCaW5hcnlPcGVyYXRpb25fMS5CaW5hcnlPcGVyYXRpb247XG52YXIgRGl2T3BfMSA9IHJlcXVpcmUoXCIuL2xpYi9iaW5vcHMvRGl2T3BcIik7XG5leHBvcnRzLkRpdk9wID0gRGl2T3BfMS5EaXZPcDtcbnZhciBNaW51c09wXzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL01pbnVzT3BcIik7XG5leHBvcnRzLk1pbnVzT3AgPSBNaW51c09wXzEuTWludXNPcDtcbnZhciBNdWxPcF8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9NdWxPcFwiKTtcbmV4cG9ydHMuTXVsT3AgPSBNdWxPcF8xLk11bE9wO1xudmFyIFBsdXNPcF8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9QbHVzT3BcIik7XG5leHBvcnRzLlBsdXNPcCA9IFBsdXNPcF8xLlBsdXNPcDtcbnZhciBHcmVhdGVyVGhhbl8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2ljL0dyZWF0ZXJUaGFuXCIpO1xuZXhwb3J0cy5HcmVhdGVyVGhhbiA9IEdyZWF0ZXJUaGFuXzEuR3JlYXRlclRoYW47XG52YXIgR3JlYXRlclRoYW5FcV8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2ljL0dyZWF0ZXJUaGFuRXFcIik7XG5leHBvcnRzLkdyZWF0ZXJUaGFuRXEgPSBHcmVhdGVyVGhhbkVxXzEuR3JlYXRlclRoYW5FcTtcbnZhciBMZXNzVGhhbl8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2ljL0xlc3NUaGFuXCIpO1xuZXhwb3J0cy5MZXNzVGhhbiA9IExlc3NUaGFuXzEuTGVzc1RoYW47XG52YXIgTGVzc1RoYW5FcV8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2ljL0xlc3NUaGFuRXFcIik7XG5leHBvcnRzLkxlc3NUaGFuRXEgPSBMZXNzVGhhbkVxXzEuTGVzc1RoYW5FcTtcbnZhciBEZWNsYXJlT3BfMSA9IHJlcXVpcmUoXCIuL2xpYi9iaW5vcHMvRGVjbGFyZU9wXCIpO1xuZXhwb3J0cy5EZWNsYXJlT3AgPSBEZWNsYXJlT3BfMS5EZWNsYXJlT3A7XG52YXIgQW5kXzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvQW5kXCIpO1xuZXhwb3J0cy5BbmQgPSBBbmRfMS5BbmQ7XG52YXIgT3JfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9PclwiKTtcbmV4cG9ydHMuT3IgPSBPcl8xLk9yO1xudmFyIEVxdWFsc18xID0gcmVxdWlyZShcIi4vbGliL2xvZ2ljL0VxdWFsc1wiKTtcbmV4cG9ydHMuRXF1YWxzID0gRXF1YWxzXzEuRXF1YWxzO1xudmFyIE5vdEVxdWFsXzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvTm90RXF1YWxcIik7XG5leHBvcnRzLk5vdEVxdWFsID0gTm90RXF1YWxfMS5Ob3RFcXVhbDtcbnZhciBJbmNyZW1lbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9iaW5vcHMvSW5jcmVtZW50XCIpO1xuZXhwb3J0cy5JbmNyZW1lbnQgPSBJbmNyZW1lbnRfMS5JbmNyZW1lbnQ7XG52YXIgRGVjcmVtZW50XzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL0RlY3JlbWVudFwiKTtcbmV4cG9ydHMuRGVjcmVtZW50ID0gRGVjcmVtZW50XzEuRGVjcmVtZW50O1xuLyogVU5BUlkgT1BTICovXG52YXIgVW5hcnlPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL2xpYi91bm9wcy9VbmFyeU9wZXJhdGlvblwiKTtcbmV4cG9ydHMuVW5hcnlPcGVyYXRpb24gPSBVbmFyeU9wZXJhdGlvbl8xLlVuYXJ5T3BlcmF0aW9uO1xudmFyIE5lZ09wXzEgPSByZXF1aXJlKFwiLi9saWIvdW5vcHMvTmVnT3BcIik7XG5leHBvcnRzLk5lZ09wID0gTmVnT3BfMS5OZWdPcDtcbnZhciBOb3RfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9Ob3RcIik7XG5leHBvcnRzLk5vdCA9IE5vdF8xLk5vdDtcbi8qIERBVEEgVFlQRVMgKi9cbnZhciBMaXN0Tm9kZV8xID0gcmVxdWlyZShcIi4vbGliL2xpc3RzL0xpc3ROb2RlXCIpO1xuZXhwb3J0cy5MaXN0Tm9kZSA9IExpc3ROb2RlXzEuTGlzdE5vZGU7XG52YXIgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3ByaW1zL051bWJlck5vZGVcIik7XG5leHBvcnRzLk51bWJlck5vZGUgPSBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZTtcbnZhciBTdHJpbmdOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvcHJpbXMvU3RyaW5nTm9kZVwiKTtcbmV4cG9ydHMuU3RyaW5nTm9kZSA9IFN0cmluZ05vZGVfMS5TdHJpbmdOb2RlO1xudmFyIEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi9saWIvcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5leHBvcnRzLkJvb2xlYW5Ob2RlID0gQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZTtcbnZhciBOT1BfMSA9IHJlcXVpcmUoXCIuL2xpYi9wcmltcy9OT1BcIik7XG5leHBvcnRzLk5PUCA9IE5PUF8xLk5PUDtcbi8qIFZBUklBQkxFUyAqL1xudmFyIFZhcmlhYmxlTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3ZhcnMvVmFyaWFibGVOb2RlXCIpO1xuZXhwb3J0cy5WYXJpYWJsZU5vZGUgPSBWYXJpYWJsZU5vZGVfMS5WYXJpYWJsZU5vZGU7XG4vKiBDT05UUk9MIENPTlNUUlVDVFMgKi9cbnZhciBDb25kaXRpb25hbF8xID0gcmVxdWlyZShcIi4vbGliL2NvbmRpdGlvbmFscy9Db25kaXRpb25hbFwiKTtcbmV4cG9ydHMuQ29uZGl0aW9uYWwgPSBDb25kaXRpb25hbF8xLkNvbmRpdGlvbmFsO1xudmFyIEZ1bkFwcF8xID0gcmVxdWlyZShcIi4vbGliL2Z1bmhvdXNlL0Z1bkFwcFwiKTtcbmV4cG9ydHMuRnVuQXBwID0gRnVuQXBwXzEuRnVuQXBwO1xudmFyIEZ1bkRlZl8xID0gcmVxdWlyZShcIi4vbGliL2Z1bmhvdXNlL0Z1bkRlZlwiKTtcbmV4cG9ydHMuRnVuRGVmID0gRnVuRGVmXzEuRnVuRGVmO1xudmFyIFNlcXVlbmNlTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3N0cnVjdHVyYWwvU2VxdWVuY2VOb2RlXCIpO1xuZXhwb3J0cy5TZXF1ZW5jZU5vZGUgPSBTZXF1ZW5jZU5vZGVfMS5TZXF1ZW5jZU5vZGU7XG52YXIgUmVwZWF0Tm9kZV8xID0gcmVxdWlyZShcIi4vbGliL2xvb3BzL1JlcGVhdE5vZGVcIik7XG5leHBvcnRzLlJlcGVhdE5vZGUgPSBSZXBlYXROb2RlXzEuUmVwZWF0Tm9kZTtcbnZhciBXaGlsZU5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb29wcy9XaGlsZU5vZGVcIik7XG5leHBvcnRzLldoaWxlTm9kZSA9IFdoaWxlTm9kZV8xLldoaWxlTm9kZTtcbnZhciBGb3JOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvbG9vcHMvRm9yTm9kZVwiKTtcbmV4cG9ydHMuRm9yTm9kZSA9IEZvck5vZGVfMS5Gb3JOb2RlO1xuLyogQlVJTFRJTiBGVU5DVElPTlMgKi9cbnZhciBDb2xvck5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zaGFwZXMvQ29sb3JOb2RlXCIpO1xuZXhwb3J0cy5Db2xvck5vZGUgPSBDb2xvck5vZGVfMS5Db2xvck5vZGU7XG52YXIgRWxsaXBzZU5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zaGFwZXMvRWxsaXBzZU5vZGVcIik7XG5leHBvcnRzLkVsbGlwc2VOb2RlID0gRWxsaXBzZU5vZGVfMS5FbGxpcHNlTm9kZTtcbnZhciBSZWN0YW5nbGVOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvc2hhcGVzL1JlY3RhbmdsZU5vZGVcIik7XG5leHBvcnRzLlJlY3RhbmdsZU5vZGUgPSBSZWN0YW5nbGVOb2RlXzEuUmVjdGFuZ2xlTm9kZTtcbnZhciBMaW5lTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3NoYXBlcy9MaW5lTm9kZVwiKTtcbmV4cG9ydHMuTGluZU5vZGUgPSBMaW5lTm9kZV8xLkxpbmVOb2RlO1xudmFyIEN1cnZlTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3NoYXBlcy9DdXJ2ZU5vZGVcIik7XG5leHBvcnRzLkN1cnZlTm9kZSA9IEN1cnZlTm9kZV8xLkN1cnZlTm9kZTtcbnZhciBFcGhOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvc2hhcGVzL0VwaE5vZGVcIik7XG5leHBvcnRzLkVwaE5vZGUgPSBFcGhOb2RlXzEuRXBoTm9kZTtcbnZhciBFbW9qaU5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zaGFwZXMvRW1vamlOb2RlXCIpO1xuZXhwb3J0cy5FbW9qaU5vZGUgPSBFbW9qaU5vZGVfMS5FbW9qaU5vZGU7XG52YXIgUHJpbnROb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvc3RydWN0dXJhbC9QcmludE5vZGVcIik7XG5leHBvcnRzLlByaW50Tm9kZSA9IFByaW50Tm9kZV8xLlByaW50Tm9kZTtcbnZhciBSZXR1cm5fMSA9IHJlcXVpcmUoXCIuL2xpYi9zdHJ1Y3R1cmFsL1JldHVyblwiKTtcbmV4cG9ydHMuUmV0dXJuID0gUmV0dXJuXzEuUmV0dXJuO1xudmFyIFJldHVybkVycm9yXzEgPSByZXF1aXJlKFwiLi9saWIvc3RydWN0dXJhbC9SZXR1cm5FcnJvclwiKTtcbmV4cG9ydHMuUmV0dXJuRXJyb3IgPSBSZXR1cm5FcnJvcl8xLlJldHVybkVycm9yO1xudmFyIEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuL2xpYi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5leHBvcnRzLkVsbGlwc2VFZmZlY3QgPSBFbGxpcHNlRWZmZWN0XzEuRWxsaXBzZUVmZmVjdDtcbnZhciBOdW1iZXJFZmZlY3RfMSA9IHJlcXVpcmUoXCIuL2xpYi9lZmZlY3RzL051bWJlckVmZmVjdFwiKTtcbmV4cG9ydHMuTnVtYmVyRWZmZWN0ID0gTnVtYmVyRWZmZWN0XzEuTnVtYmVyRWZmZWN0O1xudmFyIFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4vbGliL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuZXhwb3J0cy5TdHJpbmdFZmZlY3QgPSBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3Q7XG52YXIgRGltZW5zaW9uc18xID0gcmVxdWlyZShcIi4vbGliL3N0cnVjdHVyYWwvRGltZW5zaW9uc1wiKTtcbmV4cG9ydHMuRGltZW5zaW9ucyA9IERpbWVuc2lvbnNfMS5EaW1lbnNpb25zO1xudmFyIFJlY3RhbmdsZUVmZmVjdF8xID0gcmVxdWlyZShcIi4vbGliL2VmZmVjdHMvUmVjdGFuZ2xlRWZmZWN0XCIpO1xuZXhwb3J0cy5SZWN0YW5nbGVFZmZlY3QgPSBSZWN0YW5nbGVFZmZlY3RfMS5SZWN0YW5nbGVFZmZlY3Q7XG52YXIgTGluZUVmZmVjdF8xID0gcmVxdWlyZShcIi4vbGliL2VmZmVjdHMvTGluZUVmZmVjdFwiKTtcbmV4cG9ydHMuTGluZUVmZmVjdCA9IExpbmVFZmZlY3RfMS5MaW5lRWZmZWN0O1xudmFyIEN1cnZlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi9saWIvZWZmZWN0cy9DdXJ2ZUVmZmVjdFwiKTtcbmV4cG9ydHMuQ3VydmVFZmZlY3QgPSBDdXJ2ZUVmZmVjdF8xLkN1cnZlRWZmZWN0O1xudmFyIEVwaEVmZmVjdF8xID0gcmVxdWlyZShcIi4vbGliL2VmZmVjdHMvRXBoRWZmZWN0XCIpO1xuZXhwb3J0cy5FcGhFZmZlY3QgPSBFcGhFZmZlY3RfMS5FcGhFZmZlY3Q7XG52YXIgRW1vamlFZmZlY3RfMSA9IHJlcXVpcmUoXCIuL2xpYi9lZmZlY3RzL0Vtb2ppRWZmZWN0XCIpO1xuZXhwb3J0cy5FbW9qaUVmZmVjdCA9IEVtb2ppRWZmZWN0XzEuRW1vamlFZmZlY3Q7XG4vKiBFVkVOVFMgKi9cbnZhciBMb2dFdmVudF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2dpbmcvTG9nRXZlbnRcIik7XG5leHBvcnRzLkxvZ0V2ZW50ID0gTG9nRXZlbnRfMS5Mb2dFdmVudDtcbnZhciBDbGVhckV2ZW50XzEgPSByZXF1aXJlKFwiLi9saWIvbG9nZ2luZy9DbGVhckV2ZW50XCIpO1xuZXhwb3J0cy5DbGVhckV2ZW50ID0gQ2xlYXJFdmVudF8xLkNsZWFyRXZlbnQ7XG52YXIgRHJhZ0V2ZW50XzEgPSByZXF1aXJlKFwiLi9saWIvbG9nZ2luZy9EcmFnRXZlbnRcIik7XG5leHBvcnRzLkRyYWdFdmVudCA9IERyYWdFdmVudF8xLkRyYWdFdmVudDtcbnZhciBQYWludEV2ZW50XzEgPSByZXF1aXJlKFwiLi9saWIvbG9nZ2luZy9QYWludEV2ZW50XCIpO1xuZXhwb3J0cy5QYWludEV2ZW50ID0gUGFpbnRFdmVudF8xLlBhaW50RXZlbnQ7XG52YXIgUmVzaXplRXZlbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dnaW5nL1Jlc2l6ZUV2ZW50XCIpO1xuZXhwb3J0cy5SZXNpemVFdmVudCA9IFJlc2l6ZUV2ZW50XzEuUmVzaXplRXZlbnQ7XG52YXIgU2VsZWN0RXZlbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dnaW5nL1NlbGVjdEV2ZW50XCIpO1xuZXhwb3J0cy5TZWxlY3RFdmVudCA9IFNlbGVjdEV2ZW50XzEuU2VsZWN0RXZlbnQ7XG52YXIgSURFdmVudF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2dpbmcvSURFdmVudFwiKTtcbmV4cG9ydHMuSURFdmVudCA9IElERXZlbnRfMS5JREV2ZW50O1xuLyogTU9EVUxFUyAqL1xudmFyIE1vZHVsZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTW9kdWxlXCIpO1xuZXhwb3J0cy5Nb2R1bGUgPSBNb2R1bGVfMS5Nb2R1bGU7XG52YXIgTW9kdWxlR2VuZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9Nb2R1bGVHZW5lcmF0b3JcIik7XG5leHBvcnRzLk1vZHVsZUdlbmVyYXRvciA9IE1vZHVsZUdlbmVyYXRvcl8xLk1vZHVsZUdlbmVyYXRvcjtcbnZhciBMZXNzb25PbmVDcE9uZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uT25lQ3BPbmVcIik7XG5leHBvcnRzLkxlc3Nvbk9uZUNwT25lID0gTGVzc29uT25lQ3BPbmVfMS5MZXNzb25PbmVDcE9uZTtcbnZhciBMZXNzb25PbmVDcFR3b18xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uT25lQ3BUd29cIik7XG5leHBvcnRzLkxlc3Nvbk9uZUNwVHdvID0gTGVzc29uT25lQ3BUd29fMS5MZXNzb25PbmVDcFR3bztcbnZhciBMZXNzb25PbmVDcFRocmVlXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25PbmVDcFRocmVlXCIpO1xuZXhwb3J0cy5MZXNzb25PbmVDcFRocmVlID0gTGVzc29uT25lQ3BUaHJlZV8xLkxlc3Nvbk9uZUNwVGhyZWU7XG52YXIgTGVzc29uT25lQ3BGb3VyXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25PbmVDcEZvdXJcIik7XG5leHBvcnRzLkxlc3Nvbk9uZUNwRm91ciA9IExlc3Nvbk9uZUNwRm91cl8xLkxlc3Nvbk9uZUNwRm91cjtcbnZhciBMZXNzb25Ud29DcE9uZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVHdvQ3BPbmVcIik7XG5leHBvcnRzLkxlc3NvblR3b0NwT25lID0gTGVzc29uVHdvQ3BPbmVfMS5MZXNzb25Ud29DcE9uZTtcbnZhciBMZXNzb25Ud29DcFR3b18xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVHdvQ3BUd29cIik7XG5leHBvcnRzLkxlc3NvblR3b0NwVHdvID0gTGVzc29uVHdvQ3BUd29fMS5MZXNzb25Ud29DcFR3bztcbnZhciBMZXNzb25Ud29DcFRocmVlXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFRocmVlXCIpO1xuZXhwb3J0cy5MZXNzb25Ud29DcFRocmVlID0gTGVzc29uVHdvQ3BUaHJlZV8xLkxlc3NvblR3b0NwVGhyZWU7XG52YXIgTGVzc29uVHdvQ3BGb3VyXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Ud29DcEZvdXJcIik7XG5leHBvcnRzLkxlc3NvblR3b0NwRm91ciA9IExlc3NvblR3b0NwRm91cl8xLkxlc3NvblR3b0NwRm91cjtcbnZhciBMZXNzb25Ud29DcEZpdmVfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwRml2ZVwiKTtcbmV4cG9ydHMuTGVzc29uVHdvQ3BGaXZlID0gTGVzc29uVHdvQ3BGaXZlXzEuTGVzc29uVHdvQ3BGaXZlO1xudmFyIExlc3NvblR3b0NwU2l4XzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFNpeFwiKTtcbmV4cG9ydHMuTGVzc29uVHdvQ3BTaXggPSBMZXNzb25Ud29DcFNpeF8xLkxlc3NvblR3b0NwU2l4O1xudmFyIExlc3NvblR3b0NwU2V2ZW5fMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwU2V2ZW5cIik7XG5leHBvcnRzLkxlc3NvblR3b0NwU2V2ZW4gPSBMZXNzb25Ud29DcFNldmVuXzEuTGVzc29uVHdvQ3BTZXZlbjtcbnZhciBMZXNzb25UaHJlZUNwT25lXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25UaHJlZUNwT25lXCIpO1xuZXhwb3J0cy5MZXNzb25UaHJlZUNwT25lID0gTGVzc29uVGhyZWVDcE9uZV8xLkxlc3NvblRocmVlQ3BPbmU7XG52YXIgTGVzc29uVGhyZWVDcFR3b18xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFR3b1wiKTtcbmV4cG9ydHMuTGVzc29uVGhyZWVDcFR3byA9IExlc3NvblRocmVlQ3BUd29fMS5MZXNzb25UaHJlZUNwVHdvO1xudmFyIExlc3NvblRocmVlQ3BUaHJlZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFRocmVlXCIpO1xuZXhwb3J0cy5MZXNzb25UaHJlZUNwVGhyZWUgPSBMZXNzb25UaHJlZUNwVGhyZWVfMS5MZXNzb25UaHJlZUNwVGhyZWU7XG52YXIgTGVzc29uVGhyZWVDcEZvdXJfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BGb3VyXCIpO1xuZXhwb3J0cy5MZXNzb25UaHJlZUNwRm91ciA9IExlc3NvblRocmVlQ3BGb3VyXzEuTGVzc29uVGhyZWVDcEZvdXI7XG52YXIgTGVzc29uVGhyZWVDcEZpdmVfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BGaXZlXCIpO1xuZXhwb3J0cy5MZXNzb25UaHJlZUNwRml2ZSA9IExlc3NvblRocmVlQ3BGaXZlXzEuTGVzc29uVGhyZWVDcEZpdmU7XG52YXIgTGVzc29uVGhyZWVDcFNpeF8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFNpeFwiKTtcbmV4cG9ydHMuTGVzc29uVGhyZWVDcFNpeCA9IExlc3NvblRocmVlQ3BTaXhfMS5MZXNzb25UaHJlZUNwU2l4O1xudmFyIExlc3NvbkZvdXJDcE9uZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uRm91ckNwT25lXCIpO1xuZXhwb3J0cy5MZXNzb25Gb3VyQ3BPbmUgPSBMZXNzb25Gb3VyQ3BPbmVfMS5MZXNzb25Gb3VyQ3BPbmU7XG52YXIgTGVzc29uRm91ckNwVHdvXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Gb3VyQ3BUd29cIik7XG5leHBvcnRzLkxlc3NvbkZvdXJDcFR3byA9IExlc3NvbkZvdXJDcFR3b18xLkxlc3NvbkZvdXJDcFR3bztcbi8qIFBBUlNFUiAqL1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4vbGliL3BhcnNlci9wYXJzZXJcIik7XG5leHBvcnRzLlBhcnNlciA9IHBhcnNlcl8xLlBhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmluYXJ5T3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9CaW5hcnlPcGVyYXRpb25cIik7XG5jb25zdCBWYXJpYWJsZU5vZGVfMSA9IHJlcXVpcmUoXCIuLi92YXJzL1ZhcmlhYmxlTm9kZVwiKTtcbi8vIGxlZnQgc2lkZSBpcyB2YXJpYWJsZSwgcmlnaHQgc2lkZSBpcyB2YWxcbi8vIFJlYXNzaWduIG5ldyB2YWx1ZSB0byB2YXJcbmNsYXNzIEFzc2lnbk9wIGV4dGVuZHMgQmluYXJ5T3BlcmF0aW9uXzEuQmluYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYW4gYXNzaWdubWVudCBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbGVmdCBzaWRlIG9mIHRoZSBhc3NpZ25tZW50ICh0aGUgdmFyKVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgYXNzaWdubWVudCAodGhlIHZhbHVlKVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICBzdXBlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmICghKGxlZnQgaW5zdGFuY2VvZiBWYXJpYWJsZU5vZGVfMS5WYXJpYWJsZU5vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGFzc2lnbm1lbnQgbXVzdCBiZSBhIHZhcmlhYmxlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIGFzc2lnbiBvcCBieSBhc3NpZ25pbmcgdmFsdWUgdG8gdmFyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0IGluc3RhbmNlb2YgVmFyaWFibGVOb2RlXzEuVmFyaWFibGVOb2RlKSB7XG4gICAgICAgICAgICBsZXQgciA9IHRoaXMucmlnaHQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnRleHQuYXNzaWduKHRoaXMubGVmdC5uYW1lLCByKTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhBTFAgKGluIEFzc2lnbk9wKVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQXNzaWduT3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5sZWZ0LnRvU3RyaW5nKCkgKyAnID0gJyArIHRoaXMucmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzaWduT3BzIGNhbid0IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW4ndCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gQXNzaWduT3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGJpbmFyeSBvcGVyYXRpb25zXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzaWduT3AgPSBBc3NpZ25PcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzc2lnbk9wLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQmluYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIEJpbk9wIGFic3RyYWN0IGNsYXNzXG4gICAgICogQHBhcmFtIF9sZWZ0IFRoZSBsZWZ0IHNpZGUgb2YgdGhlIGJpbmFyeSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gX3JpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBiaW5hcnkgb3BlcmF0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX2xlZnQsIF9yaWdodCkge1xuICAgICAgICB0aGlzLl9sZWZ0ID0gX2xlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gX3JpZ2h0O1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYmluYXJ5IG9wZXJhdGlvbiwgaWYgYXBwbGljYWJsZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIGFzdCBUaGUgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHsgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBlcXVhbCB0byBhbm90aGVyIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBCaW5PcFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmluYXJ5IG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gXCJcIjsgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZXRzIGxlZnQgc2lkZSBvZiB0aGUgYmluYXJ5IG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBsZWZ0IHNpZGUgb2YgdGhlIGJpbmFyeSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBzZXQgbGVmdChsZWZ0KSB7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHJpZ2h0IHNpZGUgb2YgdGhlIGJpbmFyeSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyByaWdodCBzaWRlIG9mIHRoZSBiaW5hcnkgb3BlcmF0aW9uXG4gICAgICovXG4gICAgc2V0IHJpZ2h0KHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkJpbmFyeU9wZXJhdGlvbiA9IEJpbmFyeU9wZXJhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpbmFyeU9wZXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJpbmFyeU9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vQmluYXJ5T3BlcmF0aW9uXCIpO1xuY29uc3QgVmFyaWFibGVOb2RlXzEgPSByZXF1aXJlKFwiLi4vdmFycy9WYXJpYWJsZU5vZGVcIik7XG4vLyBsZWZ0IHNpZGUgaXMgdmFyaWFibGUsIHJpZ2h0IHNpZGUgaXMgdmFsXG4vLyBEZWNsYXJlcyBuZXcgdmFsXG5jbGFzcyBEZWNsYXJlT3AgZXh0ZW5kcyBCaW5hcnlPcGVyYXRpb25fMS5CaW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgZGVjbGFyZSBvcGVyYXRpb24sIHdoaWNoIGRlY2xhcmVzIGEgdmFyaWFibGUgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgc2lkZSBvZiB0aGUgZGVjbGFyZSBvcCAodGhlIHZhcmlhYmxlKVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgb3AgKHRoZSB2YWx1ZSlcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgc3VwZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoIShsZWZ0IGluc3RhbmNlb2YgVmFyaWFibGVOb2RlXzEuVmFyaWFibGVOb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxlZnQgaGFuZCBzaWRlIG9mIHRoZSBhc3NpZ25tZW50IG11c3QgYmUgYSB2YXJpYWJsZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyB0aGUgZGVjbGFyYXRpb24gYnkgZGVjbGFyaW5nIHRoZSB2YXJpYWJsZSBpbiB0aGUgY29udGV4dCBhbmQgYXNzaWduaW5nIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0IGluc3RhbmNlb2YgVmFyaWFibGVOb2RlXzEuVmFyaWFibGVOb2RlKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlY2xhcmUodGhpcy5sZWZ0Lm5hbWUpO1xuICAgICAgICAgICAgbGV0IHIgPSB0aGlzLnJpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgICAgICBjb250ZXh0LmFzc2lnbih0aGlzLmxlZnQubmFtZSwgcik7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIQUxQIChpbiBEZWNsYXJlT3ApXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkZWNsYXJlIG9wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwidmFyIFwiICsgdGhpcy5sZWZ0LnRvU3RyaW5nKCkgKyAnID0gJyArIHRoaXMucmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjbGFyZU9wcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbid0IGJlIGNhbGxlZCBkaXJlY2x5IG9uIGEgRGVjbGFyZU9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBiaW5hcnkgb3BlcmF0aW9uc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLkRlY2xhcmVPcCA9IERlY2xhcmVPcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlY2xhcmVPcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgTWludXNPcF8xID0gcmVxdWlyZShcIi4vTWludXNPcFwiKTtcbmNvbnN0IEFzc2lnbk9wXzEgPSByZXF1aXJlKFwiLi9Bc3NpZ25PcFwiKTtcbmNvbnN0IFZhcmlhYmxlTm9kZV8xID0gcmVxdWlyZShcIi4uL3ZhcnMvVmFyaWFibGVOb2RlXCIpO1xuY2xhc3MgRGVjcmVtZW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIGRlY3JlbWVudCBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gdmFyaWFibGUgVGhlIGV4cHJlc3Npb24gdG8gYmUgZGVjcmVtZW50ZWRcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2YXJpYWJsZSwgd3MpIHtcbiAgICAgICAgdGhpcy5leHByID0gdmFyaWFibGU7XG4gICAgICAgIGlmICh2YXJpYWJsZSBpbnN0YW5jZW9mIFZhcmlhYmxlTm9kZV8xLlZhcmlhYmxlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5pbm5lclJlcCA9IG5ldyBBc3NpZ25PcF8xLkFzc2lnbk9wKHZhcmlhYmxlLCBuZXcgTWludXNPcF8xLk1pbnVzT3AodmFyaWFibGUsIG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbm5lclJlcCA9IG5ldyBNaW51c09wXzEuTWludXNPcCh2YXJpYWJsZSwgbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBkZWNyZW1lbnQgb3AgdG8gYSBOdW1iZXJOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlubmVyUmVwLmV2YWwoY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRlY3JlbWVudCBvcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLmV4cHIudG9TdHJpbmcoKSArIFwiLS1cIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjcmVtZW50IG9wcyBjYW4ndCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2FuJ3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGRlY3JlbWVudFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5EZWNyZW1lbnQgPSBEZWNyZW1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWNyZW1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCaW5hcnlPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL0JpbmFyeU9wZXJhdGlvblwiKTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgRGl2T3AgZXh0ZW5kcyBCaW5hcnlPcGVyYXRpb25fMS5CaW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgZGl2aXNpb24gb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGRpdmlkZW5kXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSBkaXZpc29yXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHN1cGVyKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBkaXZpc2lvbiBhbmQgZXZhbHVhdGVzIGludG8gYSBzaW5nbGUgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMubGVmdC5ldmFsKG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpKS5ldmFsKGNvbnRleHQpLnZhbCAvIHRoaXMucmlnaHQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXZpc2lvbiBvcHMgY2FuJ3QgYmUgZGlyZWN0bHkgZHJhd25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbid0IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhIGRpdmlzaW9uIG9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBiaW5hcnkgb3BlcmF0aW9uc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGl2aXNpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5sZWZ0LnRvU3RyaW5nKCkgKyAnIC8gJyArIHRoaXMucmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLkRpdk9wID0gRGl2T3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaXZPcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgUGx1c09wXzEgPSByZXF1aXJlKFwiLi9QbHVzT3BcIik7XG5jb25zdCBBc3NpZ25PcF8xID0gcmVxdWlyZShcIi4vQXNzaWduT3BcIik7XG5jb25zdCBWYXJpYWJsZU5vZGVfMSA9IHJlcXVpcmUoXCIuLi92YXJzL1ZhcmlhYmxlTm9kZVwiKTtcbmNsYXNzIEluY3JlbWVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIEluY3JlbWVudFxuICAgICAqIEBwYXJhbSB2YXJpYWJsZSBUaGUgZXhwcmVzc2lvbiB0byBpbmNyZW1lbnRcbiAgICAgKiBAcGFyYW0gd3MgVHJhY2tzIHByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFyaWFibGUsIHdzKSB7XG4gICAgICAgIHRoaXMuZXhwciA9IHZhcmlhYmxlO1xuICAgICAgICBpZiAodmFyaWFibGUgaW5zdGFuY2VvZiBWYXJpYWJsZU5vZGVfMS5WYXJpYWJsZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJSZXAgPSBuZXcgQXNzaWduT3BfMS5Bc3NpZ25PcCh2YXJpYWJsZSwgbmV3IFBsdXNPcF8xLlBsdXNPcCh2YXJpYWJsZSwgbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyUmVwID0gbmV3IFBsdXNPcF8xLlBsdXNPcCh2YXJpYWJsZSwgbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEsIFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIGluY3JlbWVudCBpbnRvIGEgbnVtYmVyIG5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgZnVuY3Rpb24gc2NvcGVcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXJSZXAuZXZhbChjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5jcmVtZW50cyBjYW5ub3QgYmUgZHJhd25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGJpbm9wc1xuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluY3JlbWVudCBleHByZXNzaW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuZXhwci50b1N0cmluZygpICsgXCIrK1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5jcmVtZW50ID0gSW5jcmVtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5jcmVtZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmluYXJ5T3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9CaW5hcnlPcGVyYXRpb25cIik7XG5jb25zdCBTY29wZV8xID0gcmVxdWlyZShcIi4uL3N0cnVjdHVyYWwvU2NvcGVcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIE1pbnVzT3AgZXh0ZW5kcyBCaW5hcnlPcGVyYXRpb25fMS5CaW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHN1YnRyYWN0aW9uIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBtaW51ZW5kXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSBzdWJyYWhlbmRcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgc3VwZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIHN1YnRyYWN0aW9uIGFuZCBldmFsdWF0ZXMgdG8gYSBzaW5nbGUgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMubGVmdC5ldmFsKG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpKS5ldmFsKGNvbnRleHQpLnZhbCAtIHRoaXMucmlnaHQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdGlvbiBvcHMgY2FuJ3QgYmUgZGlyZWN0bHkgZHJhd25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbid0IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBzdWJ0cmFjdGlvblxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHN1YnRyYWN0aW9uIG9wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMubGVmdC50b1N0cmluZygpICsgJyAtICcgKyB0aGlzLnJpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5NaW51c09wID0gTWludXNPcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1pbnVzT3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCaW5hcnlPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL0JpbmFyeU9wZXJhdGlvblwiKTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgTXVsT3AgZXh0ZW5kcyBCaW5hcnlPcGVyYXRpb25fMS5CaW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgbXVsdGlwbGljYXRpb24gb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIG11bHRpcGxpY2FuZFxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgbXVsdGlwbGllclxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICBzdXBlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgbXVsdGlwbGljYXRpb24gYW5kIHJldHVybnMgYSBzaW5nbGUgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMubGVmdC5ldmFsKG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpKS5ldmFsKGNvbnRleHQpLnZhbCAqIHRoaXMucmlnaHQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtdWx0aXBsaWNhdGlvbiBvcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLmxlZnQudG9TdHJpbmcoKSArICcgKiAnICsgdGhpcy5yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWNhdGlvbiBvcHMgY2Fubm90IGJlIGRpcmVjdGx5IGRyYXduXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgbXVsdGlwbGljYWl0b24gb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBiaW5hcnkgb3BlcmF0aW9uc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLk11bE9wID0gTXVsT3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NdWxPcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJpbmFyeU9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vQmluYXJ5T3BlcmF0aW9uXCIpO1xuY29uc3QgU2NvcGVfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3R1cmFsL1Njb3BlXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG4vLyBsZWZ0IGFuZCByaWdodCBhcmUgYm90aCBleHByZXNzaW9uc1xuY2xhc3MgUGx1c09wIGV4dGVuZHMgQmluYXJ5T3BlcmF0aW9uXzEuQmluYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIGFkZGl0aW9uIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBmaXJzdCBhZGRlbmRcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHNlY29uZCBhZGRlbmRcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgc3VwZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIGFkZGl0aW9uIGFuZCByZXR1cm5zIGEgc2luZ2xlIE51bWJlck5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLmxlZnQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwgKyB0aGlzLnJpZ2h0LmV2YWwobmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCkpLmV2YWwoY29udGV4dCkudmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkaXRpb24gb3BzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhbiBhZGRpdGlvbiBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGFkZGl0aW9uIG9wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMubGVmdC50b1N0cmluZygpICsgJyArICcgKyB0aGlzLnJpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5QbHVzT3AgPSBQbHVzT3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QbHVzT3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTY29wZV8xID0gcmVxdWlyZShcIi4uL3N0cnVjdHVyYWwvU2NvcGVcIik7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY29uc3Qgc3BhY2VfbGlmdF8xID0gcmVxdWlyZShcInNwYWNlLWxpZnRcIik7XG5jbGFzcyBDb25kaXRpb25hbCB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBjb25kaXRpb25hbHMgKGlmLCBlbHNlIGlmLCBhbmQgZWxzZSBzdGF0ZW1lbnRzKVxuICAgICAqIEBwYXJhbSB0ZXN0IFRoZSBjb25kaXRpb24gb2YgdGhlIHN0YXRlbWVudFxuICAgICAqIEBwYXJhbSB0cnVlQnJhbmNoIFRoZSBicmFuY2ggdG8gZm9sbG93IGlmIHRoZSBjb25kaXRpb24gZXZhbHVhdGVzIHRvIHRydWVcbiAgICAgKiBAcGFyYW0gZmFsc2VCcmFuY2ggVGhlIGJyYW5jaCB0byBmb2xsb3cgaWYgdGhlIGNvbmRpdGlvbiBldmFsdWF0ZXMgdG8gZmFsc2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXN0LCB0cnVlQnJhbmNoLCBmYWxzZUJyYW5jaCkge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdGVzdCA9IHRlc3Q7XG4gICAgICAgIHRoaXMuX3RydWVCcmFuY2ggPSB0cnVlQnJhbmNoO1xuICAgICAgICB0aGlzLl9mYWxzZUJyYW5jaCA9IGZhbHNlQnJhbmNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIHRlc3QgcmVzdWx0IGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIHRydWUgb3IgZmFsc2UgYnJhbmNoLCBkZXBlbmRpbmcgb24gdGhlIHRlc3RcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGNoaWxkQ3R4ID0gbmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCwgY29udGV4dC5lZmZlY3RzLCBjb250ZXh0LmV2ZW50TG9nKTtcbiAgICAgICAgY2hpbGRDdHguY2FudmFzID0gc3BhY2VfbGlmdF8xLlNvbWUoY29udGV4dC5jYW52YXMuZ2V0KCkpO1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5fdGVzdC5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgaWYgKCEocmVzIGluc3RhbmNlb2YgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjb25kaXRpb24gbXVzdCBiZSBhIGJvb2xlYW4gZXhwcmVzc2lvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcy52YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cnVlQnJhbmNoLmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2ZhbHNlQnJhbmNoICE9IG51bGwpIHsgLy8gY2hlY2sgaWYgZWxzZS9lbHNlIGlmIGlzIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmFsc2VCcmFuY2guZXZhbChjaGlsZEN0eCk7IC8vIHBvc3NpYmx5IGEgYmFkIGlkZWFcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb25kaXRpb25hbCBzdGF0ZW1lbnRcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlcyA9ICdpZignICsgdGhpcy5fdGVzdC50b1N0cmluZygpICsgXCIpIHtcXG4gXCIgKyB0aGlzLl90cnVlQnJhbmNoLnRvU3RyaW5nKCkgKyBcIn1cIjtcbiAgICAgICAgaWYgKHRoaXMuX2ZhbHNlQnJhbmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlcyArPSAnXFxuZWxzZSB7XFxuICcgKyB0aGlzLl9mYWxzZUJyYW5jaC50b1N0cmluZygpICsgJ30nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJ1ZSBicmFuY2ggb2YgdGhlIGNvbmRpdGlvbmFsXG4gICAgICovXG4gICAgZ2V0IHRydWVCcmFuY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cnVlQnJhbmNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmYWxzZSBicmFuY2ggb2YgdGhlIGNvbmRpdGlvbmFsXG4gICAgICovXG4gICAgZ2V0IGZhbHNlQnJhbmNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFsc2VCcmFuY2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmRpdGlvbmFscyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgY29uZGl0aW9uYWxcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGNvbmRpdGlvbmFsc1wiKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbmRpdGlvbmFsID0gQ29uZGl0aW9uYWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25kaXRpb25hbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgUGFpbnRFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUGFpbnRFdmVudFwiKTtcbmNvbnN0IFJlc2l6ZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9SZXNpemVFdmVudFwiKTtcbmNvbnN0IENsaWNrRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL0NsaWNrRXZlbnRcIik7XG5jbGFzcyBDdXJ2ZUVmZmVjdCB7XG4gICAgY29uc3RydWN0b3IoY3VydmUpIHtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBwcml2YXRlIGJvb2xzXG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JhdGlvID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnggPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IDA7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX21vdXNlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY3VydmUgPSBjdXJ2ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIGV2YWx1YXRpbmcgbm9kZXMgKFN0cmluZ05vZGUsIEVsbGlwc2VOb2RlLCBldGMpXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyBhbGwgcGFyYW1zIHRvIHByaXZhdGUgdmFyaWFibGVzIGFuZCBkcmF3cyB0aGUgaW5pdGlhbCBvYmplY3QgdG8gdGhlIGNhbnZhc1xuICAgICAqIGJ5IGNhbGxpbmcgdXBkYXRlKClcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgcGFyZW50IFNjb3BlIHRoYXQgY29udGFpbnMgdGhlIGNhbnZhcyBhbW9uZyBvdGhlciB0aGluZ3NcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgb2JqZWN0J3MgZGltZW5zaW9ucyBpbmNsdWRpbmcgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBhc3QgVW5uZWNlc3Nhcnkgbm93LCB1c2VkIHRvIGJlIHRoZSBwYXJlbnQgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY2FudmFzLmlzRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zID0gZGltcztcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IGNvbnRleHQuY2FudmFzLmdldCgpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgY3R4ID0gY29udGV4dC5jYW52YXMuZ2V0KCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1BhaW50KCkpO1xuICAgICAgICBjb250ZXh0LmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gZHJhdyBhbmQgcmVkcmF3IHRoZSBvYmplY3Qgd2hlbiBtYW5pcHVsYXRpb25zIGFyZSBtYWRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudztcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuaDtcbiAgICAgICAgbGV0IGN1cnZhdHVyZSA9IHRoaXMuY3VydmF0dXJlO1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIGxldCB2ID0gdGhpcy5wZXJwZW5kaWN1bGFyVmVjdG9yKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLl9jdHgucXVhZHJhdGljQ3VydmVUbygoeCArIHdpZHRoIC8gMikgKyBjdXJ2YXR1cmUgKiB2WzBdLCAoeSArIGhlaWdodCAvIDIpICsgY3VydmF0dXJlICogdlsxXSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gXCIjNjczQUI3XCI7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0d1aWRlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0aGlzLl9jb3JuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vYSAqIHcgKyBiICogaCA9IDBcbiAgICBwZXJwZW5kaWN1bGFyVmVjdG9yKHcsIGgpIHtcbiAgICAgICAgaWYgKHcgPT0gMCAmJiBoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodyA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gWzEsIDBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFswLCAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzEsICgtdykgLyBoXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gb25lIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7IC8vIGJpbmQgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIG1lYW5pbmcgb2YgJ3RoaXMnXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25TaGlmdERvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25TaGlmdFVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy9tYWtlcyBpdCBzbyB0aGF0IGRvdWJsZSBjbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0ZXh0IG9uIHRoZSBwYWdlXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uIChlKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGZhbHNlOyB9LCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIGFub3RoZXIgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvZiB0aGUgb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgY29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAobXggPiB4ICYmIG14IDwgeCArIHcgJiYgbXkgPiB5ICYmIG15IDwgeSArIGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciA+IDAgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvbmUgb2YgdGhlIGNvcm5lci9zaWRlIGd1aWRlcywgcmV0dXJucyAwIGlmIG5vdFxuICAgICAqIFRoZSBjb3JuZXIgZ3VpZGVzIGFyZSBudW1iZXJlZCAxLTQgd2l0aCAxIGJlaW5nIHRoZSB0b3AgbGVmdCwgMiBiZWluZyB0aGUgdG9wIHJpZ2h0LCBhbmQgc28gb24uXG4gICAgICogVGhlIG1pZGRsZSBndWlkZXMgYXJlIG51bWJlcmVkIDUtOCwgd2l0aCA1IGJlaW5nIHRoZSB0b3AgbWlkZGxlLCA2IGJlaW5nIHRoZSByaWdodCBtaWRkbGUsIGFuZCBzbyBvbi5cbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ3VpZGVDb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGxldCB4ZGlmID0gbXggLSB4O1xuICAgICAgICBsZXQgeWRpZiA9IG15IC0geTtcbiAgICAgICAgLyogQ29ybmVyIEd1aWRlcyAqL1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIGxlZnRcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogTWlkZGxlIEd1aWRlcyAqL1xuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0geTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGFuZCBndWlkZXMgZm9yIHRoZSBvYmplY3Qgd2hlbiB0aGUgb2JqZWN0IGlzIHNlbGVjdGVkXG4gICAgICogSWYgb25lIG9mIHRoZSBndWlkZXMgaXMgc2VsZWN0ZWQsIGl0IGNvbG9ycyB0aGF0IGd1aWRlIGJsdWVcbiAgICAgKiBAcGFyYW0geCB0aGUgeCBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0geSB0aGUgeSBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb3JuZXIgdGhlIG51bWJlciBvZiB0aGUgY29ybmVyIHRvIGJlIGNvbG9yZWQgYmx1ZSAoaWYgYW55IGF0IGFsbCwgaWYgMCwgYWxsIGFyZSB3aGl0ZSlcbiAgICAgKi9cbiAgICBkcmF3R3VpZGVzKHgsIHksIHcsIGgsIGNvcm5lcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKGNvcm5lciAhPT0gMCAmJiBjb3JuZXIgPD0gNCkgeyAvLyBhIGNvcm5lciBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcnJlY3QgZ3VpZGUgYmx1ZVxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3JuZXIgIT09IDApIHsgLy8gYSBtaWRkbGUgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vaWYgbm8gZ3VpZGVzIGFyZSBzZWxlY3RlZCwgY29sb3JzIGV2ZXJ5dGhpbmcgd2hpdGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBtZXRob2QgdGhhdCBkcmF3cyBhIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB4IHggY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHkgeSBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gdyB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29sb3IgY29sb3Igb2YgdGhlIHJlY3RhbmdsZSdzIGZpbGxcbiAgICAgKi9cbiAgICBkcmF3U3F1YXJlKHgsIHksIHcsIGgsIGNvbG9yKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBtb3ZlcyB3aXRoaW4gdGhlIGNhbnZhcy5cbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiwgY2FsbHMgdGhlIG1vZGlmeSBtZXRob2RzIGlmIHRoZSBib29sZWFucyBzYXRpc2Z5IHRoZW0uXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeURyYWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jlc2l6aW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplKHRoaXMudyA8IDEwLCB0aGlzLmggPCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNDaGFuZ2luZ0RpbXMgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zKHRoaXMudyA8IDEwLCB0aGlzLmggPCAxMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBjbGlja3MgaW5zaWRlIHRoZSBjYW52YXMuXG4gICAgICogTW9kaWZpZXMgdGhlIHN0YXRlIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBndWlkZXMgY29udGFpbiB0aGUgbW91c2Ugb3IgdGhlIGJvdW5kaW5nIHJlY3QgY29udGFpbnMgdGhlIG1vdXNlLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlTdGF0ZSh0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSksIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIHVuY2xpY2tzLlxuICAgICAqIENhbGxzIG1vZGlmeVJlc2V0IHRvIHJlc2V0IGRyYWdnaW5nIGFuZCByZXNpemluZyBib29sZWFucyBhbW9uZyBvdGhlcnMuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZXVwIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5UmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHByZXNzZWQgZG93blxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHByZXNzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnREb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyByZWxlYXNlZFxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHJlbGVhc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0VXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIE1vZGlmaWNhdGlvbiBmdW5jdGlvbnMgKi9cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgaW4gb3JkZXIgdG8gZHJhZyB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIG1vZGlmeURyYWcoKSB7XG4gICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLl9kcmFnb2ZmeDtcbiAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueSAtIHRoaXMuX2RyYWdvZmZ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBzaXplIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQgKHdoZW4gYSBjb3JuZXIgZ3VpZGUgaXMgY2xpY2tlZCBhbmQgZHJhZ2dlZCkuXG4gICAgICpcbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDEwIGFuZCB0aGUgb3RoZXIgZXF1YWwgdG9cbiAgICAgKiAxMCBkaXZpZGVkIG9yIG11bHRpcGxpZWQgYnkgdGhlIHJhdGlvIG9mIHdpZHRoL2hlaWdodCB0byBrZWVwIGl0IHRoZSBzYW1lLlxuICAgICAqXG4gICAgICogVGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgaXMgZG9uZSBieSBjYWxsaW5nIHRoZSBoZWxwZXIgbWV0aG9kIG1vZGlmeVJlc2l6ZUhlbHBlci5cbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNpemUod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgaWYgKHdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTsgLy8gc2V0IGZvciB0aGUgcHJvZGlyZWN0IG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMCAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fY3VydmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAvIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7IC8vIHNldCBmb3IgdGhlIHByb2RpcmVjdCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMCAqIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fY3VydmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyAxLCAyLCBvciA0IGFyZSBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0Rpc3RhbmNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBtb3VzZSBhbmQgdGhlIGxvY2F0aW9uIG9wcG9zaXRlIHRvIGl0XG4gICAgICogKGlmIHRvcCByaWdodCBndWlkZSBpcyBjbGlja2VkLCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGFuZCB0aGUgYm90dG9tIGxlZnQgZ3VpZGUgaXMgbmV3RGlzdGFuY2UpXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgdGhpcy5fY3VydmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAvIHRoaXMuX3JhdGlvO1xuICAgICAgICB0aGlzLl9jdXJ2ZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkLlxuICAgICAqIElmIGFueSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgdG9vIHNtYWxsLCBpdCBzZXRzIHRoZW0gZXF1YWwgdG8gMTAuXG4gICAgICogQ2FsbHMgbW9kaWZ5Q2hhbmdlRGltc0hlbHBlciB0byBhY3R1YWxseSBkbyB0aGUgd29ya1xuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqL1xuICAgIG1vZGlmeUNoYW5nZURpbXMod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgaWYgKHdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGUgcmVjdGFuZ2xlIG9yaWdpbmF0ZXMgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIGFuZCBub3QgdGhlIGNlbnRlcixcbiAgICAgKiBpdCBjaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFzIHdlbGwgaWYgZ3VpZGVzIDUgb3IgOCBhcmUgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmggPiAxMCkgeyAvL2FzIGxvbmcgYXMgdGhlIGhlaWdodCBpcyA+IDEwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VydmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VydmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53ID4gMTApIHsgLy8gYXMgbG9uZyBhcyB3aWR0aCBpcyA+IDEwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIGRlcGVuZGluZyBvbiB0aGUgbW91c2UgcG9zaXRpb24gd2hlbiBjYWxsZWQgKG9uTW91c2VEb3duKVxuICAgICAqIGUuZy4gaWYgdGhlIG1vdXNlIGlzIHdpdGhpbiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIHdoZW4gdGhpcyBpcyBjYWxsZWQsIGlzU2VsZWN0ZWQgPSB0cnVlXG4gICAgICogQHBhcmFtIGd1aWRlQ29udGFpbnNcbiAgICAgKiBAcGFyYW0gY29udGFpbnNcbiAgICAgKi9cbiAgICBtb2RpZnlTdGF0ZShndWlkZUNvbnRhaW5zLCBjb250YWlucykge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy9wcmVwYXJlcyB0aGUgb2JqZWN0IGZvciBkcmFnZ2luZyB3aGV0aGVyIGl0IGlzIHBlcnNvbmFsbHkgc2VsZWN0ZWQgb3Igbm90XG4gICAgICAgICAgICBpZiAoY29udGFpbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94MSA9IHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl95MSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucyA+IDAgJiYgZ3VpZGVDb250YWlucyA8PSA0KSB7IC8vcmVzaXppbmdcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KTtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodDEgPSB0aGlzLmg7XG4gICAgICAgICAgICB0aGlzLl93aWR0aDEgPSB0aGlzLnc7XG4gICAgICAgICAgICAvL3RoaXMuX3NpemUxID0gTWF0aC5zcXJ0KE1hdGgucG93KHcsMikgKyBNYXRoLnBvdyhoLDIpKTsgLy8gc2l6ZSBpcyBkaWFnb25hbCBsZW5ndGhcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7IC8vIHNldHMgdGhlIG9mZnNldHMgZGVwZW5kaW5nIG9uIHdoaWNoIGNvcm5lciBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdzsgLy8gb2Zmc2V0IGlzIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDsgLy8gb2Zmc2V0IGlzIGJvdHRvbSBsZWZ0LCBldGNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiA0KSB7IC8vY2hhbmdpbmcgc2hhcGUgZGltZW5zaW9uc1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSBndWlkZUNvbnRhaW5zO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHsgLy8gc2V0cyB0aGUgb2Zmc2V0cyBkZXBlbmRpbmcgb24gd2hpY2ggbWlkZGxlIGd1aWRlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgY2FzZSA1OiAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3IC8gMjsgLy8gb2Zmc2V0IGlzIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OiAvL3JpZ2h0IG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5ICsgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyOyAvLyBvZmZzZXQgaXMgbGVmdCBtaWRkbGUgZXRjXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdyAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSArIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKSB7IC8vIGRyYWdnaW5nXG4gICAgICAgICAgICB0aGlzLl94MSA9IHg7IC8vIFNhdmluZyBvcmlnaW5hbCB4IGFuZCB5XG4gICAgICAgICAgICB0aGlzLl95MSA9IHk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkgeyAvLyBub3Qgc2VsZWN0ZWRcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIHRvIGZhbHNlIChsaWtlIGRyYWdnaW5nLCByZXNpemluZywgZXRjKSB3aGVuIHRoZSBtb3VzZSBpcyByZWxlYXNlZFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB0aGlzLngpID4gMSB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHRoaXMueSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh0aGlzLl9pc1Jlc2l6aW5nIHx8IHRoaXMuX2lzQ2hhbmdpbmdEaW1zKSAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc2l6ZTIgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53LCAyKSArIE1hdGgucG93KHRoaXMuaCwgMikpO1xuICAgICAgICAgICAgaWYgKChNYXRoLmFicyh0aGlzLl93aWR0aDEgLSB0aGlzLncpID4gMCkgfHwgKE1hdGguYWJzKHRoaXMuX2hlaWdodDEgLSB0aGlzLmgpID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dSZXNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKiBOT1RFOiBpbiBGaXJlZm94LCB3aW5kb3cuZXZlbnQgaXMgbm90IGdsb2JhbC4gTmVlZCB0byBiZSBwYXNzZWQgaW4gaGVyZSBhcyBhIHBhcmFtYXRlci5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIGdldE1vdXNlUG9zaXRpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fbW91c2UueCA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLng7XG4gICAgICAgIHRoaXMuX21vdXNlLnkgPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzQ2hhbmdpbmdEaW1zLCBhbmQgaXNTZWxlY3RlZCB0byBmYWxzZSBpZiB0aGUgbW91c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgaXNNb3VzZU91dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1vdXNlWCA8IHJlY3QubGVmdCB8fCBtb3VzZVggPiByZWN0LnJpZ2h0IHx8IG1vdXNlWSA8IHJlY3QudG9wIHx8IG1vdXNlWSA+IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIHBhaW50IGV2ZW50XG4gICAgICovXG4gICAgbG9nUGFpbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpbnRFdmVudF8xLlBhaW50RXZlbnQoXCJyZWN0YW5nbGVcIiwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIHJlc2l6ZSBldmVudFxuICAgICAqL1xuICAgIGxvZ1Jlc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVFdmVudF8xLlJlc2l6ZUV2ZW50KFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgTWF0aC5yb3VuZCh0aGlzLl93aWR0aDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuX2hlaWdodDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMudyAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5oICogMTAwKSAvIDEwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZWN0YW5nbGUgY2xpY2sgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dDbGljaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGlja0V2ZW50XzEuQ2xpY2tFdmVudChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIGFzc2lnbnMgYW4gSUQgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIGlkIFRoZSBJRCB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIGluaXRJRChpZCkge1xuICAgICAgICB0aGlzLmlkT2JqID0geyBfaWQ6IGlkIH07XG4gICAgfVxuICAgIGFzdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHggcG9zaXRpb24gb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VydmF0dXJlIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIGdldCBjdXJ2YXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLmN1cnZhdHVyZS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRGltZW5zaW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgZGltcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZE9iai5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICovXG4gICAgZ2V0SnVzdERyYWdnZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdXN0RHJhZ2dlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldEp1c3REcmFnZ2VkKHZhbCkge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBpcyBkcmFnZ2luZ1xuICAgICAqL1xuICAgIGdldCBpc0RyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEcmFnZ2luZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBzZWxlY3Rpb24gZXZlbnRzXG4gICAgICovXG4gICAgdG9TZWxTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIiByZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBkcmFnIGV2ZW50c1xuICAgICovXG4gICAgdG9EcmFnU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94MSArIFwiLCBcIiArIHRoaXMuX3kxICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gcmVjdGFuZ2xlIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG59XG5leHBvcnRzLkN1cnZlRWZmZWN0ID0gQ3VydmVFZmZlY3Q7XG4vKipcbiAqIEdldHMgdGhlIG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZXMgaW4gcmVsYXRpb24gdG8gdGhlIGNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB0aGUgY2FudmFzIG9iamVjdFxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0TW91c2VQb3MoY2FudmFzLCBldmVudCkge1xuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB4MSB4IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB5MSB5IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB4MiB4IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKiBAcGFyYW0geTIgeSBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MiwgMikgKyBNYXRoLnBvdyh5MSAtIHkyLCAyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DdXJ2ZUVmZmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBhaW50RXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1BhaW50RXZlbnRcIik7XG5jb25zdCBSZXNpemVFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUmVzaXplRXZlbnRcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IENsaWNrRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL0NsaWNrRXZlbnRcIik7XG5jbGFzcyBFbGxpcHNlRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihjaXJjbGUpIHtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBQcml2YXRlIGJvb2xzXG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7IC8vIEhhcyB0aGlzIG9iamVjdCBqdXN0IGJlZW4gZHJhZ2dlZD9cbiAgICAgICAgdGhpcy5fcmF0aW8gPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gMDtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5fbW91c2UgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jaXJjbGUgPSBjaXJjbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiBldmFsdWF0aW5nIG5vZGVzIChTdHJpbmdOb2RlLCBFbGxpcHNlTm9kZSwgZXRjKVxuICAgICAqIFRoaXMgbWV0aG9kIGFzc2lnbnMgYWxsIHBhcmFtcyB0byBwcml2YXRlIHZhcmlhYmxlcyBhbmQgZHJhd3MgdGhlIGluaXRpYWwgb2JqZWN0IHRvIHRoZSBjYW52YXNcbiAgICAgKiBieSBjYWxsaW5nIHVwZGF0ZSgpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIHBhcmVudCBTY29wZSB0aGF0IGNvbnRhaW5zIHRoZSBjYW52YXMgYW1vbmcgb3RoZXIgdGhpbmdzXG4gICAgICogQHBhcmFtIGRpbXMgVGhlIG9iamVjdCdzIGRpbWVuc2lvbnMgaW5jbHVkaW5nIHggYW5kIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gYXN0IFVubmVjZXNzYXJ5IG5vdywgdXNlZCB0byBiZSB0aGUgcGFyZW50IEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNhbnZhcy5pc0RlZmluZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZGltcyA9IGRpbXM7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBjb250ZXh0LmNhbnZhcy5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgbGV0IGN0eCA9IGNvbnRleHQuY2FudmFzLmdldCgpLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb2dnaW5nXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1BhaW50KCkpO1xuICAgICAgICBjb250ZXh0LmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gZHJhdyBhbmQgcmVkcmF3IHRoZSBvYmplY3Qgd2hlbiBtYW5pcHVsYXRpb25zIGFyZSBtYWRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHguZWxsaXBzZSh4LCB5LCB3IC8gMiwgaCAvIDIsIDAsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgICAgIC8vdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICAvL3RoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IFwiI0Q1QjhGRlwiO1xuICAgICAgICB0aGlzLl9jdHguc2hhZG93Q29sb3IgPSBcIiM2QzZDNkNcIjtcbiAgICAgICAgdGhpcy5fY3R4LnNoYWRvd0JsdXIgPSAxNTtcbiAgICAgICAgLy90aGlzLl9jdHguc2hhZG93T2Zmc2V0WCA9IDI7XG4gICAgICAgIC8vdGhpcy5fY3R4LnNoYWRvd09mZnNldFkgPSAyO1xuICAgICAgICB0aGlzLl9jdHguZmlsbCgpO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3R3VpZGVzKHggLSB3IC8gMiwgeSAtIGggLyAyLCB3LCBoLCB0aGlzLl9jb3JuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICAgIHByaXZhdGUgbW91c2VNb3ZlID0gdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICBwcml2YXRlIG1vdXNlRG93biA9IHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgcHJpdmF0ZSBtb3VzZVVwID0gdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgcHJpdmF0ZSBzaGlmdERvd24gPSB0aGlzLm9uU2hpZnREb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHByaXZhdGUgc2hpZnRVcCA9IHRoaXMub25TaGlmdFVwLmJpbmQodGhpcyk7XG4gICAgICAgIHByaXZhdGUgbW91c2VPdXRzaWRlID0gdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpO1xuICAgICAgICBwcml2YXRlIHNlbGVjdFN0YXJ0ID0gZnVuY3Rpb24oZTphbnkpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZmFsc2U7IH07XG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBvbmUgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTsgLy8gYmluZCBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgbWVhbmluZyBvZiAndGhpcydcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vblNoaWZ0RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vblNoaWZ0VXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmlzTW91c2VPdXRzaWRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL21ha2VzIGl0IHNvIHRoYXQgZG91YmxlIGNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRleHQgb24gdGhlIHBhZ2VcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgZnVuY3Rpb24gKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZmFsc2U7IH0sIGZhbHNlKTtcbiAgICB9XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIC8qXG4gICAgICAgIGNvbnNvbGUubG9nKFwicmVtb3ZpbmcgRXZlbnRMaXN0bmVyc1wiKTtcbiAgICAgICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZU1vdmUpOyAvLyBiaW5kIGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBtZWFuaW5nIG9mICd0aGlzJ1xuICAgICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlRG93bik7XG4gICAgICAgICAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNlVXApO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5zaGlmdERvd24pO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuc2hpZnRVcCk7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2VPdXRzaWRlKTtcbiAgICAgICAgICAvL21ha2VzIGl0IHNvIHRoYXQgZG91YmxlIGNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRleHQgb24gdGhlIHBhZ2VcbiAgICAgICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCB0aGlzLnNlbGVjdFN0YXJ0LCBmYWxzZSk7XG4gICAgICAgICAgKi9cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb2YgdGhlIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSwgZmFsc2UgaWYgb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KG14IC0geCwgMikgLyBNYXRoLnBvdyh3IC8gMiwgMikgKyBNYXRoLnBvdyhteSAtIHksIDIpIC8gTWF0aC5wb3coaCAvIDIsIDIpIDw9IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgPiAwIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb25lIG9mIHRoZSBjb3JuZXIvc2lkZSBndWlkZXMsIHJldHVybnMgMCBpZiBub3RcbiAgICAgKiBUaGUgY29ybmVyIGd1aWRlcyBhcmUgbnVtYmVyZWQgMS00IHdpdGggMSBiZWluZyB0aGUgdG9wIGxlZnQsIDIgYmVpbmcgdGhlIHRvcCByaWdodCwgYW5kIHNvIG9uLlxuICAgICAqIFRoZSBtaWRkbGUgZ3VpZGVzIGFyZSBudW1iZXJlZCA1LTgsIHdpdGggNSBiZWluZyB0aGUgdG9wIG1pZGRsZSwgNiBiZWluZyB0aGUgcmlnaHQgbWlkZGxlLCBhbmQgc28gb24uXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGd1aWRlQ29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBsZXQgeGRpZiA9IG14IC0gKHggLSB3IC8gMik7XG4gICAgICAgIGxldCB5ZGlmID0gbXkgLSAoeSAtIGggLyAyKTtcbiAgICAgICAgLyogQ29ybmVyIEd1aWRlcyAqL1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIGxlZnRcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4IC0gdyAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICB9XG4gICAgICAgIC8qIE1pZGRsZSBHdWlkZXMgKi9cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgLSBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0geTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCAtIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0geTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBhbmQgZ3VpZGVzIGZvciB0aGUgb2JqZWN0IHdoZW4gdGhlIG9iamVjdCBpcyBzZWxlY3RlZFxuICAgICAqIElmIG9uZSBvZiB0aGUgZ3VpZGVzIGlzIHNlbGVjdGVkLCBpdCBjb2xvcnMgdGhhdCBndWlkZSBibHVlXG4gICAgICogQHBhcmFtIHggdGhlIHggY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHkgdGhlIHkgY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHcgdGhlIHdpZHRoIG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29ybmVyIHRoZSBudW1iZXIgb2YgdGhlIGNvcm5lciB0byBiZSBjb2xvcmVkIGJsdWUgKGlmIGFueSBhdCBhbGwsIGlmIDAsIGFsbCBhcmUgd2hpdGUpXG4gICAgICovXG4gICAgZHJhd0d1aWRlcyh4LCB5LCB3LCBoLCBjb3JuZXIpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmIChjb3JuZXIgIT09IDAgJiYgY29ybmVyIDw9IDQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29ybmVyICE9PSAwICYmIGNvcm5lciA+IDQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgbWV0aG9kIHRoYXQgZHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geCB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5IHkgY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHcgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIGNvbG9yIG9mIHRoZSByZWN0YW5nbGUncyBmaWxsXG4gICAgICovXG4gICAgZHJhd1NxdWFyZSh4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgd2l0aGluIHRoZSBjYW52YXMuXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24sIGNhbGxzIHRoZSBtb2RpZnkgbWV0aG9kcyBpZiB0aGUgYm9vbGVhbnMgc2F0aXNmeSB0aGVtLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlEcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZXNpemluZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZSh0aGlzLncgPCAxNCwgdGhpcy5oIDwgMTQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQ2hhbmdpbmdEaW1zICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltcyh0aGlzLncgPCAxNCwgdGhpcy5oIDwgMTQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5U3RhdGUodGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpLCB0aGlzLmNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSB1bmNsaWNrcy5cbiAgICAgKiBDYWxscyBtb2RpZnlSZXNldCB0byByZXNldCBkcmFnZ2luZyBhbmQgcmVzaXppbmcgYm9vbGVhbnMgYW1vbmcgb3RoZXJzLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2V1cCBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VVcChldmVudCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiSSdtIGFuIGVsbGlwc2UhXCIpO1xuICAgICAgICB0aGlzLm1vZGlmeVJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyBwcmVzc2VkIGRvd25cbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSBwcmVzc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcmVsZWFzZWRcbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSByZWxlYXNlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdFVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBNb2RpZmljYXRpb24gZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGRyYWcgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBtb2RpZnlEcmFnKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiZWxsaXBzZSBkcmFnb2ZmeDogXCIgKyB0aGlzLl9kcmFnb2ZmeCk7XG4gICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLl9kcmFnb2ZmeDtcbiAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueSAtIHRoaXMuX2RyYWdvZmZ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBzaXplIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQgKHdoZW4gYSBjb3JuZXIgZ3VpZGUgaXMgY2xpY2tlZCBhbmQgZHJhZ2dlZCkuXG4gICAgICpcbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDE0IGFuZCB0aGUgb3RoZXIgZXF1YWwgdG9cbiAgICAgKiAxMCBkaXZpZGVkIG9yIG11bHRpcGxpZWQgYnkgdGhlIHJhdGlvIG9mIHdpZHRoL2hlaWdodCB0byBrZWVwIGl0IHRoZSBzYW1lLlxuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDE0XG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxNFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZSh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBpZiAod2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDE0O1xuICAgICAgICAgICAgdGhpcy5fY2lyY2xlLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDE0KTsgLy8gc2V0IGZvciB0aGUgcHJvZGlyZWN0IG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxNCAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fY2lyY2xlLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDE0IC8gdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMiAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTQ7XG4gICAgICAgICAgICB0aGlzLl9jaXJjbGUuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDE0KTsgLy8gc2V0IGZvciB0aGUgcHJvZGlyZWN0IG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDE0ICogdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9jaXJjbGUud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxNCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDI7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDIgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMjtcbiAgICAgICAgICAgIHRoaXMuX2NpcmNsZS53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDIgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2NpcmNsZS5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZC5cbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDEwLlxuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqL1xuICAgIG1vZGlmeUNoYW5nZURpbXMod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgaWYgKHRoaXMuX2Nvcm5lciA9PSA1IHx8IHRoaXMuX2Nvcm5lciA9PSA3KSB7IC8vIGlmIG1vZGlmeWluZyBoZWlnaHRcbiAgICAgICAgICAgIGlmICghaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMiAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDsgLy8gc2V0dGluZyB3aWR0aC9oZWlnaHQgcmF0aW8gPSB0byB0aGUgbmV3IHJhdGlvXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDE0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDIgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBtb2RpZnlpbmcgd2lkdGhcbiAgICAgICAgICAgIGlmICghd2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDI7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDE0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIGRlcGVuZGluZyBvbiB0aGUgbW91c2UgcG9zaXRpb24gd2hlbiBjYWxsZWQgKG9uTW91c2VEb3duKVxuICAgICAqIGUuZy4gaWYgdGhlIG1vdXNlIGlzIHdpdGhpbiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIHdoZW4gdGhpcyBpcyBjYWxsZWQsIGlzU2VsZWN0ZWQgPSB0cnVlXG4gICAgICogQHBhcmFtIGd1aWRlQ29udGFpbnNcbiAgICAgKiBAcGFyYW0gY29udGFpbnNcbiAgICAgKi9cbiAgICBtb2RpZnlTdGF0ZShndWlkZUNvbnRhaW5zLCBjb250YWlucykge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkgeyAvL3ByZXBhcmVzIHRoZSBvYmplY3QgZm9yIGRyYWdnaW5nIHdoZXRoZXIgaXQgaXMgcGVyc29uYWxseSBzZWxlY3RlZCBvciBub3RcbiAgICAgICAgICAgIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kxID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiAwIHx8IGNvbnRhaW5zKSB7XG4gICAgICAgICAgICBsZXQgZWZmZWN0cyA9IHRoaXMuX2NvbnRleHQuZWZmZWN0cztcbiAgICAgICAgICAgIGxldCBjdXJJRCA9IHRoaXMuZ2V0SUQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVmZmVjdElEID0gZWZmZWN0LmdldElEKCk7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdElEID09IGN1cklEKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlZmZlY3RJRCA+IGN1cklEICYmIChlZmZlY3QuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSA+IDAgfHwgZWZmZWN0LmNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChndWlkZUNvbnRhaW5zID4gMCAmJiBndWlkZUNvbnRhaW5zIDw9IDQpIHsgLy9yZXNpemluZ1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IGd1aWRlQ29udGFpbnM7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoMSA9IHRoaXMudztcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWlnaHQxID0gdGhpcy5oO1xuICAgICAgICAgICAgICAgIC8vdGhpcy5fc2l6ZTEgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53LDIpICsgTWF0aC5wb3codGhpcy5oLDIpKTsgLy8gc2F2aW5nIG9sZCBzaXplXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gNCkgeyAvL2NoYW5naW5nIHNoYXBlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gZ3VpZGVDb250YWlucztcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb250YWlucykgeyAvL3NpbXBseSBzZWxlY3RpbmcgdGhlIHNoYXBlIG9yIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLng7IC8vIFNhdmluZyBvcmlnaW5hbCB4IGFuZCB5XG4gICAgICAgICAgICAgICAgdGhpcy5feTEgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgdG8gZmFsc2UgKGxpa2UgZHJhZ2dpbmcsIHJlc2l6aW5nLCBldGMpIHdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkXG4gICAgICovXG4gICAgbW9kaWZ5UmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHsgLy8gcHJvYnMgb25seSBuZWVkIGRyYWdnaW5nIGJ1dCBvaCB3ZWxsIHwgaXNTZWwgfHwgc2VsTXVsP1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0gdGhpcy54KSA+IDEgfHwgTWF0aC5hYnModGhpcy5feTEgLSB0aGlzLnkpID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvL3RoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ01vdmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHRoaXMuX2lzUmVzaXppbmcgfHwgdGhpcy5faXNDaGFuZ2luZ0RpbXMpICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJyZXNpemluZyBlbGxpcHNlXCIpO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy9sZXQgc2l6ZTIgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53LDIpICsgTWF0aC5wb3codGhpcy5oLDIpKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTaXplIGRpZmY6IFwiICsgTWF0aC5hYnModGhpcy5fc2l6ZTEgLSBzaXplMikpO1xuICAgICAgICAgICAgaWYgKChNYXRoLmFicyh0aGlzLl93aWR0aDEgLSB0aGlzLncpID4gMCkgfHwgKE1hdGguYWJzKHRoaXMuX2hlaWdodDEgLSB0aGlzLmgpID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dSZXNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYodGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSl7XG4gICAgICAgIC8vICAgICBpZihNYXRoLmFicyh0aGlzLl94MSAtIHRoaXMueCkgPiAxIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0gdGhpcy55KSA+IDEpIHtcbiAgICAgICAgLy8gICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dNb3ZlKCkpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICogTk9URTogaW4gRmlyZWZveCwgd2luZG93LmV2ZW50IGlzIG5vdCBnbG9iYWwuIE5lZWQgdG8gYmUgcGFzc2VkIGluIGhlcmUgYXMgYSBwYXJhbWF0ZXIuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBnZXRNb3VzZVBvc2l0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX21vdXNlLnggPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS54O1xuICAgICAgICB0aGlzLl9tb3VzZS55ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0NoYW5naW5nRGltcywgYW5kIGlzU2VsZWN0ZWQgdG8gZmFsc2UgaWYgdGhlIG1vdXNlIGNsaWNrcyBvdXRzaWRlIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIGlzTW91c2VPdXRzaWRlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgICAgICBsZXQgbW91c2VZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtb3VzZVggPCByZWN0LmxlZnQgfHwgbW91c2VYID4gcmVjdC5yaWdodCB8fCBtb3VzZVkgPCByZWN0LnRvcCB8fCBtb3VzZVkgPiByZWN0LmJvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcGFpbnQgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dQYWludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWludEV2ZW50XzEuUGFpbnRFdmVudChcImVsbGlwc2VcIiwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVzaXplIGV2ZW50XG4gICAgICovXG4gICAgbG9nUmVzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZUV2ZW50XzEuUmVzaXplRXZlbnQoXCJlbGxpcHNlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgTWF0aC5yb3VuZCh0aGlzLl93aWR0aDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuX2hlaWdodDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMudyAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5oICogMTAwKSAvIDEwMCk7XG4gICAgICAgIC8vTWF0aC5yb3VuZCh0aGlzLl9zaXplMSoxMDApLzEwMCwgTWF0aC5yb3VuZCgoTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMudywyKSArIE1hdGgucG93KHRoaXMuaCwyKSkqMTAwKSkvMTAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIGNsaWNrIGV2ZW50XG4gICAgICovXG4gICAgbG9nQ2xpY2soKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xpY2tFdmVudF8xLkNsaWNrRXZlbnQoXCJlbGxpcHNlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgYXNzaWducyBhbiBJRCB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgaW5pdElEKGlkKSB7XG4gICAgICAgIHRoaXMuaWRPYmogPSB7IF9pZDogaWQgfTtcbiAgICB9XG4gICAgYXN0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgZWxsaXBzZVxuICAgICAqL1xuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBlbGxpcHNlXG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBlbGxpcHNlXG4gICAgICovXG4gICAgZ2V0IHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGVsbGlwc2VcbiAgICAgKi9cbiAgICBnZXQgaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBEaW1lbnNpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBkaW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZWxsaXBzZSBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEIG9mIHRoZSBlbGxpcHNlXG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkT2JqLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZWxsaXBzZSBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKi9cbiAgICBnZXRKdXN0RHJhZ2dlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1c3REcmFnZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgc2V0SnVzdERyYWdnZWQodmFsKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGlzIGRyYWdnaW5nXG4gICAgICovXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIHNlbGVjdGlvbiBldmVudHNcbiAgICAgKi9cbiAgICB0b1NlbFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChcIiBlbGxpcHNlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIGRyYWcgZXZlbnRzXG4gICAgKi9cbiAgICB0b0RyYWdTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoXCJlbGxpcHNlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94MSArIFwiLCBcIiArIHRoaXMuX3kxICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gZWxsaXBzZSBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxufVxuZXhwb3J0cy5FbGxpcHNlRWZmZWN0ID0gRWxsaXBzZUVmZmVjdDtcbi8qKlxuICogR2V0J3MgdGhlIG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZXMgaW4gcmVsYXRpb24gdG8gdGhlIGNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB0aGUgY2FudmFzIG9iamVjdFxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0TW91c2VQb3MoY2FudmFzLCBldmVudCkge1xuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB4MSB4IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB5MSB5IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB4MiB4IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKiBAcGFyYW0geTIgeSBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MiwgMikgKyBNYXRoLnBvdyh5MSAtIHkyLCAyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbGxpcHNlRWZmZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBQYWludEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9QYWludEV2ZW50XCIpO1xuY29uc3QgUmVzaXplRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1Jlc2l6ZUV2ZW50XCIpO1xuY29uc3QgQ2xpY2tFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvQ2xpY2tFdmVudFwiKTtcbmNsYXNzIEVtb2ppRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihlbW9qaSkge1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7IC8vIHByaXZhdGUgYm9vbHNcbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmF0aW8gPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gMDtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5fbW91c2UgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9lbW9qaSA9IGVtb2ppO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gZXZhbHVhdGluZyBub2RlcyAoU3RyaW5nTm9kZSwgRWxsaXBzZU5vZGUsIGV0YylcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3NpZ25zIGFsbCBwYXJhbXMgdG8gcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIGRyYXdzIHRoZSBpbml0aWFsIG9iamVjdCB0byB0aGUgY2FudmFzXG4gICAgICogYnkgY2FsbGluZyB1cGRhdGUoKVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBwYXJlbnQgU2NvcGUgdGhhdCBjb250YWlucyB0aGUgY2FudmFzIGFtb25nIG90aGVyIHRoaW5nc1xuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBvYmplY3QncyBkaW1lbnNpb25zIGluY2x1ZGluZyB4IGFuZCB5IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGFzdCBVbm5lY2Vzc2FyeSBub3csIHVzZWQgdG8gYmUgdGhlIHBhcmVudCBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBpZiAoY29udGV4dC5jYW52YXMuaXNEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMgPSBkaW1zO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gY29udGV4dC5jYW52YXMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0LmNhbnZhcy5nZXQoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICB0aGlzLl9lbW9qaUltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgdGhpcy5fZW1vamlJbWcuc3JjID0gJy4vcGljcy8nICsgdGhpcy5fZW1vamkubmFtZS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArICcuc3ZnJztcbiAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dQYWludCgpKTtcbiAgICAgICAgY29udGV4dC5lZmZlY3RzLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGluIG9yZGVyIHRvIGRyYXcgYW5kIHJlZHJhdyB0aGUgb2JqZWN0IHdoZW4gbWFuaXB1bGF0aW9ucyBhcmUgbWFkZVxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnc7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmg7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgLy92YXIgaW1nT2JqID0gbmV3IEltYWdlKCk7XG4gICAgICAgIC8vbGV0IGN0eCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAvLyB0aGlzLl9lbW9qaUltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAvLyB0aGlzLl9lbW9qaUltZy5zcmMgPSAnLi9waWNzL2RlbW9uY293LnBuZyc7XG4gICAgICAgIC8vaW1nT2JqLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vdGhpcy5fZW1vamlJbWcub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5fY3R4LmRyYXdJbWFnZSh0aGlzLl9lbW9qaUltZywgdGhpcy54LCB0aGlzLnksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvL3RoaXMuX2Vtb2ppSW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIHRoaXMuX2Vtb2ppSW1nLndpZHRoID0gd2lkdGg7XG4gICAgICAgIC8vIHRoaXMuX2Vtb2ppSW1nLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgLy99XG4gICAgICAgIC8vfVxuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3R3VpZGVzKHgsIHksIHdpZHRoLCBoZWlnaHQsIHRoaXMuX2Nvcm5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gb25lIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25TaGlmdERvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25TaGlmdFVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy9tYWtlcyBpdCBzbyB0aGF0IGRvdWJsZSBjbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0ZXh0IG9uIHRoZSBwYWdlXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uIChlKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGZhbHNlOyB9LCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIGFub3RoZXIgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvZiB0aGUgb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgY29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAobXggPiB4ICYmIG14IDwgeCArIHcgJiYgbXkgPiB5ICYmIG15IDwgeSArIGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciA+IDAgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvbmUgb2YgdGhlIGNvcm5lci9zaWRlIGd1aWRlcywgcmV0dXJucyAwIGlmIG5vdFxuICAgICAqIFRoZSBjb3JuZXIgZ3VpZGVzIGFyZSBudW1iZXJlZCAxLTQgd2l0aCAxIGJlaW5nIHRoZSB0b3AgbGVmdCwgMiBiZWluZyB0aGUgdG9wIHJpZ2h0LCBhbmQgc28gb24uXG4gICAgICogVGhlIG1pZGRsZSBndWlkZXMgYXJlIG51bWJlcmVkIDUtOCwgd2l0aCA1IGJlaW5nIHRoZSB0b3AgbWlkZGxlLCA2IGJlaW5nIHRoZSByaWdodCBtaWRkbGUsIGFuZCBzbyBvbi5cbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ3VpZGVDb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGxldCB4ZGlmID0gbXggLSB4O1xuICAgICAgICBsZXQgeWRpZiA9IG15IC0geTtcbiAgICAgICAgLyogQ29ybmVyIEd1aWRlcyAqL1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIGxlZnRcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogTWlkZGxlIEd1aWRlcyAqL1xuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0geTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGFuZCBndWlkZXMgZm9yIHRoZSBvYmplY3Qgd2hlbiB0aGUgb2JqZWN0IGlzIHNlbGVjdGVkXG4gICAgICogSWYgb25lIG9mIHRoZSBndWlkZXMgaXMgc2VsZWN0ZWQsIGl0IGNvbG9ycyB0aGF0IGd1aWRlIGJsdWVcbiAgICAgKiBAcGFyYW0geCB0aGUgeCBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0geSB0aGUgeSBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb3JuZXIgdGhlIG51bWJlciBvZiB0aGUgY29ybmVyIHRvIGJlIGNvbG9yZWQgYmx1ZSAoaWYgYW55IGF0IGFsbCwgaWYgMCwgYWxsIGFyZSB3aGl0ZSlcbiAgICAgKi9cbiAgICBkcmF3R3VpZGVzKHgsIHksIHcsIGgsIGNvcm5lcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKGNvcm5lciAhPT0gMCAmJiBjb3JuZXIgPD0gNCkge1xuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcm5lciBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvcm5lciAhPT0gMCkge1xuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcmVtb2ppIGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgbWV0aG9kIHRoYXQgZHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geCB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5IHkgY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHcgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIGNvbG9yIG9mIHRoZSByZWN0YW5nbGUncyBmaWxsXG4gICAgICovXG4gICAgZHJhd1NxdWFyZSh4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgd2l0aGluIHRoZSBjYW52YXMuXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24sIGNhbGxzIHRoZSBtb2RpZnkgbWV0aG9kcyBpZiB0aGUgYm9vbGVhbnMgc2F0aXNmeSB0aGVtLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlEcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZXNpemluZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZSh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQ2hhbmdpbmdEaW1zICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltcyh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5U3RhdGUodGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpLCB0aGlzLmNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSB1bmNsaWNrcy5cbiAgICAgKiBDYWxscyBtb2RpZnlSZXNldCB0byByZXNldCBkcmFnZ2luZyBhbmQgcmVzaXppbmcgYm9vbGVhbnMgYW1vbmcgb3RoZXJzLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2V1cCBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VVcChldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyBwcmVzc2VkIGRvd25cbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSBwcmVzc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0VXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIE1vZGlmaWNhdGlvbiBmdW5jdGlvbnMgKi9cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgaW4gb3JkZXIgdG8gZHJhZyB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIG1vZGlmeURyYWcoKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJhbmdsZSBkcmFnb2ZmeDogXCIgKyB0aGlzLl9kcmFnb2ZmeCk7XG4gICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLl9kcmFnb2ZmeDtcbiAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueSAtIHRoaXMuX2RyYWdvZmZ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBzaXplIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQgKHdoZW4gYSBjb3JuZXIgZ3VpZGUgaXMgY2xpY2tlZCBhbmQgZHJhZ2dlZCkuXG4gICAgICpcbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDEwIGFuZCB0aGUgb3RoZXIgZXF1YWwgdG9cbiAgICAgKiAxMCBkaXZpZGVkIG9yIG11bHRpcGxpZWQgYnkgdGhlIHJhdGlvIG9mIHdpZHRoL2hlaWdodCB0byBrZWVwIGl0IHRoZSBzYW1lLlxuICAgICAqXG4gICAgICogVGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgaXMgZG9uZSBieSBjYWxsaW5nIHRoZSBoZWxwZXIgbWV0aG9kIG1vZGlmeVJlc2l6ZUhlbHBlci5cbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNpemUod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgaWYgKHdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2Vtb2ppLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2Vtb2ppLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDEwIC8gdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2Vtb2ppLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgKiB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2Vtb2ppLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTAgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIHRoZSByZWN0YW5nbGUgb3JpZ2luYXRlcyBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgYW5kIG5vdCB0aGUgY2VudGVyLFxuICAgICAqIGl0IGNoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXMgd2VsbCBpZiBndWlkZXMgMSwgMiwgb3IgNCBhcmUgc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdEaXN0YW5jZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbW91c2UgYW5kIHRoZSBsb2NhdGlvbiBvcHBvc2l0ZSB0byBpdFxuICAgICAqIChpZiB0b3AgcmlnaHQgZ3VpZGUgaXMgY2xpY2tlZCwgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhhdCBhbmQgdGhlIGJvdHRvbSBsZWZ0IGd1aWRlIGlzIG5ld0Rpc3RhbmNlKVxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSkge1xuICAgICAgICBpZiAodGhpcy53ID4gMTAgJiYgdGhpcy5oID4gMTApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQoKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAvIHRoaXMuX3JhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgIHRoaXMuX2Vtb2ppLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgdGhpcy5fZW1vamkuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQuXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMC5cbiAgICAgKiBDYWxscyBtb2RpZnlDaGFuZ2VEaW1zSGVscGVyIHRvIGFjdHVhbGx5IGRvIHRoZSB3b3JrXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5Q2hhbmdlRGltcyh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBpZiAod2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fZW1vamkud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2Vtb2ppLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGUgcmVjdGFuZ2xlIG9yaWdpbmF0ZXMgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIGFuZCBub3QgdGhlIGNlbnRlcixcbiAgICAgKiBpdCBjaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFzIHdlbGwgaWYgZ3VpZGVzIDUgb3IgOCBhcmUgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vtb2ppLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1vamkud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbW9qaS5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53ID4gMTAgJiYgdGhpcy5oID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vtb2ppLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgZGVwZW5kaW5nIG9uIHRoZSBtb3VzZSBwb3NpdGlvbiB3aGVuIGNhbGxlZCAob25Nb3VzZURvd24pXG4gICAgICogZS5nLiBpZiB0aGUgbW91c2UgaXMgd2l0aGluIHRoZSBib3VuZGluZyByZWN0YW5nbGUgd2hlbiB0aGlzIGlzIGNhbGxlZCwgaXNTZWxlY3RlZCA9IHRydWVcbiAgICAgKiBAcGFyYW0gZ3VpZGVDb250YWluc1xuICAgICAqIEBwYXJhbSBjb250YWluc1xuICAgICAqL1xuICAgIG1vZGlmeVN0YXRlKGd1aWRlQ29udGFpbnMsIGNvbnRhaW5zKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5feTEgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiAwICYmIGd1aWRlQ29udGFpbnMgPD0gNCkgeyAvL3Jlc2l6aW5nXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSB0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSk7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQxID0gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy5fd2lkdGgxID0gdGhpcy53O1xuICAgICAgICAgICAgLy90aGlzLl9zaXplMSA9IE1hdGguc3FydChNYXRoLnBvdyh3LDIpICsgTWF0aC5wb3coaCwyKSk7IC8vIHNpemUgaXMgZGlhZ29uYWwgbGVuZ3RoXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy90aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdyAvIDIsIHkgKyBoIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucyA+IDQpIHsgLy9jaGFuZ2luZyBzaGFwZSBkaW1lbnNpb25zXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IGd1aWRlQ29udGFpbnM7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdyAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSArIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICB0aGlzLl94MSA9IHg7IC8vIFNhdmluZyBvcmlnaW5hbCB4IGFuZCB5XG4gICAgICAgICAgICB0aGlzLl95MSA9IHk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgdG8gZmFsc2UgKGxpa2UgZHJhZ2dpbmcsIHJlc2l6aW5nLCBldGMpIHdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkXG4gICAgICovXG4gICAgbW9kaWZ5UmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl94MSAtIHRoaXMueCkgPiAxIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0gdGhpcy55KSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHRoaXMuX2lzUmVzaXppbmcgfHwgdGhpcy5faXNDaGFuZ2luZ0RpbXMpICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBzaXplMiA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLncsIDIpICsgTWF0aC5wb3codGhpcy5oLCAyKSk7XG4gICAgICAgICAgICBpZiAoKE1hdGguYWJzKHRoaXMuX3dpZHRoMSAtIHRoaXMudykgPiAwKSB8fCAoTWF0aC5hYnModGhpcy5faGVpZ2h0MSAtIHRoaXMuaCkgPiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1Jlc2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqIE5PVEU6IGluIEZpcmVmb3gsIHdpbmRvdy5ldmVudCBpcyBub3QgZ2xvYmFsLiBOZWVkIHRvIGJlIHBhc3NlZCBpbiBoZXJlIGFzIGEgcGFyYW1hdGVyLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgZ2V0TW91c2VQb3NpdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLl9tb3VzZS54ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueDtcbiAgICAgICAgdGhpcy5fbW91c2UueSA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNDaGFuZ2luZ0RpbXMsIGFuZCBpc1NlbGVjdGVkIHRvIGZhbHNlIGlmIHRoZSBtb3VzZSBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBpc01vdXNlT3V0c2lkZShldmVudCkge1xuICAgICAgICBsZXQgbW91c2VYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgbGV0IG1vdXNlWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIGxldCBlbW9qaSA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1vdXNlWCA8IGVtb2ppLmxlZnQgfHwgbW91c2VYID4gZW1vamkucmlnaHQgfHwgbW91c2VZIDwgZW1vamkudG9wIHx8IG1vdXNlWSA+IGVtb2ppLmJvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGFuIGVtb2ppIHBhaW50IGV2ZW50XG4gICAgICovXG4gICAgbG9nUGFpbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpbnRFdmVudF8xLlBhaW50RXZlbnQoXCJlbW9qaVwiLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYW4gZW1vamkgcmVzaXplIGV2ZW50XG4gICAgICovXG4gICAgbG9nUmVzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZUV2ZW50XzEuUmVzaXplRXZlbnQoXCJlbW9qaSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIE1hdGgucm91bmQodGhpcy5fd2lkdGgxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLl9oZWlnaHQxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLncgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuaCAqIDEwMCkgLyAxMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGFuIGVtb2ppIGNsaWNrIGV2ZW50XG4gICAgICovXG4gICAgbG9nQ2xpY2soKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xpY2tFdmVudF8xLkNsaWNrRXZlbnQoXCJlbW9qaSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIGFzc2lnbnMgYW4gSUQgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIGlkIFRoZSBJRCB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIGluaXRJRChpZCkge1xuICAgICAgICB0aGlzLmlkT2JqID0geyBfaWQ6IGlkIH07XG4gICAgfVxuICAgIGFzdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICB1cGRhdGVBU1QoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgZW1vamlcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgZW1vamlcbiAgICAgKi9cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGVtb2ppXG4gICAgICovXG4gICAgZ2V0IHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGVtb2ppXG4gICAgICovXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRGltZW5zaW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgZGltcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVtb2ppIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW1hZ2VcbiAgICAgKi9cbiAgICBnZXQgaW1hZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbW9qaUltZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIGVtb2ppXG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkT2JqLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZW1vamkgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICovXG4gICAgZ2V0SnVzdERyYWdnZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdXN0RHJhZ2dlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgZW1vamkgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBzZXRKdXN0RHJhZ2dlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVtb2ppIGlzIGRyYWdnaW5nXG4gICAgICovXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIHNlbGVjdGlvbiBldmVudHNcbiAgICAgKi9cbiAgICB0b1NlbFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiIGVtb2ppIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgZHJhZyBldmVudHNcbiAgICAqL1xuICAgIHRvRHJhZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChcImVtb2ppIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94MSArIFwiLCBcIiArIHRoaXMuX3kxICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gZW1vamkgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRW1vamlFZmZlY3QgPSBFbW9qaUVmZmVjdDtcbi8qKlxuICogR2V0cyB0aGUgbW91c2UgeCBhbmQgeSBjb29yZGluYXRlcyBpbiByZWxhdGlvbiB0byB0aGUgY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHRoZSBjYW52YXMgb2JqZWN0XG4gKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICovXG5mdW5jdGlvbiBnZXRNb3VzZVBvcyhjYW52YXMsIGV2ZW50KSB7XG4gICAgbGV0IGVtb2ppID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSBlbW9qaS5sZWZ0LFxuICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gZW1vamkudG9wXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHgxIHggY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHkxIHkgY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHgyIHggY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSB5MiB5IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgyLCAyKSArIE1hdGgucG93KHkxIC0geTIsIDIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtb2ppRWZmZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBQYWludEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9QYWludEV2ZW50XCIpO1xuY29uc3QgUmVzaXplRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1Jlc2l6ZUV2ZW50XCIpO1xuY29uc3QgQ2xpY2tFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvQ2xpY2tFdmVudFwiKTtcbmNsYXNzIEVwaEVmZmVjdCB7XG4gICAgY29uc3RydWN0b3IoZXBoKSB7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTsgLy8gcHJpdmF0ZSBib29sc1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yYXRpbyA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSAwO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9tb3VzZSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2VwaCA9IGVwaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIGV2YWx1YXRpbmcgbm9kZXMgKFN0cmluZ05vZGUsIEVsbGlwc2VOb2RlLCBldGMpXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyBhbGwgcGFyYW1zIHRvIHByaXZhdGUgdmFyaWFibGVzIGFuZCBkcmF3cyB0aGUgaW5pdGlhbCBvYmplY3QgdG8gdGhlIGNhbnZhc1xuICAgICAqIGJ5IGNhbGxpbmcgdXBkYXRlKClcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgcGFyZW50IFNjb3BlIHRoYXQgY29udGFpbnMgdGhlIGNhbnZhcyBhbW9uZyBvdGhlciB0aGluZ3NcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgb2JqZWN0J3MgZGltZW5zaW9ucyBpbmNsdWRpbmcgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBhc3QgVW5uZWNlc3Nhcnkgbm93LCB1c2VkIHRvIGJlIHRoZSBwYXJlbnQgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY2FudmFzLmlzRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zID0gZGltcztcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IGNvbnRleHQuY2FudmFzLmdldCgpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgY3R4ID0gY29udGV4dC5jYW52YXMuZ2V0KCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgICAgICAgICAgdGhpcy5fZXBoSW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICB0aGlzLl9lcGhJbWcuc3JjID0gJy4vcGljcy9kZW1vbmNvdy5wbmcnO1xuICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1BhaW50KCkpO1xuICAgICAgICBjb250ZXh0LmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gZHJhdyBhbmQgcmVkcmF3IHRoZSBvYmplY3Qgd2hlbiBtYW5pcHVsYXRpb25zIGFyZSBtYWRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudztcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuaDtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAvL3ZhciBpbWdPYmogPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgLy9sZXQgY3R4ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIC8vIHRoaXMuX2VwaEltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAvLyB0aGlzLl9lcGhJbWcuc3JjID0gJy4vcGljcy9kZW1vbmNvdy5wbmcnO1xuICAgICAgICAvL2ltZ09iai5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICAvL3RoaXMuX2VwaEltZy5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLl9jdHguZHJhd0ltYWdlKHRoaXMuX2VwaEltZywgdGhpcy54LCB0aGlzLnksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvL3RoaXMuX2VwaEltZy5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICAvLyB0aGlzLl9lcGhJbWcud2lkdGggPSB3aWR0aDtcbiAgICAgICAgLy8gdGhpcy5fZXBoSW1nLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgLy99XG4gICAgICAgIC8vfVxuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3R3VpZGVzKHgsIHksIHdpZHRoLCBoZWlnaHQsIHRoaXMuX2Nvcm5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gb25lIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25TaGlmdERvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25TaGlmdFVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy9tYWtlcyBpdCBzbyB0aGF0IGRvdWJsZSBjbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0ZXh0IG9uIHRoZSBwYWdlXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uIChlKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGZhbHNlOyB9LCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIGFub3RoZXIgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvZiB0aGUgb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgY29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAobXggPiB4ICYmIG14IDwgeCArIHcgJiYgbXkgPiB5ICYmIG15IDwgeSArIGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciA+IDAgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvbmUgb2YgdGhlIGNvcm5lci9zaWRlIGd1aWRlcywgcmV0dXJucyAwIGlmIG5vdFxuICAgICAqIFRoZSBjb3JuZXIgZ3VpZGVzIGFyZSBudW1iZXJlZCAxLTQgd2l0aCAxIGJlaW5nIHRoZSB0b3AgbGVmdCwgMiBiZWluZyB0aGUgdG9wIHJpZ2h0LCBhbmQgc28gb24uXG4gICAgICogVGhlIG1pZGRsZSBndWlkZXMgYXJlIG51bWJlcmVkIDUtOCwgd2l0aCA1IGJlaW5nIHRoZSB0b3AgbWlkZGxlLCA2IGJlaW5nIHRoZSByaWdodCBtaWRkbGUsIGFuZCBzbyBvbi5cbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ3VpZGVDb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGxldCB4ZGlmID0gbXggLSB4O1xuICAgICAgICBsZXQgeWRpZiA9IG15IC0geTtcbiAgICAgICAgLyogQ29ybmVyIEd1aWRlcyAqL1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIGxlZnRcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogTWlkZGxlIEd1aWRlcyAqL1xuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0geTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGFuZCBndWlkZXMgZm9yIHRoZSBvYmplY3Qgd2hlbiB0aGUgb2JqZWN0IGlzIHNlbGVjdGVkXG4gICAgICogSWYgb25lIG9mIHRoZSBndWlkZXMgaXMgc2VsZWN0ZWQsIGl0IGNvbG9ycyB0aGF0IGd1aWRlIGJsdWVcbiAgICAgKiBAcGFyYW0geCB0aGUgeCBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0geSB0aGUgeSBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb3JuZXIgdGhlIG51bWJlciBvZiB0aGUgY29ybmVyIHRvIGJlIGNvbG9yZWQgYmx1ZSAoaWYgYW55IGF0IGFsbCwgaWYgMCwgYWxsIGFyZSB3aGl0ZSlcbiAgICAgKi9cbiAgICBkcmF3R3VpZGVzKHgsIHksIHcsIGgsIGNvcm5lcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKGNvcm5lciAhPT0gMCAmJiBjb3JuZXIgPD0gNCkge1xuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcmVwaCBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvcm5lciAhPT0gMCkge1xuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcmVwaCBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltcGxlIG1ldGhvZCB0aGF0IGRyYXdzIGEgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHggeCBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geSB5IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB3IHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb2xvciBjb2xvciBvZiB0aGUgcmVjdGFuZ2xlJ3MgZmlsbFxuICAgICAqL1xuICAgIGRyYXdTcXVhcmUoeCwgeSwgdywgaCwgY29sb3IpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIHdpdGhpbiB0aGUgY2FudmFzLlxuICAgICAqIEdldHMgdGhlIG1vdXNlIHBvc2l0aW9uLCBjYWxscyB0aGUgbW9kaWZ5IG1ldGhvZHMgaWYgdGhlIGJvb2xlYW5zIHNhdGlzZnkgdGhlbS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldmVudCk7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5RHJhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemUodGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0NoYW5naW5nRGltcyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXModGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIGNsaWNrcyBpbnNpZGUgdGhlIGNhbnZhcy5cbiAgICAgKiBNb2RpZmllcyB0aGUgc3RhdGUgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGd1aWRlcyBjb250YWluIHRoZSBtb3VzZSBvciB0aGUgYm91bmRpbmcgcmVjdCBjb250YWlucyB0aGUgbW91c2UuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVN0YXRlKHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSwgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgdW5jbGlja3MuXG4gICAgICogQ2FsbHMgbW9kaWZ5UmVzZXQgdG8gcmVzZXQgZHJhZ2dpbmcgYW5kIHJlc2l6aW5nIGJvb2xlYW5zIGFtb25nIG90aGVycy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNldXAgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlSZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcHJlc3NlZCBkb3duXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcHJlc3NlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdERvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdFVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBNb2RpZmljYXRpb24gZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGRyYWcgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBtb2RpZnlEcmFnKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiZXBoYW5nbGUgZHJhZ29mZng6IFwiICsgdGhpcy5fZHJhZ29mZngpO1xuICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS54IC0gdGhpcy5fZHJhZ29mZng7XG4gICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLl9kcmFnb2ZmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkICh3aGVuIGEgY29ybmVyIGd1aWRlIGlzIGNsaWNrZWQgYW5kIGRyYWdnZWQpLlxuICAgICAqXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMCBhbmQgdGhlIG90aGVyIGVxdWFsIHRvXG4gICAgICogMTAgZGl2aWRlZCBvciBtdWx0aXBsaWVkIGJ5IHRoZSByYXRpbyBvZiB3aWR0aC9oZWlnaHQgdG8ga2VlcCBpdCB0aGUgc2FtZS5cbiAgICAgKlxuICAgICAqIFRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIGlzIGRvbmUgYnkgY2FsbGluZyB0aGUgaGVscGVyIG1ldGhvZCBtb2RpZnlSZXNpemVIZWxwZXIuXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9lcGgud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMCAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fZXBoLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDEwIC8gdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2VwaC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwICogdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9lcGgud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyAxLCAyLCBvciA0IGFyZSBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0Rpc3RhbmNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBtb3VzZSBhbmQgdGhlIGxvY2F0aW9uIG9wcG9zaXRlIHRvIGl0XG4gICAgICogKGlmIHRvcCByaWdodCBndWlkZSBpcyBjbGlja2VkLCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGFuZCB0aGUgYm90dG9tIGxlZnQgZ3VpZGUgaXMgbmV3RGlzdGFuY2UpXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgdGhpcy5fZXBoLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgdGhpcy5fZXBoLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkLlxuICAgICAqIElmIGFueSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgdG9vIHNtYWxsLCBpdCBzZXRzIHRoZW0gZXF1YWwgdG8gMTAuXG4gICAgICogQ2FsbHMgbW9kaWZ5Q2hhbmdlRGltc0hlbHBlciB0byBhY3R1YWxseSBkbyB0aGUgd29ya1xuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqL1xuICAgIG1vZGlmeUNoYW5nZURpbXMod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgaWYgKHdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2VwaC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fZXBoLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGUgcmVjdGFuZ2xlIG9yaWdpbmF0ZXMgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIGFuZCBub3QgdGhlIGNlbnRlcixcbiAgICAgKiBpdCBjaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFzIHdlbGwgaWYgZ3VpZGVzIDUgb3IgOCBhcmUgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VwaC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VwaC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VwaC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53ID4gMTAgJiYgdGhpcy5oID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VwaC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIGRlcGVuZGluZyBvbiB0aGUgbW91c2UgcG9zaXRpb24gd2hlbiBjYWxsZWQgKG9uTW91c2VEb3duKVxuICAgICAqIGUuZy4gaWYgdGhlIG1vdXNlIGlzIHdpdGhpbiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIHdoZW4gdGhpcyBpcyBjYWxsZWQsIGlzU2VsZWN0ZWQgPSB0cnVlXG4gICAgICogQHBhcmFtIGd1aWRlQ29udGFpbnNcbiAgICAgKiBAcGFyYW0gY29udGFpbnNcbiAgICAgKi9cbiAgICBtb2RpZnlTdGF0ZShndWlkZUNvbnRhaW5zLCBjb250YWlucykge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kxID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gMCAmJiBndWlkZUNvbnRhaW5zIDw9IDQpIHsgLy9yZXNpemluZ1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gdGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0MSA9IHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoMSA9IHRoaXMudztcbiAgICAgICAgICAgIC8vdGhpcy5fc2l6ZTEgPSBNYXRoLnNxcnQoTWF0aC5wb3codywyKSArIE1hdGgucG93KGgsMikpOyAvLyBzaXplIGlzIGRpYWdvbmFsIGxlbmd0aFxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5ICsgaCAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiA0KSB7IC8vY2hhbmdpbmcgc2hhcGUgZGltZW5zaW9uc1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSBndWlkZUNvbnRhaW5zO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5ICsgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgdGhpcy5feDEgPSB4OyAvLyBTYXZpbmcgb3JpZ2luYWwgeCBhbmQgeVxuICAgICAgICAgICAgdGhpcy5feTEgPSB5O1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIHRvIGZhbHNlIChsaWtlIGRyYWdnaW5nLCByZXNpemluZywgZXRjKSB3aGVuIHRoZSBtb3VzZSBpcyByZWxlYXNlZFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB0aGlzLngpID4gMSB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHRoaXMueSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh0aGlzLl9pc1Jlc2l6aW5nIHx8IHRoaXMuX2lzQ2hhbmdpbmdEaW1zKSAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc2l6ZTIgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53LCAyKSArIE1hdGgucG93KHRoaXMuaCwgMikpO1xuICAgICAgICAgICAgaWYgKChNYXRoLmFicyh0aGlzLl93aWR0aDEgLSB0aGlzLncpID4gMCkgfHwgKE1hdGguYWJzKHRoaXMuX2hlaWdodDEgLSB0aGlzLmgpID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dSZXNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKiBOT1RFOiBpbiBGaXJlZm94LCB3aW5kb3cuZXZlbnQgaXMgbm90IGdsb2JhbC4gTmVlZCB0byBiZSBwYXNzZWQgaW4gaGVyZSBhcyBhIHBhcmFtYXRlci5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIGdldE1vdXNlUG9zaXRpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fbW91c2UueCA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLng7XG4gICAgICAgIHRoaXMuX21vdXNlLnkgPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzQ2hhbmdpbmdEaW1zLCBhbmQgaXNTZWxlY3RlZCB0byBmYWxzZSBpZiB0aGUgbW91c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgaXNNb3VzZU91dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBsZXQgZXBoID0gdGhpcy5fY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobW91c2VYIDwgZXBoLmxlZnQgfHwgbW91c2VYID4gZXBoLnJpZ2h0IHx8IG1vdXNlWSA8IGVwaC50b3AgfHwgbW91c2VZID4gZXBoLmJvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGFuIGVwaCBwYWludCBldmVudFxuICAgICAqL1xuICAgIGxvZ1BhaW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhaW50RXZlbnRfMS5QYWludEV2ZW50KFwiZXBoXCIsIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhbiBlcGggcmVzaXplIGV2ZW50XG4gICAgICovXG4gICAgbG9nUmVzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZUV2ZW50XzEuUmVzaXplRXZlbnQoXCJlcGggd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCBNYXRoLnJvdW5kKHRoaXMuX3dpZHRoMSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5faGVpZ2h0MSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy53ICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLmggKiAxMDApIC8gMTAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhbiBlcGggY2xpY2sgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dDbGljaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGlja0V2ZW50XzEuQ2xpY2tFdmVudChcImVwaCB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIGFzc2lnbnMgYW4gSUQgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIGlkIFRoZSBJRCB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIGluaXRJRChpZCkge1xuICAgICAgICB0aGlzLmlkT2JqID0geyBfaWQ6IGlkIH07XG4gICAgfVxuICAgIGFzdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICB1cGRhdGVBU1QoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgZXBoXG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIGVwaFxuICAgICAqL1xuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgZXBoXG4gICAgICovXG4gICAgZ2V0IHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGVwaFxuICAgICAqL1xuICAgIGdldCBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERpbWVuc2lvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlcGggaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbWFnZVxuICAgICAqL1xuICAgIGdldCBpbWFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VwaEltZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIGVwaFxuICAgICAqL1xuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZE9iai5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVwaCBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKi9cbiAgICBnZXRKdXN0RHJhZ2dlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1c3REcmFnZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBlcGggaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBzZXRKdXN0RHJhZ2dlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVwaCBpcyBkcmFnZ2luZ1xuICAgICAqL1xuICAgIGdldCBpc0RyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEcmFnZ2luZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBzZWxlY3Rpb24gZXZlbnRzXG4gICAgICovXG4gICAgdG9TZWxTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIiBlcGggd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBkcmFnIGV2ZW50c1xuICAgICovXG4gICAgdG9EcmFnU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKFwiZXBoIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94MSArIFwiLCBcIiArIHRoaXMuX3kxICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gZXBoIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG59XG5leHBvcnRzLkVwaEVmZmVjdCA9IEVwaEVmZmVjdDtcbi8qKlxuICogR2V0cyB0aGUgbW91c2UgeCBhbmQgeSBjb29yZGluYXRlcyBpbiByZWxhdGlvbiB0byB0aGUgY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHRoZSBjYW52YXMgb2JqZWN0XG4gKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICovXG5mdW5jdGlvbiBnZXRNb3VzZVBvcyhjYW52YXMsIGV2ZW50KSB7XG4gICAgbGV0IGVwaCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gZXBoLmxlZnQsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSBlcGgudG9wXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHgxIHggY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHkxIHkgY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHgyIHggY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSB5MiB5IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgyLCAyKSArIE1hdGgucG93KHkxIC0geTIsIDIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVwaEVmZmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgUGFpbnRFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUGFpbnRFdmVudFwiKTtcbmNvbnN0IFJlc2l6ZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9SZXNpemVFdmVudFwiKTtcbmNvbnN0IENsaWNrRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL0NsaWNrRXZlbnRcIik7XG5jbGFzcyBMaW5lRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihsaW5lKSB7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTsgLy8gcHJpdmF0ZSBib29sc1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yYXRpbyA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSAwO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9tb3VzZSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2xpbmUgPSBsaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gZXZhbHVhdGluZyBub2RlcyAoU3RyaW5nTm9kZSwgRWxsaXBzZU5vZGUsIGV0YylcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3NpZ25zIGFsbCBwYXJhbXMgdG8gcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIGRyYXdzIHRoZSBpbml0aWFsIG9iamVjdCB0byB0aGUgY2FudmFzXG4gICAgICogYnkgY2FsbGluZyB1cGRhdGUoKVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBwYXJlbnQgU2NvcGUgdGhhdCBjb250YWlucyB0aGUgY2FudmFzIGFtb25nIG90aGVyIHRoaW5nc1xuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBvYmplY3QncyBkaW1lbnNpb25zIGluY2x1ZGluZyB4IGFuZCB5IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGFzdCBVbm5lY2Vzc2FyeSBub3csIHVzZWQgdG8gYmUgdGhlIHBhcmVudCBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBpZiAoY29udGV4dC5jYW52YXMuaXNEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMgPSBkaW1zO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gY29udGV4dC5jYW52YXMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0LmNhbnZhcy5nZXQoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUGFpbnQoKSk7XG4gICAgICAgIGNvbnRleHQuZWZmZWN0cy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBpbiBvcmRlciB0byBkcmF3IGFuZCByZWRyYXcgdGhlIG9iamVjdCB3aGVuIG1hbmlwdWxhdGlvbnMgYXJlIG1hZGVcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy53O1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5oO1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuX2N0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gXCIjNjczQUI3XCI7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0d1aWRlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0aGlzLl9jb3JuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIG9uZSBmZWxsIHN3b29wXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpOyAvLyBiaW5kIGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBtZWFuaW5nIG9mICd0aGlzJ1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uU2hpZnREb3duLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uU2hpZnRVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaXNNb3VzZU91dHNpZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vbWFrZXMgaXQgc28gdGhhdCBkb3VibGUgY2xpY2tpbmcgZG9lc24ndCBzZWxlY3QgdGV4dCBvbiB0aGUgcGFnZVxuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBmdW5jdGlvbiAoZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IHJldHVybiBmYWxzZTsgfSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBhbm90aGVyIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb2YgdGhlIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSwgZmFsc2UgaWYgb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgaWYgKG14ID4geCAmJiBteCA8IHggKyB3ICYmIG15ID4geSAmJiBteSA8IHkgKyBoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgPiAwIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb25lIG9mIHRoZSBjb3JuZXIvc2lkZSBndWlkZXMsIHJldHVybnMgMCBpZiBub3RcbiAgICAgKiBUaGUgY29ybmVyIGd1aWRlcyBhcmUgbnVtYmVyZWQgMS00IHdpdGggMSBiZWluZyB0aGUgdG9wIGxlZnQsIDIgYmVpbmcgdGhlIHRvcCByaWdodCwgYW5kIHNvIG9uLlxuICAgICAqIFRoZSBtaWRkbGUgZ3VpZGVzIGFyZSBudW1iZXJlZCA1LTgsIHdpdGggNSBiZWluZyB0aGUgdG9wIG1pZGRsZSwgNiBiZWluZyB0aGUgcmlnaHQgbWlkZGxlLCBhbmQgc28gb24uXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGd1aWRlQ29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBsZXQgeGRpZiA9IG14IC0geDtcbiAgICAgICAgbGV0IHlkaWYgPSBteSAtIHk7XG4gICAgICAgIC8qIENvcm5lciBHdWlkZXMgKi9cbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGgpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSB4O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICB9XG4gICAgICAgIC8qIE1pZGRsZSBHdWlkZXMgKi9cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3IC8gMik7XG4gICAgICAgIHlkaWYgPSBteSAtIHk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGggLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3IC8gMik7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSB4O1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGggLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBhbmQgZ3VpZGVzIGZvciB0aGUgb2JqZWN0IHdoZW4gdGhlIG9iamVjdCBpcyBzZWxlY3RlZFxuICAgICAqIElmIG9uZSBvZiB0aGUgZ3VpZGVzIGlzIHNlbGVjdGVkLCBpdCBjb2xvcnMgdGhhdCBndWlkZSBibHVlXG4gICAgICogQHBhcmFtIHggdGhlIHggY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHkgdGhlIHkgY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHcgdGhlIHdpZHRoIG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29ybmVyIHRoZSBudW1iZXIgb2YgdGhlIGNvcm5lciB0byBiZSBjb2xvcmVkIGJsdWUgKGlmIGFueSBhdCBhbGwsIGlmIDAsIGFsbCBhcmUgd2hpdGUpXG4gICAgICovXG4gICAgZHJhd0d1aWRlcyh4LCB5LCB3LCBoLCBjb3JuZXIpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmIChjb3JuZXIgIT09IDAgJiYgY29ybmVyIDw9IDQpIHsgLy8gYSBjb3JuZXIgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29ybmVyICE9PSAwKSB7IC8vIGEgbWlkZGxlIGd1aWRlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgY29ycmVjdCBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvL2lmIG5vIGd1aWRlcyBhcmUgc2VsZWN0ZWQsIGNvbG9ycyBldmVyeXRoaW5nIHdoaXRlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgbWV0aG9kIHRoYXQgZHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geCB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5IHkgY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHcgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIGNvbG9yIG9mIHRoZSByZWN0YW5nbGUncyBmaWxsXG4gICAgICovXG4gICAgZHJhd1NxdWFyZSh4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgd2l0aGluIHRoZSBjYW52YXMuXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24sIGNhbGxzIHRoZSBtb2RpZnkgbWV0aG9kcyBpZiB0aGUgYm9vbGVhbnMgc2F0aXNmeSB0aGVtLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlEcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZXNpemluZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZSh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQ2hhbmdpbmdEaW1zICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltcyh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5U3RhdGUodGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpLCB0aGlzLmNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSB1bmNsaWNrcy5cbiAgICAgKiBDYWxscyBtb2RpZnlSZXNldCB0byByZXNldCBkcmFnZ2luZyBhbmQgcmVzaXppbmcgYm9vbGVhbnMgYW1vbmcgb3RoZXJzLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2V1cCBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VVcChldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyBwcmVzc2VkIGRvd25cbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSBwcmVzc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcmVsZWFzZWRcbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSByZWxlYXNlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdFVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBNb2RpZmljYXRpb24gZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGRyYWcgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBtb2RpZnlEcmFnKCkge1xuICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS54IC0gdGhpcy5fZHJhZ29mZng7XG4gICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLl9kcmFnb2ZmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkICh3aGVuIGEgY29ybmVyIGd1aWRlIGlzIGNsaWNrZWQgYW5kIGRyYWdnZWQpLlxuICAgICAqXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMCBhbmQgdGhlIG90aGVyIGVxdWFsIHRvXG4gICAgICogMTAgZGl2aWRlZCBvciBtdWx0aXBsaWVkIGJ5IHRoZSByYXRpbyBvZiB3aWR0aC9oZWlnaHQgdG8ga2VlcCBpdCB0aGUgc2FtZS5cbiAgICAgKlxuICAgICAqIFRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIGlzIGRvbmUgYnkgY2FsbGluZyB0aGUgaGVscGVyIG1ldGhvZCBtb2RpZnlSZXNpemVIZWxwZXIuXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9saW5lLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTsgLy8gc2V0IGZvciB0aGUgcHJvZGlyZWN0IG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMCAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fbGluZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDEwIC8gdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApOyAvLyBzZXQgZm9yIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgKiB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2xpbmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyAxLCAyLCBvciA0IGFyZSBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0Rpc3RhbmNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBtb3VzZSBhbmQgdGhlIGxvY2F0aW9uIG9wcG9zaXRlIHRvIGl0XG4gICAgICogKGlmIHRvcCByaWdodCBndWlkZSBpcyBjbGlja2VkLCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGFuZCB0aGUgYm90dG9tIGxlZnQgZ3VpZGUgaXMgbmV3RGlzdGFuY2UpXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgdGhpcy5fbGluZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW87XG4gICAgICAgIHRoaXMuX2xpbmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZC5cbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDEwLlxuICAgICAqIENhbGxzIG1vZGlmeUNoYW5nZURpbXNIZWxwZXIgdG8gYWN0dWFsbHkgZG8gdGhlIHdvcmtcbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9saW5lLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9saW5lLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIHRoZSByZWN0YW5nbGUgb3JpZ2luYXRlcyBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgYW5kIG5vdCB0aGUgY2VudGVyLFxuICAgICAqIGl0IGNoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXMgd2VsbCBpZiBndWlkZXMgNSBvciA4IGFyZSBzZWxlY3RlZFxuICAgICAqL1xuICAgIG1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKSB7XG4gICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaCA+IDEwKSB7IC8vYXMgbG9uZyBhcyB0aGUgaGVpZ2h0IGlzID4gMTBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLncgPiAxMCkgeyAvLyBhcyBsb25nIGFzIHdpZHRoIGlzID4gMTBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyBkZXBlbmRpbmcgb24gdGhlIG1vdXNlIHBvc2l0aW9uIHdoZW4gY2FsbGVkIChvbk1vdXNlRG93bilcbiAgICAgKiBlLmcuIGlmIHRoZSBtb3VzZSBpcyB3aXRoaW4gdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSB3aGVuIHRoaXMgaXMgY2FsbGVkLCBpc1NlbGVjdGVkID0gdHJ1ZVxuICAgICAqIEBwYXJhbSBndWlkZUNvbnRhaW5zXG4gICAgICogQHBhcmFtIGNvbnRhaW5zXG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGUoZ3VpZGVDb250YWlucywgY29udGFpbnMpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7IC8vcHJlcGFyZXMgdGhlIG9iamVjdCBmb3IgZHJhZ2dpbmcgd2hldGhlciBpdCBpcyBwZXJzb25hbGx5IHNlbGVjdGVkIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5feTEgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiAwICYmIGd1aWRlQ29udGFpbnMgPD0gNCkgeyAvL3Jlc2l6aW5nXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSB0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSk7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQxID0gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy5fd2lkdGgxID0gdGhpcy53O1xuICAgICAgICAgICAgLy90aGlzLl9zaXplMSA9IE1hdGguc3FydChNYXRoLnBvdyh3LDIpICsgTWF0aC5wb3coaCwyKSk7IC8vIHNpemUgaXMgZGlhZ29uYWwgbGVuZ3RoXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikgeyAvLyBzZXRzIHRoZSBvZmZzZXRzIGRlcGVuZGluZyBvbiB3aGljaCBjb3JuZXIgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7IC8vIG9mZnNldCBpcyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7IC8vIG9mZnNldCBpcyBib3R0b20gbGVmdCwgZXRjXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gNCkgeyAvL2NoYW5naW5nIHNoYXBlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gZ3VpZGVDb250YWlucztcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7IC8vIHNldHMgdGhlIG9mZnNldHMgZGVwZW5kaW5nIG9uIHdoaWNoIG1pZGRsZSBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgNTogLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdyAvIDIsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdyAvIDI7IC8vIG9mZnNldCBpcyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogLy9yaWdodCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoIC8gMjsgLy8gb2Zmc2V0IGlzIGxlZnQgbWlkZGxlIGV0Y1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWlucykgeyAvLyBkcmFnZ2luZ1xuICAgICAgICAgICAgdGhpcy5feDEgPSB4OyAvLyBTYXZpbmcgb3JpZ2luYWwgeCBhbmQgeVxuICAgICAgICAgICAgdGhpcy5feTEgPSB5O1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy8gbm90IHNlbGVjdGVkXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyB0byBmYWxzZSAobGlrZSBkcmFnZ2luZywgcmVzaXppbmcsIGV0Yykgd2hlbiB0aGUgbW91c2UgaXMgcmVsZWFzZWRcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0gdGhpcy54KSA+IDEgfHwgTWF0aC5hYnModGhpcy5feTEgLSB0aGlzLnkpID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodGhpcy5faXNSZXNpemluZyB8fCB0aGlzLl9pc0NoYW5naW5nRGltcykgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHNpemUyID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMudywgMikgKyBNYXRoLnBvdyh0aGlzLmgsIDIpKTtcbiAgICAgICAgICAgIGlmICgoTWF0aC5hYnModGhpcy5fd2lkdGgxIC0gdGhpcy53KSA+IDApIHx8IChNYXRoLmFicyh0aGlzLl9oZWlnaHQxIC0gdGhpcy5oKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUmVzaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICogTk9URTogaW4gRmlyZWZveCwgd2luZG93LmV2ZW50IGlzIG5vdCBnbG9iYWwuIE5lZWQgdG8gYmUgcGFzc2VkIGluIGhlcmUgYXMgYSBwYXJhbWF0ZXIuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBnZXRNb3VzZVBvc2l0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX21vdXNlLnggPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS54O1xuICAgICAgICB0aGlzLl9tb3VzZS55ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0NoYW5naW5nRGltcywgYW5kIGlzU2VsZWN0ZWQgdG8gZmFsc2UgaWYgdGhlIG1vdXNlIGNsaWNrcyBvdXRzaWRlIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIGlzTW91c2VPdXRzaWRlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgICAgICBsZXQgbW91c2VZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtb3VzZVggPCByZWN0LmxlZnQgfHwgbW91c2VYID4gcmVjdC5yaWdodCB8fCBtb3VzZVkgPCByZWN0LnRvcCB8fCBtb3VzZVkgPiByZWN0LmJvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlY3RhbmdsZSBwYWludCBldmVudFxuICAgICAqL1xuICAgIGxvZ1BhaW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhaW50RXZlbnRfMS5QYWludEV2ZW50KFwicmVjdGFuZ2xlXCIsIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlY3RhbmdsZSByZXNpemUgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dSZXNpemUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplRXZlbnRfMS5SZXNpemVFdmVudChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIE1hdGgucm91bmQodGhpcy5fd2lkdGgxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLl9oZWlnaHQxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLncgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuaCAqIDEwMCkgLyAxMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIGNsaWNrIGV2ZW50XG4gICAgICovXG4gICAgbG9nQ2xpY2soKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xpY2tFdmVudF8xLkNsaWNrRXZlbnQoXCJyZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCBhc3NpZ25zIGFuIElEIHRvIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSBpZCBUaGUgSUQgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBpbml0SUQoaWQpIHtcbiAgICAgICAgdGhpcy5pZE9iaiA9IHsgX2lkOiBpZCB9O1xuICAgIH1cbiAgICBhc3QoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERpbWVuc2lvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRPYmouX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqL1xuICAgIGdldEp1c3REcmFnZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fanVzdERyYWdnZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBzZXRKdXN0RHJhZ2dlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaXMgZHJhZ2dpbmdcbiAgICAgKi9cbiAgICBnZXQgaXNEcmFnZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRHJhZ2dpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3Igc2VsZWN0aW9uIGV2ZW50c1xuICAgICAqL1xuICAgIHRvU2VsU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCIgcmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgZHJhZyBldmVudHNcbiAgICAqL1xuICAgIHRvRHJhZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBmcm9tIFwiICsgdGhpcy5feDEgKyBcIiwgXCIgKyB0aGlzLl95MSArIFwiIHRvIFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBJRCBhc3NpZ25tZW50IGV2ZW50c1xuICAgICAqL1xuICAgIHRvSURTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pZE9iai5faWQudG9TdHJpbmcoKSArIFwiIHRvIHJlY3RhbmdsZSBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxufVxuZXhwb3J0cy5MaW5lRWZmZWN0ID0gTGluZUVmZmVjdDtcbi8qKlxuICogR2V0cyB0aGUgbW91c2UgeCBhbmQgeSBjb29yZGluYXRlcyBpbiByZWxhdGlvbiB0byB0aGUgY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHRoZSBjYW52YXMgb2JqZWN0XG4gKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICovXG5mdW5jdGlvbiBnZXRNb3VzZVBvcyhjYW52YXMsIGV2ZW50KSB7XG4gICAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHgxIHggY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHkxIHkgY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHgyIHggY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSB5MiB5IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgyLCAyKSArIE1hdGgucG93KHkxIC0geTIsIDIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmVFZmZlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBQYWludEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9QYWludEV2ZW50XCIpO1xuY29uc3QgUmVzaXplRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1Jlc2l6ZUV2ZW50XCIpO1xuY29uc3QgQ2xpY2tFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvQ2xpY2tFdmVudFwiKTtcbmNsYXNzIE51bWJlckVmZmVjdCB7XG4gICAgY29uc3RydWN0b3IobnVtKSB7XG4gICAgICAgIHRoaXMuX2ZvbnRTaXplID0gMjA7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0xpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gMDtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5fbW91c2UgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzID0ge1xuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBpbnRlcnZhbDogMCxcbiAgICAgICAgICAgIHN0cjogXCJcIixcbiAgICAgICAgICAgIGluaXRNb3VzZVBvczogMCxcbiAgICAgICAgICAgIGN1cnNvclBvczogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9udW0gPSBudW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiBldmFsdWF0aW5nIG5vZGVzIChTdHJpbmdOb2RlLCBFbGxpcHNlTm9kZSwgZXRjKVxuICAgICAqIFRoaXMgbWV0aG9kIGFzc2lnbnMgYWxsIHBhcmFtcyB0byBwcml2YXRlIHZhcmlhYmxlcyBhbmQgZHJhd3MgdGhlIGluaXRpYWwgb2JqZWN0IHRvIHRoZSBjYW52YXNcbiAgICAgKiBieSBjYWxsaW5nIHVwZGF0ZSgpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIHBhcmVudCBTY29wZSB0aGF0IGNvbnRhaW5zIHRoZSBjYW52YXMgYW1vbmcgb3RoZXIgdGhpbmdzXG4gICAgICogQHBhcmFtIGRpbXMgVGhlIG9iamVjdCdzIGRpbWVuc2lvbnMgaW5jbHVkaW5nIHggYW5kIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gYXN0IFVubmVjZXNzYXJ5IG5vdywgdXNlZCB0byBiZSB0aGUgcGFyZW50IEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNhbnZhcyAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gY29udGV4dC5jYW52YXMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9kaW1zID0gZGltcztcbiAgICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0LmNhbnZhcy5nZXQoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgLy8gbG9nZ2luZ1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUGFpbnQoKSk7IC8vIHRoaXMuY29udGV4dCBvciBjb250ZXh0P1xuICAgICAgICAgICAgY29udGV4dC5lZmZlY3RzLnB1c2godGhpcyk7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNhbnZhcyBpcyBOT1QgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gZHJhdyBhbmQgcmVkcmF3IHRoZSBvYmplY3Qgd2hlbiBtYW5pcHVsYXRpb25zIGFyZSBtYWRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgZm9udERlZXRzID0gdGhpcy5fZm9udFNpemUgKyBcInB4IENvdXJpZXIgTmV3XCI7XG4gICAgICAgIHRoaXMuX2N0eC5mb250ID0gZm9udERlZXRzO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gXCIjNjczQUI3XCI7XG4gICAgICAgIGxldCBzdHIgPSB0aGlzLl9udW0udG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxUZXh0KHN0ciwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICBsZXQgbnVtYmVyRGltcyA9IHRoaXMuX2N0eC5tZWFzdXJlVGV4dChzdHIpO1xuICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLndpZHRoID0gbnVtYmVyRGltcy53aWR0aDtcbiAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5oZWlnaHQgPSB0aGlzLl9mb250U2l6ZTtcbiAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5zdHIgPSBzdHI7XG4gICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuaW50ZXJ2YWwgPSB0aGlzLl9udW1iZXJNZXRyaWNzLndpZHRoIC8gdGhpcy5fbnVtYmVyTWV0cmljcy5zdHIubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3VGV4dEd1aWRlcyh0aGlzLngsIHRoaXMueSAtIHRoaXMuX2ZvbnRTaXplLCB0aGlzLl9udW1iZXJNZXRyaWNzLndpZHRoLCB0aGlzLl9udW1iZXJNZXRyaWNzLmhlaWdodCwgdGhpcy5fY29ybmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNFZGl0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBvbmUgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTsgLy8gYmluZCBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgbWVhbmluZyBvZiAndGhpcydcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vblNoaWZ0RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vblNoaWZ0VXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmlzTW91c2VPdXRzaWRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL21ha2VzIGl0IHNvIHRoYXQgZG91YmxlIGNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRleHQgb24gdGhlIHBhZ2VcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgZnVuY3Rpb24gKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZmFsc2U7IH0sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gYW5vdGhlciBmZWxsIHN3b29wXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9mIHRoZSBvYmplY3QncyBib3VuZGluZyByZWN0YW5nbGUsIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBjb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnggPD0gbXgpICYmICh0aGlzLnggKyB0aGlzLl9udW1iZXJNZXRyaWNzLndpZHRoID49IG14KSAmJlxuICAgICAgICAgICAgKHRoaXMueSAtIHRoaXMuX2ZvbnRTaXplIDw9IG15KSAmJiAodGhpcy55ID49IG15KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciA+IDAgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvbmUgb2YgdGhlIGNvcm5lci9zaWRlIGd1aWRlcywgcmV0dXJucyAwIGlmIG5vdFxuICAgICAqIFRoZSBjb3JuZXIgZ3VpZGVzIGFyZSBudW1iZXJlZCAxLTQgd2l0aCAxIGJlaW5nIHRoZSB0b3AgbGVmdCwgMiBiZWluZyB0aGUgdG9wIHJpZ2h0LCBhbmQgc28gb24uXG4gICAgICogVGhlIG1pZGRsZSBndWlkZXMgYXJlIG51bWJlcmVkIDUtOCwgd2l0aCA1IGJlaW5nIHRoZSB0b3AgbWlkZGxlLCA2IGJlaW5nIHRoZSByaWdodCBtaWRkbGUsIGFuZCBzbyBvbi5cbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ3VpZGVDb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHhkaWYgPSBteCAtICh0aGlzLnggKyB0aGlzLl9udW1iZXJNZXRyaWNzLndpZHRoKTtcbiAgICAgICAgbGV0IHlkaWYgPSBteSAtICh0aGlzLnkgLSB0aGlzLl9mb250U2l6ZSk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBib3VuZGluZyByZWN0YW5nbGUgYW5kIGd1aWRlcyBmb3IgdGhlIG9iamVjdCB3aGVuIHRoZSBvYmplY3QgaXMgc2VsZWN0ZWRcbiAgICAgKiBJZiBvbmUgb2YgdGhlIGd1aWRlcyBpcyBzZWxlY3RlZCwgaXQgY29sb3JzIHRoYXQgZ3VpZGUgYmx1ZVxuICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB5IHRoZSB5IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB3IHRoZSB3aWR0aCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggdGhlIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvcm5lciB0aGUgbnVtYmVyIG9mIHRoZSBjb3JuZXIgdG8gYmUgY29sb3JlZCBibHVlIChpZiBhbnkgYXQgYWxsLCBpZiAwLCBhbGwgYXJlIHdoaXRlKVxuICAgICAqL1xuICAgIGRyYXdUZXh0R3VpZGVzKHgsIHksIHcsIGgsIGNvcm5lcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKGNvcm5lciAhPT0gMCkge1xuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGd1aWRlIGJsdWUgaWYgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBtZXRob2QgdGhhdCBkcmF3cyBhIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB4IHggY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHkgeSBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gdyB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29sb3IgY29sb3Igb2YgdGhlIHJlY3RhbmdsZSdzIGZpbGxcbiAgICAgKi9cbiAgICBkcmF3U3F1YXJlKHgsIHksIHcsIGgsIGNvbG9yKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgLyogRXZlbnQgbGlzdGVuZXIgZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBtb3ZlcyB3aXRoaW4gdGhlIGNhbnZhcy5cbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiwgY2FsbHMgdGhlIG1vZGlmeSBtZXRob2RzIGlmIHRoZSBib29sZWFucyBzYXRpc2Z5IHRoZW0uXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCAmJiB0aGlzLl9pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeURyYWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jlc2l6aW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplKHRoaXMuX2ZvbnRTaXplIDwgMTUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSAmJiB0aGlzLl9pc1NlbGVjdGVkICYmIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpIHsgLy90ZXh0IGVkaXRpbmdcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMubW9kaWZ5VGV4dC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2lzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmluaXRNb3VzZVBvcyA9IHRoaXMuX21vdXNlLng7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGlmeVN0YXRlKHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSA+IDAsIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIHVuY2xpY2tzLlxuICAgICAqIENhbGxzIG1vZGlmeVJlc2V0IHRvIHJlc2V0IGRyYWdnaW5nIGFuZCByZXNpemluZyBib29sZWFucyBhbW9uZyBvdGhlcnMuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZXVwIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5UmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHByZXNzZWQgZG93blxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHByZXNzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnREb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyByZWxlYXNlZFxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHJlbGVhc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0VXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIE1vZGlmaWNhdGlvbiBmdW5jdGlvbnMgKi9cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgaW4gb3JkZXIgdG8gZHJhZyB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIG1vZGlmeURyYWcoKSB7XG4gICAgICAgIC8vKFwic3RyaW5nIGRyYWdvZmZ4OiBcIiArIHRoaXMuX2RyYWdvZmZ4KTtcbiAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueCAtIHRoaXMuX2RyYWdvZmZ4O1xuICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy5fZHJhZ29mZnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIG1vdmVzIHRoZSB0ZXh0IGVkaXQgY3Vyc29yIGJhc2VkIG9uIHdoZXJlIHRoZSBtb3VzZSBpcyBjbGlja2VkXG4gICAgICovXG4gICAgbW9kaWZ5VGV4dEN1cnNvcigpIHtcbiAgICAgICAgbGV0IGxlZnRXYWxsID0gdGhpcy54OyAvLyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgbGVmdCBtb3N0IHNpZGUgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAgICBsZXQgeERpZiA9IHRoaXMuX251bWJlck1ldHJpY3MuaW5pdE1vdXNlUG9zIC0gbGVmdFdhbGw7IC8vIGRpZmZlcmVuY2UgYmV0d2VlbiBtb3VzZSB4IGFuZCBsZWZ0IHdhbGxcbiAgICAgICAgbGV0IGludGVydmFsID0gdGhpcy5fbnVtYmVyTWV0cmljcy5pbnRlcnZhbDsgLy8gdGhlIHRleHQgd2lkdGggZGl2aWRlZCBieSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmdcbiAgICAgICAgbGV0IG1vdmVGYWN0b3IgPSAwO1xuICAgICAgICBpZiAoeERpZiA+PSBpbnRlcnZhbCAvIDIgJiYgeERpZiA8PSBpbnRlcnZhbCkge1xuICAgICAgICAgICAgbW92ZUZhY3RvciA9IGxlZnRXYWxsICsgaW50ZXJ2YWw7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmN1cnNvclBvcyA9IGludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHhEaWYgPD0gaW50ZXJ2YWwgLyAyKSB7XG4gICAgICAgICAgICBtb3ZlRmFjdG9yID0gbGVmdFdhbGw7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmN1cnNvclBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeERpZiAlIGludGVydmFsID49IGludGVydmFsIC8gMikge1xuICAgICAgICAgICAgbW92ZUZhY3RvciA9IGxlZnRXYWxsICsgaW50ZXJ2YWwgKiBNYXRoLmNlaWwoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuY3Vyc29yUG9zID0gaW50ZXJ2YWwgKiBNYXRoLmNlaWwoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4RGlmICUgaW50ZXJ2YWwgPCBpbnRlcnZhbCAvIDIpIHtcbiAgICAgICAgICAgIG1vdmVGYWN0b3IgPSBsZWZ0V2FsbCArIGludGVydmFsICogTWF0aC5mbG9vcih4RGlmIC8gaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5jdXJzb3JQb3MgPSBpbnRlcnZhbCAqIE1hdGguZmxvb3IoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdHgubW92ZVRvKG1vdmVGYWN0b3IsIHRoaXMueSAtIHRoaXMuX2ZvbnRTaXplKTtcbiAgICAgICAgdGhpcy5fY3R4LmxpbmVUbyhtb3ZlRmFjdG9yLCB0aGlzLnkpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSBcImdyZXlcIjtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGVkaXRzIHRoZSBzdHJpbmcgd2hlbiBlZGl0aW5nIHRleHRcbiAgICAgKiBAcGFyYW0gZXZlbnQga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG1vZGlmeVRleHQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRWRpdGluZykge1xuICAgICAgICAgICAgbGV0IGZpcnN0SGFsZjtcbiAgICAgICAgICAgIGxldCBzZWNvbmRIYWxmO1xuICAgICAgICAgICAgbGV0IHN0ciA9IHRoaXMuX251bS50b1N0cmluZygpO1xuICAgICAgICAgICAgbGV0IGJyZWFrUG9pbnQgPSB0aGlzLl9udW1iZXJNZXRyaWNzLmN1cnNvclBvcyAvIHRoaXMuX251bWJlck1ldHJpY3MuaW50ZXJ2YWw7XG4gICAgICAgICAgICBmaXJzdEhhbGYgPSBzdHIuc3Vic3RyaW5nKDAsIGJyZWFrUG9pbnQpO1xuICAgICAgICAgICAgc2Vjb25kSGFsZiA9IHN0ci5zdWJzdHJpbmcoYnJlYWtQb2ludCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNyAmJiB0aGlzLl9udW1iZXJNZXRyaWNzLmluaXRNb3VzZVBvcyA+IHRoaXMueCArIHRoaXMuX251bWJlck1ldHJpY3MuaW50ZXJ2YWwgLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5pbml0TW91c2VQb3MgLT0gdGhpcy5fbnVtYmVyTWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzkgJiYgdGhpcy5fbnVtYmVyTWV0cmljcy5pbml0TW91c2VQb3MgPCB0aGlzLnggKyB0aGlzLl9udW1iZXJNZXRyaWNzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5pbml0TW91c2VQb3MgKz0gdGhpcy5fbnVtYmVyTWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gOCAmJiBzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpcnN0SGFsZiA9IGZpcnN0SGFsZi5zdWJzdHJpbmcoMCwgZmlyc3RIYWxmLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIHN0ciA9IGZpcnN0SGFsZiArIHNlY29uZEhhbGY7XG4gICAgICAgICAgICAgICAgdGhpcy5fbnVtLnZhbCA9IE51bWJlcihzdHIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuaW5pdE1vdXNlUG9zIC09IHRoaXMuX251bWJlck1ldHJpY3MuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQga2V5TmFtZSA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5TmFtZS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEhhbGYgKz0ga2V5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gZmlyc3RIYWxmICsgc2Vjb25kSGFsZjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbnVtLnZhbCA9IE51bWJlcihzdHIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmluaXRNb3VzZVBvcyArPSB0aGlzLl9udW1iZXJNZXRyaWNzLmludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9kaWZpZXMgdGhlIGZvbnQgc2l6ZSBvZiB0aGUgdGV4dFxuICAgICAqIElmIHRoZSB0ZXh0IGZvbnQgaXMgc21hbGxlciB0aGFuIDE1cHQsIGl0IHNldCdzIGl0IGVxdWFsIHRvIDE1cHRcbiAgICAgKiBAcGFyYW0gaXNUb29TbWFsbCB0cnVlIGlmIHRoZSBmb250IHNpemUgaXMgPCAxNVxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZShpc1Rvb1NtYWxsKSB7XG4gICAgICAgIGlmIChpc1Rvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9mb250U2l6ZSA9IDE1O1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250U2l6ZSArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMC4yO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAwLjI7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyBkZXBlbmRpbmcgb24gdGhlIG1vdXNlIHBvc2l0aW9uIHdoZW4gY2FsbGVkIChvbk1vdXNlRG93bilcbiAgICAgKiBlLmcuIGlmIHRoZSBtb3VzZSBpcyB3aXRoaW4gdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSB3aGVuIHRoaXMgaXMgY2FsbGVkLCBpc1NlbGVjdGVkID0gdHJ1ZVxuICAgICAqIEBwYXJhbSBndWlkZUNvbnRhaW5zXG4gICAgICogQHBhcmFtIGNvbnRhaW5zXG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGUoZ3VpZGVDb250YWlucywgY29udGFpbnMpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy9wcmVwYXJlcyB0aGUgb2JqZWN0IGZvciBkcmFnZ2luZyB3aGV0aGVyIGl0IGlzIHBlcnNvbmFsbHkgc2VsZWN0ZWQgb3Igbm90XG4gICAgICAgICAgICBpZiAoY29udGFpbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZih0aGlzLl9jb250ZXh0Lm11bFNlbGVjdGVkLm11bFNlbCl7XG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJzdHJpbmcgZWZmZWN0IG11bFNlbGVjdGVkOiBcIiArIHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQubXVsU2VsKTtcbiAgICAgICAgICAgIC8vICAgICAvL2lmKHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQudmFsKXtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dTZWxlY3RlZCgpKTtcbiAgICAgICAgICAgIC8vICAgICAvL3RoaXMubG9nU2VsZWN0ZWQoKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zKSB7IC8vaWYgdGhlIGNvcm5lciBndWlkZXMgY29udGFpbiB0aGUgbW91c2Ugd2UgYXJlIHJlc2l6aW5nXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLng7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMueTtcbiAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZTEgPSB0aGlzLl9mb250U2l6ZTsgLy8gc2F2aW5nIG9sZCBmb250IHNpemVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgdGhpcy5feCA9IHRoaXMueDsgLy8gU2F2aW5nIG9yaWdpbmFsIHggYW5kIHlcbiAgICAgICAgICAgIHRoaXMuX3kgPSB0aGlzLnk7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyB0byBmYWxzZSAobGlrZSBkcmFnZ2luZywgcmVzaXppbmcsIGV0Yykgd2hlbiB0aGUgbW91c2UgaXMgcmVsZWFzZWRcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3ggLSB0aGlzLngpID4gMSB8fCBNYXRoLmFicyh0aGlzLl95IC0gdGhpcy55KSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy90aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dNb3ZlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3NpemUxIC0gdGhpcy5fZm9udFNpemUpID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1Jlc2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJzdHJpbmcgZWZmZWN0IG11bFNlbGVjdGVkOiBcIiArIHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQudmFsKTtcbiAgICAgICAgLy8gaWYodGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC52YWwpe1xuICAgICAgICAvLyAgICAgdGhpcy5sb2dTZWxlY3RlZCgpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmKHRoaXMuaXNNdWx0aXBsZVNlbGVjdGVkKXtcbiAgICAgICAgLy8gICAgIGNvbnRleHQuZXZlbnRMb2cucHVzaChuZXcgU2VsZWN0RXZlbnQoc2VsZWN0ZWRFbGVtcykpO1xuICAgICAgICAvLyAgICAgbWFzdGVyTG9nLnB1c2goY29udGV4dC5ldmVudExvZ1tjb250ZXh0LmV2ZW50TG9nLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgLy8gICAgIC8vY29uc29sZS5sb2coXCJtdWx0aXBsZSBzZWxlY3RlZFwiKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyAvL3RoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ01vdmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKiBOT1RFOiBpbiBGaXJlZm94LCB3aW5kb3cuZXZlbnQgaXMgbm90IGdsb2JhbC4gTmVlZCB0byBiZSBwYXNzZWQgaW4gaGVyZSBhcyBhIHBhcmFtYXRlci5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIGdldE1vdXNlUG9zaXRpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fbW91c2UueCA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLng7XG4gICAgICAgIHRoaXMuX21vdXNlLnkgPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzQ2hhbmdpbmdEaW1zLCBhbmQgaXNTZWxlY3RlZCB0byBmYWxzZSBpZiB0aGUgbW91c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgaXNNb3VzZU91dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1vdXNlWCA8IHJlY3QubGVmdCB8fCBtb3VzZVggPiByZWN0LnJpZ2h0IHx8IG1vdXNlWSA8IHJlY3QudG9wIHx8IG1vdXNlWSA+IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHBhaW50IGV2ZW50XG4gICAgICovXG4gICAgbG9nUGFpbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpbnRFdmVudF8xLlBhaW50RXZlbnQodGhpcy5fbnVtLnRvU3RyaW5nKCksIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlc2l6ZSBldmVudFxuICAgICAqL1xuICAgIGxvZ1Jlc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVFdmVudF8xLlJlc2l6ZUV2ZW50KHRoaXMuX251bS50b1N0cmluZygpICsgXCIgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCBNYXRoLnJvdW5kKHRoaXMuX3NpemUxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLl9mb250U2l6ZSAqIDEwMCkgLyAxMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgY2xpY2sgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dDbGljaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGlja0V2ZW50XzEuQ2xpY2tFdmVudCh0aGlzLl9udW0udG9TdHJpbmcoKSArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgYXNzaWducyBhbiBJRCB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgaW5pdElEKGlkKSB7XG4gICAgICAgIHRoaXMuaWRPYmogPSB7IF9pZDogaWQsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIGdldCBjYW52YXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBjYW52YXMgVGhlIGNhbnZhcyB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldCBjYW52YXMoY2FudmFzKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgICB9XG4gICAgYXN0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIG51bWJlclxuICAgICAqL1xuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBEaW1lbnNpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBkaW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICovXG4gICAgZ2V0SnVzdERyYWdnZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdXN0RHJhZ2dlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgZWxsaXBzZSBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldEp1c3REcmFnZ2VkKHZhbCkge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZWxsaXBzZSBpcyBkcmFnZ2luZ1xuICAgICAqL1xuICAgIGdldCBpc0RyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEcmFnZ2luZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0IG51bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX251bS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9iamVjdCBJRFxuICAgICAqL1xuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZE9iai5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3Igc2VsZWN0aW9uIGV2ZW50c1xuICAgICAqL1xuICAgIHRvU2VsU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCIgXCIgKyB0aGlzLl9udW0udG9TdHJpbmcoKSArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgZHJhZyBldmVudHNcbiAgICAqL1xuICAgIHRvRHJhZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9udW0udG9TdHJpbmcoKSArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94ICsgXCIsIFwiICsgdGhpcy5feSArIFwiIHRvIFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBJRCBhc3NpZ25tZW50IGV2ZW50c1xuICAgICAqL1xuICAgIHRvSURTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pZE9iai5faWQudG9TdHJpbmcoKSArIFwiIHRvIFwiICsgdGhpcy5fbnVtLnRvU3RyaW5nKCkgKyBcIiBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxufVxuZXhwb3J0cy5OdW1iZXJFZmZlY3QgPSBOdW1iZXJFZmZlY3Q7XG4vKipcbiAqIEdldCdzIHRoZSBtb3VzZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGluIHJlbGF0aW9uIHRvIHRoZSBjYW52YXNcbiAqIEBwYXJhbSBjYW52YXMgdGhlIGNhbnZhcyBvYmplY3RcbiAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGdldE1vdXNlUG9zKGNhbnZhcywgZXZlbnQpIHtcbiAgICBsZXQgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0LFxuICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gcmVjdC50b3BcbiAgICB9O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0geDEgeCBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geTEgeSBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geDIgeCBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICogQHBhcmFtIHkyIHkgY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDIsIDIpICsgTWF0aC5wb3coeTEgLSB5MiwgMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TnVtYmVyRWZmZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBQYWludEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9QYWludEV2ZW50XCIpO1xuY29uc3QgUmVzaXplRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1Jlc2l6ZUV2ZW50XCIpO1xuY29uc3QgQ2xpY2tFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvQ2xpY2tFdmVudFwiKTtcbmNsYXNzIFJlY3RhbmdsZUVmZmVjdCB7XG4gICAgY29uc3RydWN0b3IocmVjdCkge1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7IC8vIHByaXZhdGUgYm9vbHNcbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmF0aW8gPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gMDtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5fbW91c2UgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9yZWN0ID0gcmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIGV2YWx1YXRpbmcgbm9kZXMgKFN0cmluZ05vZGUsIEVsbGlwc2VOb2RlLCBldGMpXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyBhbGwgcGFyYW1zIHRvIHByaXZhdGUgdmFyaWFibGVzIGFuZCBkcmF3cyB0aGUgaW5pdGlhbCBvYmplY3QgdG8gdGhlIGNhbnZhc1xuICAgICAqIGJ5IGNhbGxpbmcgdXBkYXRlKClcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgcGFyZW50IFNjb3BlIHRoYXQgY29udGFpbnMgdGhlIGNhbnZhcyBhbW9uZyBvdGhlciB0aGluZ3NcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgb2JqZWN0J3MgZGltZW5zaW9ucyBpbmNsdWRpbmcgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBhc3QgVW5uZWNlc3Nhcnkgbm93LCB1c2VkIHRvIGJlIHRoZSBwYXJlbnQgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY2FudmFzLmlzRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zID0gZGltcztcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IGNvbnRleHQuY2FudmFzLmdldCgpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgY3R4ID0gY29udGV4dC5jYW52YXMuZ2V0KCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1BhaW50KCkpO1xuICAgICAgICBjb250ZXh0LmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gZHJhdyBhbmQgcmVkcmF3IHRoZSBvYmplY3Qgd2hlbiBtYW5pcHVsYXRpb25zIGFyZSBtYWRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudztcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuaDtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgLy90aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIC8vdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gXCIjZDViOGZmXCI7XG4gICAgICAgIHRoaXMuX2N0eC5zaGFkb3dDb2xvciA9IFwiIzZDNkM2Q1wiO1xuICAgICAgICB0aGlzLl9jdHguc2hhZG93Qmx1ciA9IDE1O1xuICAgICAgICAvL3RoaXMuX2N0eC5zaGFkb3dPZmZzZXRYID0gMjtcbiAgICAgICAgLy90aGlzLl9jdHguc2hhZG93T2Zmc2V0WSA9IDI7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdHdWlkZXMoeCwgeSwgd2lkdGgsIGhlaWdodCwgdGhpcy5fY29ybmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBvbmUgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTsgLy8gYmluZCBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgbWVhbmluZyBvZiAndGhpcydcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vblNoaWZ0RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vblNoaWZ0VXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmlzTW91c2VPdXRzaWRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL21ha2VzIGl0IHNvIHRoYXQgZG91YmxlIGNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRleHQgb24gdGhlIHBhZ2VcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgZnVuY3Rpb24gKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZmFsc2U7IH0sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gYW5vdGhlciBmZWxsIHN3b29wXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9mIHRoZSBvYmplY3QncyBib3VuZGluZyByZWN0YW5nbGUsIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBjb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGlmIChteCA+IHggJiYgbXggPCB4ICsgdyAmJiBteSA+IHkgJiYgbXkgPCB5ICsgaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbnVtYmVyID4gMCBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9uZSBvZiB0aGUgY29ybmVyL3NpZGUgZ3VpZGVzLCByZXR1cm5zIDAgaWYgbm90XG4gICAgICogVGhlIGNvcm5lciBndWlkZXMgYXJlIG51bWJlcmVkIDEtNCB3aXRoIDEgYmVpbmcgdGhlIHRvcCBsZWZ0LCAyIGJlaW5nIHRoZSB0b3AgcmlnaHQsIGFuZCBzbyBvbi5cbiAgICAgKiBUaGUgbWlkZGxlIGd1aWRlcyBhcmUgbnVtYmVyZWQgNS04LCB3aXRoIDUgYmVpbmcgdGhlIHRvcCBtaWRkbGUsIDYgYmVpbmcgdGhlIHJpZ2h0IG1pZGRsZSwgYW5kIHNvIG9uLlxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBndWlkZUNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgbGV0IHhkaWYgPSBteCAtIHg7XG4gICAgICAgIGxldCB5ZGlmID0gbXkgLSB5O1xuICAgICAgICAvKiBDb3JuZXIgR3VpZGVzICovXG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgfVxuICAgICAgICAvKiBNaWRkbGUgR3VpZGVzICovXG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICB5ZGlmID0gbXkgLSB5O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIG1pZGRsZVxuICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9taWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiA2O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGgpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgcmV0dXJuIDc7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9taWRkbGUgbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBib3VuZGluZyByZWN0YW5nbGUgYW5kIGd1aWRlcyBmb3IgdGhlIG9iamVjdCB3aGVuIHRoZSBvYmplY3QgaXMgc2VsZWN0ZWRcbiAgICAgKiBJZiBvbmUgb2YgdGhlIGd1aWRlcyBpcyBzZWxlY3RlZCwgaXQgY29sb3JzIHRoYXQgZ3VpZGUgYmx1ZVxuICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB5IHRoZSB5IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB3IHRoZSB3aWR0aCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggdGhlIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvcm5lciB0aGUgbnVtYmVyIG9mIHRoZSBjb3JuZXIgdG8gYmUgY29sb3JlZCBibHVlIChpZiBhbnkgYXQgYWxsLCBpZiAwLCBhbGwgYXJlIHdoaXRlKVxuICAgICAqL1xuICAgIGRyYXdHdWlkZXMoeCwgeSwgdywgaCwgY29ybmVyKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAoY29ybmVyICE9PSAwICYmIGNvcm5lciA8PSA0KSB7IC8vIGEgY29ybmVyIGd1aWRlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgY29ycmVjdCBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvcm5lciAhPT0gMCkgeyAvLyBhIG1pZGRsZSBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcnJlY3QgZ3VpZGUgYmx1ZVxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy9pZiBubyBndWlkZXMgYXJlIHNlbGVjdGVkLCBjb2xvcnMgZXZlcnl0aGluZyB3aGl0ZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltcGxlIG1ldGhvZCB0aGF0IGRyYXdzIGEgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHggeCBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geSB5IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB3IHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb2xvciBjb2xvciBvZiB0aGUgcmVjdGFuZ2xlJ3MgZmlsbFxuICAgICAqL1xuICAgIGRyYXdTcXVhcmUoeCwgeSwgdywgaCwgY29sb3IpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIHdpdGhpbiB0aGUgY2FudmFzLlxuICAgICAqIEdldHMgdGhlIG1vdXNlIHBvc2l0aW9uLCBjYWxscyB0aGUgbW9kaWZ5IG1ldGhvZHMgaWYgdGhlIGJvb2xlYW5zIHNhdGlzZnkgdGhlbS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldmVudCk7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5RHJhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemUodGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0NoYW5naW5nRGltcyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXModGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIGNsaWNrcyBpbnNpZGUgdGhlIGNhbnZhcy5cbiAgICAgKiBNb2RpZmllcyB0aGUgc3RhdGUgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGd1aWRlcyBjb250YWluIHRoZSBtb3VzZSBvciB0aGUgYm91bmRpbmcgcmVjdCBjb250YWlucyB0aGUgbW91c2UuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVN0YXRlKHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSwgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgdW5jbGlja3MuXG4gICAgICogQ2FsbHMgbW9kaWZ5UmVzZXQgdG8gcmVzZXQgZHJhZ2dpbmcgYW5kIHJlc2l6aW5nIGJvb2xlYW5zIGFtb25nIG90aGVycy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNldXAgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlSZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcHJlc3NlZCBkb3duXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcHJlc3NlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdERvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHJlbGVhc2VkXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcmVsZWFzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnRVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogTW9kaWZpY2F0aW9uIGZ1bmN0aW9ucyAqL1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBpbiBvcmRlciB0byBkcmFnIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgbW9kaWZ5RHJhZygpIHtcbiAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueCAtIHRoaXMuX2RyYWdvZmZ4O1xuICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy5fZHJhZ29mZnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHNpemUgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZCAod2hlbiBhIGNvcm5lciBndWlkZSBpcyBjbGlja2VkIGFuZCBkcmFnZ2VkKS5cbiAgICAgKlxuICAgICAqIElmIGFueSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgdG9vIHNtYWxsLCBpdCBzZXRzIHRoZW0gZXF1YWwgdG8gMTAgYW5kIHRoZSBvdGhlciBlcXVhbCB0b1xuICAgICAqIDEwIGRpdmlkZWQgb3IgbXVsdGlwbGllZCBieSB0aGUgcmF0aW8gb2Ygd2lkdGgvaGVpZ2h0IHRvIGtlZXAgaXQgdGhlIHNhbWUuXG4gICAgICpcbiAgICAgKiBUaGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBpcyBkb25lIGJ5IGNhbGxpbmcgdGhlIGhlbHBlciBtZXRob2QgbW9kaWZ5UmVzaXplSGVscGVyLlxuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZSh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBpZiAod2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fcmVjdC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7IC8vIHNldCBmb3IgdGhlIHByb2RpcmVjdCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX3JlY3QuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTAgLyB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fcmVjdC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApOyAvLyBzZXQgZm9yIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgKiB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX3JlY3Qud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyAxLCAyLCBvciA0IGFyZSBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0Rpc3RhbmNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBtb3VzZSBhbmQgdGhlIGxvY2F0aW9uIG9wcG9zaXRlIHRvIGl0XG4gICAgICogKGlmIHRvcCByaWdodCBndWlkZSBpcyBjbGlja2VkLCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGFuZCB0aGUgYm90dG9tIGxlZnQgZ3VpZGUgaXMgbmV3RGlzdGFuY2UpXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgdGhpcy5fcmVjdC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW87XG4gICAgICAgIHRoaXMuX3JlY3QuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQuXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMC5cbiAgICAgKiBDYWxscyBtb2RpZnlDaGFuZ2VEaW1zSGVscGVyIHRvIGFjdHVhbGx5IGRvIHRoZSB3b3JrXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5Q2hhbmdlRGltcyh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBpZiAod2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fcmVjdC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fcmVjdC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyA1IG9yIDggYXJlIHNlbGVjdGVkXG4gICAgICovXG4gICAgbW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oID4gMTApIHsgLy9hcyBsb25nIGFzIHRoZSBoZWlnaHQgaXMgPiAxMFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0LndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53ID4gMTApIHsgLy8gYXMgbG9uZyBhcyB3aWR0aCBpcyA+IDEwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0LndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgZGVwZW5kaW5nIG9uIHRoZSBtb3VzZSBwb3NpdGlvbiB3aGVuIGNhbGxlZCAob25Nb3VzZURvd24pXG4gICAgICogZS5nLiBpZiB0aGUgbW91c2UgaXMgd2l0aGluIHRoZSBib3VuZGluZyByZWN0YW5nbGUgd2hlbiB0aGlzIGlzIGNhbGxlZCwgaXNTZWxlY3RlZCA9IHRydWVcbiAgICAgKiBAcGFyYW0gZ3VpZGVDb250YWluc1xuICAgICAqIEBwYXJhbSBjb250YWluc1xuICAgICAqL1xuICAgIG1vZGlmeVN0YXRlKGd1aWRlQ29udGFpbnMsIGNvbnRhaW5zKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkgeyAvL3ByZXBhcmVzIHRoZSBvYmplY3QgZm9yIGRyYWdnaW5nIHdoZXRoZXIgaXQgaXMgcGVyc29uYWxseSBzZWxlY3RlZCBvciBub3RcbiAgICAgICAgICAgIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kxID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gMCAmJiBndWlkZUNvbnRhaW5zIDw9IDQpIHsgLy9yZXNpemluZ1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gdGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0MSA9IHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoMSA9IHRoaXMudztcbiAgICAgICAgICAgIC8vdGhpcy5fc2l6ZTEgPSBNYXRoLnNxcnQoTWF0aC5wb3codywyKSArIE1hdGgucG93KGgsMikpOyAvLyBzaXplIGlzIGRpYWdvbmFsIGxlbmd0aFxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHsgLy8gc2V0cyB0aGUgb2Zmc2V0cyBkZXBlbmRpbmcgb24gd2hpY2ggY29ybmVyIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgY2FzZSAxOiAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3OyAvLyBvZmZzZXQgaXMgYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoOyAvLyBvZmZzZXQgaXMgYm90dG9tIGxlZnQsIGV0Y1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucyA+IDQpIHsgLy9jaGFuZ2luZyBzaGFwZSBkaW1lbnNpb25zXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IGd1aWRlQ29udGFpbnM7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikgeyAvLyBzZXRzIHRoZSBvZmZzZXRzIGRlcGVuZGluZyBvbiB3aGljaCBtaWRkbGUgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIDU6IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyOyAvLyBvZmZzZXQgaXMgYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6IC8vcmlnaHQgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaCAvIDI7IC8vIG9mZnNldCBpcyBsZWZ0IG1pZGRsZSBldGNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdyAvIDIsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5ICsgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbnMpIHsgLy8gZHJhZ2dpbmdcbiAgICAgICAgICAgIHRoaXMuX3gxID0geDsgLy8gU2F2aW5nIG9yaWdpbmFsIHggYW5kIHlcbiAgICAgICAgICAgIHRoaXMuX3kxID0geTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7IC8vIG5vdCBzZWxlY3RlZFxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgdG8gZmFsc2UgKGxpa2UgZHJhZ2dpbmcsIHJlc2l6aW5nLCBldGMpIHdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkXG4gICAgICovXG4gICAgbW9kaWZ5UmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl94MSAtIHRoaXMueCkgPiAxIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0gdGhpcy55KSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHRoaXMuX2lzUmVzaXppbmcgfHwgdGhpcy5faXNDaGFuZ2luZ0RpbXMpICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBzaXplMiA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLncsIDIpICsgTWF0aC5wb3codGhpcy5oLCAyKSk7XG4gICAgICAgICAgICBpZiAoKE1hdGguYWJzKHRoaXMuX3dpZHRoMSAtIHRoaXMudykgPiAwKSB8fCAoTWF0aC5hYnModGhpcy5faGVpZ2h0MSAtIHRoaXMuaCkgPiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1Jlc2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqIE5PVEU6IGluIEZpcmVmb3gsIHdpbmRvdy5ldmVudCBpcyBub3QgZ2xvYmFsLiBOZWVkIHRvIGJlIHBhc3NlZCBpbiBoZXJlIGFzIGEgcGFyYW1hdGVyLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgZ2V0TW91c2VQb3NpdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLl9tb3VzZS54ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueDtcbiAgICAgICAgdGhpcy5fbW91c2UueSA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNDaGFuZ2luZ0RpbXMsIGFuZCBpc1NlbGVjdGVkIHRvIGZhbHNlIGlmIHRoZSBtb3VzZSBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBpc01vdXNlT3V0c2lkZShldmVudCkge1xuICAgICAgICBsZXQgbW91c2VYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgbGV0IG1vdXNlWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5fY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobW91c2VYIDwgcmVjdC5sZWZ0IHx8IG1vdXNlWCA+IHJlY3QucmlnaHQgfHwgbW91c2VZIDwgcmVjdC50b3AgfHwgbW91c2VZID4gcmVjdC5ib3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZWN0YW5nbGUgcGFpbnQgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dQYWludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWludEV2ZW50XzEuUGFpbnRFdmVudChcInJlY3RhbmdsZVwiLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZWN0YW5nbGUgcmVzaXplIGV2ZW50XG4gICAgICovXG4gICAgbG9nUmVzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZUV2ZW50XzEuUmVzaXplRXZlbnQoXCJyZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCBNYXRoLnJvdW5kKHRoaXMuX3dpZHRoMSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5faGVpZ2h0MSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy53ICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLmggKiAxMDApIC8gMTAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlY3RhbmdsZSBjbGljayBldmVudFxuICAgICAqL1xuICAgIGxvZ0NsaWNrKCkge1xuICAgICAgICByZXR1cm4gbmV3IENsaWNrRXZlbnRfMS5DbGlja0V2ZW50KFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgYXNzaWducyBhbiBJRCB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgaW5pdElEKGlkKSB7XG4gICAgICAgIHRoaXMuaWRPYmogPSB7IF9pZDogaWQgfTtcbiAgICB9XG4gICAgYXN0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBEaW1lbnNpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBkaW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkT2JqLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKi9cbiAgICBnZXRKdXN0RHJhZ2dlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1c3REcmFnZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgc2V0SnVzdERyYWdnZWQodmFsKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGlzIGRyYWdnaW5nXG4gICAgICovXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIHNlbGVjdGlvbiBldmVudHNcbiAgICAgKi9cbiAgICB0b1NlbFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiIHJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIGRyYWcgZXZlbnRzXG4gICAgKi9cbiAgICB0b0RyYWdTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoXCJyZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgZnJvbSBcIiArIHRoaXMuX3gxICsgXCIsIFwiICsgdGhpcy5feTEgKyBcIiB0byBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgSUQgYXNzaWdubWVudCBldmVudHNcbiAgICAgKi9cbiAgICB0b0lEU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaWRPYmouX2lkLnRvU3RyaW5nKCkgKyBcIiB0byByZWN0YW5nbGUgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVjdGFuZ2xlRWZmZWN0ID0gUmVjdGFuZ2xlRWZmZWN0O1xuLyoqXG4gKiBHZXRzIHRoZSBtb3VzZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGluIHJlbGF0aW9uIHRvIHRoZSBjYW52YXNcbiAqIEBwYXJhbSBjYW52YXMgdGhlIGNhbnZhcyBvYmplY3RcbiAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGdldE1vdXNlUG9zKGNhbnZhcywgZXZlbnQpIHtcbiAgICBsZXQgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0LFxuICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gcmVjdC50b3BcbiAgICB9O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0geDEgeCBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geTEgeSBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geDIgeCBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICogQHBhcmFtIHkyIHkgY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDIsIDIpICsgTWF0aC5wb3coeTEgLSB5MiwgMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVjdGFuZ2xlRWZmZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUGFpbnRFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUGFpbnRFdmVudFwiKTtcbmNvbnN0IFJlc2l6ZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9SZXNpemVFdmVudFwiKTtcbmNvbnN0IENsaWNrRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL0NsaWNrRXZlbnRcIik7XG5jbGFzcyBTdHJpbmdFZmZlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHN0cikge1xuICAgICAgICB0aGlzLl9mb250U2l6ZSA9IDIwO1xuICAgICAgICAvL3ByaXZhdGUgX3NpemUyOiBudW1iZXI7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTsgLy8gUHJpdmF0ZSBib29sc1xuICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTsgLy8gSGFzIHRoaXMgb2JqZWN0IGp1c3QgYmVlbiBkcmFnZ2VkP1xuICAgICAgICAvL3ByaXZhdGUgX2xvZzogc3RyaW5nW107XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSAwO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9tb3VzZSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3RleHRNZXRyaWNzID0ge1xuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBpbnRlcnZhbDogMCxcbiAgICAgICAgICAgIGluaXRNb3VzZVBvczogMCxcbiAgICAgICAgICAgIGN1cnNvclBvczogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zdHIgPSBzdHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiBldmFsdWF0aW5nIG5vZGVzIChTdHJpbmdOb2RlLCBFbGxpcHNlTm9kZSwgZXRjKVxuICAgICAqIFRoaXMgbWV0aG9kIGFzc2lnbnMgYWxsIHBhcmFtcyB0byBwcml2YXRlIHZhcmlhYmxlcyBhbmQgZHJhd3MgdGhlIGluaXRpYWwgb2JqZWN0IHRvIHRoZSBjYW52YXNcbiAgICAgKiBieSBjYWxsaW5nIHVwZGF0ZSgpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIHBhcmVudCBTY29wZSB0aGF0IGNvbnRhaW5zIHRoZSBjYW52YXMgYW1vbmcgb3RoZXIgdGhpbmdzXG4gICAgICogQHBhcmFtIGRpbXMgVGhlIG9iamVjdCdzIGRpbWVuc2lvbnMgaW5jbHVkaW5nIHggYW5kIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gYXN0IFVubmVjZXNzYXJ5IG5vdywgdXNlZCB0byBiZSB0aGUgcGFyZW50IEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNhbnZhcyAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gY29udGV4dC5jYW52YXMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9kaW1zID0gZGltcztcbiAgICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0LmNhbnZhcy5nZXQoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgLy8gbG9nZ2luZ1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUGFpbnQoKSk7IC8vIHRoaXMuY29udGV4dCBvciBjb250ZXh0P1xuICAgICAgICAgICAgY29udGV4dC5lZmZlY3RzLnB1c2godGhpcyk7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNhbnZhcyBpcyBOT1QgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gZHJhdyBhbmQgcmVkcmF3IHRoZSBvYmplY3Qgd2hlbiBtYW5pcHVsYXRpb25zIGFyZSBtYWRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgZm9udERlZXRzID0gdGhpcy5fZm9udFNpemUgKyBcInB4IENvdXJpZXIgTmV3XCI7XG4gICAgICAgIHRoaXMuX2N0eC5mb250ID0gZm9udERlZXRzO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gXCIjNjczQUI3XCI7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsVGV4dCh0aGlzLl9zdHIudmFsLCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLndpZHRoID0gdGhpcy5fY3R4Lm1lYXN1cmVUZXh0KHRoaXMuX3N0ci52YWwpLndpZHRoO1xuICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5pbnRlcnZhbCA9IHRoaXMuX3RleHRNZXRyaWNzLndpZHRoICE9IDAgPyB0aGlzLl90ZXh0TWV0cmljcy53aWR0aCAvIHRoaXMuX3N0ci52YWwubGVuZ3RoIDogMDtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1RleHRHdWlkZXModGhpcy54LCB0aGlzLnkgLSB0aGlzLl9mb250U2l6ZSwgdGhpcy5fdGV4dE1ldHJpY3Mud2lkdGgsIHRoaXMuX2ZvbnRTaXplLCB0aGlzLl9jb3JuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIG9uZSBmZWxsIHN3b29wXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpOyAvLyBiaW5kIGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBtZWFuaW5nIG9mICd0aGlzJ1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uU2hpZnREb3duLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uU2hpZnRVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaXNNb3VzZU91dHNpZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vbWFrZXMgaXQgc28gdGhhdCBkb3VibGUgY2xpY2tpbmcgZG9lc24ndCBzZWxlY3QgdGV4dCBvbiB0aGUgcGFnZVxuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBmdW5jdGlvbiAoZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IHJldHVybiBmYWxzZTsgfSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBhbm90aGVyIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb2YgdGhlIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSwgZmFsc2UgaWYgb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICByZXR1cm4gKHRoaXMueCA8PSBteCkgJiYgKHRoaXMueCArIHRoaXMuX3RleHRNZXRyaWNzLndpZHRoID49IG14KSAmJlxuICAgICAgICAgICAgKHRoaXMueSAtIHRoaXMuX2ZvbnRTaXplIDw9IG15KSAmJiAodGhpcy55ID49IG15KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciA+IDAgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvbmUgb2YgdGhlIGNvcm5lci9zaWRlIGd1aWRlcywgcmV0dXJucyAwIGlmIG5vdFxuICAgICAqIFRoZSBjb3JuZXIgZ3VpZGVzIGFyZSBudW1iZXJlZCAxLTQgd2l0aCAxIGJlaW5nIHRoZSB0b3AgbGVmdCwgMiBiZWluZyB0aGUgdG9wIHJpZ2h0LCBhbmQgc28gb24uXG4gICAgICogVGhlIG1pZGRsZSBndWlkZXMgYXJlIG51bWJlcmVkIDUtOCwgd2l0aCA1IGJlaW5nIHRoZSB0b3AgbWlkZGxlLCA2IGJlaW5nIHRoZSByaWdodCBtaWRkbGUsIGFuZCBzbyBvbi5cbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ3VpZGVDb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHhkaWYgPSBteCAtICh0aGlzLnggKyB0aGlzLl90ZXh0TWV0cmljcy53aWR0aCk7XG4gICAgICAgIGxldCB5ZGlmID0gbXkgLSAodGhpcy55IC0gdGhpcy5fZm9udFNpemUpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGFuZCBndWlkZXMgZm9yIHRoZSBvYmplY3Qgd2hlbiB0aGUgb2JqZWN0IGlzIHNlbGVjdGVkXG4gICAgICogSWYgb25lIG9mIHRoZSBndWlkZXMgaXMgc2VsZWN0ZWQsIGl0IGNvbG9ycyB0aGF0IGd1aWRlIGJsdWVcbiAgICAgKiBAcGFyYW0geCB0aGUgeCBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0geSB0aGUgeSBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb3JuZXIgdGhlIG51bWJlciBvZiB0aGUgY29ybmVyIHRvIGJlIGNvbG9yZWQgYmx1ZSAoaWYgYW55IGF0IGFsbCwgaWYgMCwgYWxsIGFyZSB3aGl0ZSlcbiAgICAgKi9cbiAgICBkcmF3VGV4dEd1aWRlcyh4LCB5LCB3LCBoLCBjb3JuZXIpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmIChjb3JuZXIgIT09IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBndWlkZSBibHVlIGlmIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgbWV0aG9kIHRoYXQgZHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geCB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5IHkgY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHcgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIGNvbG9yIG9mIHRoZSByZWN0YW5nbGUncyBmaWxsXG4gICAgICovXG4gICAgZHJhd1NxdWFyZSh4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qIEV2ZW50IGxpc3RlbmVyIGZ1bmN0aW9ucyAqL1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgd2l0aGluIHRoZSBjYW52YXMuXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24sIGNhbGxzIHRoZSBtb2RpZnkgbWV0aG9kcyBpZiB0aGUgYm9vbGVhbnMgc2F0aXNmeSB0aGVtLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQgJiYgdGhpcy5faXNEcmFnZ2luZykge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLl9zdHIudmFsICsgXCIgaXMgYmVpbmcgZHJhZ2dlZC5cIik7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeURyYWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jlc2l6aW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplKHRoaXMuX2ZvbnRTaXplIDwgMTUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSAmJiB0aGlzLl9pc1NlbGVjdGVkICYmIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpIHsgLy90ZXh0IGVkaXRpbmdcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMubW9kaWZ5VGV4dC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2lzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX3N0ci52YWwgKyBcIiBpcyBzZXR0aW5nIGRyYWdnaW5nIHRvIGZhbHNlXCIpO1xuICAgICAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuaW5pdE1vdXNlUG9zID0gdGhpcy5fbW91c2UueDtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kaWZ5U3RhdGUodGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpID4gMCwgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgdW5jbGlja3MuXG4gICAgICogQ2FsbHMgbW9kaWZ5UmVzZXQgdG8gcmVzZXQgZHJhZ2dpbmcgYW5kIHJlc2l6aW5nIGJvb2xlYW5zIGFtb25nIG90aGVycy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNldXAgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlSZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcHJlc3NlZCBkb3duXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcHJlc3NlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdERvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHJlbGVhc2VkXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcmVsZWFzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnRVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogTW9kaWZpY2F0aW9uIGZ1bmN0aW9ucyAqL1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBpbiBvcmRlciB0byBkcmFnIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgbW9kaWZ5RHJhZygpIHtcbiAgICAgICAgLy8oXCJzdHJpbmcgZHJhZ29mZng6IFwiICsgdGhpcy5fZHJhZ29mZngpO1xuICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS54IC0gdGhpcy5fZHJhZ29mZng7XG4gICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLl9kcmFnb2ZmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgbW92ZXMgdGhlIHRleHQgZWRpdCBjdXJzb3IgYmFzZWQgb24gd2hlcmUgdGhlIG1vdXNlIGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBtb2RpZnlUZXh0Q3Vyc29yKCkge1xuICAgICAgICBsZXQgeERpZiA9IHRoaXMuX3RleHRNZXRyaWNzLmluaXRNb3VzZVBvcyAtIHRoaXMueDsgLy8gZGlmZmVyZW5jZSBiZXR3ZWVuIG1vdXNlIHggYW5kIGxlZnQgd2FsbFxuICAgICAgICBsZXQgaW50ZXJ2YWwgPSB0aGlzLl90ZXh0TWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuY3Vyc29yUG9zID0gaW50ZXJ2YWwgIT0gMCA/IGludGVydmFsICogTWF0aC5yb3VuZCh4RGlmIC8gaW50ZXJ2YWwpIDogMDtcbiAgICAgICAgbGV0IG1vdmVGYWN0b3IgPSB0aGlzLl90ZXh0TWV0cmljcy5jdXJzb3JQb3MgKyB0aGlzLng7XG4gICAgICAgIHRoaXMuX2N0eC5tb3ZlVG8obW92ZUZhY3RvciwgdGhpcy55IC0gdGhpcy5fZm9udFNpemUpO1xuICAgICAgICB0aGlzLl9jdHgubGluZVRvKG1vdmVGYWN0b3IsIHRoaXMueSk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9IFwiZ3JleVwiO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZWRpdHMgdGhlIHN0cmluZyB3aGVuIGVkaXRpbmcgdGV4dFxuICAgICAqIEBwYXJhbSBldmVudCBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgbW9kaWZ5VGV4dChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzRWRpdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbnRlcnZhbCA9IHRoaXMuX3RleHRNZXRyaWNzLmludGVydmFsO1xuICAgICAgICBsZXQgYnJlYWtQb2ludCA9IGludGVydmFsICE9IDAgPyB0aGlzLl90ZXh0TWV0cmljcy5jdXJzb3JQb3MgLyBpbnRlcnZhbCA6IDA7XG4gICAgICAgIGxldCBmaXJzdEhhbGYgPSB0aGlzLl9zdHIudmFsLnN1YnN0cmluZygwLCBicmVha1BvaW50KTtcbiAgICAgICAgbGV0IHNlY29uZEhhbGYgPSB0aGlzLl9zdHIudmFsLnN1YnN0cmluZyhicmVha1BvaW50KTtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDM3OiAvLyBBcnJvdyBsZWZ0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RleHRNZXRyaWNzLmluaXRNb3VzZVBvcyA+IHRoaXMueCArIGludGVydmFsIC8gMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5pbml0TW91c2VQb3MgLT0gaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzk6IC8vIEFycm93IHJpZ2h0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RleHRNZXRyaWNzLmluaXRNb3VzZVBvcyA8IHRoaXMueCArIHRoaXMuX3RleHRNZXRyaWNzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmluaXRNb3VzZVBvcyArPSBpbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OiAvLyBCYWNrc3BhY2VcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGV4dE1ldHJpY3MuY3Vyc29yUG9zID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEhhbGYgPSBmaXJzdEhhbGYuc3Vic3RyaW5nKDAsIGZpcnN0SGFsZi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RyLnN0ciA9IGZpcnN0SGFsZiArIHNlY29uZEhhbGY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmluaXRNb3VzZVBvcyAtPSBpbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIEJhY2tzcGFjaW5nIG9uIEZpcmVmb3ggd2lsbCBnbyBiYWNrIHRvIGEgcHJldmlvdXMgcGFnZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0NjogLy8gRGVsXG4gICAgICAgICAgICAgICAgc2Vjb25kSGFsZiA9IHNlY29uZEhhbGYuc3Vic3RyaW5nKDEsIHNlY29uZEhhbGYubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHIuc3RyID0gZmlyc3RIYWxmICsgc2Vjb25kSGFsZjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbGV0IGtleU5hbWUgPSBldmVudC5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKGtleU5hbWUubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RIYWxmICs9IGtleU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0ci5zdHIgPSBmaXJzdEhhbGYgKyBzZWNvbmRIYWxmO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSB0aGlzLl9jdHgubWVhc3VyZVRleHQodGhpcy5fc3RyLnZhbCkud2lkdGggLyB0aGlzLl9zdHIudmFsLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5pbml0TW91c2VQb3MgKz0gaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb2RpZmllcyB0aGUgZm9udCBzaXplIG9mIHRoZSB0ZXh0XG4gICAgICogSWYgdGhlIHRleHQgZm9udCBpcyBzbWFsbGVyIHRoYW4gMTVwdCwgaXQgc2V0J3MgaXQgZXF1YWwgdG8gMTVwdFxuICAgICAqIEBwYXJhbSBpc1Rvb1NtYWxsIHRydWUgaWYgdGhlIGZvbnQgc2l6ZSBpcyA8IDE1XG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplKGlzVG9vU21hbGwpIHtcbiAgICAgICAgaWYgKGlzVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplID0gMTU7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAwLjI7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgdGhpcy5fZm9udFNpemUgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDAuMjtcbiAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIGRlcGVuZGluZyBvbiB0aGUgbW91c2UgcG9zaXRpb24gd2hlbiBjYWxsZWQgKG9uTW91c2VEb3duKVxuICAgICAqIGUuZy4gaWYgdGhlIG1vdXNlIGlzIHdpdGhpbiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIHdoZW4gdGhpcyBpcyBjYWxsZWQsIGlzU2VsZWN0ZWQgPSB0cnVlXG4gICAgICogQHBhcmFtIGd1aWRlQ29udGFpbnNcbiAgICAgKiBAcGFyYW0gY29udGFpbnNcbiAgICAgKi9cbiAgICBtb2RpZnlTdGF0ZShndWlkZUNvbnRhaW5zLCBjb250YWlucykge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkgeyAvL3ByZXBhcmVzIHRoZSBvYmplY3QgZm9yIGRyYWdnaW5nIHdoZXRoZXIgaXQgaXMgcGVyc29uYWxseSBzZWxlY3RlZCBvciBub3RcbiAgICAgICAgICAgIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kxID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYodGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC5tdWxTZWwpe1xuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKFwic3RyaW5nIGVmZmVjdCBtdWxTZWxlY3RlZDogXCIgKyB0aGlzLl9jb250ZXh0Lm11bFNlbGVjdGVkLm11bFNlbCk7XG4gICAgICAgICAgICAvLyAgICAgLy9pZih0aGlzLl9jb250ZXh0Lm11bFNlbGVjdGVkLnZhbCl7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nU2VsZWN0ZWQoKSk7XG4gICAgICAgICAgICAvLyAgICAgLy90aGlzLmxvZ1NlbGVjdGVkKCk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucykgeyAvL2lmIHRoZSBjb3JuZXIgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIHdlIGFyZSByZXNpemluZ1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSB0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2codGhpcy5fc3RyLnZhbCArIFwiaXMgc2VsZWN0ZWQ/XCIgKyB0aGlzLl9zZWxlY3RlZCk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwic3RhdGUgc2VsZWN0aW9uIGlzIFwiICsgdGhpcy5fc3RyLnZhbCk7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMueDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy55O1xuICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zaXplMSA9IHRoaXMuX2ZvbnRTaXplOyAvLyBzYXZpbmcgb2xkIGZvbnQgc2l6ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICB0aGlzLl94MSA9IHRoaXMueDsgLy8gU2F2aW5nIG9yaWdpbmFsIHggYW5kIHlcbiAgICAgICAgICAgIHRoaXMuX3kxID0gdGhpcy55O1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2codGhpcy5fc3RyLnZhbCArIFwiaXMgc2VsZWN0ZWQ/XCIgKyB0aGlzLl9zZWxlY3RlZCk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwic3RhdGUgc2VsZWN0aW9uIGlzIFwiICsgdGhpcy5fc3RyLnZhbCk7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLng7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLnk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzRWRpdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2codGhpcy5fc3RyLnZhbCArIFwiIGlzIGRyYWdnaW5nPyBcIiArIHRoaXMuX2lzRHJhZ2dpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIHRvIGZhbHNlIChsaWtlIGRyYWdnaW5nLCByZXNpemluZywgZXRjKSB3aGVuIHRoZSBtb3VzZSBpcyByZWxlYXNlZFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX3N0ci52YWwgKyBcIiBsb2dnaW5nIGRyYWdcIik7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB0aGlzLngpID4gMSB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHRoaXMueSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nTW92ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jlc2l6aW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2codGhpcy5fc3RyLnZhbCArIFwiIGxvZ2dpbmcgcmVzaXplXCIpO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3NpemUxIC0gdGhpcy5fZm9udFNpemUpID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1Jlc2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJzdHJpbmcgZWZmZWN0IG11bFNlbGVjdGVkOiBcIiArIHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQudmFsKTtcbiAgICAgICAgLy8gaWYodGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC52YWwpe1xuICAgICAgICAvLyAgICAgdGhpcy5sb2dTZWxlY3RlZCgpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmKHRoaXMuaXNNdWx0aXBsZVNlbGVjdGVkKXtcbiAgICAgICAgLy8gICAgIGNvbnRleHQuZXZlbnRMb2cucHVzaChuZXcgU2VsZWN0RXZlbnQoc2VsZWN0ZWRFbGVtcykpO1xuICAgICAgICAvLyAgICAgbWFzdGVyTG9nLnB1c2goY29udGV4dC5ldmVudExvZ1tjb250ZXh0LmV2ZW50TG9nLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgLy8gICAgIC8vY29uc29sZS5sb2coXCJtdWx0aXBsZSBzZWxlY3RlZFwiKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyAvL3RoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ01vdmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKiBOT1RFOiBpbiBGaXJlZm94LCB3aW5kb3cuZXZlbnQgaXMgbm90IGdsb2JhbC4gTmVlZCB0byBiZSBwYXNzZWQgaW4gaGVyZSBhcyBhIHBhcmFtYXRlci5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIGdldE1vdXNlUG9zaXRpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fbW91c2UueCA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLng7XG4gICAgICAgIHRoaXMuX21vdXNlLnkgPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzQ2hhbmdpbmdEaW1zLCBhbmQgaXNTZWxlY3RlZCB0byBmYWxzZSBpZiB0aGUgbW91c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgaXNNb3VzZU91dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1vdXNlWCA8IHJlY3QubGVmdCB8fCBtb3VzZVggPiByZWN0LnJpZ2h0IHx8IG1vdXNlWSA8IHJlY3QudG9wIHx8IG1vdXNlWSA+IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHBhaW50IGV2ZW50XG4gICAgICovXG4gICAgbG9nUGFpbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpbnRFdmVudF8xLlBhaW50RXZlbnQodGhpcy5fc3RyLnZhbCwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVzaXplIGV2ZW50XG4gICAgICovXG4gICAgbG9nUmVzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZUV2ZW50XzEuUmVzaXplRXZlbnQodGhpcy5fc3RyLnZhbCArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgTWF0aC5yb3VuZCh0aGlzLl9zaXplMSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5fZm9udFNpemUgKiAxMDApIC8gMTAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIGNsaWNrIGV2ZW50XG4gICAgICovXG4gICAgbG9nQ2xpY2soKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xpY2tFdmVudF8xLkNsaWNrRXZlbnQodGhpcy5fc3RyLnZhbCArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgYXNzaWducyBhbiBJRCB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgaW5pdElEKGlkKSB7XG4gICAgICAgIHRoaXMuaWRPYmogPSB7IF9pZDogaWQsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIGdldCBjYW52YXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBjYW52YXMgVGhlIGNhbnZhcyB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldCBjYW52YXMoY2FudmFzKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgICB9XG4gICAgYXN0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgZWxsaXBzZVxuICAgICAqL1xuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBlbGxpcHNlXG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERpbWVuc2lvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVsbGlwc2UgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgKi9cbiAgICBnZXRKdXN0RHJhZ2dlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1c3REcmFnZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgc2V0SnVzdERyYWdnZWQodmFsKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGlzIGRyYWdnaW5nXG4gICAgICovXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXQgc3RyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RyLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb2JqZWN0IElEXG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkT2JqLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBzZWxlY3Rpb24gZXZlbnRzXG4gICAgICovXG4gICAgdG9TZWxTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIiBcIiArIHRoaXMuX3N0ci52YWwgKyBcIiB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIGRyYWcgZXZlbnRzXG4gICAgKi9cbiAgICB0b0RyYWdTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fc3RyLnZhbCArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94MSArIFwiLCBcIiArIHRoaXMuX3kxICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gXCIgKyB0aGlzLl9zdHIudmFsICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaW5nRWZmZWN0ID0gU3RyaW5nRWZmZWN0O1xuLyoqXG4gKiBHZXQncyB0aGUgbW91c2UgeCBhbmQgeSBjb29yZGluYXRlcyBpbiByZWxhdGlvbiB0byB0aGUgY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHRoZSBjYW52YXMgb2JqZWN0XG4gKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICovXG5mdW5jdGlvbiBnZXRNb3VzZVBvcyhjYW52YXMsIGV2ZW50KSB7XG4gICAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHgxIHggY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHkxIHkgY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHgyIHggY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSB5MiB5IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgyLCAyKSArIE1hdGgucG93KHkxIC0geTIsIDIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmluZ0VmZmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFJldHVybkVycm9yXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9SZXR1cm5FcnJvclwiKTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xuLy8gQXBwbGljYXRpb24gb2YgYSBmdW5jdGlvbi4gQXNzdW1lcyBhcmcgdmFsdWVzIHBhc3NlZCBpbiBzYW1lIG9yZGVyIGFzIEZ1bkRlZiBhcmdzXG5jbGFzcyBGdW5BcHAge1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYSBmdW5jdGlvbiBhcHBsaWNhdGlvblxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBhcmdzIEZ1bmN0aW9uIGFyZ3VtZW50cywgaWYgYXBwbGljYWJsZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiwgaWYgYW55XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgYXJncywgd3MsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX2FyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGZ1bmRlZiA9IGNvbnRleHQubG9va3VwKHRoaXMuX25hbWUsIGNvbnRleHQpOyAvLyBsb29raW5nIHVwIGZ1bmN0aW9uXG4gICAgICAgIC8vbGV0IGNoaWxkID0gbmV3IFNjb3BlKGZ1bmRlZi5zY29wZSk7IC8vIGF2b2lkaW5nIG92ZXJ3cml0ZTsgbmVlZCB0byB0b3NzIGFmdGVyIHJldHVybmluZ1xuICAgICAgICBsZXQgY2hpbGQgPSBmdW5kZWYuc2NvcGUuY29weSgpOyAvLyBDb3B5aW5nIGRlZmluaXRpb24gc2NvcGVcbiAgICAgICAgLy8gQXNzaWducyBhcmcgdmFsdWVzIHRvIGRlZmluaXRpb24gYXJndW1lbnRzXG4gICAgICAgIGlmICh0aGlzLl9hcmdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXJncy5sZW5ndGg7IGkrKykgeyAvL2xvb2t1cHM/XG4gICAgICAgICAgICAgICAgLy9jaGlsZC5kZWNsYXJlKHRoaXMuX2Z1bmN0LmFyZ3NbaV0pOyAvLyByZWRlY2xhcmU/XG4gICAgICAgICAgICAgICAgY2hpbGQuYXNzaWduKGZ1bmRlZi5hcmdzW2ldLCB0aGlzLl9hcmdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaWQgPSBjb250ZXh0Lmdsb2JhbEZ1bklEOyAvLyBBc3NpZ25zIGFuIElEIHRvIHRoZSBmdW5jdGlvblxuICAgICAgICBjb250ZXh0Lmdsb2JhbEZ1bklEKys7XG4gICAgICAgIGNoaWxkLnJldFZhbElEID0gc3BhY2VfbGlmdF8xLlNvbWUoaWQpOyAvLyBuZXcgbWV0aG9kXG4gICAgICAgIC8vIHdlIG9ubHkgcmV0dXJuIGEgdmFsdWUgd2l0aCBmdW5jdGlvbiBhcHBsaWNhdGlvblxuICAgICAgICAvLyBpZiBpdCBpcyBleHBsaWNpdGx5IHJldHVybmVkIHVzaW5nIGEgcmV0dXJuIHN0YXRlbWVudDtcbiAgICAgICAgLy8gd2UgYWJ1c2UgSlMgZXhjZXB0aW9ucyBmb3IgdGhpcyBwdXJwb3NlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGlsZC5oYWRGdW5FdmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIGZ1bmRlZi5ib2R5LmV2YWwoY2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgd2UgY2F0Y2ggb25seSB0aGUgZXJyb3IgaW50ZW5kZWQgZm9yIHVzXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJldHVybkVycm9yXzEuUmV0dXJuRXJyb3IgJiYgcGFyc2VJbnQoZS5JRCkgPT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5yZXRWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlcnJvciB3YXMgbm90IGludGVuZGVkIGZvciB1czsgcmV0aHJvd1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICAvL3JldHVybiBmdW5kZWYuYm9keS5ldmFsKGNoaWxkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZnVuY3Rpb24gYXBwbGljYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGFyZ3NMaXN0ID0gJyc7XG4gICAgICAgIGlmICh0aGlzLl9hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXJncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzTGlzdCArPSB0aGlzLl9hcmdzW2ldLnRvU3RyaW5nKCkgKyBcIiwgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzTGlzdCArPSB0aGlzLl9hcmdzW3RoaXMuX2FyZ3MubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLm5hbWUgKyAnKCcgKyBhcmdzTGlzdCArIFwiKVwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGFwcGxpY2F0aW9ucyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBmdW5jdGlvbiBhcHBsaWNhdGlvblxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gZnVuY3Rpb25zXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXJndW1lbnRzIG9mIHRoZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldCBhcmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXJncztcbiAgICB9XG59XG5leHBvcnRzLkZ1bkFwcCA9IEZ1bkFwcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZ1bkFwcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNsYXNzIEZ1bkRlZiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgYm9keSwgYXJncywgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5fYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLy8gQmluZHMgYXJncyBpbiBjb250ZXh0IG9mIGRlZmluaXRpb247IG5vIHZhbHVlc1xuICAgIC8vIEJpbmRzIG5hbWUgdG8gcGFyZW50IGNvbnRleHQgKGN1ciBjb250ZXh0IGlzIG5ldyBjb250ZXh0KVxuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICB0aGlzLl9mdW5TY29wZSA9IG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpOyAvLyAqKioqKioqKioqKioqIGNvcHk/Pz8/XG4gICAgICAgIHRoaXMuX2Z1blNjb3BlLmNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgICAgICB0aGlzLl9mdW5TY29wZS5ldmVudExvZyA9IGNvbnRleHQuZXZlbnRMb2c7XG4gICAgICAgIHRoaXMuX2Z1blNjb3BlLmVmZmVjdHMgPSBjb250ZXh0LmVmZmVjdHM7XG4gICAgICAgIC8qXG4gICAgICAgIGlmKHRoaXMuX2FyZ3MgIT0gbnVsbCl7XG4gICAgICAgICAgICBmb3IobGV0IGVudHJ5IG9mIHRoaXMuX2FyZ3Mpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1blNjb3BlLmRlY2xhcmUoZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIGNvbnRleHQuZGVjbGFyZSh0aGlzLl9uYW1lKTsgLy8gYXNzaWduIHdpdGggdmFsIGZ1bmN0aW9uXG4gICAgICAgIGNvbnRleHQuYXNzaWduKHRoaXMuX25hbWUsIHRoaXMpOyAvLyBwYXJlbnQgb3IgY3VycmVudD9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGFyZ3NMaXN0ID0gJyc7XG4gICAgICAgIGlmICh0aGlzLl9hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXJncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzTGlzdCArPSB0aGlzLl9hcmdzW2ldICsgXCIsIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnc0xpc3QgKz0gdGhpcy5fYXJnc1t0aGlzLl9hcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwiZnVuIFwiICsgdGhpcy5fbmFtZSArIFwiKFwiICsgYXJnc0xpc3QgKyAnKScgKyAnIHtcXG4gJyArIHRoaXMuX2JvZHkudG9TdHJpbmcoKSArICd9JztcbiAgICB9XG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGZ1bmN0aW9uc1wiKTtcbiAgICB9XG4gICAgLy8gR2V0IG1ldGhvZHNcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIGdldCBib2R5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9keTtcbiAgICB9XG4gICAgZ2V0IGFyZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcmdzO1xuICAgIH1cbiAgICBnZXQgc2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mdW5TY29wZTtcbiAgICB9XG59XG5leHBvcnRzLkZ1bkRlZiA9IEZ1bkRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZ1bkRlZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIExpc3ROb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYW4gYXJyYXktbGlrZSBsaXN0XG4gICAgICogQHBhcmFtIGxpc3QgVGhlIGxpc3QsIHN0b3JlZCBpbiBhIFRTIGFycmF5XG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGlzdCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9saXN0ID0gbGlzdDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyBlYWNoIGVsZW1lbnQgb2YgdGhlIGxpc3QgYW5kIHB1c2hlcyBpdCBvbnRvIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBldmFsTGlzdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBleHByIG9mIHRoaXMuX2xpc3QpIHtcbiAgICAgICAgICAgIGV2YWxMaXN0LnB1c2goZXhwci5ldmFsKGNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpc3ROb2RlKGV2YWxMaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGlzdFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgbGlzdCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2xpc3QubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0ICs9IHRoaXMuX2xpc3RbaV0udG9TdHJpbmcoKSArIFwiLCBcIjtcbiAgICAgICAgfVxuICAgICAgICBsaXN0ICs9IHRoaXMuX2xpc3RbdGhpcy5fbGlzdC5sZW5ndGggLSAxXS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyAnWycgKyBsaXN0ICsgJ10nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGxpc3QgZXF1YWxzIGFub3RoZXIgbGlzdFxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHkgKG11c3QgYmUgYSBMaXN0Tm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgTGlzdE5vZGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcy5saXN0W2ldLmVxdWFsc1ZhbChyaWdodC5saXN0W2ldKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhdyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgbGlzdFxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkcmF3IGEgTGlzdE5vZGVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxpc3RcbiAgICAgKi9cbiAgICBnZXQgbGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0Tm9kZSA9IExpc3ROb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlzdE5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMb2dFdmVudF8xID0gcmVxdWlyZShcIi4vTG9nRXZlbnRcIik7XG5jbGFzcyBDbGVhckV2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBDbGVhciBFdmVudCwgd2hpY2ggbG9ncyB3aGVuIHRoZSBjYW52YXMgaXMgY2xlYXJlZFxuICAgICAqIEBwYXJhbSB0b0xvZyBXaGF0IHRvIGxvZyAoc3BvaWxlcjogbm90aGluZylcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b0xvZykge1xuICAgICAgICBzdXBlcih0b0xvZyk7XG4gICAgICAgIHRoaXMudGFnID0gXCJjbGVhclwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYW5kIHJldHVybnMgbWVzc2FnZSBcIkNvbnNvbGUgY2xlYXJlZFwiIHdpdGggZGF0ZSBhbmQgdGltZSBhdHRhY2hlZFxuICAgICAqL1xuICAgIGFzc2VtYmxlTG9nKCkge1xuICAgICAgICBsZXQgdG9QcmludCA9IFwiQ29uc29sZSBjbGVhcmVkXCI7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0l0ZW0odG9QcmludCk7XG4gICAgfVxuICAgIGV2ZW50VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2xlYXJFdmVudFwiO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiBcInt9XCI7XG4gICAgfVxufVxuZXhwb3J0cy5DbGVhckV2ZW50ID0gQ2xlYXJFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNsZWFyRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMb2dFdmVudF8xID0gcmVxdWlyZShcIi4vTG9nRXZlbnRcIik7XG5jbGFzcyBDbGlja0V2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgQ2xpY2sgRXZlbnQsIHdoaWNoIGxvZ3Mgd2hlbiBhbiBvYmplY3Qgb24gdGhlIGNhbnZhcyBpcyBjbGlja2VkXG4gICAgICogQHBhcmFtIHRvTG9nIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCB0byBsb2dcbiAgICAgKiBAcGFyYW0geDEgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0IHRvIGxvZ1xuICAgICAqIEBwYXJhbSB5MSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3QgdG8gbG9nXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9Mb2csIHgxLCB5MSkge1xuICAgICAgICBzdXBlcih0b0xvZywgeDEsIHkxKTtcbiAgICAgICAgdGhpcy50YWcgPSBcImNsaWNrXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhbmQgcmV0dXJucyBtZXNzYWdlIG9mIGZvcm0gXCJDbGlja2VkIG9uIG9iaiBhdCB4LCB5XCIgd2l0aCBkYXRlIGFuZCB0aW1lIGF0dGFjaGVkXG4gICAgICovXG4gICAgYXNzZW1ibGVMb2coKSB7XG4gICAgICAgIGxldCB0b1ByaW50ID0gXCJDbGlja2VkIG9uIFwiICsgdGhpcy50b0xvZyArIFwiIGF0IFwiICsgdGhpcy54MS50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy55MS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dJdGVtKHRvUHJpbnQpO1xuICAgIH1cbiAgICBldmVudFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcIkNsaWNrRXZlbnRcIjtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gXCJ7IG9uOiAnXCIgKyB0aGlzLnRvTG9nICsgXCInLCB4OiAnXCIgKyB0aGlzLngxICsgXCInLCB5OiAnXCIgKyB0aGlzLnkxICsgXCInIH1cIjtcbiAgICB9XG59XG5leHBvcnRzLkNsaWNrRXZlbnQgPSBDbGlja0V2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xpY2tFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ0V2ZW50XzEgPSByZXF1aXJlKFwiLi9Mb2dFdmVudFwiKTtcbmNsYXNzIERyYWdFdmVudCBleHRlbmRzIExvZ0V2ZW50XzEuTG9nRXZlbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIERyYWcgRXZlbnQsIHdoaWNoIGxvZ3Mgd2hlbiBhbiBvYmplY3Qgb24gdGhlIGNhbnZhcyBpcyBkcmFnZ2VkXG4gICAgICogQHBhcmFtIHRvTG9nIFRoZSBlZmZlY3QgdG8gbG9nXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9Mb2cpIHtcbiAgICAgICAgc3VwZXIodG9Mb2cpO1xuICAgICAgICB0aGlzLnRhZyA9IFwiZHJhZ1wiO1xuICAgICAgICB0aGlzLl90b1ByaW50ID0gdGhpcy5hc3NlbWJsZVN0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBsb2cgc3RyaW5nIHVzaW5nIHRoZSBFZmZlY3QncyB0b0RyYWdTdHJpbmcoKSBtZXRob2RcbiAgICAgKi9cbiAgICBhc3NlbWJsZVN0cmluZygpIHtcbiAgICAgICAgdGhpcy5fdG9QcmludCA9IHRoaXMudG9Mb2cudG9EcmFnU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl90b1ByaW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYW5kIHJldHVybnMgZmluYWwgbG9nIG1lc3NhZ2Ugb2YgZm9ybSBcIkRyYWdnZWQgb2JqIGZyb20geDEsIHkxIHRvIHgyLCB5MlwiXG4gICAgICogd2l0aCBkYXRlIGFuZCB0aW1lIGF0dGFjaGVkXG4gICAgICovXG4gICAgYXNzZW1ibGVMb2coKSB7XG4gICAgICAgIGxldCBwcmludCA9IFwiRHJhZ2dlZCBcIiArIHRoaXMuX3RvUHJpbnQ7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0l0ZW0ocHJpbnQpO1xuICAgIH1cbiAgICBldmVudFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcIkRyYWdFdmVudFwiO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiBcInsgb246ICdcIiArIHRoaXMudG9Mb2cudG9EcmFnU3RyaW5nKCkgKyBcIicgfVwiO1xuICAgIH1cbn1cbmV4cG9ydHMuRHJhZ0V2ZW50ID0gRHJhZ0V2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHJhZ0V2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0xvZ0V2ZW50XCIpO1xuY2xhc3MgSURFdmVudCBleHRlbmRzIExvZ0V2ZW50XzEuTG9nRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEEgY29uc3RydWN0b3IgZm9yIGFuIElEIGV2ZW50LCB1c2VkIHdoZW4gYW4gb2JqZWN0IGdldHMgYXNzaWduZWQgYW4gSURcbiAgICAgKiBAcGFyYW0gdG9Mb2cgVGhlIGVmZmVjdCB0byBsb2dcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b0xvZykge1xuICAgICAgICBzdXBlcih0b0xvZyk7XG4gICAgICAgIHRoaXMudGFnID0gXCJJRFwiO1xuICAgICAgICB0aGlzLl90b1ByaW50ID0gdGhpcy5hc3NlbWJsZVN0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgc3RyaW5nIHVzaW5nIHRoZSBlZmZlY3QncyB0b0lEU3RyaW5nKCkgbWV0aG9kXG4gICAgICovXG4gICAgYXNzZW1ibGVTdHJpbmcoKSB7XG4gICAgICAgIHRoaXMuX3RvUHJpbnQgPSB0aGlzLnRvTG9nLnRvSURTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvUHJpbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBtZXNzYWdlIG9mIGZvcm0gXCJBc3NpZ25lZCBJRCAjIHRvIG9iaiBhdCB4LCB5XCIgd2l0aCBkYXRlIGFuZCB0aW1lIGF0dGFjaGVkXG4gICAgICovXG4gICAgYXNzZW1ibGVMb2coKSB7XG4gICAgICAgIGxldCBwcmludCA9IFwiQXNzaWduZWQgSUQgXCIgKyB0aGlzLl90b1ByaW50O1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dJdGVtKHByaW50KTtcbiAgICB9XG4gICAgZXZlbnRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJJREV2ZW50XCI7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIFwieyBvbjogJ1wiICsgdGhpcy50b0xvZy50b0lEU3RyaW5nKCkgKyBcIicgfVwiO1xuICAgIH1cbn1cbmV4cG9ydHMuSURFdmVudCA9IElERXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JREV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgTG9nRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IGNsYXNzIGNvbnN0cnVjdG9yIGZvciBhIExvZyBFdmVudC4gUmVnaXN0ZXJzIGV2ZW50IHRpbWUuXG4gICAgICogQHBhcmFtIHRvTG9nIFRoZSBzdHJpbmcsIG9iamVjdCwgb3IgYXJyYXkgb2Ygb2JqZWN0cyB0byBiZSBsb2dnZWRcbiAgICAgKiBAcGFyYW0geDEgSW5pdGlhbCB4IHBvc2l0aW9uLCBpZiBhcHBsaWNhYmxlXG4gICAgICogQHBhcmFtIHkxIEluaXRpYWwgeSBwb3NpdGlvbiwgaWYgYXBwbGljYWJsZVxuICAgICAqIEBwYXJhbSB4MiBGaW5hbCB4IHBvc2l0aW9uLCBpZiBhcHBsaWNhYmxlXG4gICAgICogQHBhcmFtIHkyIEZpbmFsIHkgcG9zaXRpb24sIGlmIGFwcGxpY2FibGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b0xvZywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgbGV0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5fZGF0ZSA9IHRvZGF5LmdldEZ1bGxZZWFyKCkgKyAnLScgKyAodG9kYXkuZ2V0TW9udGgoKSArIDEpICsgJy0nICsgdG9kYXkuZ2V0RGF0ZSgpO1xuICAgICAgICB0aGlzLl90aW1lID0gdG9kYXkuZ2V0SG91cnMoKSArIFwiOlwiICsgdG9kYXkuZ2V0TWludXRlcygpICsgXCI6XCIgKyB0b2RheS5nZXRTZWNvbmRzKCk7XG4gICAgICAgIHRoaXMuX2RhdGVUaW1lID0gdGhpcy5fZGF0ZSArICcgJyArIHRoaXMuX3RpbWU7XG4gICAgICAgIHRoaXMuX3RvTG9nID0gdG9Mb2c7XG4gICAgICAgIC8vdGhpcy5fdG9Mb2dBcnJheSA9IHRvTG9nQXJyYXk7XG4gICAgICAgIHRoaXMuX3gxID0geDE7XG4gICAgICAgIHRoaXMuX3kxID0geTE7XG4gICAgICAgIHRoaXMuX3gyID0geDI7XG4gICAgICAgIHRoaXMuX3kyID0geTI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGRhdGUgYW5kIHRpbWUgdG8gbG9nIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gdG9Mb2cgVGhlIGxvZyBtZXNzYWdlXG4gICAgICovXG4gICAgbG9nSXRlbSh0b0xvZykge1xuICAgICAgICByZXR1cm4gXCIgXCIgKyB0aGlzLl9kYXRlVGltZSArIFwiOiBcIiArIHRvTG9nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRhdGUtdGltZSBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXQgZGF0ZVRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgb3IgZWZmZWN0KHMpIHRvIGJlIGxvZ2dlZFxuICAgICAqL1xuICAgIGdldCB0b0xvZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvTG9nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGV2ZW50IHRhZ1xuICAgICAqL1xuICAgIGdldCB0YWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGFnIHN0cmluZ1xuICAgICAqL1xuICAgIHNldCB0YWcodGFnKSB7XG4gICAgICAgIHRoaXMuX3RhZyA9IHRhZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB4MVxuICAgICAqL1xuICAgIGdldCB4MSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3gxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHkxXG4gICAgICovXG4gICAgZ2V0IHkxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgeDJcbiAgICAgKi9cbiAgICBnZXQgeDIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94MjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB5MlxuICAgICAqL1xuICAgIGdldCB5MigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3kyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIHRvIGEgcmVtb3RlIHNlcnZlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9nVG9SZW1vdGVTZXJ2ZXIoZXZlbnR0eXBlLCB1aWQsIGRhdGEpIHtcbiAgICAgICAgLy8gbW9kaWZpZWQgZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEwMDczNzg4LzQ4MDc2NFxuICAgICAgICBmdW5jdGlvbiBwYWQobiwgd2lkdGgpIHtcbiAgICAgICAgICAgIGxldCBwYWRXaXRoID0gJzAnO1xuICAgICAgICAgICAgbGV0IG5zdHIgPSBuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gbnN0ci5sZW5ndGggPj0gd2lkdGggPyBuc3RyIDogbmV3IEFycmF5KHdpZHRoIC0gbnN0ci5sZW5ndGggKyAxKS5qb2luKHBhZFdpdGgpICsgbnN0cjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGxldCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBtb250aCA9IHBhZChkYXRlLmdldE1vbnRoKCkgKyAxLCAyKTtcbiAgICAgICAgbGV0IGRheSA9IHBhZChkYXRlLmdldERheSgpLCAyKTtcbiAgICAgICAgbGV0IGhvdXIgPSBwYWQoZGF0ZS5nZXRIb3VycygpLCAyKTtcbiAgICAgICAgbGV0IG1pbnV0ZXMgPSBwYWQoZGF0ZS5nZXRNaW51dGVzKCksIDIpO1xuICAgICAgICBsZXQgc2Vjb25kcyA9IHBhZChkYXRlLmdldFNlY29uZHMoKSwgMik7XG4gICAgICAgIGxldCBwYXlsb2FkID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIHBheWxvYWQuYXBwZW5kKCd1aWQnLCB1aWQpO1xuICAgICAgICBwYXlsb2FkLmFwcGVuZCgnZGF0YScsIGRhdGEpO1xuICAgICAgICBwYXlsb2FkLmFwcGVuZCgnZXZlbnR0eXBlJywgZXZlbnR0eXBlKTtcbiAgICAgICAgLy8gTVVTVCBVU0UgVEhFIEZPTExPV0lORyBEQVRFIEZPUk1BVFxuICAgICAgICAvLyBwYXlsb2FkLmFwcGVuZCgndGltZScsICcyMDE5LTAxLTAxIDE2OjM2OjAwJyk7XG4gICAgICAgIHBheWxvYWQuYXBwZW5kKCd0aW1lJywgeWVhciArICctJyArIG1vbnRoICsgJy0nICsgZGF5ICsgJyAnICsgaG91ciArICc6JyArIG1pbnV0ZXMgKyAnOicgKyBzZWNvbmRzKTtcbiAgICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbihcIlBPU1RcIiwgXCJodHRwOi8vY2FtZW1iZXJ0LmNzLndpbGxpYW1zLmVkdTo4MDgwL2V2ZW50c1wiLCB0cnVlKTtcbiAgICAgICAgeGhyLnNlbmQocGF5bG9hZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Mb2dFdmVudCA9IExvZ0V2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9nRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMb2dFdmVudF8xID0gcmVxdWlyZShcIi4vTG9nRXZlbnRcIik7XG5jbGFzcyBQYWludEV2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgUGFpbnQgRXZlbnQsIHVzZWQgd2hlbiBhbiBvYmplY3QgaXMgcGFpbnRlZCBvbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHRvTG9nIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCB0byBiZSBsb2dnZWRcbiAgICAgKiBAcGFyYW0geDEgVGhlIHggcG9zaXRpb24gb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB5MSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9Mb2csIHgxLCB5MSkge1xuICAgICAgICBzdXBlcih0b0xvZywgeDEsIHkxKTtcbiAgICAgICAgdGhpcy50YWcgPSBcInBhaW50XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhbmQgcmV0dXJucyBtZXNzYWdlIG9mIGZvcm0gXCJQYWludGVkIG9iaiBhdCB4LCB5XCIgd2l0aCBkYXRlIGFuZCB0aW1lIGF0dGFjaGVkXG4gICAgICovXG4gICAgYXNzZW1ibGVMb2coKSB7XG4gICAgICAgIGxldCB0b1ByaW50ID0gXCJQYWludGVkIFwiICsgdGhpcy50b0xvZyArIFwiIGF0IFwiICsgdGhpcy54MS50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy55MS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dJdGVtKHRvUHJpbnQpO1xuICAgIH1cbiAgICBldmVudFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcIlBhaW50RXZlbnRcIjtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gXCJ7IG9uOiAnXCIgKyB0aGlzLnRvTG9nICsgXCInLCB4OiAnXCIgKyB0aGlzLngxICsgXCInLCB5OiAnXCIgKyB0aGlzLnkxICsgXCInIH1cIjtcbiAgICB9XG59XG5leHBvcnRzLlBhaW50RXZlbnQgPSBQYWludEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFpbnRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ0V2ZW50XzEgPSByZXF1aXJlKFwiLi9Mb2dFdmVudFwiKTtcbmNsYXNzIFJlc2l6ZUV2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIFJlc2l6ZSBFdmVudCwgdXNlZCB3aGVuIGFuIG9iamVjdCBvbiB0aGUgY2FudmFzIGlzIHJlc2l6ZWRcbiAgICAgKiBAcGFyYW0gdG9Mb2cgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QgdG8gYmUgbG9nZ2VkXG4gICAgICogQHBhcmFtIHgxIEluaXRpYWwgeCBkaW1lbnNpb24gb2YgdGhlIG9iamVjdCwgb3IgaW5pdGlhbCBmb250IHNpemVcbiAgICAgKiBAcGFyYW0geTEgSW5pdGlhbCB5IGRpbWVuc2lvbiBvZiB0aGUgb2JqZWN0LCBvciBmaW5hbCBmb250IHNpemVcbiAgICAgKiBAcGFyYW0geDIgRmluYWwgeCBkaW1lbnNpb24gb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB5MiBGaW5hbCB5IGRpbWVuc2lvbiBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9Mb2csIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHN1cGVyKHRvTG9nLCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgIHRoaXMudGFnID0gXCJyZXNpemVcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGxvZyBtZXNzYWdlIG9mIGZvcm0gXCJSZXNpemVkIG9iaiBmcm9tIHNpemUgeDEsIHkxIHRvIHNpemUgeDIsIHkyXCIgZm9yIHJlY3RzIGFuZCBlbGxpcHNlc1xuICAgICAqIG9yIG9mIGZvcm0gXCJSZXNpemVkIG9iaiBmcm9tIHNpemUgeDEgdG8gc2l6ZSB5MVwiIGZvciBzdHJpbmdzXG4gICAgICogSGFzIGRhdGUgYW5kIHRpbWUgYXR0YWNoZWRcbiAgICAgKi9cbiAgICBhc3NlbWJsZUxvZygpIHtcbiAgICAgICAgaWYgKHRoaXMueDIgIT0gdW5kZWZpbmVkICYmIHRoaXMueTIgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnRvUHJpbnQgPSBcIlJlc2l6ZWQgXCIgKyB0aGlzLnRvTG9nICsgXCIgZnJvbSBzaXplIFwiICsgdGhpcy54MS50b1N0cmluZygpICsgXCIgYnkgXCIgKyB0aGlzLnkxLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICArIFwiIHRvIHNpemUgXCIgKyB0aGlzLngyLnRvU3RyaW5nKCkgKyBcIiBieSBcIiArIHRoaXMueTIudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9QcmludCA9IFwiUmVzaXplZCBcIiArIHRoaXMudG9Mb2cgKyBcIiBmcm9tIHNpemUgXCIgKyB0aGlzLngxLnRvU3RyaW5nKCkgKyBcIiB0byBzaXplIFwiICsgdGhpcy55MS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0l0ZW0odGhpcy50b1ByaW50KTtcbiAgICB9XG4gICAgZXZlbnRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJSZXNpemVFdmVudFwiO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICh0aGlzLngyICE9IHVuZGVmaW5lZCAmJiB0aGlzLnkyICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwieyBvbjogJ1wiICsgdGhpcy50b0xvZyArIFwiJywgZnJvbV94OiAnXCIgKyB0aGlzLngxICsgXCInLCBmcm9tX3k6ICdcIiArIHRoaXMueTEgKyBcIicsIHRvX3g6ICdcIiArIHRoaXMueDIgKyBcIicsIHRvX3k6ICdcIiArIHRoaXMueTIgKyBcIicgfVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSSBkb24ndCB1bmRlcnN0YW5kIHRoaXMuIFdoeSB0aGlzLnkxP1xuICAgICAgICAgICAgcmV0dXJuIFwieyBvbjogJ1wiICsgdGhpcy50b0xvZyArIFwiJywgZnJvbV94OiAnXCIgKyB0aGlzLngxICsgXCInLCB0b195OiAnXCIgKyB0aGlzLnkxICsgXCInIH1cIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUmVzaXplRXZlbnQgPSBSZXNpemVFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlc2l6ZUV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0xvZ0V2ZW50XCIpO1xuY2xhc3MgU2VsZWN0RXZlbnQgZXh0ZW5kcyBMb2dFdmVudF8xLkxvZ0V2ZW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBTZWxlY3Rpb24gRXZlbnQsIHVzZWQgd2hlbiBtdWx0aXBsZSBvYmplY3RzIG9uIHRoZSBjYW52YXMgYXJlIHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHRvTG9nIFRoZSBhcnJheSBvZiBvYmplY3RzIHNlbGVjdGVkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9Mb2cpIHtcbiAgICAgICAgc3VwZXIodG9Mb2cpO1xuICAgICAgICB0aGlzLnRhZyA9IFwic2VsZWN0XCI7XG4gICAgICAgIHRoaXMuX3RvUHJpbnQgPSB0aGlzLmFzc2VtYmxlU3RyaW5ncygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYW5kIHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYWxsIHRoZSBvYmplY3RzIHNlbGVjdGVkXG4gICAgICovXG4gICAgYXNzZW1ibGVTdHJpbmdzKCkge1xuICAgICAgICBsZXQgbG9nU3RyaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBlbGVtIG9mIHRoaXMudG9Mb2cpIHtcbiAgICAgICAgICAgIGxvZ1N0cmluZ3MucHVzaChlbGVtLnRvU2VsU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlNlbGVjdGVkXCIgKyBsb2dTdHJpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlIHdpdGggZGF0ZSBhbmQgdGltZSBhdHRhY2hlZFxuICAgICAqL1xuICAgIGFzc2VtYmxlTG9nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dJdGVtKHRoaXMuX3RvUHJpbnQpO1xuICAgIH1cbiAgICBldmVudFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcIlNlbGVjdEV2ZW50XCI7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIFwieyBvbjogJ1wiICsgdGhpcy5sb2dJdGVtKHRoaXMuX3RvUHJpbnQpICsgXCInIH1cIjtcbiAgICB9XG59XG5leHBvcnRzLlNlbGVjdEV2ZW50ID0gU2VsZWN0RXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZWxlY3RFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jbGFzcyBBbmQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBsb2dpY2FsICdhbmQnICgmJikgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgc2lkZSBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBvcGVyYXRpb24gYW5kIHJldHVybnMgYSBib29sZWFuIG9mIHRoZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlICYmIHJocyBpbnN0YW5jZW9mIEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMudmFsICYmIHJocy52YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50cyB0byB0aGUgJ2FuZCcgb3BlcmF0b3IgbXVzdCBiZSBib29sZWFucy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArICcgYW5kICcgKyB0aGlzLl9yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIHRoZSAnYW5kJyBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSAnYW5kJyBvcGVyYXRpb24gY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVmdCBzaWRlIG9mIHRoZSBvcFxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgb3BcbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLkFuZCA9IEFuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFuZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jbGFzcyBFcXVhbHMge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBlcXVhbGl0eSAoPT0pIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IHNpZGUgb2YgdGhlIGVxdWFsaXR5XG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIGNvbXBhcmlzb24gYW5kIGV2YWx1YXRlcyB0byBhIEJvb2xlYW5Ob2RlXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMuZXF1YWxzVmFsKHJocykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcXVhbGl0eSBvcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLl9sZWZ0LnRvU3RyaW5nKCkgKyAnIGVxdWFscyAnICsgdGhpcy5fcmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2FuJ3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGFuIGVxdWFsaXR5IG9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIndlbGwgdGhpcyBpcyBtZXRhXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbGl0eSBvcHMgY2FuJ3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLkVxdWFscyA9IEVxdWFscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVxdWFscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIEdyZWF0ZXJUaGFuIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgR3JlYXRlclRoYW4gKD4pIG9wXG4gICAgICogQHBhcmFtIGxlZnQgTGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSByaWdodCBSaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgR3JlYXRlclRoYW4gY29tcGFyaXNvbiBhbmQgcmV0dXJucyBCb29sZWFuTm9kZSByZXByZXNlbnRhdGlvbiBvZiByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSAmJiByaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMudmFsID4gcmhzLnZhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50cyB0byB0aGUgPiBvcGVyYXRvciBtdXN0IGJlIG51bWVyaWMuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLl9sZWZ0LnRvU3RyaW5nKCkgKyBcIiA+IFwiICsgdGhpcy5fcmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBHcmVhdGVyVGhhbiBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyZWF0ZXJUaGFuIG9wIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbn1cbmV4cG9ydHMuR3JlYXRlclRoYW4gPSBHcmVhdGVyVGhhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyZWF0ZXJUaGFuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgR3JlYXRlclRoYW5FcSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIEdyZWF0ZXJUaGFuRXEgKGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0bywgPj0pIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IExlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gcmlnaHQgUmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIEdyZWF0ZXJUaGFuRXEgb3BlcmF0aW9uIGFuZCByZXR1cm5zIEJvb2xlYW5Ob2RlIHdpdGggcmVzdWx0XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSAmJiByaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMudmFsID49IHJocy52YWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudHMgdG8gdGhlID49IG9wZXJhdG9yIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArICcgPj0gJyArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gR3JlYXRlclRoYW5FcSBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyZWF0ZXJUaGFuRXEgb3AgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG4gICAgfVxufVxuZXhwb3J0cy5HcmVhdGVyVGhhbkVxID0gR3JlYXRlclRoYW5FcTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyZWF0ZXJUaGFuRXEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jbGFzcyBMZXNzVGhhbiB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIExlc3NUaGFuICg8KSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBMZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0IFJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgTGVzc1RoYW4gY29tcGFyaXNvbiBhbmQgcmV0dXJucyBCb29sZWFuTm9kZSB3aXRoIHJlc3VsdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KSArIFwiIGlzIGxlc3MgdGhhbiBcIiArIHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCkpO1xuICAgICAgICBsZXQgbGhzID0gdGhpcy5fbGVmdC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBsZXQgcmhzID0gdGhpcy5fcmlnaHQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgaWYgKGxocyBpbnN0YW5jZW9mIE51bWJlck5vZGVfMS5OdW1iZXJOb2RlICYmIHJocyBpbnN0YW5jZW9mIE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiVGhleSdyZSBib3RoIG51bWJlciBub2Rlc1wiKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cobGhzLnZhbCArIFwiPFwiICsgcmhzLnZhbCk7XG4gICAgICAgICAgICAvL2xldCBib29sOiBib29sZWFuID0gbGhzLnZhbCA8IHJocy52YWw7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiYm9vbDogXCIgKyBib29sKTtcbiAgICAgICAgICAgIHJldHVybiAobmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLnZhbCA8IHJocy52YWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50cyB0byBsZXNzIHRoYW4gbXVzdCBwcm9kdWNlIG51bWVyaWMgdmFsdWVzLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArICcgPCAnICsgdGhpcy5fcmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBMZXNzVGhhbiBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlc3NUaGFuIG9wIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc1RoYW4gPSBMZXNzVGhhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NUaGFuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgTGVzc1RoYW5FcSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIExlc3NUaGFuRXEgKGxlc3MgdGhhbiBvciBlcXVhbCB0bywgPD0pIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IHNpZGUgb2YgdGhlIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgTGVzc1RoYW5FcSBjb21wYXJpc29uIGFuZCByZXR1cm5zIEJvb2xlYW5Ob2RlIHdpdGggcmVzdWx0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsaHMgPSB0aGlzLl9sZWZ0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGxldCByaHMgPSB0aGlzLl9yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUgJiYgcmhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLnZhbCA8PSByaHMudmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJndW1lbnRzIHRvIHRoZSA8PSBvcGVyYXRvciBtdXN0IGJlIG51bWVyaWMuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLl9sZWZ0LnRvU3RyaW5nKCkgKyBcIiA8PSBcIiArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gTGVzc1RoYW5FcSBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlc3NUaGFuRXEgb3BzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc1RoYW5FcSA9IExlc3NUaGFuRXE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzVGhhbkVxLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNsYXNzIE5vdCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBsb2dpY2FsIE5vdCAoISkgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGV4cHIgVGhlIGV4cHJlc3Npb24gdG8gYmUgb3BlcmF0ZWQgb24gKG11c3QgYmUgYSBCb29sZWFuTm9kZSlcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihleHByLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2V4cHIgPSBleHByO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIE5vdCBvcGVyYXRpb24gYW5kIHJldHVybnMgQm9vbGVhbk5vZGUgd2l0aCByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGUgPSB0aGlzLl9leHByLmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKCFlLnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJndW1lbnQgdG8gdGhlICEgb3BlcmF0b3IgbXVzdCBiZSBib29sZWFuLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJub3QgXCIgKyB0aGlzLl9leHByLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBOb3Qgb3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3Qgb3BlcmF0aW9ucyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGV4cHJlc3Npb24gdG8gYmUgb3BlcmF0ZWQgb25cbiAgICAgKi9cbiAgICBnZXQgZXhwcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHI7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3QgPSBOb3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jbGFzcyBOb3RFcXVhbCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIE5vdEVxdWFsICghPSkgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgTGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSByaWdodCBSaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgTm90RXF1YWwgb3BlcmF0aW9uIGFuZCByZXR1cm5zIEJvb2xlYW5Ob2RlIHdpdGggcmVzdWx0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsaHMgPSB0aGlzLl9sZWZ0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGxldCByaHMgPSB0aGlzLl9yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUgJiYgcmhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLnZhbCAhPT0gcmhzLnZhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50cyB0byB0aGUgIT0gb3BlcmF0b3IgbXVzdCBiZSBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5fbGVmdC50b1N0cmluZygpICsgXCIgbm90IGVxdWFscyBcIiArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBOb3RFcXVhbCBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdEVxdWFsIG9wcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLk5vdEVxdWFsID0gTm90RXF1YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob3RFcXVhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jbGFzcyBPciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGxvZ2ljYWwgJ29yJyAofHwpIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IExlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gcmlnaHQgUmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIE9yIG9wZXJhdGlvbiBhbmQgcmV0dXJucyBCb29sZWFuTm9kZSB3aXRoIHJlc3VsdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IEN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsaHMgPSB0aGlzLl9sZWZ0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGxldCByaHMgPSB0aGlzLl9yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZSAmJiByaHMgaW5zdGFuY2VvZiBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLnZhbCB8fCByaHMudmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudHMgdG8gdGhlICdvcicgb3BlcmF0b3IgbXVzdCBiZSBib29sZWFucy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArICcgb3IgJyArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gT3Igb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3Igb3BlcmF0aW9ucyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLk9yID0gT3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Pci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jb25zdCBzcGFjZV9saWZ0XzEgPSByZXF1aXJlKFwic3BhY2UtbGlmdFwiKTtcbmNsYXNzIEZvck5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIEZvciBsb29wXG4gICAgICogQHBhcmFtIGluaXQgSW5pdGlhbGl6ZXMgdGhlIHZhcmlhYmxlIHVzZWQgaW4gdGhlIGNvbmRpdGlvblxuICAgICAqIEBwYXJhbSBjb25kIFRoZSBjb25kaXRpb24gKG11c3QgZXZhbHVhdGUgdG8gQm9vbGVhbk5vZGUpXG4gICAgICogQHBhcmFtIHBvc3QgVGhlIHBvc3RldmFsdWF0aW9uIGNvbmRpdGlvblxuICAgICAqIEBwYXJhbSBib2R5IFRoZSBib2R5IG9mIHRoZSBsb29wXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW5pdCwgY29uZCwgcG9zdCwgYm9keSwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2luaXQgPSBpbml0O1xuICAgICAgICB0aGlzLl9jb25kID0gY29uZDtcbiAgICAgICAgdGhpcy5fcG9zdCA9IHBvc3Q7XG4gICAgICAgIHRoaXMuX2JvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBGb3IgbG9vcFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgY2hpbGRDdHggPSBuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0LCBjb250ZXh0LmVmZmVjdHMsIGNvbnRleHQuZXZlbnRMb2cpO1xuICAgICAgICBjaGlsZEN0eC5jYW52YXMgPSBzcGFjZV9saWZ0XzEuU29tZShjb250ZXh0LmNhbnZhcy5nZXQoKSk7XG4gICAgICAgIHRoaXMuX2luaXQuZXZhbChjaGlsZEN0eCk7IC8vIGluaXRpYWxpemUgdmFyXG4gICAgICAgIGxldCByZXMgPSB0aGlzLl9jb25kLmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICBpZiAoIShyZXMgaW5zdGFuY2VvZiBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbmRpdGlvbiBtdXN0IGJlIGEgYm9vbGVhbiBleHByZXNzaW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV0O1xuICAgICAgICB3aGlsZSAocmVzLnZhbCkge1xuICAgICAgICAgICAgcmV0ID0gdGhpcy5fYm9keS5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgICAgIHRoaXMuX3Bvc3QuZXZhbChjaGlsZEN0eCk7XG4gICAgICAgICAgICByZXMgPSB0aGlzLl9jb25kLmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIEZvck5vZGVcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIEZvciBsb29wXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JOb2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHJldHVybiBcIkNhbm5vdCBjYWxsIGRyYXcgb24gRm9yIGxvb3BcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZm9yIGxvb3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgJ2ZvcignICsgdGhpcy5faW5pdC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5fY29uZC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5fcG9zdC50b1N0cmluZygpICsgXCIpIHtcXG4gXCJcbiAgICAgICAgICAgICsgdGhpcy5fYm9keS50b1N0cmluZygpICsgXCJ9XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkZvck5vZGUgPSBGb3JOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Rm9yTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3Qgc3BhY2VfbGlmdF8xID0gcmVxdWlyZShcInNwYWNlLWxpZnRcIik7XG5jbGFzcyBSZXBlYXROb2RlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIHJlcGVhdChuKXt9XG4gICAgICogQHBhcmFtIG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIGxvb3AncyBzY29wZVxuICAgICAqIEBwYXJhbSBib2R5IFRoZSBlbmNsb3NlZCBib2R5IG9mIHRoZSBsb29wXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobiwgYm9keSkge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbiA9IG47XG4gICAgICAgIHRoaXMuX2JvZHkgPSBib2R5O1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLl9ib2R5LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgdGhlIHJlcGVhdCBsb29wXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBjaGlsZEN0eCA9IG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQsIGNvbnRleHQuZWZmZWN0cywgY29udGV4dC5ldmVudExvZyk7XG4gICAgICAgIGNoaWxkQ3R4LmNhbnZhcyA9IHNwYWNlX2xpZnRfMS5Tb21lKGNvbnRleHQuY2FudmFzLmdldCgpKTtcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMuX24uZXZhbChjaGlsZEN0eCk7XG4gICAgICAgIGlmICghKHJlcyBpbnN0YW5jZW9mIE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHBhcmFtZXRlciBmb3IgcmVwZWF0KCkgbXVzdCBiZSBhIG51bWJlciBleHByZXNzaW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy52YWw7IGkrKykge1xuICAgICAgICAgICAgcmV0ID0gdGhpcy5fYm9keS5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXBlYXQgc3RhdGVtZW50XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAncmVwZWF0KCcgKyB0aGlzLl9uLnRvU3RyaW5nKCkgKyBcIikge1xcbiBcIiArIHRoaXMuX2JvZHkudG9TdHJpbmcoKSArIFwifVwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJvZHkgb2YgdGhlIHJlcGVhdCBsb29wXG4gICAgICovXG4gICAgZ2V0IGJvZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib2R5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBlYXROb2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgcmVwZWF0XG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiByZXBlYXRzXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVwZWF0Tm9kZSA9IFJlcGVhdE5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXBlYXROb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU2NvcGVfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3R1cmFsL1Njb3BlXCIpO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xuY2xhc3MgV2hpbGVOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBXaGlsZSBsb29wXG4gICAgICogQHBhcmFtIGNvbmQgVGhlIFdoaWxlIGxvb3AgY29uZGl0aW9uXG4gICAgICogQHBhcmFtIGJvZHkgVGhlIGJvZHkgb2YgdGhlIGxvb3BcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25kLCBib2R5LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY29uZCA9IGNvbmQ7XG4gICAgICAgIHRoaXMuX2JvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBib2R5IG9mIHRoZSBsb29wIHdoaWxlIHRoZSBjb25kaXRpb24gaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBjaGlsZEN0eCA9IG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQsIGNvbnRleHQuZWZmZWN0cywgY29udGV4dC5ldmVudExvZyk7XG4gICAgICAgIGNoaWxkQ3R4LmNhbnZhcyA9IHNwYWNlX2xpZnRfMS5Tb21lKGNvbnRleHQuY2FudmFzLmdldCgpKTtcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMuX2NvbmQuZXZhbChjaGlsZEN0eCk7XG4gICAgICAgIGlmICghKHJlcyBpbnN0YW5jZW9mIEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29uZGl0aW9uIG11c3QgYmUgYSBib29sZWFuIGV4cHJlc3Npb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXQ7XG4gICAgICAgIHdoaWxlIChyZXMudmFsKSB7XG4gICAgICAgICAgICByZXQgPSB0aGlzLl9ib2R5LmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICAgICAgcmVzID0gdGhpcy5fY29uZC5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBXaGlsZU5vZGVzXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBXaGlsZSBsb29wXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGlsZU5vZGVzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBXaGlsZSBsb29wXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFdoaWxlIGxvb3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJ3aGlsZShcIiArIHRoaXMuX2NvbmQudG9TdHJpbmcoKSArIFwiKSB7XFxuIFwiICsgdGhpcy5fYm9keS50b1N0cmluZygpICsgXCJ9XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLldoaWxlTm9kZSA9IFdoaWxlTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdoaWxlTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhdGlvbiwgY29udGVudCwgdG9wLCBsZWZ0KSB7XG4gICAgICAgIHRoaXMuX2xvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLl90b3AgPSB0b3A7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgIH1cbn1cbmV4cG9ydHMuSW5zdHJ1Y3Rpb24gPSBJbnN0cnVjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUluc3RydWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTW9kdWxlXzEgPSByZXF1aXJlKFwiLi9Nb2R1bGVcIik7XG5jb25zdCBFbGxpcHNlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9FbGxpcHNlRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uRm91ckNwT25lIGV4dGVuZHMgTW9kdWxlXzEuTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDRjMVwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2w0YzInO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFlvdSd2ZSBtYWRlIGl0IHRvIHRoZSBGSU5BTCBDSEFMTEVOR0VTISBDb21wbGV0ZSB0aGVzZSBjaGFsbGVuZ2VzIHRvIGVhcm4gRVRFUk5BTCBHTE9SWSEgPC9wPlxuICAgIDxwPiBUaHJvdWdob3V0IHRoaXMgSG91ciBvZiBDb2RlLCB5b3UgaGF2ZSBsZWFybmVkOiA8L3A+XG4gICAgPHA+IC0gSG93IHRvIHByaW50IGEgd29yZCwgY2lyY2xlLCByZWN0YW5nbGUsIGFuZCBjdXJ2ZS4gPC9wPlxuICAgIDxwPiAtIEhvdyB0byBzdG9yZSBhbnkgb2YgdGhlIHZhbHVlIGFib3ZlIGluIGEgdmFyaWFibGUuIDwvcD5cbiAgICA8cD4gLSBIb3cgdG8gdXNlIGlmL2Vsc2Ugc3RhdGVtZW50IHRvIGNoZWNrIGEgY29uZGl0aW9uIGFib3V0IGEgdmFyaWFibGUuIDwvcD5cbiAgICA8cD4gRWFjaCBvZiB0aGUgZm9sbG93aW5nIGNoYWxsZW5nZXMgd2lsbCB0ZXN0IHRoZXNlIGNvbmNlcHRzLiBMZXQncyBkaXZlIHJpZ2h0IGluISA8L3A+XG4gICAgPHA+IFByaW50IGEgY2lyY2xlIGFuZCBwdXQgaXRzIGhlaWdodCBhbmQgd2lkdGggaW4gb25lIG9mIHRoZSBib3hlcyB0byB0aGUgc2lkZS4gVGhlbiBwcmludCBhIHJlY3RhbmdsZSBhbmQgcHV0IGl0cyBoZWlnaHQgYW5kIHdpZHRoIGluIHRoZSBib3guIDwvcD5cbiAgICA8cD4gQ0hBTExFTkdFOiBQcmludCBhIGNpcmNsZSBhbmQgcmVjdGFuZ2xlLiBQdXQgdGhlaXIgcmVzcGVjdGl2ZSB3aWR0aCBhbmQgaGVpZ2h0IGluIHRoZSBib3hlcyBwcm92aWRlZC4gPC9wPmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIGxlYWRpbmcgaW50byBjb25kaXRpb25hbHNcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IHRoaXMuZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgIGxldCByZWdleCA9IC9wcmludFxccypcXChcXHMqZWxsaXBzZVxccypcXChcXHMqWzEtOV1bMC05XSpcXHMqLFxccypbMS05XVswLTldKlxccypcXClcXHMqLFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKTsvO1xuICAgICAgICBsZXQgbWF0Y2ggPSBjb2RlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICBsZXQgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBFbGxpcHNlRWZmZWN0XzEuRWxsaXBzZUVmZmVjdCkge1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdDtcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvbkZvdXJDcE9uZSA9IExlc3NvbkZvdXJDcE9uZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvbkZvdXJDcE9uZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE1vZHVsZV8xID0gcmVxdWlyZShcIi4vTW9kdWxlXCIpO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvbkZvdXJDcFR3byBleHRlbmRzIE1vZHVsZV8xLk1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImw0YzJcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsNGMyJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBZZXMhIFlvdSBnb3QgdGhpcyEgPC9wPlxuICAgIDxwPiBOb3cgbGV0J3MgcHV0IHRob3NlIHNraWxscyBpbiBpZi9lbHNlIHN0YXRlbWVudHMgdG8gd29yayEgPC9wPlxuICAgIDxwPiBDcmVhdGUgYSBwYWlyIG9mIGlmL2Vsc2Ugc3RhdGVtZW50cyB0byBwcmludCBvdXQgdG8gdGhlIENBTlZBUyBhIGNsYWltIG9mIHdoZXRoZXIgdGhlIGNpcmNsZSBpcyBwb3NpdGlvbmVkIEFCT1ZFIG9yIEJFTE9XIHRoZSByZWN0YW5nbGUuIDwvcD5cbiAgICA8cD4gQ0hBTExFTkdFOiBQcmludCBhIGNsYWltIHRoYXQgc3RhdGVzIHdoZXRoZXIgY2lyY2xlIGlzIEFCT1ZFIG9yIEJFTE9XIHRoZSByZWN0YW5nbGUuIDwvcD5cbiAgICA8cD4gSElOVDogUmVtZW1iZXIgdGhhdCB0aGUgbnVtYmVycyBpbiB0aGUgcHJpbnQoKSBzdGF0ZW1lbnRzIGRldGVybWluZSB0aGUgcG9zaXRpb24gb2YgdGhlIHNoYXBlcyBiZWluZyBwcmludGVkLiA8L3A+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gbGVhZGluZyBpbnRvIGNvbmRpdGlvbmFsc1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2RlID0gdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgbGV0IHJlZ2V4ID0gL3ByaW50XFxzKlxcKFxccyplbGxpcHNlXFxzKlxcKFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKVxccyosXFxzKlsxLTldWzAtOV0qXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqXFwpOy87XG4gICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uRm91ckNwVHdvID0gTGVzc29uRm91ckNwVHdvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uRm91ckNwVHdvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTW9kdWxlXzEgPSByZXF1aXJlKFwiLi9Nb2R1bGVcIik7XG5jb25zdCBJbnN0cnVjdGlvbl8xID0gcmVxdWlyZShcIi4vSW5zdHJ1Y3Rpb25cIik7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3Nvbk9uZUNwRm91ciBleHRlbmRzIE1vZHVsZV8xLk1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoY3R4LCBlZGl0b3IpIHtcbiAgICAgICAgc3VwZXIoY3R4LCBlZGl0b3IpO1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMWM0XCI7XG4gICAgICAgIHRoaXMuX3ByZXZNb2R1bGUgPSAnbDFjMic7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDJjMSc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnY2FudmFzJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBDSEFMTEVOR0U6IFByaW50IHRoZSB3b3JkIFwibW9vXCIgb24gdGhlIENBTlZBUywgYW5kIHB1dCBpdCBpbnNpZGUgdGhlIGJveCBhdCB0aGUgY2VudGVyIG9mIHRoZSBDQU5WQVMuIDwvcD5gO1xuICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4ID0gMztcbiAgICAgICAgdGhpcy5zcXVhcmVfc2l6ZSA9IDEwMDtcbiAgICAgICAgdGhpcy5mb250X3NpemUgPSAyMDtcbiAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCgoY3R4LmNhbnZhcy53aWR0aCAtIHRoaXMuc3F1YXJlX3NpemUpIC8gMik7XG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQoKGN0eC5jYW52YXMuaGVpZ2h0IC0gdGhpcy5zcXVhcmVfc2l6ZSkgLyAyKTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBcIkluIHJlYWwgbGlmZSwgY29tcHV0ZXIgc2NpZW50aXN0cyBvZnRlbiBjYW4gb25seSBjaGFuZ2UgdGhlaXIgQ09ERSB0byBhZmZlY3QgdGhlIENBTlZBUywgaW5zdGVhZCBvZiBpbnRlcmFjdGluZyB3aXRoIHRoZSBDQU5WQVMgZGlyZWN0bHkuXCI7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjMwJVwiLCBcIjEwJVwiKSk7XG4gICAgICAgIGNvbnRlbnQgPSBcIkFueW9uZSwgaW5jbHVkaW5nIHlvdSwgaXMgY3V0IG91dCB0byBiZSBhIGNvbXB1dGVyIHNjaWVudGlzdCEgTGV0J3MgaGF2ZSBhIGNoYWxsZW5nZS5cIjtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IFwiVGhlIENBTlZBUyBpcyB0ZW1wb3JhcmlseSBmcm96ZW4uIFlvdSBjYW4gbm8gbG9uZ2VyIGludGVyYWN0IHdpdGggb2JqZWN0cyBkcmF3biBvbiBpdC5cIjtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiODAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IFwiQ2FuIHlvdSBmaWd1cmUgb3V0IGhvdyB0byB3cml0ZSBDT0RFIHRvIHByaW50IHRoZSB3b3JkICdtb28nIGluc2lkZSB0aGUgYm94IGF0IHRoZSBjZW50ZXIgb2YgdGhlIENBTlZBUz9cIjtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiODAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IFwiQ29uZ3JhdHVsYXRpb25zISBZb3UgZmluaXNoZWQgeW91ciBmaXJzdCBjb2RpbmcgY2hhbGxlbmdlIVwiO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NhbnZhcy1jb250YWluZXInLCBjb250ZW50LCBcIjgwJVwiLCBcIjEwJVwiKSk7XG4gICAgfVxuICAgIGRyYXdHdWlkZXMoKSB7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5yZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLnNxdWFyZV9zaXplLCB0aGlzLnNxdWFyZV9zaXplKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLmN0eC5mb250ID0gdGhpcy5mb250X3NpemUgKyBcInB4IENvdXJpZXIgTmV3XCI7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoXCJQdXQgd29yZFwiLCB0aGlzLngsIHRoaXMueSAtIDIgKiB0aGlzLmZvbnRfc2l6ZSk7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KFwiaW4gaGVyZVwiLCB0aGlzLngsIHRoaXMueSAtIHRoaXMuZm9udF9zaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHMgdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2xhdGVzdEluc3RySW5kZXgpIHtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0ICYmIGVmZmVjdC5zdHIgPT09IFwibW9vXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZWZmZWN0LnggPiB0aGlzLnggJiYgZWZmZWN0LnggPCB0aGlzLnggKyB0aGlzLnNxdWFyZV9zaXplKSAmJiAoZWZmZWN0LnkgPiB0aGlzLnkgJiYgZWZmZWN0LnkgPCB0aGlzLnkgKyB0aGlzLnNxdWFyZV9zaXplKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhdGVzdEluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25PbmVDcEZvdXIgPSBMZXNzb25PbmVDcEZvdXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25PbmVDcEZvdXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBNb2R1bGVfMSA9IHJlcXVpcmUoXCIuL01vZHVsZVwiKTtcbmNvbnN0IEluc3RydWN0aW9uXzEgPSByZXF1aXJlKFwiLi9JbnN0cnVjdGlvblwiKTtcbmNsYXNzIExlc3Nvbk9uZUNwT25lIGV4dGVuZHMgTW9kdWxlXzEuTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihjdHgsIGVkaXRvcikge1xuICAgICAgICBzdXBlcihjdHgsIGVkaXRvcik7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwxYzFcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsMWMyJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBHT0FMOiBXcml0ZSAnSGVsbG8nIG9uIHRoZSBDQU5WQVMuIDwvcD5gO1xuICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4ID0gMDtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBcIkZpcnN0LCBsZXQncyB0ZWxsIHRoZSBjb21wdXRlciB0byBwcmludCBzb21ldGhpbmcgb24gdGhlIENBTlZBUy4gQ2xpY2sgb24gdGhlIENPREUgYm94LlwiO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NvZGUtZWRpdG9yJywgY29udGVudCwgXCI3MCVcIiwgXCIxMCVcIikpO1xuICAgICAgICBjb250ZW50ID0gJ0dyZWF0ISBOb3cgdHlwZSA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+cHJpbnQoXCJIZWxsb1wiKTs8L3NwYW4+IGluIHRoaXMgQ09ERSBib3guJztcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNDAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9ICdOb3RpY2UgdGhhdCB3aGF0IHlvdSB0eXBlZCBjYXVzZXMgdGhlIGNvbXB1dGVyIHRvIHByaW50IHRoZSB3b3JkIFwiSGVsbG9cIiBvbiB0aGUgQ0FOVkFTIGhlcmUuIENvbmdyYXR1bGF0aW9ucyEgWW91IGp1c3Qgd3JvdGUgeW91ciBmaXJzdCBsaW5lIG9mIGNvZGUhJztcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjYW52YXMtY29udGFpbmVyJywgY29udGVudCwgXCI2NSVcIiwgXCIxMCVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiB3cml0ZSBhbnkgc3RyaW5nIG9uIENBTlZBU1xuICAgICAqIEBwYXJhbSBkb2N1bWVudCBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzIHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9sYXRlc3RJbnN0ckluZGV4KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuZWRpdG9yLmdldElucHV0RmllbGQoKSAmJiB0aGlzLl9sYXRlc3RJbnN0ckluZGV4ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhdGVzdEluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGxldCByZWdleCA9IC9wcmludFxccypcXChcXHMqXFxcIkhlbGxvXFxcIlxccypcXCkvO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMuZWRpdG9yLmdldFZhbHVlKCkubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhdGVzdEluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uT25lQ3BPbmUgPSBMZXNzb25PbmVDcE9uZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3Nvbk9uZUNwT25lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTW9kdWxlXzEgPSByZXF1aXJlKFwiLi9Nb2R1bGVcIik7XG5jb25zdCBJbnN0cnVjdGlvbl8xID0gcmVxdWlyZShcIi4vSW5zdHJ1Y3Rpb25cIik7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3Nvbk9uZUNwVGhyZWUgZXh0ZW5kcyBNb2R1bGVfMS5Nb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGN0eCwgZWRpdG9yKSB7XG4gICAgICAgIHN1cGVyKGN0eCwgZWRpdG9yKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDFjM1wiO1xuICAgICAgICB0aGlzLl9wcmV2TW9kdWxlID0gJ2wxYzInO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wxYzQnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ2NhbnZhcyc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gR09BTDogTW92ZSB0aGUgd29yZCBhcm91bmQgdGhlIENBTlZBUyBzb2xlbHkgYnkgY2hhbmdpbmcgeW91ciBDT0RFLiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgcHJpbnQoXCJIZWxsb1wiLCAxMDAsIDEwMClgO1xuICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMTA7XG4gICAgICAgIHRoaXMuc3F1YXJlX3NpemUgPSAxMDA7XG4gICAgICAgIHRoaXMuZm9udF9zaXplID0gMjA7XG4gICAgICAgIHRoaXMueCA9IGN0eC5jYW52YXMud2lkdGggLSB0aGlzLnNxdWFyZV9zaXplIC0gdGhpcy55O1xuICAgICAgICBsZXQgY29udGVudCA9IGBNb3ZpbmcgdGhpbmdzIG9uIHRoZSBDQU5WQVMgY2hhbmdlcyB0aGUgQ09ERS4gV2hhdCBpZiB3ZSBjaGFuZ2UgdGhlIENPREU/IEluIHRoZSA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+cHJpbnQ8L3NwYW4+IHN0YXRlbWVudCBhYm92ZSwgY2hhbmdlIHRoZSBmaXJzdCA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+MTAwPC9zcGFuPiB0byA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+MjAwPC9zcGFuPi4gT2JzZXJ2ZSB0aGUgQ0FOVkFTLmA7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjMwJVwiLCBcIjEwJVwiKSk7XG4gICAgICAgIGNvbnRlbnQgPSBcIkNoYW5naW5nIHRob3NlIG51bWJlcnMgaW4gdGhlIENPREUgbW92ZXMgdGhlIHdvcmQgb24gQ0FOVkFTISBOb3csIHRyeSBtb3ZlIHRoaXMgd29yZCBpbnNpZGUgdGhlIHRvcC1yaWdodCBib3ggYnkgY2hhbmdpbmcgeW91ciBDT0RFIGFsb25lLlwiO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NhbnZhcy1jb250YWluZXInLCBjb250ZW50LCBcIjcwJVwiLCBcIjEwJVwiKSk7XG4gICAgICAgIGNvbnRlbnQgPSBcIllheSEgWW91J3ZlIGxlYXJuZWQgaG93IHRvIHRlbGwgdGhlIGNvbXB1dGVyIHRvIHdyaXRlIGZvciB5b3UhXCI7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjUwJVwiLCBcIjEwJVwiKSk7XG4gICAgfVxuICAgIGRyYXdHdWlkZXMoKSB7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5yZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLnNxdWFyZV9zaXplLCB0aGlzLnNxdWFyZV9zaXplKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLmN0eC5mb250ID0gdGhpcy5mb250X3NpemUgKyBcInB4IENvdXJpZXIgTmV3XCI7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoXCJQdXQgd29yZFwiLCB0aGlzLngsIHRoaXMueSAtIDIgKiB0aGlzLmZvbnRfc2l6ZSk7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KFwiaW4gaGVyZVwiLCB0aGlzLngsIHRoaXMueSAtIHRoaXMuZm9udF9zaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9sYXRlc3RJbnN0ckluZGV4KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbGV0IHJlZ2V4ID0gL3ByaW50XFxzKlxcKFxccypcXFwiLipcXFwiXFxzKixcXHMqMjAwXFxzKixcXHMqMTAwXFxzKlxcKS87XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGF0ZXN0SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LnggPiB0aGlzLnggJiYgZWZmZWN0LnggPCB0aGlzLnggKyB0aGlzLnNxdWFyZV9zaXplICYmIGVmZmVjdC55ID4gdGhpcy55ICYmIGVmZmVjdC55IDwgdGhpcy55ICsgdGhpcy5zcXVhcmVfc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhdGVzdEluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25PbmVDcFRocmVlID0gTGVzc29uT25lQ3BUaHJlZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3Nvbk9uZUNwVGhyZWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBNb2R1bGVfMSA9IHJlcXVpcmUoXCIuL01vZHVsZVwiKTtcbmNvbnN0IEluc3RydWN0aW9uXzEgPSByZXF1aXJlKFwiLi9JbnN0cnVjdGlvblwiKTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uT25lQ3BUd28gZXh0ZW5kcyBNb2R1bGVfMS5Nb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGN0eCwgZWRpdG9yKSB7XG4gICAgICAgIHN1cGVyKGN0eCwgZWRpdG9yKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDFjMlwiO1xuICAgICAgICB0aGlzLl9wcmV2TW9kdWxlID0gJ2wxYzInO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wxYzMnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ2NvZGUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IEdPQUw6IE1vdmUgdGhlIHdvcmRzIHlvdSBqdXN0IGNyZWF0ZWQgdG8gZXhwbG9yZSBob3cgaXQgYWZmZWN0cyB5b3VyIGNvZGUuIDwvcD5gO1xuICAgICAgICB0aGlzLl9zdGFydGVyQ29kZSA9IGBwcmludChcIkhlbGxvXCIsIDEwMCwgMTAwKWA7XG4gICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXggPSAxO1xuICAgICAgICB0aGlzLnkgPSAxMDtcbiAgICAgICAgdGhpcy5zcXVhcmVfc2l6ZSA9IDEwMDtcbiAgICAgICAgdGhpcy5mb250X3NpemUgPSAyMDtcbiAgICAgICAgdGhpcy54ID0gY3R4LmNhbnZhcy53aWR0aCAtIHRoaXMuc3F1YXJlX3NpemUgLSB0aGlzLnk7XG4gICAgICAgIGxldCBjb250ZW50ID0gYE5vdGljZSB0aGUgbnVtYmVycyBhZGRlZCBpbnNpZGUgdGhlIGJyYWNrZXRzIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj4oKTwvc3Bhbj4gb2YgeW91ciA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+cHJpbnQ8L3NwYW4+IHN0YXRlbWVudD8gVGhleSBzcGVjaWZ5IHdoZXJlIHlvdXIgY29tcHV0ZXIgc2hvdWxkIHdyaXRlIHRoZSB3b3JkIG9uIHRoZSBDQU5WQVMuYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiMzAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IFwiVG8gdW5kZXJzdGFuZCB3aGF0IHRoZXkgZG8sIGZpcnN0IGNsaWNrIG9uIHRoZSB3b3JkIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTIGFuZCBkcmFnIGl0IGFyb3VuZC5cIjtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjYW52YXMtY29udGFpbmVyJywgY29udGVudCwgXCI3MCVcIiwgXCIxMCVcIikpO1xuICAgICAgICBjb250ZW50ID0gXCJOb3cgZHJhZyB0aGUgd29yZCBpbnRvIHRoZSB0b3AtcmlnaHQgYm94IG9uIHRoZSBDQU5WQVMuXCI7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY2FudmFzLWNvbnRhaW5lcicsIGNvbnRlbnQsIFwiODAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBEaWQgeW91IG5vdGljZSB0aGF0IHRoZSBudW1iZXJzIGluc2lkZSB0aGUgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPnByaW50PC9zcGFuPiBzdGF0ZW1lbnQgY2hhbmdlPyBOb3cgZHJhZyB0aGUgd29yZCBpbnRvIHRoZSB0b3AtbGVmdCBib3ggb24gdGhlIENBTlZBUy5gO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NvZGUtZWRpdG9yJywgY29udGVudCwgXCIzMCVcIiwgXCIxMCVcIikpO1xuICAgICAgICBjb250ZW50ID0gJ1RoZXNlIG51bWJlcnMgaW5kaWNhdGUgdGhlIGxvY2F0aW9uIG9uIHRoZSBDQU5WQVMgd2hlcmUgdGhlIGNvbXB1dGVyIHNob3VsZCBkcmF3IHRoZSB3b3JkISBUaGUgZmlyc3QgbnVtYmVyIGNoYW5nZXMgd2hlbiB0aGUgd29yZCBtb3ZlcyBsZWZ0IGFuZCByaWdodC4gVGhlIHNlY29uZCBudW1iZXIgY2hhbmdlcyB3aGVuIHRoZSB3b3JkIG1vdmVzIHVwIGFuZCBkb3duLic7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjMwJVwiLCBcIjEwJVwiKSk7XG4gICAgfVxuICAgIGRyYXdHdWlkZXMoKSB7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5yZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLnNxdWFyZV9zaXplLCB0aGlzLnNxdWFyZV9zaXplKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLmN0eC5mb250ID0gdGhpcy5mb250X3NpemUgKyBcInB4IENvdXJpZXIgTmV3XCI7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoXCJQdXQgd29yZFwiLCB0aGlzLngsIHRoaXMueSArIHRoaXMuc3F1YXJlX3NpemUgKyB0aGlzLmZvbnRfc2l6ZSk7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KFwiaW4gaGVyZVwiLCB0aGlzLngsIHRoaXMueSArIHRoaXMuc3F1YXJlX3NpemUgKyAyICogdGhpcy5mb250X3NpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2xhdGVzdEluc3RySW5kZXgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyICE9PSBcIlwiICYmIGVmZmVjdC5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYXRlc3RJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVmZmVjdC54ID4gdGhpcy54ICYmIGVmZmVjdC54IDwgdGhpcy54ICsgdGhpcy5zcXVhcmVfc2l6ZSAmJiBlZmZlY3QueSA+IHRoaXMueSAmJiBlZmZlY3QueSA8IHRoaXMueSArIHRoaXMuc3F1YXJlX3NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYXRlc3RJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVmZmVjdC54ID4gdGhpcy54ICYmIGVmZmVjdC54IDwgdGhpcy54ICsgdGhpcy5zcXVhcmVfc2l6ZSAmJiBlZmZlY3QueSA+IHRoaXMueSAmJiBlZmZlY3QueSA8IHRoaXMueSArIHRoaXMuc3F1YXJlX3NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYXRlc3RJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uT25lQ3BUd28gPSBMZXNzb25PbmVDcFR3bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3Nvbk9uZUNwVHdvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTW9kdWxlXzEgPSByZXF1aXJlKFwiLi9Nb2R1bGVcIik7XG5jb25zdCBJbnN0cnVjdGlvbl8xID0gcmVxdWlyZShcIi4vSW5zdHJ1Y3Rpb25cIik7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3NvblRocmVlQ3BGaXZlIGV4dGVuZHMgTW9kdWxlXzEuTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihjdHgsIGVkaXRvcikge1xuICAgICAgICBzdXBlcihjdHgsIGVkaXRvcik7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwzYzVcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsM2M2JztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBHT0FMOiBDaGFuZ2UgdGhlIHZhbHVlIG9mIGMgYXJvdW5kIHRvIHNlZSB3aGVuIFwiYyBpcyBOT1QgZXF1YWwgdG8gOC5cIiB3b3VsZCBiZSBwcmludGVkIG9uIHRoZSBDQU5WQVMuIDwvcD5gO1xuICAgICAgICB0aGlzLl9zdGFydGVyQ29kZSA9IGBjID0gODtcbmlmKGMgPT0gOCkge1xuXFx0cHJpbnQoXCJjIGlzIGVxdWFsIHRvIDguXCIsIDEwMywgMTQzKTtcbn0gZWxzZSB7XG5cXHRwcmludChcImMgaXMgTk9UIGVxdWFsIHRvIDguXCIsIDEwMywgMTQzKTtcbn1gO1xuICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4ID0gMjtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBgTm93LCB3aGF0IGlmIHdlIHdhbnQgdG8gcHJpbnQgYW5vdGhlciBtZXNzYWdlLCA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+YyBpcyBub3QgZXF1YWwgdG8gODwvc3Bhbj4gYW55IHRpbWUgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmM8L3NwYW4+IGlzIG5vdCBlcXVhbCB0byA4P2A7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjUwJVwiLCBcIjEwJVwiKSk7XG4gICAgICAgIGNvbnRlbnQgPSBgT2JzZXJ2ZSB0aGUgQ09ERSBhYm92ZS4gV2hlbiB0aGUgY29uZGl0aW9uIGluc2lkZSB0aGUgYnJhY2tldHMgb2YgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmlmKCk8L3NwYW4+IGlzIHNhdGlzZmllZCwgdGhlIGNvZGUgYmxvY2sgaW5zaWRlIHRoZSBicmFjZXMgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPnt9PC9zcGFuPiByaWdodCBhZnRlciBpdCB3b3VsZCBydW4uYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNDAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBXaGF0IHdvdWxkIGhhcHBlbiBpZiB3ZSBjaGFuZ2UgdGhlIHZhbHVlIG9mIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5jPC9zcGFuPj8gSW4gdGhlIENPREUgYWJvdmUsIGNoYW5nZSB0aGUgdmFsdWUgb2YgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmM8L3NwYW4+IHRvIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj41PC9zcGFuPiBhbmQgb2JzZXJ2ZSB3aGF0IGhhcHBlbnMuYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBEaWQgeW91IG5vdGljZSB0aGUgY2xhaW0gcHJpbnRlZCBoZXJlIGNoYW5nZWQ/IFdoZW4gdGhlIGNvbmRpdGlvbiBpbnNpZGUgdGhlIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5pZjwvc3Bhbj4gc3RhdGVtZW50IGlzIG5vdCBzYXRpc2ZpZWQsIHRoZSBzZWNvbmQgY29kZSBibG9jayBpbnNpZGUgdGhlIGJyYWNlcyA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+e308L3NwYW4+IGFmdGVyIHRoZSA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+ZWxzZTwvc3Bhbj4gc3RhdGVtZW50IHdvdWxkIHJ1biBpbnN0ZWFkIWA7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY2FudmFzLWNvbnRhaW5lcicsIGNvbnRlbnQsIFwiNzAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBUbyBnZXQgYSBiZXR0ZXIgaWRlYSwgY2hhbmdlIHRoZSB2YWx1ZSBvZiA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+Yzwvc3Bhbj4gYmFjayB0byA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+ODwvc3Bhbj4uYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNDAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBEaWQgeW91IHNlZSB0aGUgY2xhaW0gY2hhbmdlZCBhZ2Fpbj8gTm93LCBjaGFuZ2UgdGhlIHZhbHVlIG9mIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5jPC9zcGFuPiB0byA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+MTc8L3NwYW4+LmA7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjQwJVwiLCBcIjEwJVwiKSk7XG4gICAgICAgIGNvbnRlbnQgPSBgSG9wZSB5b3UgZ2V0IHRoZSBoYW5nIG9mIHdoYXQgYW4gPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmVsc2U8L3NwYW4+IHN0YXRlbWVudCBkb2VzIGJ5IHRoaXMgcG9pbnQhIEFzIGxvbmcgYXMgdGhlIGNvbmRpdGlvbiBpbnNpZGUgdGhlIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5pZjwvc3Bhbj4gc3RhdGVtZW50IGlzIG5vdCBzYXRpc2ZpZWQsIHRoZSBjb2RlIGJsb2NrIGluc2lkZSB0aGUgc2Vjb25kIGJyYWNlcyA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+ZWxzZXt9PC9zcGFuPiB3b3VsZCBydW4gaW5zdGVhZCBvZiB0aGUgZmlyc3QgY29kZSBibG9jay5gO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NhbnZhcy1jb250YWluZXInLCBjb250ZW50LCBcIjcwJVwiLCBcIjEwJVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIGxlYWRpbmcgaW50byBjb25kaXRpb25hbHNcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50IHRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHMgdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FudmFzSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2RlID0gdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgbGV0IHJlZ2V4O1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fbGF0ZXN0SW5zdHJJbmRleCkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICAgICAgICAgIC8vbGV0IHJlZ2V4ID0gL2NcXHMqPVxccypbXjhdXFxzKi87XG4gICAgICAgICAgICAgICAgcmVnZXggPSAvY1xccyo9XFxzKjVcXHMqLztcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSBtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciA9PT0gXCJjIGlzIE5PVCBlcXVhbCB0byA4LlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXggPSA0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5leHRJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgICAgICAgICByZWdleCA9IC9jXFxzKj1cXHMqOFxccyovO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gY29kZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyID09PSBcImMgaXMgZXF1YWwgdG8gOC5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGF0ZXN0SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgICAgICAgICAgcmVnZXggPSAvY1xccyo9XFxzKjE3XFxzKi87XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBjb2RlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0ICYmIGVmZmVjdC5zdHIgPT09IFwiYyBpcyBOT1QgZXF1YWwgdG8gOC5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGF0ZXN0SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25UaHJlZUNwRml2ZSA9IExlc3NvblRocmVlQ3BGaXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVGhyZWVDcEZpdmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBNb2R1bGVfMSA9IHJlcXVpcmUoXCIuL01vZHVsZVwiKTtcbmNvbnN0IEluc3RydWN0aW9uXzEgPSByZXF1aXJlKFwiLi9JbnN0cnVjdGlvblwiKTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVGhyZWVDcEZvdXIgZXh0ZW5kcyBNb2R1bGVfMS5Nb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGN0eCwgZWRpdG9yKSB7XG4gICAgICAgIHN1cGVyKGN0eCwgZWRpdG9yKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDNjNFwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wzYzUnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IEdPQUw6IENoYW5nZSB0aGUgdmFsdWUgb2YgYyBzbyB0aGF0IHRoZSBsaW5lIFwiYyBpcyBlcXVhbCB0byA4LlwiIGlzIHByaW50ZWQgb24gdGhlIENBTlZBUy4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYGMgPSAxMDA7XG5pZihjID09IDgpIHtcblxcdHByaW50KFwiYyBpcyBlcXVhbCB0byA4LlwiLCAxMDMsIDE0Myk7XG59YDtcbiAgICAgICAgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCA9IDI7XG4gICAgICAgIGxldCBjb250ZW50ID0gYFlvdSBjYW4gcHV0IGFuIGluZXF1YWxpdHkgY29uZGl0aW9uIGluc2lkZSB0aGUgYnJhY2tldHMgb2YgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmlmKCk8L3NwYW4+LCBzdWNoIGFzIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5hIDwgNTwvc3Bhbj4gb3IgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmIgPiAyMDwvc3Bhbj4uYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBZb3UgY2FuIGFsc28gdXNlIGFuIGVxdWFsaXR5IGNvbmRpdGlvbi4gT2JzZXJ2ZSB0aGUgQ09ERSBhYm92ZSB3aXRoIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5jID09IDg8L3NwYW4+LiBUaGUgMiBlcXVhbCBzaWducyA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+PT08L3NwYW4+IG1lYW4gdGhhdCB5b3UgYXJlIGNoZWNraW5nIHdoZXRoZXIgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmM8L3NwYW4+IGlzIEVYQUNUTFkgRVFVQUwgdG8gPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPjg8L3NwYW4+IG9yIG5vdC5gO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NvZGUtZWRpdG9yJywgY29udGVudCwgXCI0MCVcIiwgXCIxMCVcIikpO1xuICAgICAgICBjb250ZW50ID0gYExldCdzIGhhdmUgYSBzbWFsbCBjaGFsbGVuZ2U6IENhbiB5b3UgY2hhbmdlIHRoZSB2YWx1ZSBvZiA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+Yzwvc3Bhbj4gc28gdGhhdCB0aGUgY2xhaW0gPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmMgaXMgZXF1YWwgdG8gOC48L3NwYW4+IGlzIHByaW50ZWQgb24gdGhlIENBTlZBUz9gO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NvZGUtZWRpdG9yJywgY29udGVudCwgXCI1MCVcIiwgXCIxMCVcIikpO1xuICAgICAgICBjb250ZW50ID0gYFRoYXQncyBjb3JyZWN0ISB0aGUgY29kZSBpbnNpZGUgdGhlIGJyYWNlcyA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+e308L3NwYW4+IG9mIHRoZSA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+aWY8L3NwYW4+IHN0YXRlbWVudCBvbmx5IHJ1bnMgd2hlbiA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+Yzwvc3Bhbj4gaXMgZXhhY3RseSBlcXVhbCB0byA4IWA7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY2FudmFzLWNvbnRhaW5lcicsIGNvbnRlbnQsIFwiNzAlXCIsIFwiMTAlXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gbGVhZGluZyBpbnRvIGNvbmRpdGlvbmFsc1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgdGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0cyB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fbGF0ZXN0SW5zdHJJbmRleCkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICAgICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGUgPSB0aGlzLmVkaXRvci5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGxldCByZWdleCA9IC9jXFxzKj1cXHMqOFxccyovO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSBtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICAgICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0ICYmIGVmZmVjdC5zdHIgPT09IFwiYyBpcyBlcXVhbCB0byA4LlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYXRlc3RJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblRocmVlQ3BGb3VyID0gTGVzc29uVGhyZWVDcEZvdXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25UaHJlZUNwRm91ci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE1vZHVsZV8xID0gcmVxdWlyZShcIi4vTW9kdWxlXCIpO1xuY29uc3QgSW5zdHJ1Y3Rpb25fMSA9IHJlcXVpcmUoXCIuL0luc3RydWN0aW9uXCIpO1xuY29uc3QgU3RyaW5nRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9TdHJpbmdFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25UaHJlZUNwT25lIGV4dGVuZHMgTW9kdWxlXzEuTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihjdHgsIGVkaXRvcikge1xuICAgICAgICBzdXBlcihjdHgsIGVkaXRvcik7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwzYzFcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsM2MyJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBHT0FMOiBDaGFuZ2UgdGhlIHZhbHVlIG9mIGEgdG8gMTIuIDwvcD5gO1xuICAgICAgICB0aGlzLl9zdGFydGVyQ29kZSA9IGBhID0gNTtcbnByaW50KGEsIDExOCwgNjMpO1xucHJpbnQoXCJhIGlzIGxlc3MgdGhhbiAxMFwiLCAxMDMsIDE0Myk7YDtcbiAgICAgICAgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCA9IDM7XG4gICAgICAgIGxldCBjb250ZW50ID0gXCJXZSBsZWFybmVkIHRvIHRlbGwgdGhlIGNvbXB1dGVyIHRvIHByaW50IGEgbG90IG9mIHRoaW5ncy4gTm93LCBsZXQncyB0ZWFjaCBpdCB0byBtYWtlIHNvbWUgZGVjaXNpb25zIG9uIGl0cyBvd24uXCI7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjUwJVwiLCBcIjEwJVwiKSk7XG4gICAgICAgIGNvbnRlbnQgPSAnTG9vayBhdCB0aGUgQ09ERSBhYm92ZS4gV2UgbGV0IDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5hID0gNTwvc3Bhbj4sIHRoZW4gd2UgcHJpbnQgdGhlIHZhbHVlIG9mIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5hPC9zcGFuPiB0byB0aGUgQ0FOVkFTLiBUaGVuIHdlIHByaW50IHRoZSBsaW5lIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5hIGlzIGxlc3MgdGhhbiAxMDwvc3Bhbj4uJztcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNDAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBTaW5jZSA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+YTwvc3Bhbj4gaXMgNSwgYW5kIDUgPCAxMCwgd2Uga25vdyB0aGF0IDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5hPC9zcGFuPiBpcyBsZXNzIHRoYW4gMTAuIEJ1dCB3aGF0IHdvdWxkIGhhcHBlbiBpZiB3ZSBjaGFuZ2UgdGhlIHZhbHVlIG9mIGEgdG8sIHNheSwgMTI/YDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBDaGFuZ2UgdGhlIHZhbHVlIG9mIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5hPC9zcGFuPiB0byA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+MTI8L3NwYW4+LiBPYnNlcnZlIHdoYXQgaGFwcGVucyBvbiB0aGUgQ0FOVkFTLmA7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjQwJVwiLCBcIjEwJVwiKSk7XG4gICAgICAgIGNvbnRlbnQgPSAnRG8geW91IG5vdGljZSB0aGUgY2xhaW0gdGhhdCA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+YSBpcyBsZXNzIHRoYW4gMTA8L3NwYW4+IGRpZCBub3QgY2hhbmdlPyA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+YTwvc3Bhbj4gaXMgbm93IDEyIGFuZCBjbGVhcmx5IGdyZWF0ZXIgdGhhbiAxMCEgWWV0IG91ciBjb21wdXRlciBkb2VzIG5vdCBrbm93IHRvIG5vdCBwcmludCB0aGUgd3JvbmcgY2xhaW0hJztcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjYW52YXMtY29udGFpbmVyJywgY29udGVudCwgXCI3MCVcIiwgXCIxMCVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiBsZWFkaW5nIGludG8gY29uZGl0aW9uYWxzXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudCB0aGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzIHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9sYXRlc3RJbnN0ckluZGV4KSB7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgICAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgY29kZSA9IHRoaXMuZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgbGV0IHJlZ2V4ID0gL2FcXHMqPVxccyoxMlxccyovO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSBtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICAgICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0ICYmIGVmZmVjdC5zdHIgPT09IFwiYSBpcyBsZXNzIHRoYW4gMTBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGF0ZXN0SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25UaHJlZUNwT25lID0gTGVzc29uVGhyZWVDcE9uZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblRocmVlQ3BPbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBNb2R1bGVfMSA9IHJlcXVpcmUoXCIuL01vZHVsZVwiKTtcbmNvbnN0IEluc3RydWN0aW9uXzEgPSByZXF1aXJlKFwiLi9JbnN0cnVjdGlvblwiKTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3NvblRocmVlQ3BTaXggZXh0ZW5kcyBNb2R1bGVfMS5Nb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGN0eCwgZWRpdG9yKSB7XG4gICAgICAgIC8vc2V0dGluZyB1cCB0aGUgQ09ERSBhbmQgQ0FOVkFTXG4gICAgICAgIHN1cGVyKGN0eCwgZWRpdG9yKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDNjNlwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wzYzYnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IEdPQUw6IENyZWF0ZSBhbiBpZi9lbHNlIHN0YXRlbWVudCB0byBwcmludCB0aGUgY29ycmVjdCBjbGFpbSBhYm91dCB0aGUgc2l6ZXMgb2YgdGhlIDIgY2lyY2xlcy4gPC9wPmA7XG4gICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXggPSAzO1xuICAgICAgICB0aGlzLmZvbnRfc2l6ZSA9IDIwO1xuICAgICAgICB0aGlzLmFfc2l6ZSA9IE1hdGgucm91bmQoTWF0aC5taW4oY3R4LmNhbnZhcy53aWR0aCwgY3R4LmNhbnZhcy5oZWlnaHQpICogMC40KTtcbiAgICAgICAgdGhpcy5iX3NpemUgPSBNYXRoLnJvdW5kKHRoaXMuYV9zaXplIC8gMik7XG4gICAgICAgIHRoaXMuc3F1YXJlX3NpemUgPSB0aGlzLmFfc2l6ZSArIE1hdGgucm91bmQoTWF0aC5taW4oY3R4LmNhbnZhcy53aWR0aCwgY3R4LmNhbnZhcy5oZWlnaHQpICogMC4xKTtcbiAgICAgICAgdGhpcy55QSA9IE1hdGgucm91bmQoKGN0eC5jYW52YXMuaGVpZ2h0IC0gdGhpcy5zcXVhcmVfc2l6ZSkgLyAyKTtcbiAgICAgICAgdGhpcy55QiA9IHRoaXMueUE7XG4gICAgICAgIHRoaXMueEEgPSBNYXRoLnJvdW5kKGN0eC5jYW52YXMud2lkdGggLyAyKSAtIHRoaXMuc3F1YXJlX3NpemUgLSAxMDtcbiAgICAgICAgdGhpcy54QiA9IHRoaXMueEEgKyB0aGlzLnNxdWFyZV9zaXplICsgMTA7XG4gICAgICAgIGxldCBzcXVhcmVfbWlkID0gTWF0aC5yb3VuZCh0aGlzLnNxdWFyZV9zaXplIC8gMik7XG4gICAgICAgIGxldCBjaXJjX3hBID0gdGhpcy54QSArIHNxdWFyZV9taWQ7XG4gICAgICAgIGxldCBjaXJjX3lBID0gdGhpcy55QSArIHNxdWFyZV9taWQ7XG4gICAgICAgIGxldCBjaXJjX3hCID0gdGhpcy54QiArIHNxdWFyZV9taWQ7XG4gICAgICAgIGxldCBjaXJjX3lCID0gdGhpcy55QiArIHNxdWFyZV9taWQ7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID1cbiAgICAgICAgICAgIGBhID0gJHt0aGlzLmFfc2l6ZX07XG5wcmludChhLCAke3RoaXMueEF9LCAke3RoaXMueUEgLSAyICogdGhpcy5mb250X3NpemV9KTtcbnByaW50KGVsbGlwc2UoYSwgYSksICR7Y2lyY194QX0sICR7Y2lyY195QX0pO1xuYiA9ICR7dGhpcy5iX3NpemV9O1xucHJpbnQoYiwgJHt0aGlzLnhCfSwgJHt0aGlzLnlBIC0gMiAqIHRoaXMuZm9udF9zaXplfSk7XG5wcmludChlbGxpcHNlKGIsIGIpLCAke2NpcmNfeEJ9LCAke2NpcmNfeUJ9KTtcbnByaW50KFwiQ2lyY2xlIEEgaXMgc21hbGxlciB0aGFuIGNpcmNsZSBCLlwiLCAke3RoaXMueEF9LCAke3RoaXMueUEgKyB0aGlzLnNxdWFyZV9zaXplICsgdGhpcy5mb250X3NpemV9KTtgO1xuICAgICAgICAvL3NldHRpbmcgdXAgdGhlIEluc3RydWN0aW9uc1xuICAgICAgICBsZXQgY29udGVudCA9IGBOb3cgdGhhdCB5b3Uga25vdyBob3cgdG8gdXNlIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5pZi9lbHNlPC9zcGFuPiBzdGF0ZW1lbnRzLCBsZXQncyBwdXQgdGhlbSBhbGwgdG9nZXRoZXIhYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9ICdBYm92ZSB3ZSBoYXZlIHRoZSBDT0RFIHRvIGRyYXcgMiBjaXJjbGVzOiBjaXJjbGUgQSBoYXMgaGVpZ2h0IGFuZCB3aWR0aCA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+YTwvc3Bhbj4sIGFuZCBjaXJjbGUgQiBoYXMgaGVpZ2h0IGFuZCB3aWR0aCA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+Yjwvc3Bhbj4uJztcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNDAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBIb3dldmVyLCBjdXJyZW50bHkgdGhlIGNsYWltIHRoYXQgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPkNpcmNsZSBBIGlzIHNtYWxsZXIgdGhhbiBjaXJjbGUgQi48L3NwYW4+IGlzIHByaW50ZWQgcmVnYXJkbGVzcyBvZiB0aGUgY2lyY2xlcycgYWN0dWFsIHNpemVzLmA7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjUwJVwiLCBcIjEwJVwiKSk7XG4gICAgICAgIGNvbnRlbnQgPSBgSGVyZSdzIGEgY2hhbGxlbmdlIGZvciB5b3U6IENyZWF0ZSBhbiA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+aWYvZWxzZTwvc3Bhbj4gc3RhdGVtZW50IHRvIHByaW50IDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5DaXJjbGUgQSBpcyBzbWFsbGVyIHRoYW4gY2lyY2xlIEIuPC9zcGFuPiB3aGVuIGl0IGlzIGFjdHVhbGx5IHNvLCBhbmQgcHJpbnQgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPkNpcmNsZSBBIGlzIGJpZ2dlciB0aGFuIGNpcmNsZSBCLjwvc3Bhbj4gb3RoZXJ3aXNlLmA7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjgwJVwiLCBcIjEwJVwiKSk7XG4gICAgICAgIGNvbnRlbnQgPSAnQ29uZ3JhdHVsYXRpb25zISBZb3UganVzdCBzdWNjZXNzZnVsbHkgd3JvdGUgYSBjb21wbGljYXRlZCA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+aWYvZWxzZTwvc3Bhbj4gc3RhdGVtZW50ISc7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY2FudmFzLWNvbnRhaW5lcicsIGNvbnRlbnQsIFwiNzAlXCIsIFwiMTAlXCIpKTtcbiAgICB9XG4gICAgZHJhd0d1aWRlcygpIHtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4LnJlY3QodGhpcy54QSwgdGhpcy55QSwgdGhpcy5zcXVhcmVfc2l6ZSwgdGhpcy5zcXVhcmVfc2l6ZSk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5jdHguZm9udCA9IHRoaXMuZm9udF9zaXplICsgXCJweCBDb3VyaWVyIE5ld1wiO1xuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KFwiQ2lyY2xlIEFcIiwgdGhpcy54QSwgdGhpcy55QSAtIHRoaXMuZm9udF9zaXplKTtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4LnJlY3QodGhpcy54QiwgdGhpcy55QiwgdGhpcy5zcXVhcmVfc2l6ZSwgdGhpcy5zcXVhcmVfc2l6ZSk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLmN0eC5maWxsVGV4dChcIkNpcmNsZSBCXCIsIHRoaXMueEIsIHRoaXMueUIgLSB0aGlzLmZvbnRfc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIGxlYWRpbmcgaW50byBjb25kaXRpb25hbHNcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50IHRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHMgdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2xhdGVzdEluc3RySW5kZXgpIHtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlID0gdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVnZXgxID0gL2lmXFxzKlxcKFxccyphXFxzKls8Pl1cXHMqYlxccypcXCkvO1xuICAgICAgICAgICAgICAgIGxldCByZWdleDIgPSAvaWZcXHMqXFwoXFxzKmJcXHMqWzw+XVxccyphXFxzKlxcKS87XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoMSA9IGNvZGUubWF0Y2gocmVnZXgxKTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2gyID0gY29kZS5tYXRjaChyZWdleDIpO1xuICAgICAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSAobWF0Y2gxICE9IG51bGwgJiYgbWF0Y2gxLmxlbmd0aCA+IDApIHx8IChtYXRjaDIgIT0gbnVsbCAmJiBtYXRjaDIubGVuZ3RoID4gMCk7XG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICAgICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgY2lyY2xlQSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGNpcmNsZUIgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vbG9vayBmb3IgY2lyY2xlcyBBIGFuZCBCXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LnggPiB0aGlzLnhBICYmIGVmZmVjdC54IDwgdGhpcy54QSArIHRoaXMuc3F1YXJlX3NpemUgJiYgZWZmZWN0LnkgPiB0aGlzLnlBICYmIGVmZmVjdC55IDwgdGhpcy55QSArIHRoaXMuc3F1YXJlX3NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXJjbGVBID0gZWZmZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LnggPiB0aGlzLnhCICYmIGVmZmVjdC54IDwgdGhpcy54QiArIHRoaXMuc3F1YXJlX3NpemUgJiYgZWZmZWN0LnkgPiB0aGlzLnlCICYmIGVmZmVjdC55IDwgdGhpcy55QiArIHRoaXMuc3F1YXJlX3NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXJjbGVCID0gZWZmZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaXJjbGVBICE9IG51bGwgJiYgY2lyY2xlQiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0ciA9IGVmZmVjdC5zdHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzdHIgPT09IFwiQ2lyY2xlIEEgaXMgc21hbGxlciB0aGFuIGNpcmNsZSBCLlwiICYmIGNpcmNsZUEudyA8IGNpcmNsZUIudyAmJiBjaXJjbGVBLmggPCBjaXJjbGVCLmgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChzdHIgPT09IFwiQ2lyY2xlIEEgaXMgYmlnZ2VyIHRoYW4gY2lyY2xlIEIuXCIgJiYgY2lyY2xlQS53ID4gY2lyY2xlQi53ICYmIGNpcmNsZUEuaCA+IGNpcmNsZUIuaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGF0ZXN0SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25UaHJlZUNwU2l4ID0gTGVzc29uVGhyZWVDcFNpeDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblRocmVlQ3BTaXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBNb2R1bGVfMSA9IHJlcXVpcmUoXCIuL01vZHVsZVwiKTtcbmNvbnN0IEluc3RydWN0aW9uXzEgPSByZXF1aXJlKFwiLi9JbnN0cnVjdGlvblwiKTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVGhyZWVDcFRocmVlIGV4dGVuZHMgTW9kdWxlXzEuTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihjdHgsIGVkaXRvcikge1xuICAgICAgICBzdXBlcihjdHgsIGVkaXRvcik7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwzYzNcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsM2M0JztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBHT0FMOiBNYWtlIHRoZSBsaW5lIFwiYiBpcyBncmVhdGVyIHRoYW4gMjBcIiBvbmx5IGJlIHByaW50ZWQgb24gdGhlIENBTlZBUyB3aGVuIGIgaXMgYWN0dWFsbHkgZ3JlYXRlciB0aGFuIDIwLiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgYiA9IDg7XG5pZihiIDwgMTApIHtcblxcdHByaW50KFwiYiBpcyBncmVhdGVyIHRoYW4gMjAuXCIsIDEwMywgMTQzKTtcbn1gO1xuICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4ID0gMTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmlmPC9zcGFuPiBzdGF0ZW1lbnRzIGFsbG93IHlvdSB0byBydW4gYSBibG9jayBvZiBjb2RlIGluc2lkZSB0aGUgY3VybHkgYnJhY2VzIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj57fTwvc3Bhbj4gT05MWSB3aGVuIHRoZSBjb25kaXRpb24gaW5zaWRlIHRoZSBicmFja2V0cyA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+aWYoKTwvc3Bhbj4gaXMgdHJ1ZS5gO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NvZGUtZWRpdG9yJywgY29udGVudCwgXCI1MCVcIiwgXCIxMCVcIikpO1xuICAgICAgICBjb250ZW50ID0gYExldCdzIGhhdmUgYSBxdWljayBjaGFsbGVuZ2U6IG9ic2VydmUgdGhlIENPREUgYWJvdmUuIENoYW5nZSB0aGUgY29kZSBpbnNpZGUgdGhlIGJyYWNrZXRzIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5pZigpPC9zcGFuPiBzbyB0aGF0IHRoZSBjbGFpbSA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+YiBpcyBncmVhdGVyIHRoYW4gMjA8L3NwYW4+IGlzIG9ubHkgcHJpbnRlZCBvbiB0aGUgQ0FOVkFTIHdoZW4gPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmI8L3NwYW4+IGlzIGFjdHVhbGx5IGdyZWF0ZXIgdGhhbiAyMC5gO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NvZGUtZWRpdG9yJywgY29udGVudCwgXCI0MCVcIiwgXCIxMCVcIikpO1xuICAgICAgICBjb250ZW50ID0gYFlvdXIgQ09ERSBzZWVtcyBjb3JyZWN0ISBOb3cgY2hhbmdlIHRoZSB2YWx1ZSBvZiA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+Yjwvc3Bhbj4gdG8gPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPjUwPC9zcGFuPiB0byB0ZXN0IHRoYXQgaXQgcnVucyBjb3JyZWN0bHkuYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9ICdUaGUgY2xhaW0gaXMgcHJpbnRlZCB3aXRoIHRoZSBjb3JyZWN0IHZhbHVlIG9mIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5iPC9zcGFuPiEgR29vZCBqb2IhJztcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjYW52YXMtY29udGFpbmVyJywgY29udGVudCwgXCI3MCVcIiwgXCIxMCVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiBsZWFkaW5nIGludG8gY29uZGl0aW9uYWxzXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudCB0aGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzIHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbnZhc0lzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IHRoaXMuZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgIGxldCByZWdleDtcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2xhdGVzdEluc3RySW5kZXgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgICAgICAgICByZWdleCA9IC9pZlxccypcXChcXHMqYlxccyo+XFxzKjIwXFxzKlxcKS87XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBjb2RlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYXRlc3RJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgICAgICAgICByZWdleCA9IC9pZlxccypcXChcXHMqYlxccyo+XFxzKjIwXFxzKlxcKS87XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBjb2RlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgICAgICBsZXQgYXNzaWduID0gL2JcXHMqPVxccyo1MFxccyovO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaEFzc2lnbiA9IGNvZGUubWF0Y2goYXNzaWduKTtcbiAgICAgICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwICYmIG1hdGNoQXNzaWduICE9IG51bGwgJiYgbWF0Y2hBc3NpZ24ubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyID09PSBcImIgaXMgZ3JlYXRlciB0aGFuIDIwLlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYXRlc3RJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblRocmVlQ3BUaHJlZSA9IExlc3NvblRocmVlQ3BUaHJlZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblRocmVlQ3BUaHJlZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE1vZHVsZV8xID0gcmVxdWlyZShcIi4vTW9kdWxlXCIpO1xuY29uc3QgSW5zdHJ1Y3Rpb25fMSA9IHJlcXVpcmUoXCIuL0luc3RydWN0aW9uXCIpO1xuY29uc3QgU3RyaW5nRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9TdHJpbmdFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25UaHJlZUNwVHdvIGV4dGVuZHMgTW9kdWxlXzEuTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihjdHgsIGVkaXRvcikge1xuICAgICAgICBzdXBlcihjdHgsIGVkaXRvcik7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwzYzJcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsM2MzJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBHT0FMOiBDaGFuZ2UgdGhlIHZhbHVlIG9mIGEgYXJvdW5kIGFuZCBvYnNlcnZlIHdoYXQgaGFwcGVucy4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYGEgPSAxMjtcbnByaW50KGEsIDExOCwgNjMpO1xuaWYoYSA8IDEwKSB7XG5cXHRwcmludChcImEgaXMgbGVzcyB0aGFuIDEwXCIsIDEwMywgMTQzKTtcbn1gO1xuICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4ID0gMjtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBgTGV0J3MgdGVhY2ggdGhlIGNvbXB1dGVyIHRvIHByaW50IHRoZSBzZW50ZW5jZSA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+YSBpcyBsZXNzIHRoYW4gMTA8L3NwYW4+IE9OTFkgd2hlbiA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+YTwvc3Bhbj4gaXMgdHJ1bHkgbGVzcyB0aGFuIDEwLmA7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjUwJVwiLCBcIjEwJVwiKSk7XG4gICAgICAgIGNvbnRlbnQgPSAnV2Ugd2lsbCB1c2Ugc29tZXRoaW5nIGNhbGxlZCBhbiA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+aWY8L3NwYW4+IHN0YXRlbWVudC4gT2JzZXJ2ZSB0aGUgQ09ERSBhYm92ZS4gQWxsIHdlIGFkZGVkIHdhcyBhbiA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+aWY8L3NwYW4+IHN0YXRlbWVudCB0aGF0IGNoZWNrcyB3aGV0aGVyIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5hIDwgMTA8L3NwYW4+LiBJZiBhIGlzIGxlc3MgdGhhbiAxMCwgdGhlIGNvZGUgaW5zaWRlIHRoZSBjdXJseSBicmFjZXMgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPnt9PC9zcGFuPiB3aWxsIGJlIGV4ZWN1dGVkLic7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjQwJVwiLCBcIjEwJVwiKSk7XG4gICAgICAgIGNvbnRlbnQgPSBgTGV0J3MgaW52ZXN0aWdhdGUgd2hhdCB0aGlzIHN0YXRlbWVudCBkb2VzLiBGaXJzdCwgY2hhbmdlIHRoZSB2YWx1ZSBvZiA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+YTwvc3Bhbj4gdG8gPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPjg8L3NwYW4+LiBPYnNlcnZlIHdoYXQgaGFwcGVucy5gO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NvZGUtZWRpdG9yJywgY29udGVudCwgXCI1MCVcIiwgXCIxMCVcIikpO1xuICAgICAgICBjb250ZW50ID0gYERpZCB5b3Ugc2VlIHRoZSBjb3JyZWN0IGNsYWltIGlzIHByaW50ZWQgb24gdGhlIENBTlZBUz8gTm93IGxldCdzIGNoYW5nZSB0aGUgdmFsdWUgb2YgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmE8L3NwYW4+IHRvLCBzYXksIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj4yNTwvc3Bhbj4uYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNDAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9ICdUaGUgY2xhaW0gYWJvdXQgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmE8L3NwYW4+IGRpc2FwcGVhcnMhIEZpbmFsbHksIGNoYW5nZSB0aGUgdmFsdWUgb2YgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmE8L3NwYW4+IHRvIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj4wPC9zcGFuPi4nO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NhbnZhcy1jb250YWluZXInLCBjb250ZW50LCBcIjcwJVwiLCBcIjEwJVwiKSk7XG4gICAgICAgIGNvbnRlbnQgPSAnVGhlIGNsYWltIGFwcGVhcnMgYWdhaW4hIFRoZSA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+aWY8L3NwYW4+IHN0YXRlbWVudCBtYWtlcyB0aGUgY29tcHV0ZXIgY29uc3RhbnRseSBjaGVjayB0aGUgdmFsdWUgb2YgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmE8L3NwYW4+LCBhbmQgb25seSBwcmludCB0aGUgY2xhaW0gd2hlbiB0aGUgY29uZGl0aW9uIGluc2lkZSB0aGUgYnJhY2tldHMgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPigpPC9zcGFuPiBpcyBzYXRpc2ZpZWQhJztcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gbGVhZGluZyBpbnRvIGNvbmRpdGlvbmFsc1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgdGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0cyB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSB0aGlzLmVkaXRvci5nZXRWYWx1ZSgpO1xuICAgICAgICBsZXQgcmVnZXg7XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9sYXRlc3RJbnN0ckluZGV4KSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgICAgICAgICAgcmVnZXggPSAvYVxccyo9XFxzKjhcXHMqLztcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSBtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciA9PT0gXCJhIGlzIGxlc3MgdGhhbiAxMFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYXRlc3RJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgICAgICAgICByZWdleCA9IC9hXFxzKj1cXHMqMjVcXHMqLztcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSBtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciA9PT0gXCJhIGlzIGxlc3MgdGhhbiAxMFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVJc0NvcnJlY3QgJiYgIWNhbnZhc0lzQ29ycmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGF0ZXN0SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgICAgICAgICAgcmVnZXggPSAvYVxccyo9XFxzKjBcXHMqLztcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSBtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciA9PT0gXCJhIGlzIGxlc3MgdGhhbiAxMFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYXRlc3RJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblRocmVlQ3BUd28gPSBMZXNzb25UaHJlZUNwVHdvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVGhyZWVDcFR3by5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE1vZHVsZV8xID0gcmVxdWlyZShcIi4vTW9kdWxlXCIpO1xuY29uc3QgSW5zdHJ1Y3Rpb25fMSA9IHJlcXVpcmUoXCIuL0luc3RydWN0aW9uXCIpO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwRml2ZSBleHRlbmRzIE1vZHVsZV8xLk1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoY3R4LCBlZGl0b3IpIHtcbiAgICAgICAgc3VwZXIoY3R4LCBlZGl0b3IpO1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMmM1XCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDJjNic7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gR09BTDogQ3JlYXRlIGEgdmFyaWFibGUgYyByZWZlcnJpbmcgdG8gYW4gZWxsaXBzZSg3NSwgNzUpLCB0aGVuIHdyaXRlIDIgcHJpbnQgc3RhdGVtZW50cyB0byBwcmludCBjLiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgYSA9IFwibW9vIG1vb1wiO1xuYiA9IGVsbGlwc2UoMTAwLCAxMDApO1xucHJpbnQoYiwgMTAwLCAxMDApO2A7XG4gICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXggPSAwO1xuICAgICAgICBsZXQgY29udGVudCA9IGBMZXQncyB0YWtlIHRoaXMgb25lIHN0ZXAgZnVydGhlcjogQ3JlYXRlIGEgbmV3IHZhcmlhYmxlIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5jPC9zcGFuPiwgYW5kIG1ha2UgaXQgcmVmZXIgdG8gYW4gPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmVsbGlwc2UoNzUsIDc1KTwvc3Bhbj4uYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBOb3cgY2hhbmdlIHRoZSA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+cHJpbnQ8L3NwYW4+IHN0YXRlbWVudCB0byBwcmludCA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+Yzwvc3Bhbj4gaW5zdGVhZCBvZiA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+Yjwvc3Bhbj4uYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNDAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBGaW5hbGx5LCB3cml0ZSA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+cHJpbnQoYywgMzAwLCAxMDApOzwvc3Bhbj4gdW5kZXJuZWF0aCB0aGUgZXhpc3RpbmcgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPnByaW50PC9zcGFuPiBzdGF0ZW1lbnQuYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9ICdBd2Vzb21lLCBZb3UgYXJlIGdldHRpbmcgZ29vZCBhdCB1c2luZyB2YXJpYWJsZXMhIFdoYXQgeW91IGp1c3QgZGlkIGlzIHRvIGRyYXcgMiBjaXJjbGVzLCBib3RoIG5hbWVkIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5jPC9zcGFuPiEnO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NvZGUtZWRpdG9yJywgY29udGVudCwgXCI3MCVcIiwgXCIxMCVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgdGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0cyB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBlbGxpcHNlQ291bnQgPSAwO1xuICAgICAgICBsZXQgY29kZSA9IHRoaXMuZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgIGxldCBhc3NpZ25tZW50ID0gL2NcXHMqPVxccyplbGxpcHNlXFxzKlxcKFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKVxccyovZztcbiAgICAgICAgbGV0IG1hdGNoQXNzaWduO1xuICAgICAgICBsZXQgcHJpbnQgPSAvcHJpbnRcXHMqXFwoXFxzKmNcXHMqLFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKS9nO1xuICAgICAgICBsZXQgbWF0Y2hQcmludDtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9sYXRlc3RJbnN0ckluZGV4KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgICAgICAgICAgbWF0Y2hBc3NpZ24gPSBjb2RlLm1hdGNoKGFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaEFzc2lnbiAhPSBudWxsICYmIG1hdGNoQXNzaWduLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhdGVzdEluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICAgICAgICAgIG1hdGNoQXNzaWduID0gY29kZS5tYXRjaChhc3NpZ25tZW50KTtcbiAgICAgICAgICAgICAgICBtYXRjaFByaW50ID0gY29kZS5tYXRjaChwcmludCk7XG4gICAgICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoQXNzaWduICE9IG51bGwgJiYgbWF0Y2hBc3NpZ24ubGVuZ3RoID4gMCAmJiBtYXRjaFByaW50ICE9IG51bGwgJiYgbWF0Y2hQcmludC5sZW5ndGggPj0gMTtcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGxpcHNlQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29kZUlzQ29ycmVjdCAmJiBlbGxpcHNlQ291bnQgPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGF0ZXN0SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgICAgICAgICAgbWF0Y2hBc3NpZ24gPSBjb2RlLm1hdGNoKGFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgICAgIG1hdGNoUHJpbnQgPSBjb2RlLm1hdGNoKHByaW50KTtcbiAgICAgICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2hBc3NpZ24gIT0gbnVsbCAmJiBtYXRjaEFzc2lnbi5sZW5ndGggPiAwICYmIG1hdGNoUHJpbnQgIT0gbnVsbCAmJiBtYXRjaFByaW50Lmxlbmd0aCA+PSAyO1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbGlwc2VDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2RlSXNDb3JyZWN0ICYmIGVsbGlwc2VDb3VudCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYXRlc3RJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblR3b0NwRml2ZSA9IExlc3NvblR3b0NwRml2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblR3b0NwRml2ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE1vZHVsZV8xID0gcmVxdWlyZShcIi4vTW9kdWxlXCIpO1xuY29uc3QgSW5zdHJ1Y3Rpb25fMSA9IHJlcXVpcmUoXCIuL0luc3RydWN0aW9uXCIpO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwRm91ciBleHRlbmRzIE1vZHVsZV8xLk1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoY3R4LCBlZGl0b3IpIHtcbiAgICAgICAgc3VwZXIoY3R4LCBlZGl0b3IpO1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMmM0XCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDJjNSc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gR09BTDogQ2hhbmdlIGEgdG8gYiBpbiB0aGUgcHJpbnQgc3RhdGVtZW50LiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgYSA9IFwibW9vIG1vb1wiO1xuYiA9IGVsbGlwc2UoMTAwLCAxMDApO1xucHJpbnQoYSwgMTAwLCAxMDApO2A7XG4gICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXggPSAyO1xuICAgICAgICBsZXQgY29udGVudCA9IFwiVGltZSB0byB0YWtlIHlvdXIgY29kaW5nIHRvIHRoZSBuZXh0IGxldmVsLiBMZXQncyBsZWFybiBhYm91dCB2YXJpYWJsZXMhXCI7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjUwJVwiLCBcIjEwJVwiKSk7XG4gICAgICAgIGNvbnRlbnQgPSBcIlZhcmlhYmxlcyBhcmUgc2ltcGx5IG5hbWVzIHlvdSBnaXZlIHRvIHRoZSB0aGluZ3MgdGhhdCB5b3UgZHJhdy5cIjtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNDAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBGb3IgZXhhbXBsZSwgdGFrZSBhIGxvb2sgYXQgdGhlIGNvZGUgYWJvdmUuIENoYW5nZSB0aGUgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmE8L3NwYW4+IGluIHRoZSA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+cHJpbnQ8L3NwYW4+IHN0YXRlbWVudCB0byA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+Yjwvc3Bhbj4sIGFuZCBvYnNlcnZlIHdoYXQgaGFwcGVuZWQgb24gdGhlIENBTlZBUy5gO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NvZGUtZWRpdG9yJywgY29udGVudCwgXCI1MCVcIiwgXCIxMCVcIikpO1xuICAgICAgICBjb250ZW50ID0gJ0RpZCB5b3Ugc2VlIHRoZSBDQU5WQVMgY2hhbmdlZD8gSW4gb3VyIGNvZGUsIHdlIG1ha2UgdmFyaWFibGUgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmE8L3NwYW4+IHJlZmVyIHRvIHRoZSB3b3JkcyA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+XCJtb28gbW9vXCI8L3NwYW4+LCBhbmQgdmFyaWFibGUgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmI8L3NwYW4+IHJlZmVyIHRvIGFuIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5lbGxpcHNlKDEwMCwgMTAwKTwvc3Bhbj4uJztcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNDAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9ICdBcyBhIHJlc3VsdCwgd2hlbiB3ZSB0ZWxsIHRoZSBjb21wdXRlciB0byBwcmludCA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+YTwvc3Bhbj4sIGl0IHdpbGwgcHJpbnQgXCJtb28gbW9vXCIsIGFuZCB3aGVuIHdlIHRlbGwgdGhlIGNvbXB1dGVyIHRvIHByaW50IDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5iPC9zcGFuPiwgaXQgd2lsbCBwcmludCBhIGNpcmNsZSEnO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NhbnZhcy1jb250YWluZXInLCBjb250ZW50LCBcIjcwJVwiLCBcIjEwJVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudCB0aGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzIHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9sYXRlc3RJbnN0ckluZGV4KSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgICAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgY29kZSA9IHRoaXMuZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgbGV0IHJlZ2V4ID0gL3ByaW50XFxzKlxcKFxccypiXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqLFxccypbMS05XVswLTldKlxccypcXCk7LztcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBjb2RlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgICAgICAgICBsZXQgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbnZhc0lzQ29ycmVjdCAmJiBlZmZlY3QgaW5zdGFuY2VvZiBFbGxpcHNlRWZmZWN0XzEuRWxsaXBzZUVmZmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOZXh0SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Ud29DcEZvdXIgPSBMZXNzb25Ud29DcEZvdXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Ud29DcEZvdXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBNb2R1bGVfMSA9IHJlcXVpcmUoXCIuL01vZHVsZVwiKTtcbmNvbnN0IEluc3RydWN0aW9uXzEgPSByZXF1aXJlKFwiLi9JbnN0cnVjdGlvblwiKTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jb25zdCBSZWN0YW5nbGVFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1JlY3RhbmdsZUVmZmVjdFwiKTtcbmNvbnN0IExpbmVFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0xpbmVFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25Ud29DcE9uZSBleHRlbmRzIE1vZHVsZV8xLk1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoY3R4LCBlZGl0b3IpIHtcbiAgICAgICAgc3VwZXIoY3R4LCBlZGl0b3IpO1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMmMxXCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDJjMic7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gR09BTDogcmVwbGFjZSBcIm1vb1wiIGluIHRoZSBwcmludCBzdGF0ZW1lbnQgdG8gZHJhdyBkaWZmZXJlbnQgc2hhcGVzLiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgcHJpbnQoXCJtb29cIiwgMTAwLCAxMDApYDtcbiAgICAgICAgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCA9IDA7XG4gICAgICAgIGxldCBjb250ZW50ID0gYE5vdyBsZXQncyBsZWFybiB0byBwcmludCBzaGFwZXMgb24gdGhlIENBTlZBUyEgSW4gdGhlIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5wcmludDwvc3Bhbj4gc3RhdGVtZW50IGFib3ZlLCByZXBsYWNlIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5tb288L3NwYW4+IHdpdGggPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmVsbGlwc2UoMTAwLDEwMCk8L3NwYW4+LiBPYnNlcnZlIHdoYXQgaGFwcGVuZWQgb24gdGhlIENBTlZBUy5gO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NvZGUtZWRpdG9yJywgY29udGVudCwgXCIzMCVcIiwgXCIxMCVcIikpO1xuICAgICAgICBjb250ZW50ID0gYFllcCEgWW91IHRvbGQgdGhlIGNvbXB1dGVyIHRvIGRyYXcgYSBjaXJjbGUgb24gdGhlIENBTlZBUy4gTm93IGluIHRoZSA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+cHJpbnQ8L3NwYW4+IHN0YXRlbWVudCwgcmVwbGFjZSB0aGUgd29yZCA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+ZWxsaXBzZTwvc3Bhbj4gd2l0aCA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+cmVjdDwvc3Bhbj4uYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiMzAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBGaW5hbGx5LCByZXBsYWNlIHRoZSB3b3JkIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5yZWN0PC9zcGFuPiB3aXRoIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5saW5lPC9zcGFuPi5gO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NvZGUtZWRpdG9yJywgY29udGVudCwgXCIzMCVcIiwgXCIxMCVcIikpO1xuICAgICAgICBjb250ZW50ID0gYEJ5IHB1dHRpbmcgZGlmZmVyZW50IHRoaW5ncyBpbnNpZGUgdGhlIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5wcmludDwvc3Bhbj4gc3RhdGVtZW50LCB5b3UgY2FuIHRlbGwgdGhlIGNvbXB1dGVyIHRvIGRyYXcgZGlmZmVyZW50IHRoaW5ncyBvbiB0aGUgQ0FOVkFTLiBSZW1lbWJlciB0aGlzIGxlc3NvbiFgO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NhbnZhcy1jb250YWluZXInLCBjb250ZW50LCBcIjcwJVwiLCBcIjEwJVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHMgdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBsZXQgY29kZSA9IHRoaXMuZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fbGF0ZXN0SW5zdHJJbmRleCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrQ29kZUFuZENhbnZhc0VmZmVjdChjb2RlLCBcImVsbGlwc2VcIiwgZWZmZWN0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhdGVzdEluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrQ29kZUFuZENhbnZhc0VmZmVjdChjb2RlLCBcInJlY3RcIiwgZWZmZWN0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhdGVzdEluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrQ29kZUFuZENhbnZhc0VmZmVjdChjb2RlLCBcImxpbmVcIiwgZWZmZWN0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhdGVzdEluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0NvZGVBbmRDYW52YXNFZmZlY3QoY29kZSwgZiwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlZ2V4ID0gbmV3IFJlZ0V4cCgncHJpbnRcXFxccypcXFxcKFxcXFxzKicgKyBmICsgJ1xcXFxzKlxcXFwoXFxcXHMqWzEtOV1bMC05XSpcXFxccyosXFxcXHMqWzEtOV1bMC05XSpcXFxccypcXFxcKVxcXFxzKixcXFxccypbMS05XVswLTldKlxcXFxzKixcXFxccypbMS05XVswLTldKlxcXFxzKlxcXFwpJyk7XG4gICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChmKSB7XG4gICAgICAgICAgICBjYXNlIFwiZWxsaXBzZVwiOlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBFbGxpcHNlRWZmZWN0XzEuRWxsaXBzZUVmZmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJlY3RcIjpcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgUmVjdGFuZ2xlRWZmZWN0XzEuUmVjdGFuZ2xlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBMaW5lRWZmZWN0XzEuTGluZUVmZmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJtb3Zpbmcgb24gdG8gbmV4dCBpbnN0cnVjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Ud29DcE9uZSA9IExlc3NvblR3b0NwT25lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVHdvQ3BPbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBNb2R1bGVfMSA9IHJlcXVpcmUoXCIuL01vZHVsZVwiKTtcbmNvbnN0IEluc3RydWN0aW9uXzEgPSByZXF1aXJlKFwiLi9JbnN0cnVjdGlvblwiKTtcbmNvbnN0IE51bWJlckVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvTnVtYmVyRWZmZWN0XCIpO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwU2V2ZW4gZXh0ZW5kcyBNb2R1bGVfMS5Nb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGN0eCwgZWRpdG9yKSB7XG4gICAgICAgIHN1cGVyKGN0eCwgZWRpdG9yKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDJjN1wiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wzYzEnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IENIQUxMRU5HRTogQ3JlYXRlIGEgY2lyY2xlIGFuZCBwcmludCBvdXQgaXRzIHNpemUuIDwvcD5gO1xuICAgICAgICB0aGlzLl9zdGFydGVyQ29kZSA9IGBhID0gNTA7XG5wcmludChlbGxpcHNlKDEwMCwgMTAwKSwgMTI1LCAxNzUpO2A7XG4gICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXggPSAxO1xuICAgICAgICB0aGlzLnggPSAxMDtcbiAgICAgICAgdGhpcy5zcXVhcmVfc2l6ZSA9IDI1MDtcbiAgICAgICAgdGhpcy5mb250X3NpemUgPSAyMDtcbiAgICAgICAgdGhpcy55ID0gY3R4LmNhbnZhcy5oZWlnaHQgLSB0aGlzLnNxdWFyZV9zaXplIC0gdGhpcy54O1xuICAgICAgICBsZXQgY29udGVudCA9IGBMZXQncyBsZWFybiBvbmUgZmluYWwgdGhpbmcgYWJvdXQgdmFyaWFibGVzLiBPYnNlcnZlIHRoZSBjb2RlIGFib3ZlOiB3ZSBjb25uZWN0IHRoZSB2YXJpYWJsZSA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+YTwvc3Bhbj4gdG8gdGhlIG51bWJlciA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+NTA8L3NwYW4+LCBhbmQgd2UgYWxzbyBoYXZlIGEgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPnByaW50PC9zcGFuPiBzdGF0ZW1lbnQgdG8gcHJpbnQgYW4gZWxsaXBzZS5gO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NvZGUtZWRpdG9yJywgY29udGVudCwgXCI1MCVcIiwgXCIxMCVcIikpO1xuICAgICAgICBjb250ZW50ID0gYFJlcGxhY2UgdGhlIHR3byBudW1iZXJzIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj4xMDA8L3NwYW4+IGluc2lkZSB0aGUgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPnByaW50PC9zcGFuPiBzdGF0ZW1lbnQgd2l0aCB0aGUgbGV0dGVyIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5hPC9zcGFuPi4gT2JzZXJ2ZSB3aGF0IGhhcHBlbnMuYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNDAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBEaWQgeW91IHNlZSB0aGUgY2lyY2xlIG9uIENBTlZBUyBiZWNvbWUgc21hbGxlcj8gVGhlIHZhcmlhYmxlIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5hPC9zcGFuPiBpcyB0aWVkIHRvIHRoZSBudW1iZXIgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPjUwPC9zcGFuPiwgc28gbm93IHRoZSBjaXJjbGUgaGFzIGRpbWVuc2lvbiA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+YTwvc3Bhbj4hYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBMZXQncyBhZGQgb25lIGxhc3QgYml0IG9mIENPREU6IHdyaXRlIHNvbWV0aGluZyB0byBwcmludCB0aGUgdmFsdWUgb2YgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmE8L3NwYW4+IG9uIHRoZSBDQU5WQVMuYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNDAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IFwiVGhhdCdzIGNvcnJlY3QhIEZpbmFsbHksIGNsaWNrIG9uIHRoZSBjaXJjbGUgb24gdGhlIENBTlZBUywgYW5kIG1ha2UgaXQgYmlnZ2VyIHRoYW4gdGhlIGJveCBwcm92aWRlZC4gT2JzZXJ2ZSB3aGF0IGhhcHBlbmVkIHRvIHRoZSBwcmludGVkIG51bWJlci5cIjtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IFwiRGlkIHlvdSBzZWUgdGhlIHByaW50ZWQgbnVtYmVyIGNoYW5nZT8gWW91IGhhdmUgc3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCAyIGVsZW1lbnRzIG9uIHRoZSBDQU5WQVMgdG9nZXRoZXIgLSBhIGNpcmNsZSBhbmQgYSBudW1iZXIgLSBieSBhIHZhcmlhYmxlISBSZW1lbWJlciB0aGlzIGxlc3NvbiBhYm91dCB2YXJpYWJsZXMgaW4gdGhlIGZ1dHVyZSB3aGVuIHlvdSBuZWVkIHRvIGxpbmsgZGlmZmVyZW50IHRoaW5ncyBvbiBDQU5WQVMgdG9nZXRoZXIhXCI7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjcwJVwiLCBcIjEwJVwiKSk7XG4gICAgfVxuICAgIGRyYXdHdWlkZXMoKSB7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5yZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLnNxdWFyZV9zaXplLCB0aGlzLnNxdWFyZV9zaXplKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLmN0eC5mb250ID0gdGhpcy5mb250X3NpemUgKyBcInB4IENvdXJpZXIgTmV3XCI7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoXCJNYWtlIGNpcmNsZVwiLCB0aGlzLngsIHRoaXMueSArIHRoaXMuZm9udF9zaXplKTtcbiAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoXCJiaWdnZXIgdGhhbiB0aGlzIGJveFwiLCB0aGlzLngsIHRoaXMueSArIDIgKiB0aGlzLmZvbnRfc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudCB0aGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzIHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbnZhc0lzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IHRoaXMuZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fbGF0ZXN0SW5zdHJJbmRleCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICAgICAgICAgIGxldCByZWdleCA9IG5ldyBSZWdFeHAoJ3ByaW50XFxcXHMqXFxcXChcXFxccyplbGxpcHNlXFxcXHMqXFxcXChcXFxccyphXFxcXHMqLFxcXFxzKmFcXFxccypcXFxcKVxcXFxzKixcXFxccypbMS05XVswLTldKlxcXFxzKixcXFxccypbMS05XVswLTldKlxcXFxzKlxcXFwpJyk7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gY29kZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXggPSAzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5leHRJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgTnVtYmVyRWZmZWN0XzEuTnVtYmVyRWZmZWN0ICYmIGVmZmVjdC5udW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IGVmZmVjdC5udW07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBlZmZlY3QyIG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0MiBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0ICYmICh2YWwgPT0gZWZmZWN0Mi53IHx8IHZhbCA9PSBlZmZlY3QyLmgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYXRlc3RJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBsZXQgY2lyY2xlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBOdW1iZXJFZmZlY3RfMS5OdW1iZXJFZmZlY3QgJiYgZWZmZWN0Lm51bSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gZWZmZWN0Lm51bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdDIgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QyIGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QgJiYgKHZhbCA9PSBlZmZlY3QyLncgfHwgdmFsID09IGVmZmVjdDIuaCkgJiYgdmFsID4gdGhpcy5zcXVhcmVfc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGF0ZXN0SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Ud29DcFNldmVuID0gTGVzc29uVHdvQ3BTZXZlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblR3b0NwU2V2ZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBNb2R1bGVfMSA9IHJlcXVpcmUoXCIuL01vZHVsZVwiKTtcbmNvbnN0IEluc3RydWN0aW9uXzEgPSByZXF1aXJlKFwiLi9JbnN0cnVjdGlvblwiKTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25Ud29DcFNpeCBleHRlbmRzIE1vZHVsZV8xLk1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoY3R4LCBlZGl0b3IpIHtcbiAgICAgICAgc3VwZXIoY3R4LCBlZGl0b3IpO1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMmM2XCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDJjNyc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnY29kZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gR09BTDogRW5sYXJnZSBvbmUgb2YgdGhlIGNpcmNsZXMgcmVmZXJyZWQgdG8gYnkgYyBvbiB0aGUgQ0FOVkFTLiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgYSA9IFwibW9vIG1vb1wiO1xuYiA9IGVsbGlwc2UoMTAwLCAxMDApO1xuYyA9IGVsbGlwc2UoNzUsIDc1KTtcbnByaW50KGMsIDEwMCwgMTAwKTtcbnByaW50KGMsIDMwMCwgMTAwKWA7XG4gICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXggPSAxO1xuICAgICAgICAvL3B1dCBib3ggYXQgdG9wLWxlZnQgb2YgQ0FOVkFTXG4gICAgICAgIHRoaXMueCA9IDI1O1xuICAgICAgICB0aGlzLnkgPSAyNTtcbiAgICAgICAgdGhpcy5zcXVhcmVfc2l6ZSA9IDI1MDtcbiAgICAgICAgdGhpcy5mb250X3NpemUgPSAyMDtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBgTm93IHRoYXQgeW91IGhhdmUgZHJhd24gMiBjaXJjbGVzIGJvdGggYXJlIGNhbGxlZCA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+Yzwvc3Bhbj4sIGxldCdzIHNlZSB3aGF0IGhhcHBlbnMgd2hlbiB5b3UgdHJ5IHRvIG1vZGlmeSBvbmUgb2YgdGhlbS5gO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NvZGUtZWRpdG9yJywgY29udGVudCwgXCI1MCVcIiwgXCIxMCVcIikpO1xuICAgICAgICBjb250ZW50ID0gYENsaWNrIG9uIG9uZSBvZiB0aGUgY2lyY2xlcyBvbiB0aGUgQ0FOVkFTLCBhbmQgdHJ5IG1ha2UgaXQgYmlnZ2VyLiBPYnNlcnZlIHdoYXQgaGFwcGVucyB0byB5b3VyIGRlY2xhcmF0aW9uIG9mIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5jPC9zcGFuPi5gO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NvZGUtZWRpdG9yJywgY29udGVudCwgXCI3MCVcIiwgXCIxMCVcIikpO1xuICAgICAgICBjb250ZW50ID0gYERpZCB5b3Ugc2VlIHdoYXQgaGFwcGVuZWQ/IENoYW5naW5nIG9uZSBjaXJjbGUgY2hhbmdlcyB3aGF0IDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5jPC9zcGFuPiBpcyBpbiB5b3VyIENPREUhYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9ICdGdXJ0aGVybW9yZSwgdGhhdCBjaGFuZ2UgYWxzbyBhZmZlY3RlZCB0aGUgb3RoZXIgY2lyY2xlIG9uIHRoZSBDQU5WQVMhIFRoZSAyIGNpcmNsZSByZWZlcnJlZCB0byBieSA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+Yzwvc3Bhbj4gYXJlIGFsd2F5cyBpZGVudGljYWwsIG5vIG1hdHRlciB3aGF0ISc7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY2FudmFzLWNvbnRhaW5lcicsIGNvbnRlbnQsIFwiNzAlXCIsIFwiMTAlXCIpKTtcbiAgICB9XG4gICAgZHJhd0d1aWRlcygpIHtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4LnJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMuc3F1YXJlX3NpemUsIHRoaXMuc3F1YXJlX3NpemUpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuY3R4LmZvbnQgPSB0aGlzLmZvbnRfc2l6ZSArIFwicHggQ291cmllciBOZXdcIjtcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICB0aGlzLmN0eC5maWxsVGV4dChcIk1ha2UgY2lyY2xlXCIsIHRoaXMueCwgdGhpcy55ICsgdGhpcy5mb250X3NpemUpO1xuICAgICAgICB0aGlzLmN0eC5maWxsVGV4dChcImJpZ2dlciB0aGFuIHRoaXMgYm94XCIsIHRoaXMueCwgdGhpcy55ICsgMiAqIHRoaXMuZm9udF9zaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50IHRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHMgdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2xhdGVzdEluc3RySW5kZXgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QudyA+IDI1MCAmJiBlZmZlY3QuaCA+IDI1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXggPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTmV4dEluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Ud29DcFNpeCA9IExlc3NvblR3b0NwU2l4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVHdvQ3BTaXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBNb2R1bGVfMSA9IHJlcXVpcmUoXCIuL01vZHVsZVwiKTtcbmNvbnN0IEluc3RydWN0aW9uXzEgPSByZXF1aXJlKFwiLi9JbnN0cnVjdGlvblwiKTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwVGhyZWUgZXh0ZW5kcyBNb2R1bGVfMS5Nb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGN0eCwgZWRpdG9yKSB7XG4gICAgICAgIHN1cGVyKGN0eCwgZWRpdG9yKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDJjM1wiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wyYzQnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IEdPQUw6IERyYXcgMiBjaXJjbGVzIGFuZCBhIHdvcmQgb24gdGhlIENBTlZBUy4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYHByaW50KGVsbGlwc2UoMTAwLCAxMDApLCAxMjAsIDE1MCk7XFxuYDtcbiAgICAgICAgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCA9IDE7XG4gICAgICAgIGxldCBjb250ZW50ID0gXCJXaGF0IGlmIHdlIHdhbnQgdG8gZHJhdyBtb3JlIHRoYW4gb25seSAxIGNpcmNsZT9cIjtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBGaXJzdCBjb3B5IHRoZSA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+cHJpbnQ8L3NwYW4+IHN0YXRlbWVudCBvbiB0aGUgZmlyc3QgbGluZSBhbmQgcGFzdGUgaXQgb24gdGhlIHNlY29uZCBsaW5lIGFib3ZlLmA7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjQwJVwiLCBcIjEwJVwiKSk7XG4gICAgICAgIGNvbnRlbnQgPSBgSG0sIHRoYXQgc2hvdWxkIGhhdmUgY3JlYXRlZCBhIHNlY29uZCBjaXJjbGUgcmlnaHQ/IExldCdzIHRyeSB0byBmaXggdGhpcyBieSBjaGFuZ2luZyB0aGUgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPjEyMDwvc3Bhbj4gYWJvdmUgdG8gPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPjIwMDwvc3Bhbj4uYDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IFwiWWVwISBPbmUgY2lyY2xlIHdhcyBvbiB0b3Agb2YgdGhlIG90aGVyIHRoaXMgZW50aXJlIHRpbWUhIEluIHRoZSBmdXR1cmUsIGJlIG1pbmRmdWwgb2YgdGhpcy5cIjtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IFwiTm93IGxldCdzIGhhdmUgYSBxdWljayBjaGFsbGVuZ2U6IGluIGFkZGl0aW9uIHRvIHRoZSAyIGNpcmNsZXMsIHdyaXRlIGEgd29yZCBvbiB0aGUgY2FudmFzLiBEbyB5b3UgcmVtZW1iZXIgaG93IHRvIHByaW50IGEgd29yZD9cIjtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBUaGVyZSdzIG5vIGxpbWl0IHRvIGhvdyBtYW55IDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5wcmludDwvc3Bhbj4gc3RhdGVtZW50cyB0aGUgY29tcHV0ZXIgY2FuIHVuZGVyc3RhbmQsIHNvIHlvdSBjYW4gd3JpdGUgMTAwMCA8c3BhbiBjbGFzcz1cImlubGluZS1jb2RlXCI+cHJpbnQ8L3NwYW4+IHN0YXRlbWVudHMsIGFuZCB0aGUgY29tcHV0ZXIgd2lsbCBkcmF3IDEwMDAgdGhpbmdzIG9uIHRoZSBDQU5WQVMgZm9yIHlvdSFgO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NhbnZhcy1jb250YWluZXInLCBjb250ZW50LCBcIjcwJVwiLCBcIjEwJVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudCB0aGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzIHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgbGV0IGNpcmNsZUNvdW50ID0gMDtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9sYXRlc3RJbnN0ckluZGV4KSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaXJjbGVDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaXJjbGVDb3VudCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYXRlc3RJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBsZXQgbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QueCA9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjaXJjbGVDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoY2lyY2xlQ291bnQgPj0gMikgJiYgbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCArPSAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5leHRJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBsZXQgc3RyaW5nRXhpc3RzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHJpbmdFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ0V4aXN0cyA9IGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyICE9PSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBFbGxpcHNlRWZmZWN0XzEuRWxsaXBzZUVmZmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2lyY2xlQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGNpcmNsZUNvdW50ID49IDIpICYmIHN0cmluZ0V4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGF0ZXN0SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Ud29DcFRocmVlID0gTGVzc29uVHdvQ3BUaHJlZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblR3b0NwVGhyZWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBNb2R1bGVfMSA9IHJlcXVpcmUoXCIuL01vZHVsZVwiKTtcbmNvbnN0IEluc3RydWN0aW9uXzEgPSByZXF1aXJlKFwiLi9JbnN0cnVjdGlvblwiKTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25Ud29DcFR3byBleHRlbmRzIE1vZHVsZV8xLk1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoY3R4LCBlZGl0b3IpIHtcbiAgICAgICAgc3VwZXIoY3R4LCBlZGl0b3IpO1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMmMyXCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDJjMyc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gR09BTDogRml0IHRoZSBjaXJjbGUgaW5zaWRlIHRoZSBnaXZlbiBib3guIDwvcD5gO1xuICAgICAgICB0aGlzLl9zdGFydGVyQ29kZSA9IGBwcmludChlbGxpcHNlKDEwMCwgMTAwKSwgMTIwLCAxNTApO2A7XG4gICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXggPSAwO1xuICAgICAgICB0aGlzLnkgPSAxMDtcbiAgICAgICAgdGhpcy5yZWN0X2ggPSA1MDtcbiAgICAgICAgdGhpcy5yZWN0X3cgPSAxMDA7XG4gICAgICAgIHRoaXMuZm9udF9zaXplID0gMjA7XG4gICAgICAgIHRoaXMueCA9IE1hdGgucm91bmQoKGN0eC5jYW52YXMud2lkdGggLSB0aGlzLnJlY3RfdykgLyAyKTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBgV2hhdCBhcmUgdGhlIG51bWJlcnMgPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPigxMDAsIDEwMCk8L3NwYW4+IG5leHQgdG8gPHNwYW4gY2xhc3M9XCJpbmxpbmUtY29kZVwiPmVsbGlwc2U8L3NwYW4+IGZvcj8gTGV0J3MgZmluZCBvdXQgYnkgZmlyc3QgY2xpY2tpbmcgb24gdGhlIGNpcmNsZSBvbiB0aGUgQ0FOVkFTLmA7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY2FudmFzLWNvbnRhaW5lcicsIGNvbnRlbnQsIFwiODAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IFwiTm93IGRyYWcgdGhlIDggdGlwcyBhcm91bmQgdGhlIGNpcmNsZSB0byByZXNpemUgaXQuIFRyeSB0byBmaXQgdGhlIGNpcmNsZSBlbnRpcmVseSBpbnNpZGUgdGhlIGdpdmVuIGJveC4gT2JzZXJ2ZSB0aGUgQ09ERSBhYm92ZS5cIjtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlLWVkaXRvcicsIGNvbnRlbnQsIFwiNTAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9IGBZZXAhIFRob3NlIG51bWJlcnMgaW5zaWRlIDxzcGFuIGNsYXNzPVwiaW5saW5lLWNvZGVcIj5lbGxpcHNlKF8sXyk8L3NwYW4+IGNoYW5nZSB0aGUgZGltZW5zaW9uIG9mIHRoZSBjaXJjbGUhIE5vdGUgdGhhdCB5b3UgY2FuIGFsc28gZGlyZWN0bHkgcmV0eXBlIHRoZXNlIG51bWJlcnMgaW4gdGhlIENPREUgYXJlYSwgd2l0aG91dCB0b3VjaGluZyB0aGUgQ0FOVkFTLmA7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZS1lZGl0b3InLCBjb250ZW50LCBcIjUwJVwiLCBcIjEwJVwiKSk7XG4gICAgfVxuICAgIGRyYXdHdWlkZXMoKSB7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5yZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLnJlY3RfdywgdGhpcy5yZWN0X2gpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuY3R4LmZvbnQgPSB0aGlzLmZvbnRfc2l6ZSArIFwicHggQ291cmllciBOZXdcIjtcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICB0aGlzLmN0eC5maWxsVGV4dChcIkZpdCBjaXJjbGVcIiwgdGhpcy54LCB0aGlzLnkgLSAyICogdGhpcy5mb250X3NpemUpO1xuICAgICAgICB0aGlzLmN0eC5maWxsVGV4dChcImluIGhlcmVcIiwgdGhpcy54LCB0aGlzLnkgLSB0aGlzLmZvbnRfc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHMgdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2xhdGVzdEluc3RySW5kZXgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QgJiYgZWZmZWN0LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhdGVzdEluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LnggPiB0aGlzLnggJiYgZWZmZWN0LnggPCB0aGlzLnggKyB0aGlzLnJlY3Rfd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGVmZmVjdC55ID4gdGhpcy55ICYmIGVmZmVjdC55IDwgdGhpcy55ICsgdGhpcy5yZWN0X2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBlZmZlY3QudyA8IHRoaXMucmVjdF93ICYmIGVmZmVjdC5oIDwgdGhpcy5yZWN0X2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYXRlc3RJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVHdvQ3BUd28gPSBMZXNzb25Ud29DcFR3bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblR3b0NwVHdvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihjdHgsIGVkaXRvcikge1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzID0gW107IC8vc2VyaWVzIG9mIHR1dG9yaWFsIGluc3RydWN0aW9uc1xuICAgICAgICB0aGlzLl9pbnN0ckluZGV4ID0gMDsgLy9pbmRleCBvZiBjdXJyZW50IGluc3RydWN0aW9uIGJlaW5nIGRpc3BsYXllZFxuICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4ID0gMDsgLy9mdXJ0aGVzdCBpbnN0cnVjdGlvbiByZWFjaGVkIHdpdGhpbiB0aGlzIGNoZWNrcG9pbnRcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZ3VpZGVzIHRvIGhlbHAgbGVzc29uIGluc3RydWN0aW9uc1xuICAgICAqIEBwYXJhbSBjdHggdGhlIGNhbnZhcyAyRCBjb250ZXh0XG4gICAgICovXG4gICAgZHJhd0d1aWRlcygpIHsgfVxuICAgIDtcbiAgICByZW5kZXJMYXRlc3RJbnN0cnVjdGlvbihkb2N1bWVudCkge1xuICAgICAgICB0aGlzLl9pbnN0ckluZGV4ID0gdGhpcy5fbGF0ZXN0SW5zdHJJbmRleDtcbiAgICAgICAgdGhpcy5yZW5kZXJJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgfVxuICAgIHJlbmRlck5leHRJbnN0cnVjdGlvbihkb2N1bWVudCkge1xuICAgICAgICB0aGlzLl9pbnN0ckluZGV4ID0gKHRoaXMuX2luc3RySW5kZXggKyAxIDwgdGhpcy5faW5zdHJCb3hlcy5sZW5ndGgpID8gdGhpcy5faW5zdHJJbmRleCArIDEgOiB0aGlzLl9pbnN0ckluZGV4O1xuICAgICAgICBjb25zb2xlLmxvZyhcImN1cnJlbnQgaW5zdHI6IFwiICsgdGhpcy5faW5zdHJJbmRleCk7XG4gICAgICAgIHRoaXMucmVuZGVySW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgIH1cbiAgICByZW5kZXJQcmV2SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5faW5zdHJJbmRleCA9ICh0aGlzLl9pbnN0ckluZGV4IC0gMSA+PSAwKSA/IHRoaXMuX2luc3RySW5kZXggLSAxIDogdGhpcy5faW5zdHJJbmRleDtcbiAgICAgICAgdGhpcy5yZW5kZXJJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlbmRlciB0aGUgY3VycmVudCBpbnN0cnVjdGlvbiBvZiB0aGlzIGNoZWNrcG9pbnRcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKi9cbiAgICByZW5kZXJJbnN0cnVjdGlvbihkb2N1bWVudCkge1xuICAgICAgICBsZXQgY3VySW5zdHJ1Y3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluc3RydWN0aW9uXCIpO1xuICAgICAgICBpZiAoY3VySW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgY3VySW5zdHJ1Y3Rpb24ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCJpbnN0ckluZGV4IFwiICsgdGhpcy5faW5zdHJJbmRleCk7XG4gICAgICAgIGxldCBpbnN0cnVjdGlvbiA9IHRoaXMuX2luc3RyQm94ZXNbdGhpcy5faW5zdHJJbmRleF07XG4gICAgICAgIC8vcmVuZGVyIHRoZSBpbnN0cnVjdGlvbiBjb250ZW50XG4gICAgICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJpbnN0cnVjdGlvblwiO1xuICAgICAgICBkaXYuaWQgPSAnaW5zdHJ1Y3Rpb24nO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gaW5zdHJ1Y3Rpb24uX2NvbnRlbnQ7XG4gICAgICAgIGRpdi5zdHlsZS50b3AgPSBpbnN0cnVjdGlvbi5fdG9wO1xuICAgICAgICBkaXYuc3R5bGUubGVmdCA9IGluc3RydWN0aW9uLl9sZWZ0O1xuICAgICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgLy9yZW5kZXIgdGhlIGJ1dHRvbnNcbiAgICAgICAgbGV0IGlubmVyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgbGV0IHByZXZJbnN0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIHByZXZJbnN0ci5pZCA9ICdwcmV2aW91cy1pbnN0cnVjdGlvbic7XG4gICAgICAgIHByZXZJbnN0ci5pbm5lclRleHQgPSBcIjxcIjtcbiAgICAgICAgbGV0IHRoaXNNb2R1bGUgPSB0aGlzO1xuICAgICAgICBwcmV2SW5zdHIub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXNNb2R1bGUucmVuZGVyUHJldkluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RySW5kZXggPT0gMCkge1xuICAgICAgICAgICAgcHJldkluc3RyLnN0eWxlLmJhY2tncm91bmQgPSBcIiNEOEQ4RDhcIjtcbiAgICAgICAgICAgIHByZXZJbnN0ci5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5uZXJEaXYuYXBwZW5kQ2hpbGQocHJldkluc3RyKTtcbiAgICAgICAgbGV0IG5leHRJbnN0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIG5leHRJbnN0ci5pZCA9ICduZXh0LWluc3RydWN0aW9uJztcbiAgICAgICAgbmV4dEluc3RyLmlubmVyVGV4dCA9IFwiPlwiO1xuICAgICAgICBuZXh0SW5zdHIub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXNNb2R1bGUucmVuZGVyTmV4dEluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RySW5kZXggPT0gdGhpcy5faW5zdHJCb3hlcy5sZW5ndGggfHwgdGhpcy5faW5zdHJJbmRleCA9PSB0aGlzLl9sYXRlc3RJbnN0ckluZGV4KSB7XG4gICAgICAgICAgICBuZXh0SW5zdHIuc3R5bGUuYmFja2dyb3VuZCA9IFwiI0Q4RDhEOFwiO1xuICAgICAgICAgICAgbmV4dEluc3RyLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbm5lckRpdi5hcHBlbmRDaGlsZChuZXh0SW5zdHIpO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoaW5uZXJEaXYpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpbnN0cnVjdGlvbi5fbG9jYXRpb24pLmFwcGVuZENoaWxkKGRpdik7XG4gICAgfVxuICAgIGdldCBudW1JbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0ckJveGVzLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTW9kdWxlID0gTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW9kdWxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi8uLi9pbmRleFwiKTtcbmNvbnN0IGluZGV4XzIgPSByZXF1aXJlKFwiLi4vLi4vaW5kZXhcIik7XG5jb25zdCBpbmRleF8zID0gcmVxdWlyZShcIi4uLy4uL2luZGV4XCIpO1xuY29uc3QgaW5kZXhfNCA9IHJlcXVpcmUoXCIuLi8uLi9pbmRleFwiKTtcbmNsYXNzIE1vZHVsZUdlbmVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY3VyQ29uc3RydWN0b3JzID0gbmV3IE1hcChbXG4gICAgICAgICAgICBbJ2wxYzEnLCAoY3R4LCBlZGl0b3IpID0+IG5ldyBpbmRleF8xLkxlc3Nvbk9uZUNwT25lKGN0eCwgZWRpdG9yKV0sXG4gICAgICAgICAgICBbJ2wxYzInLCAoY3R4LCBlZGl0b3IpID0+IG5ldyBpbmRleF8xLkxlc3Nvbk9uZUNwVHdvKGN0eCwgZWRpdG9yKV0sXG4gICAgICAgICAgICBbJ2wxYzMnLCAoY3R4LCBlZGl0b3IpID0+IG5ldyBpbmRleF8xLkxlc3Nvbk9uZUNwVGhyZWUoY3R4LCBlZGl0b3IpXSxcbiAgICAgICAgICAgIFsnbDFjNCcsIChjdHgsIGVkaXRvcikgPT4gbmV3IGluZGV4XzEuTGVzc29uT25lQ3BGb3VyKGN0eCwgZWRpdG9yKV0sXG4gICAgICAgICAgICBbJ2wyYzEnLCAoY3R4LCBlZGl0b3IpID0+IG5ldyBpbmRleF8yLkxlc3NvblR3b0NwT25lKGN0eCwgZWRpdG9yKV0sXG4gICAgICAgICAgICBbJ2wyYzInLCAoY3R4LCBlZGl0b3IpID0+IG5ldyBpbmRleF8yLkxlc3NvblR3b0NwVHdvKGN0eCwgZWRpdG9yKV0sXG4gICAgICAgICAgICBbJ2wyYzMnLCAoY3R4LCBlZGl0b3IpID0+IG5ldyBpbmRleF8yLkxlc3NvblR3b0NwVGhyZWUoY3R4LCBlZGl0b3IpXSxcbiAgICAgICAgICAgIFsnbDJjNCcsIChjdHgsIGVkaXRvcikgPT4gbmV3IGluZGV4XzIuTGVzc29uVHdvQ3BGb3VyKGN0eCwgZWRpdG9yKV0sXG4gICAgICAgICAgICBbJ2wyYzUnLCAoY3R4LCBlZGl0b3IpID0+IG5ldyBpbmRleF8yLkxlc3NvblR3b0NwRml2ZShjdHgsIGVkaXRvcildLFxuICAgICAgICAgICAgWydsMmM2JywgKGN0eCwgZWRpdG9yKSA9PiBuZXcgaW5kZXhfMi5MZXNzb25Ud29DcFNpeChjdHgsIGVkaXRvcildLFxuICAgICAgICAgICAgWydsMmM3JywgKGN0eCwgZWRpdG9yKSA9PiBuZXcgaW5kZXhfMi5MZXNzb25Ud29DcFNldmVuKGN0eCwgZWRpdG9yKV0sXG4gICAgICAgICAgICBbJ2wzYzEnLCAoY3R4LCBlZGl0b3IpID0+IG5ldyBpbmRleF8zLkxlc3NvblRocmVlQ3BPbmUoY3R4LCBlZGl0b3IpXSxcbiAgICAgICAgICAgIFsnbDNjMicsIChjdHgsIGVkaXRvcikgPT4gbmV3IGluZGV4XzMuTGVzc29uVGhyZWVDcFR3byhjdHgsIGVkaXRvcildLFxuICAgICAgICAgICAgWydsM2MzJywgKGN0eCwgZWRpdG9yKSA9PiBuZXcgaW5kZXhfMy5MZXNzb25UaHJlZUNwVGhyZWUoY3R4LCBlZGl0b3IpXSxcbiAgICAgICAgICAgIFsnbDNjNCcsIChjdHgsIGVkaXRvcikgPT4gbmV3IGluZGV4XzMuTGVzc29uVGhyZWVDcEZvdXIoY3R4LCBlZGl0b3IpXSxcbiAgICAgICAgICAgIFsnbDNjNScsIChjdHgsIGVkaXRvcikgPT4gbmV3IGluZGV4XzMuTGVzc29uVGhyZWVDcEZpdmUoY3R4LCBlZGl0b3IpXSxcbiAgICAgICAgICAgIFsnbDNjNicsIChjdHgsIGVkaXRvcikgPT4gbmV3IGluZGV4XzMuTGVzc29uVGhyZWVDcFNpeChjdHgsIGVkaXRvcildLFxuICAgICAgICAgICAgWydsNGMxJywgKGN0eCwgZWRpdG9yKSA9PiBuZXcgaW5kZXhfNC5MZXNzb25Gb3VyQ3BPbmUoY3R4LCBlZGl0b3IpXSxcbiAgICAgICAgICAgIFsnbDRjMicsIChjdHgsIGVkaXRvcikgPT4gbmV3IGluZGV4XzQuTGVzc29uRm91ckNwVHdvKGN0eCwgZWRpdG9yKV1cbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuY2hlY2twb2ludHMgPSBuZXcgTWFwKFtcbiAgICAgICAgICAgIFsnbDFjMScsIG51bGxdLFxuICAgICAgICAgICAgWydsMWMyJywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wxYzMnLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDFjNCcsIG51bGxdLFxuICAgICAgICAgICAgWydsMmMxJywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wyYzInLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDJjMycsIG51bGxdLFxuICAgICAgICAgICAgWydsMmM0JywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wyYzUnLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDJjNicsIG51bGxdLFxuICAgICAgICAgICAgWydsMmM3JywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wzYzEnLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDNjMicsIG51bGxdLFxuICAgICAgICAgICAgWydsM2MzJywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wzYzQnLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDNjNScsIG51bGxdLFxuICAgICAgICAgICAgWydsM2M2JywgbnVsbF0sXG4gICAgICAgICAgICBbJ2w0YzEnLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDRjMicsIG51bGxdXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGVNb2R1bGUoY3AsIGN0eCwgZWRpdG9yKSB7XG4gICAgICAgIGxldCBjaGVja3BvaW50ID0gdGhpcy5jaGVja3BvaW50cy5nZXQoY3ApO1xuICAgICAgICBpZiAoY2hlY2twb2ludCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2twb2ludDtcbiAgICAgICAgfVxuICAgICAgICBjaGVja3BvaW50ID0gdGhpcy5jdXJDb25zdHJ1Y3RvcnMuZ2V0KGNwKShjdHgsIGVkaXRvcik7XG4gICAgICAgIHRoaXMuY2hlY2twb2ludHMuc2V0KGNwLCBjaGVja3BvaW50KTtcbiAgICAgICAgcmV0dXJuIGNoZWNrcG9pbnQ7XG4gICAgfVxufVxuZXhwb3J0cy5Nb2R1bGVHZW5lcmF0b3IgPSBNb2R1bGVHZW5lcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Nb2R1bGVHZW5lcmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwYW50c18xID0gcmVxdWlyZShcInBhbnRzXCIpO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi8uLi9pbmRleFwiKTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xudmFyIFBhcnNlcjtcbihmdW5jdGlvbiAoUGFyc2VyKSB7XG4gICAgLyoqXG4gICAgICogdG8gYmUgbW92ZWQgdG8gUGFudHNcbiAgICAgKiBudW1iZXIgcGFyc2VzIG51bWJlcnMgYnkgcmVwZWF0ZWRseSBhcHBseWluZyB0aGUgZGlnaXQgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG8gPSBwYW50c18xLlByaW1pdGl2ZXMubWFueTEocGFudHNfMS5QcmltaXRpdmVzLmRpZ2l0KCkpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIGxldCBzID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZGlnaXQgb2Ygby5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gZGlnaXQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHBhbnRzXzEuUHJpbWl0aXZlcy5TdWNjZXNzKG8uaW5wdXRzdHJlYW0sIHBhcnNlRmxvYXQocykpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQYXJzZXIubnVtYmVyID0gbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIHRvIGJlIG1vdmVkIHRvIFBhbnRzXG4gICAgICogc3RyaW5nIGlzIGFuIGFyYml0cmFyeSBzdHJpbmcgcGFyc2VyIHRoYXQgcmVwZWF0ZWRseSBhcHBsaWVzIHRoZSBsZXR0ZXIgcHJpbWl0aXZlXG4gICAgICogcmV0dXJucyBhIENoYXJTdHJlYW0gcmVwcmVzZW50aW5nIHRoZSBlbnRpcmUgcGFyc2VkIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmluZygpIHtcbiAgICAgICAgbGV0IHAgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55MShwYW50c18xLlByaW1pdGl2ZXMubGV0dGVyKCkpKTtcbiAgICAgICAgbGV0IGYgPSAoeHMpID0+IHBhbnRzXzEuQ2hhclV0aWwuQ2hhclN0cmVhbS5jb25jYXQoeHMpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwKShmKTtcbiAgICB9XG4gICAgUGFyc2VyLnN0cmluZyA9IHN0cmluZztcbiAgICAvKipcbiAgICAgKiB0byBiZSBtb3ZlZCB0byBQYW50c1xuICAgICAqIHB1bmN0dWF0aW9uIHBhcnNlcyBhbGwgcG9zc2libGUgcHVuY3R1YXRpb24gY2hhcmFjdGVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bmN0dWF0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNhdCh4ID0+IHggPT0gXCIhXCJcbiAgICAgICAgICAgIHx8IHggPT0gXCIuXCJcbiAgICAgICAgICAgIHx8IHggPT0gJywnXG4gICAgICAgICAgICB8fCB4ID09IFwiO1wiXG4gICAgICAgICAgICB8fCB4ID09ICc/J1xuICAgICAgICAgICAgfHwgeCA9PSBcIi1cIlxuICAgICAgICAgICAgfHwgeCA9PSBcIiZcIlxuICAgICAgICAgICAgfHwgeCA9PSAnJCdcbiAgICAgICAgICAgIHx8IHggPT0gJzonXG4gICAgICAgICAgICB8fCB4ID09ICcvJ1xuICAgICAgICAgICAgfHwgeCA9PSAnfCdcbiAgICAgICAgICAgIHx8IHggPT0gJyUnXG4gICAgICAgICAgICB8fCB4ID09ICcjJ1xuICAgICAgICAgICAgfHwgeCA9PSBcIkBcIlxuICAgICAgICAgICAgfHwgeCA9PSBcIn5cIlxuICAgICAgICAgICAgfHwgeCA9PSAnYCdcbiAgICAgICAgICAgIHx8IHggPT0gJyonXG4gICAgICAgICAgICB8fCB4ID09ICdeJ1xuICAgICAgICAgICAgfHwgeCA9PSAneydcbiAgICAgICAgICAgIHx8IHggPT0gJ30nXG4gICAgICAgICAgICB8fCB4ID09IFwiW1wiXG4gICAgICAgICAgICB8fCB4ID09ICddJ1xuICAgICAgICAgICAgfHwgeCA9PSAnKCdcbiAgICAgICAgICAgIHx8IHggPT0gXCIpXCJcbiAgICAgICAgICAgIHx8IHggPT0gXCInXCJcbiAgICAgICAgICAgIHx8IHggPT0gXCJfXCIpO1xuICAgIH1cbiAgICBQYXJzZXIucHVuY3R1YXRpb24gPSBwdW5jdHVhdGlvbjtcbiAgICBsZXQgaWQgPSAoeCkgPT4geDtcbiAgICAvL2xldCBlZmZlY3RzOiBFZmZlY3Q8YW55PltdID0gW107XG4gICAgLyoqXG4gICAgICogcGFyc2UgaXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIHRoZSBpbnB1dCB0ZXh0IGluIGEgQ2hhclN0cmVhbVxuICAgICAqIGFuZCBwYXNzZXMgaXQgdG8gdGhlIHVwcGVyLWxldmVsIHBhcnNlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHByb2dyYW0gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHByb2dyYW0gdGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlKHByb2dyYW0pIHtcbiAgICAgICAgcHJvZ3JhbSArPSBcIlxcblwiO1xuICAgICAgICB6ID0gMDtcbiAgICAgICAgLy9wcmludE9mZnNldCA9IC0xO1xuICAgICAgICAvL3RoaXMuZWZmZWN0cyA9IGVmZmVjdHM7XG4gICAgICAgIGxldCBvID0gUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIobmV3IHBhbnRzXzEuQ2hhclV0aWwuQ2hhclN0cmVhbShwcm9ncmFtKSk7XG4gICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYWNlX2xpZnRfMS5Tb21lKG8ucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYWNlX2xpZnRfMS5Ob25lO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBhcnNlci5wYXJzZSA9IHBhcnNlO1xuICAgIC8qKlxuICAgICAqIEV4cHJlc3Npb24gcGFyc2VyIGZpcnN0IHNlYXJjaGVzIGZvciB0aGUgZmlyc3QgZXhwcmVzc2lvbiBvZiBhIHNlcXVlbmNlIGFuZCBlaXRoZXJcbiAgICAgKiBhbm90aGVyIGV4cHJlc3Npb24gb3IgdGhlIGVuZCBvZiB0aGUgcHJvZ3JhbSAoTk9QKSBhbmQgcmV0dXJucyBhIHNlcXVlbmNlIG5vZGVcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIGJ1ZyBvZiBlYWdlciBwYXJzaW5nXG4gICAgICovXG4gICAgUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIgPSBpID0+IHtcbiAgICAgICAgbGV0IGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuU2VxdWVuY2VOb2RlKHR1cFswXSwgdHVwWzFdKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHAgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9TZXEpKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCc7JykpKHBhbnRzXzEuUHJpbWl0aXZlcy5ubCgpKSkocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyKSkocGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoXyA9PiBuZXcgaW5kZXhfMS5OT1AoKSkpKSkoZik7XG4gICAgICAgIHJldHVybiBwKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhyb3VnaCBhbGwgcG9zc2libGUgZXhwcmVzc2lvbnMgZXhjZXB0IGZvciBzZXF1ZW5jZXNcbiAgICAgKiB1c2VkIHRvIGF2b2lkIGluZmluaXRlIGxvb3BpbmcgaW4gdXBwZXIgbGV2ZWwgcGFyc2VcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIGJ1ZyBvZiBlYWdlciBwYXJzaW5nXG4gICAgICovXG4gICAgUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSA9IGkgPT4ge1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKGxOdW1iZXIoKSkobHN0cmluZzIoKSk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UodmFyTmFtZVBhcnNlKCkpKHAxKTtcbiAgICAgICAgbGV0IHAzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShCb29sUGFyc2UoKSkocDIpO1xuICAgICAgICBsZXQgcDQgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHZhckRlY1BhcnNlKCkpKHAzKTtcbiAgICAgICAgbGV0IHA1ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIudW5PcHNFeHByKShwNCk7XG4gICAgICAgIGxldCBwNiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoRGVjbGFyZSgpKShwNSk7XG4gICAgICAgIGxldCBwNyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmJpbk9wRXhwcikocDYpO1xuICAgICAgICBsZXQgcDggPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKExvZ2ljRXhwcigpKShwNyk7XG4gICAgICAgIGxldCBwOSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLkxpc3RIZWFkKShwOCk7XG4gICAgICAgIGxldCBwMTAgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5mdW5BcHApKHA5KTtcbiAgICAgICAgbGV0IHAxMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLnJldHVyblBhcnNlcikocDEwKTtcbiAgICAgICAgbGV0IHAxMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmNvbmRQYXJzZSkocDExKTtcbiAgICAgICAgbGV0IHAxMyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLldoaWxlTG9vcCkocDEyKTtcbiAgICAgICAgbGV0IHAxNCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLkZvckxvb3ApKHAxMyk7XG4gICAgICAgIGxldCBwMTUgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5mdW5EZWYpKHAxNCk7XG4gICAgICAgIGxldCBwMTYgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5sb29wUGFyc2UpKHAxNSk7XG4gICAgICAgIHJldHVybiBwMTYoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aHJvdWdoIGFsbCBwb3NzaWJsZSBleHByZXNzaW9ucyBleGNlcHQgZm9yIGJpbk9wIGV4cHJlc3Npb25zXG4gICAgICogdXNlZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIGluIHRoZSBiaW5hcnkgZXhwcmVzc2lvbiBwYXJzZXJcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIGJ1ZyBvZiBlYWdlciBwYXJzaW5nXG4gICAgICovXG4gICAgUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb0Jpbk9wID0gaSA9PiB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UobE51bWJlcigpKShsc3RyaW5nMigpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZSh2YXJOYW1lUGFyc2UoKSkocDEpO1xuICAgICAgICBsZXQgcDMgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKEJvb2xQYXJzZSgpKShwMik7XG4gICAgICAgIGxldCBwNCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UodmFyRGVjUGFyc2UoKSkocDMpO1xuICAgICAgICBsZXQgcDUgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci51bk9wc0V4cHIpKHA0KTtcbiAgICAgICAgbGV0IHA2ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShEZWNsYXJlKCkpKHA1KTtcbiAgICAgICAgbGV0IHA3ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuTGlzdEhlYWQpKHA2KTtcbiAgICAgICAgbGV0IHA4ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuZnVuQXBwKShwNyk7XG4gICAgICAgIGxldCBwOSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLnJldHVyblBhcnNlcikocDgpO1xuICAgICAgICBsZXQgcDEwID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuY29uZFBhcnNlKShwOSk7XG4gICAgICAgIGxldCBwMTEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5XaGlsZUxvb3ApKHAxMCk7XG4gICAgICAgIGxldCBwMTIgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5Gb3JMb29wKShwMTEpO1xuICAgICAgICBsZXQgcDEzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuZnVuRGVmKShwMTIpO1xuICAgICAgICBsZXQgcDE0ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIubG9vcFBhcnNlKShwMTMpO1xuICAgICAgICByZXR1cm4gcDE0KGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhyb3VnaCBhbGwgcG9zc2libGUgZXhwcmVzc2lvbnMgZXhjZXB0IGZvciBsb2dpY2FsIGV4cHJlc3Npb25zXG4gICAgICogdXNlZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIGluIHRoZSBsb2dpY2FsIGV4cHJlc3Npb24gcGFyc2VyXG4gICAgICogQHBhcmFtIGkgYSBub25zZW5zZSBwYXJhbWV0ZXIgdXNlZCB0byBhdm9pZCBidWcgb2YgZWFnZXIgcGFyc2luZ1xuICAgICAqL1xuICAgIFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9Mb2dpYyA9IGkgPT4ge1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKGxOdW1iZXIoKSkobHN0cmluZzIoKSk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UodmFyTmFtZVBhcnNlKCkpKHAxKTtcbiAgICAgICAgbGV0IHAzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShCb29sUGFyc2UoKSkocDIpO1xuICAgICAgICBsZXQgcDQgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHZhckRlY1BhcnNlKCkpKHAzKTtcbiAgICAgICAgbGV0IHA1ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIudW5PcHNFeHByKShwNCk7XG4gICAgICAgIGxldCBwNiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoRGVjbGFyZSgpKShwNSk7XG4gICAgICAgIGxldCBwNyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmJpbk9wRXhwcikocDYpO1xuICAgICAgICBsZXQgcDggPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5MaXN0SGVhZCkocDcpO1xuICAgICAgICBsZXQgcDkgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5mdW5BcHApKHA4KTtcbiAgICAgICAgbGV0IHAxMCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLnJldHVyblBhcnNlcikocDkpO1xuICAgICAgICBsZXQgcDExID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuY29uZFBhcnNlKShwMTApO1xuICAgICAgICBsZXQgcDEyID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuV2hpbGVMb29wKShwMTEpO1xuICAgICAgICBsZXQgcDEzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuRm9yTG9vcCkocDEyKTtcbiAgICAgICAgbGV0IHAxNCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmZ1bkRlZikocDEzKTtcbiAgICAgICAgbGV0IHAxNSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmxvb3BQYXJzZSkocDE0KTtcbiAgICAgICAgcmV0dXJuIHAxNShpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGxOdW1iZXIgaXMgdXNlZCB0byB3cmFwIHBhcnNlZCBudW1iZXJzIGluIE51bWJlck5vZGVzIGZvciB0aGUgQVNUXG4gICAgICovXG4gICAgZnVuY3Rpb24gbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgbyA9IG51bWJlcigpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGFudHNfMS5QcmltaXRpdmVzLlN1Y2Nlc3Moby5pbnB1dHN0cmVhbSwgbmV3IGluZGV4XzEuTnVtYmVyTm9kZShvLnJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQYXJzZXIubE51bWJlciA9IGxOdW1iZXI7XG4gICAgLyoqXG4gICAgICogYmluT3BzQ2hhciBwYXJzZXMgYWxsIHBvc3NpYmxlIGJpbmFyeSBvcGVyYXRvcnMsIHN1Y2ggYXMgKyBvciAtXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluT3BzQ2hhcigpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuc2F0KHggPT4geCA9PSBcIitcIlxuICAgICAgICAgICAgICAgIHx8IHggPT0gXCItXCJcbiAgICAgICAgICAgICAgICB8fCB4ID09IFwiL1wiXG4gICAgICAgICAgICAgICAgfHwgeCA9PSBcIj1cIlxuICAgICAgICAgICAgICAgIHx8IHggPT0gXCIqXCIpKShpc3RyZWFtKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUGFyc2VyLmJpbk9wc0NoYXIgPSBiaW5PcHNDaGFyO1xuICAgIC8qKlxuICAgICAqIGJpbk9wc1Nob3J0IHJldHVybnMgYSB0dXBsZSB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgYmluYXJ5IG9wZXJhdG9yIChDaGFyU3RyZWFtKVxuICAgICAqIGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgdGhlIGV4cHJlc3Npb24gdG8gdGhlIHJpZ2h0IG9mIHRoZSBvcGVyYXRvciAoRXhwcmVzc2lvbjx7fT4pXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluT3BTaG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEoYmluT3BzQ2hhcigpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKSgoeCkgPT4geCk7XG4gICAgfVxuICAgIFBhcnNlci5iaW5PcFNob3J0ID0gYmluT3BTaG9ydDtcbiAgICAvKipcbiAgICAgKiBiaW5PcEV4cHIgcGFyc2VzIGFsbCBwb3NzaWJsZSBiaW5hcnkgb3BlcmF0aW9uIGV4cHJlc3Npb25zIGFuZCByZXR1cm5zIHRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgQVNUIG5vZGUgY29uc3RydWN0IChhbHNvIHBhcnNlcyBwb3N0Zml4IGluY3JlbWVudHMvZGVjcmVtZW50cyBsaWtlIGkrKylcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIHRoZSBidWcgd2l0aCBlYWdlciBldmFsdWF0aW9uXG4gICAgICovXG4gICAgUGFyc2VyLmJpbk9wRXhwciA9IGkgPT4ge1xuICAgICAgICB2YXIgZiA9ICh0dXApID0+IHtcbiAgICAgICAgICAgIGxldCBsaHMgPSB0dXBbMF07XG4gICAgICAgICAgICBsZXQgb3AgPSB0dXBbMV1bMF07XG4gICAgICAgICAgICBsZXQgcmhzID0gdHVwWzFdWzFdO1xuICAgICAgICAgICAgc3dpdGNoIChvcC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLlBsdXNPcChsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5NaW51c09wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkRpdk9wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLk11bE9wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkFzc2lnbk9wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmluYXJ5IE9wZXJhdGlvbiBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9CaW5PcCkodmFyRGVjUGFyc2UoKSk7XG4gICAgICAgIGxldCBwMiA9IGJpbk9wU2hvcnQoKTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwb3N0UGx1cyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vQmluT3ApKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCcrKycpKSh0dXAgPT4geyByZXR1cm4gbmV3IGluZGV4XzEuSW5jcmVtZW50KHR1cFswXSwgd3MpOyB9KTtcbiAgICAgICAgbGV0IHBvc3RNaW51cyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vQmluT3ApKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCctLScpKSh0dXAgPT4geyByZXR1cm4gbmV3IGluZGV4XzEuRGVjcmVtZW50KHR1cFswXSwgd3MpOyB9KTtcbiAgICAgICAgbGV0IGJpbk9wID0gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHAxKSkocDIpKGYpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShiaW5PcCkocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwb3N0UGx1cykocG9zdE1pbnVzKSkoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB1bk9wc0NoYXIgcGFyc2VzIGFsbCBwb3NzaWJsZSB1bmFyeSBvcGVyYXRvcnNcbiAgICAgKiBPbmx5IG5lZ2F0aW9ucyBhcmUgc3VwcG9ydGVkLCBidXQgbW9yZSBjYW4gYmUgYWRkZWQgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIGkgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIudW5PcHNDaGFyID0gaSA9PiB7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKFwiLVwiKSkoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB1bk9wc0V4cHIgd3JhcHMgYSB1bmFyeSBvcGVyYXRpb24gZXhwcmVzc2lvbiBpbiB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIEFTVCBub2RlIGFuZCByZXR1cm5zIGl0XG4gICAgICogQHBhcmFtIGkgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIudW5PcHNFeHByID0gaSA9PiB7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLk5lZ09wKHR1cFsxXSwgd3MpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgd3MgPSBcIlwiO1xuICAgICAgICBsZXQgcHJlY2VkaW5nV1MgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKSh4ID0+IHdzID0geC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShQYXJzZXIudW5PcHNDaGFyKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSkoZikoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBsc3RyaW5nIHBhcnNlcyB2YWxpZCBzdHJpbmdzIGluIHRoZSBTV0VMTCBsYW5ndWFnZVxuICAgICAqIGEgdmFsaWQgc3RyaW5nIGlzIHN1cnJvdW5kZWQgYnkgcXVvdGF0aW9ucyBhbmQgY29uc2lzdHMgb2YgbGV0dGVycywgbnVtYmVycywgcHVuY3R1YXRpb24sIGFuZC9vciB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbHN0cmluZygpIHtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHBhbnRzXzEuUHJpbWl0aXZlcy5sZXR0ZXIoKSkocGFudHNfMS5QcmltaXRpdmVzLndzMSgpKSkocGFudHNfMS5QcmltaXRpdmVzLmRpZ2l0KCkpO1xuICAgICAgICAvL2xldCBwMSA9IFByaW1pdGl2ZXMuY2hvaWNlKFByaW1pdGl2ZXMubGV0dGVyKCkpKFByaW1pdGl2ZXMud3MxKCkpO1xuICAgICAgICBsZXQgcCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoXCJcXFwiXCIpKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKFwiXFxcIlwiKSkocGFudHNfMS5QcmltaXRpdmVzLm1hbnkocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMSkocHVuY3R1YXRpb24oKSkpKTtcbiAgICAgICAgbGV0IGYgPSAoeHMpID0+IHBhbnRzXzEuQ2hhclV0aWwuQ2hhclN0cmVhbS5jb25jYXQoeHMpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwKShmKTtcbiAgICB9XG4gICAgUGFyc2VyLmxzdHJpbmcgPSBsc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIGxzdHJpbmcyIHdyYXBzIHN0cmluZ3MgcGFyc2VkIGJ5IGxzdHJpbmcgaW4gU3RyaW5Ob2RlIG9iamVjdHMgYW5kIHJldHVybnMgdGhlbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxzdHJpbmcyKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgICAgICBsZXQgcHJlY2VkaW5nV1MgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKSh4ID0+IHdzID0geC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGxldCBvID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShsc3RyaW5nKCkpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGFudHNfMS5QcmltaXRpdmVzLlN1Y2Nlc3Moby5pbnB1dHN0cmVhbSwgbmV3IGluZGV4XzEuU3RyaW5nTm9kZShvLnJlc3VsdC50b1N0cmluZygpLCB3cykpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQYXJzZXIubHN0cmluZzIgPSBsc3RyaW5nMjtcbiAgICAvKipcbiAgICAgKiB2YXJOYW1lUGFyc2UgcGFyc2VzIHZhbGlkIHZhcmlhYmxlIG5hbWVzXG4gICAgICogdmFyaWFibGUgbmFtZXMgaW4gU1dFTEwgYmVnaW4gd2l0aCBhIGxvd2VyY2FzZSBjaGFyIGFuZCBhcmUgZm9sbG93ZWRcbiAgICAgKiBieSBsZXR0ZXJzIG9yIGRpZ2l0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhck5hbWVQYXJzZSgpIHtcbiAgICAgICAgdmFyIGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuVmFyaWFibGVOb2RlKHR1cFswXS50b1N0cmluZygpICsgcGFudHNfMS5DaGFyVXRpbC5DaGFyU3RyZWFtLmNvbmNhdCh0dXBbMV0pLnRvU3RyaW5nKCksIHdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBmaXJzdENoYXIgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5sb3dlcigpKTtcbiAgICAgICAgbGV0IG5leHRDaGFycyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55KHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UocGFudHNfMS5QcmltaXRpdmVzLmRpZ2l0KCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5sZXR0ZXIoKSkpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShmaXJzdENoYXIpKG5leHRDaGFycykoZik7XG4gICAgfVxuICAgIFBhcnNlci52YXJOYW1lUGFyc2UgPSB2YXJOYW1lUGFyc2U7XG4gICAgLyoqXG4gICAgICogdmFyRGVjUGFyc2UgcGFyc2VzIHZhbGlkIHZhcmlhYmxlIGRlY2xhcmF0aW9ucyBpbiB0aGUgZm9ybSBcInZhciB4XCJcbiAgICAgKiB0aGUgcGFyc2VyIHRoZW4gd3JhcHMgdGhlIHBhcnNlZCB2YWx1ZSBpbiBhIHZhcmlhYmxlIG5vZGUgZm9yIHRoZSBBU1RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YXJEZWNQYXJzZSgpIHtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cihcInZhclwiKSk7XG4gICAgICAgIGxldCB2YXJOYW1lID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzMSgpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkodmFyTmFtZVBhcnNlKCkpO1xuICAgICAgICBsZXQgcCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocDEpKHZhck5hbWUpKHR1cCA9PiB0dXBbMV0pO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgUGFyc2VyLnZhckRlY1BhcnNlID0gdmFyRGVjUGFyc2U7XG4gICAgLyoqXG4gICAgICogRGVjbGFyZSBwYXJzZXMgdmFyaWFibGUgZGVjbGFyYXRpb25zIGluIHRoZSBmb3JtIFwidmFyIHggPSAyXCJcbiAgICAgKiBhbmQgcmV0dXJucyBhIERlY2xhcmVPcCBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjbGFyZSgpIHtcbiAgICAgICAgbGV0IGVxID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignPScpKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmxlZnQodmFyRGVjUGFyc2UoKSkoZXEpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwMSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSkodHVwID0+IHsgcmV0dXJuIG5ldyBpbmRleF8xLkRlY2xhcmVPcCh0dXBbMF0sIHR1cFsxXSk7IH0pO1xuICAgIH1cbiAgICBQYXJzZXIuRGVjbGFyZSA9IERlY2xhcmU7XG4gICAgLyoqXG4gICAgICogTGlzdEhlYWQgcGFyc2VzIGFsbCBsaXN0cyBpbiB0aGUgU1dFTEwgbGFuZ3VhZ2UsIGluY2x1ZGluZyBlbXB0eSBsaXN0c1xuICAgICAqIExpc3RzIGFyZSBzdXJyb3VuZGVkIGJ5IHNxdWFyZSBicmFja2V0cyBhbmQgZWFjaCBlbGVtZW50IGlzIHNlcGFyYXRlZCBieSBhIGNvbW1hXG4gICAgICogcmV0dXJucyBhIGxpc3ROb2RlIG9iamVjdFxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIuTGlzdEhlYWQgPSBpID0+IHtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwMCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCdbJykpKShwMCk7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgbGV0IGhkID0gdHVwWzBdO1xuICAgICAgICAgICAgbGV0IHJlcyA9IFtoZF07XG4gICAgICAgICAgICBsZXQgdGFpbCA9IHR1cFsxXTtcbiAgICAgICAgICAgIGZvciAobGV0IGVsZW0gb2YgdGFpbCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkxpc3ROb2RlKHJlcywgd3MpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHAxKShMaXN0VGFpbCgpKShmKTtcbiAgICAgICAgbGV0IHAzID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ1tdJykpKShfID0+IG5ldyBpbmRleF8xLkxpc3ROb2RlKFtdLCB3cykpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMykocDIpKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTGlzdCBUYWlsIHBhcnNlcyBzZWNvbmQgdGhyb3VnaCBsYXN0IGVsZW1lbnRzIG9mIGEgbGlzdCwgZWFjaCBzZXBhcmF0ZWQgYnkgYSBjb21tYVxuICAgICAqIHJldHVybnMgYW4gYXJyYXkgb2YgRXhwcmVzc2lvbnMgdGhhdCB3aWxsIGJlIGFjY2Vzc2VkIGJ5IExpc3RIZWFkXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGlzdFRhaWwoKSB7XG4gICAgICAgIGxldCBwMCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMuY2hhcignLCcpKShwMCk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5sZWZ0KHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55KHAxKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ10nKSk7XG4gICAgICAgIHJldHVybiBwMjtcbiAgICB9XG4gICAgUGFyc2VyLkxpc3RUYWlsID0gTGlzdFRhaWw7XG4gICAgLyoqXG4gICAgICogZnVuRGVmQXJnTGlzdCBwYXJzZXMgYXJndW1lbnQgbGlzdHMgZm9yIGZ1bmN0aW9uIGRlZmluaXRpb25zLFxuICAgICAqIHN1cnJvdW5kZWQgYnkgcGFyZW5zIGFuZCBzZXBhcmF0ZWQgYnkgY29tbWFzXG4gICAgICogcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bkRlZkFyZ0xpc3QoKSB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKCcpKShzdHJpbmcoKSk7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgbGV0IGhkID0gdHVwWzBdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgcmVzID0gW2hkXTtcbiAgICAgICAgICAgIGxldCB0YWlsID0gdHVwWzFdO1xuICAgICAgICAgICAgZm9yIChsZXQgZWxlbSBvZiB0YWlsKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goZWxlbS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocDEpKGZ1bkRlZkFyZ0xpc3RUYWlsKCkpKGYpO1xuICAgICAgICBsZXQgcDMgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJygpJykpKF8gPT4gW10pO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMykocDIpO1xuICAgIH1cbiAgICBQYXJzZXIuZnVuRGVmQXJnTGlzdCA9IGZ1bkRlZkFyZ0xpc3Q7XG4gICAgLyoqXG4gICAgICogZnVuRGVmQXJnTGlzdFRhaWwgcGFyc2VzIHRoZSBzZWNvbmQgdGhyb3VnaCBsYXN0IGVsZW1lbnRzIG9mIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBwYXJhbWV0ZXIgbGlzdFxuICAgICAqIHBhcmFtZXRlcnMgYXJlIHNlcGFyYXRlZCBieSBjb21tYXMgYW5kIGVuZCB3aXRoIGEgY2xvc2luZyBwYXJlbnNcbiAgICAgKiByZXR1cm5zIGFuIGFycmF5IG9mIHBhcmFtZXRlcnMsIHdoaWNoIGlzIGFjY2Vzc2VkIGJ5IGZ1bkRlZkFyZ0xpc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5EZWZBcmdMaXN0VGFpbCgpIHtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcsJykpKHN0cmluZygpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmxlZnQocGFudHNfMS5QcmltaXRpdmVzLm1hbnkocDEpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKScpKTtcbiAgICAgICAgcmV0dXJuIHAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmdW5BcHBBcmdMaXN0IHBhcnNlcyBhcmd1bWVudCBsaXN0cyBmb3IgZnVuY3Rpb24gYXBwbGljYXRpb25zLCBpbmNsdWRpbmcgZW1wdHkgYXJncyBsaXN0c1xuICAgICAqIHRoZSBwYXJzZXIgcmV0dXJucyBhbiBhcnJheSBvZiBFeHByZXNzaW9uIG9iamVjdHMgdGhhdCByZXByZXNlbnQgdGhlIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bkFwcEFyZ0xpc3QoKSB7XG4gICAgICAgIGxldCBleHByID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcoJykpKGV4cHIpO1xuICAgICAgICB2YXIgZiA9ICh0dXApID0+IHtcbiAgICAgICAgICAgIGxldCBoZCA9IHR1cFswXTtcbiAgICAgICAgICAgIGxldCByZXMgPSBbaGRdO1xuICAgICAgICAgICAgbGV0IHRhaWwgPSB0dXBbMV07XG4gICAgICAgICAgICBmb3IgKGxldCBlbGVtIG9mIHRhaWwpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocDEpKGZ1bkFwcEFyZ0xpc3RUYWlsKCkpKGYpO1xuICAgICAgICBsZXQgcDMgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJygpJykpKF8gPT4gW10pO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMykocDIpO1xuICAgIH1cbiAgICBQYXJzZXIuZnVuQXBwQXJnTGlzdCA9IGZ1bkFwcEFyZ0xpc3Q7XG4gICAgLyoqXG4gICAgICogZnVuQXBwQXJnTGlzdFRhaWwgcGFyc2VzIHRoZSBzZWNvbmQgdGhyb3VnaCBsYXN0IGVsZW1lbnRzIG9mIGFuIGFyZ3VtZW50IGxpc3RcbiAgICAgKiBlYWNoIGVsZW1lbnQgaXMgc2VwYXJhdGVkIGJ5IGEgY29tbWFcbiAgICAgKiByZXR1cm5zIGFuIGFycmF5IG9mIEV4cHJlc3Npb24gb2JqZWN0cywgbGF0ZXIgYWNjZXNzZWQgYnkgZnVuQXBwQXJnc0xpc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5BcHBBcmdMaXN0VGFpbCgpIHtcbiAgICAgICAgbGV0IGNvbW1hID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignLCcpKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KGNvbW1hKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmxlZnQocGFudHNfMS5QcmltaXRpdmVzLm1hbnkocDEpKShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcpJykpKTtcbiAgICAgICAgcmV0dXJuIHAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXR1cm5QYXJzZXIgcGFyc2VzIHZhbGlkIHJldHVybiBzdGF0ZW1lbnRzIGluIHRoZSBmb3JtIFwicmV0dXJuIHhcIlxuICAgICAqIHdyYXBzIHRoZSBwYXJzZWQgdmFsdWUgaW4gYSBSZXR1cm4gbm9kZSBmb3IgdGhlIEFTVFxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIucmV0dXJuUGFyc2VyID0gaSA9PiB7XG4gICAgICAgIGxldCBleHByID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cigncmV0dXJuJykpKShleHByKTtcbiAgICAgICAgdmFyIGYgPSAoZSkgPT4geyByZXR1cm4gbmV3IGluZGV4XzEuUmV0dXJuKGUsIHdzKTsgfTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocCkoZikoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBmdW5EZWYgcGFyc2VzIHZhbGlkIGZ1bmN0aW9uIGRlZmluaXRpb25zIGluIHRoZSBmb3JtIFwiZnVuIGZ1bmN0aW9uTmFtZShhcmdMaXN0KXsgYm9keTt9XCJcbiAgICAgKiB0aGUgcGFyc2VyIHJldHVybnMgYSBmdW5EZWYgbm9kZSBmb3IgdGhlIEFTVFxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIuZnVuRGVmID0gaSA9PiB7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cignZnVuJykpKShwYW50c18xLlByaW1pdGl2ZXMuc2VxKFxuICAgICAgICAvKiBmdW5jdGlvbiBuYW1lICovXG4gICAgICAgIHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4oc3RyaW5nKCkpKGNzID0+IGNzLnRvU3RyaW5nKCkpKShwYW50c18xLlByaW1pdGl2ZXMuc2VxKFxuICAgICAgICAvKiBmdW5jdGlvbiBhcmd1bWVudHMgKi9cbiAgICAgICAgZnVuRGVmQXJnTGlzdCgpKShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQoXG4gICAgICAgIC8qIGZ1bmN0aW9uIGJvZHkgKi9cbiAgICAgICAgcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcigneycpKSkocGFudHNfMS5QcmltaXRpdmVzLmxlZnQocGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlcikpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCd9JykpKSkoaWQpKShcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBBU1Qgbm9kZVxuICAgICAgICAodHVwKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm5hbWUgPSB0dXBbMF07XG4gICAgICAgICAgICBsZXQgYXJncyA9IHR1cFsxXVswXTtcbiAgICAgICAgICAgIGxldCBib2R5ID0gdHVwWzFdWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkZ1bkRlZihmbmFtZSwgYm9keSwgYXJncywgd3MpO1xuICAgICAgICB9KSkoaSk7XG4gICAgfTtcbiAgICAvL2xldCBwcmludE9mZnNldCA9IC0xO1xuICAgIC8vbGV0IGJvdW5kaW5nUmVjdHMgPSBbXTtcbiAgICBsZXQgeiA9IDA7XG4gICAgLy9UT0RPXG4gICAgZnVuY3Rpb24gZ2V0Tm9uT3ZlcmxhcHBpbmdDb29yZHMoKSB7XG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfVxuICAgIFBhcnNlci5nZXROb25PdmVybGFwcGluZ0Nvb3JkcyA9IGdldE5vbk92ZXJsYXBwaW5nQ29vcmRzO1xuICAgIC8qKlxuICAgICAqIGZ1bkFwcCBwYXJzZXMgdmFsaWQgZnVuY3Rpb24gYXBwbGljYXRpb25zIGluIHRoZSBmb3JtIFwiZnVuY3Rpb25OYW1lKGFyZ3NMaXN0KVwiIGFuZCByZXR1cm5zIGEgZnVuQXBwIG5vZGVcbiAgICAgKiBwYXJzZXIgY2hlY2tzIGZvciBidWlsdC1pbiBmdW5jdGlvbnMsIGxpa2UgcHJpbnQsIGVsbGlwc2UsIGFuZCByZWN0OyBhbmQgcmV0dXJucyB0aGUgdmFsaWQgQVNUIG5vZGVcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIHRoZSBidWcgd2l0aCBlYWdlciBldmFsdWF0aW9uXG4gICAgICovXG4gICAgUGFyc2VyLmZ1bkFwcCA9IGkgPT4ge1xuICAgICAgICBsZXQgd3MgPSBcIlwiO1xuICAgICAgICBsZXQgcHJlY2VkaW5nV1MgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKSh4ID0+IHdzID0geC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShzdHJpbmcoKSkpKGZ1bkFwcEFyZ0xpc3QoKSkodHVwID0+IHtcbiAgICAgICAgICAgIGxldCBmbmFtZSA9IHR1cFswXS50b1N0cmluZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmbmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwcmludFwiOlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInogY29vcmRpbmF0ZTogXCIgKyB6KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1cFsxXS5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9ib3VuZGluZ1JlY3RzLnB1c2goW3R1cFsxXVswXS53aWR0aCwgdHVwWzFdWzBdLmhlaWdodCwgdHVwWzFdWzFdLCB0dXBbMV1bMl1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5QcmludE5vZGUodHVwWzFdWzBdLCB0cnVlLCBuZXcgaW5kZXhfMS5EaW1lbnNpb25zKHR1cFsxXVsxXSwgdHVwWzFdWzJdLCBuZXcgaW5kZXhfMS5OdW1iZXJOb2RlKHorKyksIG5ldyBpbmRleF8xLk51bWJlck5vZGUoMSkpLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9wcmludE9mZnNldCA9IChwcmludE9mZnNldCArIDEpICUgMTI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5QcmludE5vZGUodHVwWzFdWzBdLCB0cnVlLCBuZXcgaW5kZXhfMS5EaW1lbnNpb25zKG5ldyBpbmRleF8xLk51bWJlck5vZGUoMTAwKSwgbmV3IGluZGV4XzEuTnVtYmVyTm9kZSgxMDApLCBuZXcgaW5kZXhfMS5OdW1iZXJOb2RlKHorKyksIG5ldyBpbmRleF8xLk51bWJlck5vZGUoMSkpLCB3cyk7XG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gbmV3IFByaW50Tm9kZSh0dXBbMV1bMF0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZWxsaXBzZVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHVwWzFdLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuRWxsaXBzZU5vZGUodHVwWzFdWzBdLCB0dXBbMV1bMV0sIHdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0dXBbMV0ubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5SZWN0YW5nbGVOb2RlKHR1cFsxXVswXSwgdHVwWzFdWzFdLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHVwWzFdLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuTGluZU5vZGUodHVwWzFdWzBdLCB0dXBbMV1bMV0sIHdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJjdXJ2ZVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHVwWzFdLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuQ3VydmVOb2RlKHR1cFsxXVswXSwgdHVwWzFdWzFdLCB0dXBbMV1bMl0sIHdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJlcGhcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1cFsxXS5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkVwaE5vZGUodHVwWzFdWzBdLCB0dXBbMV1bMV0sIHdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbW9qaVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHVwWzFdLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuRW1vamlOb2RlKHR1cFsxXVswXSwgdHVwWzFdWzFdLCB0dXBbMV1bMl0sIHdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFyZ3MgPSB0dXBbMV07XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuRnVuQXBwKGZuYW1lLCBhcmdzLCB3cyk7XG4gICAgICAgIH0pKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQm9vbFBhcnNlIHBhcnNlcyB2YWxpZCBib29sZWFucywgdHJ1ZSBhbmQgZmFsc2UsIGFuZCByZXR1cm5zIGEgQm9vbGVhbk5vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb29sUGFyc2UoKSB7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cigndHJ1ZScpKSkoXyA9PiBuZXcgaW5kZXhfMS5Cb29sZWFuTm9kZSh0cnVlLCB3cykpO1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cignZmFsc2UnKSkpKF8gPT4gbmV3IGluZGV4XzEuQm9vbGVhbk5vZGUoZmFsc2UsIHdzKSk7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHAxKShwMik7XG4gICAgfVxuICAgIFBhcnNlci5Cb29sUGFyc2UgPSBCb29sUGFyc2U7XG4gICAgLyoqXG4gICAgICogbG9naWNDaGFyIHBhcnNlcyBhbGwgbG9naWNhbCBvcGVyYXRvcnMgaW4gdGhlIFNXRUxMIGxhbmd1YWdlIGFuZCByZXR1cm5zIHRoZSBjb25zdW1lZCBvcGVyYXRvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZ2ljQ2hhcigpIHtcbiAgICAgICAgdmFyIGxvZ2ljQ2hhciA9IFtcImVxdWFsc1wiLCAnPT0nLCAnYW5kJywgJz4nLCAnPCcsICdub3QgZXF1YWxzJywgJ29yJ107XG4gICAgICAgIHZhciBsb2dpY0NoYXIyID0gWyc+PScsICc8PSddO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHJTYXQobG9naWNDaGFyKSk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLnN0clNhdChsb2dpY0NoYXIyKSk7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHAyKShwMSk7XG4gICAgfVxuICAgIFBhcnNlci5sb2dpY0NoYXIgPSBsb2dpY0NoYXI7XG4gICAgLyoqXG4gICAgICogbG9naWNTaG9ydCByZXR1cm5zIGEgdHVwbGUsIHdoZXJlIHRoZSBmaXJzdCBlbGVtZW50IHJlcHJlc2VudHMgdGhlIGxvZ2ljYWwgb3BlcmF0b3IgYW5kXG4gICAgICogdGhlIHNlY29uZCBlbGVtZW50IGlzIHRoZSBleHByZXNzaW9uIHRvIHRoZSByaWdodCBvZiB0aGUgb3BlcmF0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2dpY1Nob3J0KCkge1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShsb2dpY0NoYXIoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSkoKHgpID0+IHgpO1xuICAgIH1cbiAgICBQYXJzZXIubG9naWNTaG9ydCA9IGxvZ2ljU2hvcnQ7XG4gICAgLyoqXG4gICAgICogbG9naWNFeHByIHBhcnNlcyBsb2dpY2FsIGV4cHJlc3Npb25zIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIEFTVCBub2RlXG4gICAgICogQHBhcmFtIGkgYSBub25zZW5zZSBwYXJhbWV0ZXIgdXNlZCB0byBhdm9pZCB0aGUgYnVnIHdpdGggZWFnZXIgZXZhbHVhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZ2ljRXhwcigpIHtcbiAgICAgICAgLy8gVE9ETzogRGFuICgyMDE4LTExLTE5KSwgc2hvdWxkbid0IHBhcmFtZXRlcml6ZWQgdHlwZSBiZSBCb29sZWFuTm9kZT9cbiAgICAgICAgdmFyIGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICBsZXQgbGhzID0gdHVwWzBdO1xuICAgICAgICAgICAgbGV0IG9wID0gdHVwWzFdWzBdO1xuICAgICAgICAgICAgbGV0IHJocyA9IHR1cFsxXVsxXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3AudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcXVhbHNcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkVxdWFscyhsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI9PVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuRXF1YWxzKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFuZFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuQW5kKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkdyZWF0ZXJUaGFuKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkxlc3NUaGFuKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIj49XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5HcmVhdGVyVGhhbkVxKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIjw9XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5MZXNzVGhhbkVxKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5PcihsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJub3QgZXF1YWxzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5Ob3RFcXVhbChsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvZ2ljYWwgZXhwcmVzc2lvbiBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgd3MgPSBcIlwiO1xuICAgICAgICBsZXQgcHJlY2VkaW5nV1MgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKSh4ID0+IHdzID0geC50b1N0cmluZygpKTtcbiAgICAgICAgbGV0IG5vdCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cignbm90JykpO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQobm90KShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IG5vdEV4cHIgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHAxKSh4ID0+IG5ldyBpbmRleF8xLk5vdCh4LCB3cykpO1xuICAgICAgICBsZXQgbG9naWNFeHByID0gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9Mb2dpYykpKGxvZ2ljU2hvcnQoKSkoZik7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKG5vdEV4cHIpKGxvZ2ljRXhwcik7XG4gICAgfVxuICAgIFBhcnNlci5Mb2dpY0V4cHIgPSBMb2dpY0V4cHI7XG4gICAgLyoqXG4gICAgICogSWZQYXJzZSBwYXJzZXMgdmFsaWQgaWYgc3RhdGVtZW50cyBpbiB0aGUgZm9ybSBcImlmKGNvbmRpdGlvbil7IGJvZHk7IH1cIlxuICAgICAqIHJldHVybnMgYW4gYXJyYXkgd2hlcmUgdGhlIGZpcnN0IGVsZW0gaXMgdGhlIGNvbmRpdGlvbiBhbmQgdGhlIHNlY29uZCBpcyB0aGUgYm9keVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIElmUGFyc2UoKSB7XG4gICAgICAgIGxldCBleHByID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IGJvZHlQYXJzZSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIpO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ2lmJykpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcoJykpKHggPT4geCk7XG4gICAgICAgIGxldCBjb25kID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocDEpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcpJykpKGV4cHIpO1xuICAgICAgICBsZXQgY3VybHkgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCd7JykpO1xuICAgICAgICBsZXQgYm9keSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKGN1cmx5KShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignfScpKShib2R5UGFyc2UpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShjb25kKShib2R5KSh4ID0+IHgpO1xuICAgIH1cbiAgICBQYXJzZXIuSWZQYXJzZSA9IElmUGFyc2U7XG4gICAgLyoqXG4gICAgICAqIElmRWxzZVBhcnNlIHBhcnNlcyB2YWxpZCBpZiBlbHNlIHN0YXRlbWVudHMgaW4gdGhlIGZvcm0gXCJpZihjb25kaXRpb24peyBib2R5OyB9IGVsc2V7IGJvZHkyO31cIlxuICAgICAgKiByZXR1cm5zIGFuIGFycmF5IHdoZXJlIHRoZSBmaXJzdCBlbGVtIGlzIHRoZSBjb25kaXRpb24gYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGZpcnN0IGJvZHkgYW5kIHRoZSB0aGlyZCBpcyBib2R5MlxuICAgICAgKi9cbiAgICBmdW5jdGlvbiBJZkVsc2VQYXJzZSgpIHtcbiAgICAgICAgbGV0IGUgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ2Vsc2UnKSk7XG4gICAgICAgIGxldCBib2R5ID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlcik7XG4gICAgICAgIGxldCBib2R5MiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ3snKSkocGFudHNfMS5QcmltaXRpdmVzLnN0cignfScpKShib2R5KTtcbiAgICAgICAgbGV0IGVsc2VQYXJzZSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChlKShib2R5Mik7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgdHVwWzBdLnB1c2godHVwWzFdKTtcbiAgICAgICAgICAgIHJldHVybiB0dXBbMF07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuc2VxKElmUGFyc2UoKSkoZWxzZVBhcnNlKShmKTtcbiAgICB9XG4gICAgUGFyc2VyLklmRWxzZVBhcnNlID0gSWZFbHNlUGFyc2U7XG4gICAgLyoqXG4gICAgICogY29uZFBhcnNlIHBhcnNlcyBwb3NzaWJsZSBjb25kaXRpb25hbCBzdGF0ZW1lbnRzLCBpbmNsdWRpbmcgaWYgYW5kIGlmL2Vsc2Ugc3RhdGVtZW50c1xuICAgICAqIHJldHVybnMgYSBDb25kaXRpb25hbCBub2RlXG4gICAgICogQHBhcmFtIGkgYSBub25zZW5zZSBwYXJhbWV0ZXIgdXNlZCB0byBhdm9pZCB0aGUgYnVnIHdpdGggZWFnZXIgZXZhbHVhdGlvblxuICAgICAqL1xuICAgIFBhcnNlci5jb25kUGFyc2UgPSBpID0+IHtcbiAgICAgICAgdmFyIGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICBpZiAodHVwLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkNvbmRpdGlvbmFsKHR1cFswXSwgdHVwWzFdLCB0dXBbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkNvbmRpdGlvbmFsKHR1cFswXSwgdHVwWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShJZkVsc2VQYXJzZSgpKShJZlBhcnNlKCkpKShmKShpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlcGVhdExvb3AgcGFyc2VzIHZhbGlkIHJlcGVhdCBzdGF0ZW1lbnQgb2YgdGhlIGZvcm0gXCJyZXBlYXQobil7IGJvZHk7IH1cIlxuICAgICAqIHJldHVybnMgYW4gYXJyYXkgd2hlcmUgdGhlIGZpcnN0IGVsZW0gaXMgbnVtYmVyIG9mIHJlcGVhdHMgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGJvZHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZXBlYXRMb29wKCkge1xuICAgICAgICBsZXQgZXhwciA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBib2R5UGFyc2UgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCdyZXBlYXQnKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJygnKSkoeCA9PiB4KTtcbiAgICAgICAgbGV0IG4gPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwMSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJyknKSkoZXhwcik7XG4gICAgICAgIGxldCBjdXJseSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ3snKSk7XG4gICAgICAgIGxldCBib2R5ID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4oY3VybHkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCd9JykpKGJvZHlQYXJzZSk7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuc2VxKG4pKGJvZHkpKHggPT4geCk7XG4gICAgfVxuICAgIFBhcnNlci5SZXBlYXRMb29wID0gUmVwZWF0TG9vcDtcbiAgICAvKipcbiAgICAgKiBsb29wUGFyc2UgcGFyc2VzIHBvc3NpYmxlIGxvb3Agc3RhdGVtZW50cywgaXMgYSBoZWxwZXIgZm9yIFJlcGVhdExvb3BcbiAgICAgKiByZXR1cm5zIGEgUmVwZWF0Tm9kZVxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIubG9vcFBhcnNlID0gaSA9PiB7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR1cC5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5SZXBlYXROb2RlKHR1cFswXSwgdHVwWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4oUmVwZWF0TG9vcCgpKShmKShpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoaWxlTG9vcCBwYXJzZXMgdmFsaWQgd2hpbGUgbG9vcHMgaW4gdGhlIGZvcm0gXCJ3aGlsZShjb25kaXRpb24pIHsgYm9keTt9XCJcbiAgICAgKiByZXR1cm5zIGEgV2hpbGVOb2RlIGZvciB0aGUgQVNUXG4gICAgICovXG4gICAgUGFyc2VyLldoaWxlTG9vcCA9IGkgPT4ge1xuICAgICAgICBsZXQgZXhwciA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBib2R5UGFyc2UgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyKTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKFwid2hpbGVcIikpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKCcpKSh4ID0+IHgpO1xuICAgICAgICBsZXQgY29uZCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHAxKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKScpKShleHByKTtcbiAgICAgICAgbGV0IGN1cmx5ID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcigneycpKTtcbiAgICAgICAgbGV0IGJvZHkgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihjdXJseSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ30nKSkoYm9keVBhcnNlKTtcbiAgICAgICAgdmFyIGYgPSAodHVwKSA9PiB7IHJldHVybiBuZXcgaW5kZXhfMS5XaGlsZU5vZGUodHVwWzBdLCB0dXBbMV0sIHdzKTsgfTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEoY29uZCkoYm9keSkoZikoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3JMb29wIHBhcnNlcyB2YWxpZCBmb3IgbG9vcHMgaW4gdGhlIGZvcm0gXCJmb3IoaW5pdGlhbCwgY29uZGl0aW9uLCBwb3N0KSB7IGJvZHk7fVwiIGFuZCByZXR1cm5zIGEgRm9yTm9kZVxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIuRm9yTG9vcCA9IGkgPT4ge1xuICAgICAgICBsZXQgYXJncyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoZnVuQXBwQXJnTGlzdCgpKTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ2ZvcicpKSkoYXJncyk7XG4gICAgICAgIGxldCBjdXJseSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ3snKSk7XG4gICAgICAgIGxldCBleHByID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLm5sKCkpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIpO1xuICAgICAgICBsZXQgYm9keSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKGN1cmx5KShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignfScpKShleHByKTtcbiAgICAgICAgdmFyIGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5pdCA9IHR1cFswXVswXTtcbiAgICAgICAgICAgIGxldCBjb25kID0gdHVwWzBdWzFdO1xuICAgICAgICAgICAgbGV0IHBvc3QgPSB0dXBbMF1bMl07XG4gICAgICAgICAgICBsZXQgYm9keSA9IHR1cFsxXTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5Gb3JOb2RlKGluaXQsIGNvbmQsIHBvc3QsIGJvZHksIHdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocDEpKGJvZHkpKGYpKGkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gc2luZ2xlQ29tbWVudCgpIHtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLm1hbnkxKHBhbnRzXzEuUHJpbWl0aXZlcy5pdGVtKCkpO1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHAxKSh4cyA9PiBwYW50c18xLkNoYXJVdGlsLkNoYXJTdHJlYW0uY29uY2F0KHhzKSk7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMuc3RyKCcvLycpKShwYW50c18xLlByaW1pdGl2ZXMubmwoKSkocDIpO1xuICAgICAgICAvL3JldHVybiBQcmltaXRpdmVzLnNlcTxDaGFyVXRpbC5DaGFyU3RyZWFtLCBDaGFyVXRpbC5DaGFyU3RyZWFtLCBDaGFyVXRpbC5DaGFyU3RyZWFtW10+KFByaW1pdGl2ZXMuc3RyKCcvLycpKShQcmltaXRpdmVzLm5sKCkpKHg9PngpO1xuICAgIH1cbiAgICBQYXJzZXIuc2luZ2xlQ29tbWVudCA9IHNpbmdsZUNvbW1lbnQ7XG4gICAgZnVuY3Rpb24gbXVsdGlMaW5lQ29tbWVudCgpIHtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLm1hbnkxKHBhbnRzXzEuUHJpbWl0aXZlcy5pdGVtKCkpO1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHAxKSh4cyA9PiBwYW50c18xLkNoYXJVdGlsLkNoYXJTdHJlYW0uY29uY2F0KHhzKSk7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMuc3RyKCdcXC8qKicpKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCcqXFwvJykpKHAyKTtcbiAgICB9XG4gICAgUGFyc2VyLm11bHRpTGluZUNvbW1lbnQgPSBtdWx0aUxpbmVDb21tZW50O1xufSkoUGFyc2VyID0gZXhwb3J0cy5QYXJzZXIgfHwgKGV4cG9ydHMuUGFyc2VyID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEJvb2xlYW5Ob2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgQm9vbGVhbk5vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYSBib29sZWFuXG4gICAgICogQHBhcmFtIHZhbCBUaGUgYm9vbGVhbiB2YWx1ZSBvZiB0aGUgQm9vbGVhbk5vZGVcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlIHNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFsLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBCb29sZWFuTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQm9vbGVhbk5vZGVzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBCb29sZWFuTm9kZSBlcXVhbHMgYW5vdGhlclxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgQm9vbGVhbk5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbCA9PT0gcmlnaHQudmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQm9vbGVhbk5vZGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5fdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBib29sZWFuIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IHZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm9vbGVhbiB2YWx1ZVxuICAgICAqL1xuICAgIHNldCB2YWwodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFsID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkJvb2xlYW5Ob2RlID0gQm9vbGVhbk5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cb29sZWFuTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIE5PUCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qIEEgTk9QIGlzIGEgcGxhY2Vob2xkZXIgb3BlcmF0aW9uIHRoYXQgZXZhbHVhdGVzIHRvIG5vdGhpbmcgKi9cbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE5PUFxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOT1BzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTk9QcyBjYW5ub3QgYmUgZHJhd24uXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBOT1BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIE5PUCBlcXVhbHMgYW5vdGhlciAoc3BvaWxlcjogaXQgZG9lc24ndClcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5OT1AgPSBOT1A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OT1AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL051bWJlckVmZmVjdFwiKTtcbi8vIE5vZGVzIHJlcHJlc2VudGluZyBudW1iZXJzXG4vLyBTaG91bGQgYWJzdHJhY3QgTm9kZSBjbGFzcyBpbXBsZW1lbnQgRXhwcmVzc2lvbj9cbmNsYXNzIE51bWJlck5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIE51bWJlck5vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYSBudW1iZXJcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSBudW1iZXIgdmFsdWVcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2YWwsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdmFsID0gdmFsO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBOdW1iZXJOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOdW1iZXJOb2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGxldCBlID0gbmV3IE51bWJlckVmZmVjdF8xLk51bWJlckVmZmVjdCh0aGlzKTtcbiAgICAgICAgZS5kcmF3KGNvbnRleHQsIGRpbXMsIGFzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIE51bWJlck5vZGUgZXF1YWxzIGFub3RoZXIgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHkgKG11c3QgYmUgYSBOdW1iZXJOb2RlKVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBOdW1iZXJOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWwgPT09IHJpZ2h0LnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIE51bWJlck5vZGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5fdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgc3RvcmVkIGluIHRoZSBub2RlXG4gICAgICovXG4gICAgZ2V0IHZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIG51bWJlciBzdG9yZWQgaW4gdGhlIG5vZGVcbiAgICAgKi9cbiAgICBzZXQgdmFsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5OdW1iZXJOb2RlID0gTnVtYmVyTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU51bWJlck5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIFN0cmluZ05vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIFN0cmluZ05vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gc3RyIFRoZSBzdHJpbmcgc3RvcmVkIGluIHRoZSBub2RlXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RyLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0ciA9IHN0cjtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBTdHJpbmdOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgU3RyaW5nIHVzaW5nIFN0cmluZ0VmZmVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBzdHJpbmcgdG8gYmUgZHJhd25cbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGxldCBlID0gbmV3IFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCh0aGlzKTtcbiAgICAgICAgZS5kcmF3KGNvbnRleHQsIGRpbXMsIGFzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIFN0cmluZ05vZGUgZXF1YWxzIGFub3RoZXIgU3RyaW5nTm9kZVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHksIG11c3QgYmUgYSBTdHJpbmdOb2RlXG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIFN0cmluZ05vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbCA9PT0gcmlnaHQudmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgU3RyaW5nTm9kZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyAnXFxcIicgKyB0aGlzLl9zdHIgKyAnXFxcIic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmluZyBzdG9yZWQgaW4gdGhlIG5vZGVcbiAgICAgKi9cbiAgICBzZXQgc3RyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3N0ciA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgc3RvcmVkIGluIHRoZSBub2RlXG4gICAgICovXG4gICAgZ2V0IHZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaW5nTm9kZSA9IFN0cmluZ05vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdHJpbmdOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQ29sb3JOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBDb2xvck5vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYW4gUkdCIGNvbG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVkLCBncmVlbiwgYmx1ZSkge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JlZCA9IHJlZDtcbiAgICAgICAgdGhpcy5fZ3JlZW4gPSBncmVlbjtcbiAgICAgICAgdGhpcy5fYmx1ZSA9IGJsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgaW50byBhIHN0cmluZyBSR0IgdmFsdWVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZCArIFwiIFwiICsgdGhpcy5fZ3JlZW4gKyBcIiBcIiArIHRoaXMuX2JsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbG9yTm9kZXMgY2Fubm90IGN1cnJlbnRseSBiZSBkcmF3blxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBDb2xvck5vZGUgZXF1YWxzIGFub3RoZXIgQ29sb3JOb2RlXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhIEJvb2xlYW5Ob2RlKVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBDb2xvck5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5yZWQgPT09IHJpZ2h0LnJlZCAmJiB0aGlzLmdyZWVuID09PSByaWdodC5ncmVlbiAmJiB0aGlzLmJsdWUgPT09IHJpZ2h0LmJsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQ29sb3JOb2RlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZWQgdmFsdWVcbiAgICAgKi9cbiAgICBnZXQgcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByZWQgdmFsdWVcbiAgICAgKi9cbiAgICBzZXQgcmVkKHJlZCkge1xuICAgICAgICB0aGlzLl9yZWQgPSByZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGdyZWVuIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IGdyZWVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JlZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdyZWVuIHZhbHVlXG4gICAgICovXG4gICAgc2V0IGdyZWVuKGdyZWVuKSB7XG4gICAgICAgIHRoaXMuX2dyZWVuID0gZ3JlZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJsdWUgdmFsdWVcbiAgICAgKi9cbiAgICBnZXQgYmx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJsdWUgdmFsdWVcbiAgICAgKi9cbiAgICBzZXQgYmx1ZShibHVlKSB7XG4gICAgICAgIHRoaXMuX2JsdWUgPSBibHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5Db2xvck5vZGUgPSBDb2xvck5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvck5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IEN1cnZlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9DdXJ2ZUVmZmVjdFwiKTtcbmNsYXNzIEN1cnZlTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgQ3VydmVOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgY3VydmVcbiAgICAgKiBAcGFyYW0gZHggdGhlIHJ1biBvZiB0aGUgY3VydmVcbiAgICAgKiBAcGFyYW0gZHkgdGhlIHJpc2Ugb2YgdGhlIGN1cnZlXG4gICAgICogQHBhcmFtIGN1cnZhdHVyZSBob3cgbXVjaCB0aGUgY3VydmUsIHVtbSwgY3VydmVzXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZHgsIGR5LCBjdXJ2YXR1cmUsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZHggPSBkeDtcbiAgICAgICAgdGhpcy5fZHkgPSBkeTtcbiAgICAgICAgdGhpcy5fY3VydmF0dXJlID0gY3VydmF0dXJlO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIEN1cnZlTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGN1cnZlIHVzaW5nIEN1cnZlRWZmZWN0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXMgVGhlIGxpbmUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSBhc3QgVGhlIHByb2dyYW0gQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgZGltcy53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl9keC5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGRpbXMuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMuX2R5LmV2YWwoY29udGV4dCkudmFsLCBcIlwiKTtcbiAgICAgICAgZGltcy5jdXJ2YXR1cmUgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5fY3VydmF0dXJlLmV2YWwoY29udGV4dCkudmFsLCBcIlwiKTtcbiAgICAgICAgbGV0IGUgPSBuZXcgQ3VydmVFZmZlY3RfMS5DdXJ2ZUVmZmVjdCh0aGlzKTtcbiAgICAgICAgZS5kcmF3KGNvbnRleHQsIGRpbXMsIGFzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIEN1cnZlTm9kZSBlcXVhbHMgYW5vdGhlciAoaWYgdGhlaXIgZHgsIGR5LCBhbmQgY3VydmF0dXJlIGFyZSBlcXVhbClcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5IChtdXN0IGJlIGEgQ3VydmVOb2RlKVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBDdXJ2ZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5keC5lcXVhbHNWYWwocmlnaHQuZHgpICYmIHRoaXMuZHkuZXF1YWxzVmFsKHJpZ2h0LmR5KSAmJiB0aGlzLmN1cnZhdHVyZS5lcXVhbHNWYWwocmlnaHQuY3VydmF0dXJlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtb3ZlKCkgeyB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VydmVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJjdXJ2ZShcIiArIHRoaXMuX2R4LnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLl9keS50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5fY3VydmF0dXJlLnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcnVuIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIGdldCBkeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBydW4gb2YgdGhlIGN1cnZlXG4gICAgICovXG4gICAgc2V0IGR4KGR4KSB7XG4gICAgICAgIHRoaXMuX2R4ID0gZHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJpc2Ugb2YgdGhlIGN1cnZlXG4gICAgICovXG4gICAgZ2V0IGR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJpc2Ugb2YgdGhlIGN1cnZlXG4gICAgICovXG4gICAgc2V0IGR5KGR5KSB7XG4gICAgICAgIHRoaXMuX2R5ID0gZHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnZhdHVyZSBvZiB0aGUgY3VydmVcbiAgICAgKi9cbiAgICBnZXQgY3VydmF0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VydmF0dXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJ2YXR1cmUgb2YgdGhlIGN1cnZlXG4gICAgICovXG4gICAgc2V0IGN1cnZhdHVyZShjdXJ2YXR1cmUpIHtcbiAgICAgICAgdGhpcy5fY3VydmF0dXJlID0gY3VydmF0dXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5DdXJ2ZU5vZGUgPSBDdXJ2ZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DdXJ2ZU5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFbGxpcHNlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9FbGxpcHNlRWZmZWN0XCIpO1xuY2xhc3MgRWxsaXBzZU5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhbiBFbGxpcHNlTm9kZSwgYSBub2RlIHJlcHJlc2VudGluZyBhbiBlbGxpcHNlXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgZWxsaXBzZVxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgZWxsaXBzZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIEVsbGlwc2VOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgZWxsaXBzZSBvbiB0aGUgY2FudmFzIHVzaW5nIEVsbGlwc2VFZmZlY3RcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgZWxsaXBzZVxuICAgICAqIEBwYXJhbSBhc3QgVGhlIHByb2dyYW0gQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgZGltcy53aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICBkaW1zLmhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgbGV0IGUgPSBuZXcgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBFbGxpcHNlTm9kZSBlcXVhbHMgYW5vdGhlciBFbGxpcHNlTm9kZSAoaWYgdGhlaXIgd2lkdGhzIGFuZCBoZWlnaHRzIGFyZSBlcXVhbClcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5IChtdXN0IGJlIGFuIEVsbGlwc2VOb2RlKVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBFbGxpcHNlTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoLmVxdWFsc1ZhbChyaWdodC53aWR0aCkgJiYgdGhpcy5oZWlnaHQuZXF1YWxzVmFsKHJpZ2h0LmhlaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZWxsaXBzZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyBcImVsbGlwc2UoXCIgKyB0aGlzLl93aWR0aC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5faGVpZ2h0LnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9XG4gICAgbW92ZSgpIHsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVsbGlwc2Ugd2lkdGhcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZWxsaXBzZSB3aWR0aFxuICAgICAqL1xuICAgIHNldCB3aWR0aCh3aWR0aCkge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhlIGVsbGlwc2UgaGVpZ2h0XG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBlbGxpcHNlIGhlaWdodFxuICAgICAqL1xuICAgIHNldCBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuRWxsaXBzZU5vZGUgPSBFbGxpcHNlTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVsbGlwc2VOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBFbW9qaUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRW1vamlFZmZlY3RcIik7XG5jbGFzcyBFbW9qaU5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhbiBFbW9qaSBOb2RlXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIEVtb2ppTm9kZVxuICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIEVtb2ppTm9kZVxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgRW1vamlOb2RlXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgd2lkdGgsIGhlaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIEVtb2ppTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIHJlY3RhbmdsZSB1c2luZyBFbW9qaUVmZmVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSByZWN0YW5nbGUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSBhc3QgVGhlIHByb2dyYW0gQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgZGltcy53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl93aWR0aC5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGRpbXMuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMuX2hlaWdodC5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGxldCBlID0gbmV3IEVtb2ppRWZmZWN0XzEuRW1vamlFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBFbW9qaU5vZGUgZXF1YWxzIGFub3RoZXIgKGlmIHRoZWlyIHdpZHRocyBhbmQgaGVpZ2h0cyBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhbiBFbW9qaU5vZGUpXG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIEVtb2ppTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5hbWUuZXF1YWxzVmFsKHJpZ2h0Lm5hbWUpICYmIHRoaXMud2lkdGguZXF1YWxzVmFsKHJpZ2h0LndpZHRoKSAmJiB0aGlzLmhlaWdodC5lcXVhbHNWYWwocmlnaHQuaGVpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtb3ZlKCkgeyB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgRW1vamlOb2RlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwiZW1vamkoXCIgKyB0aGlzLl9uYW1lLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLl93aWR0aC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5faGVpZ2h0LnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgRW1vamlOb2RlXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBuYW1lIG9mIHRoZSBFbW9qaU5vZGVcbiAgICAgKi9cbiAgICBzZXQgbmFtZSh3aWR0aCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIEVtb2ppTm9kZVxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB3aWR0aCBvZiB0aGUgRW1vamlOb2RlXG4gICAgICovXG4gICAgc2V0IHdpZHRoKHdpZHRoKSB7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgRW1vamlOb2RlXG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBFbW9qaU5vZGVcbiAgICAgKi9cbiAgICBzZXQgaGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkVtb2ppTm9kZSA9IEVtb2ppTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtb2ppTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgRXBoRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9FcGhFZmZlY3RcIik7XG5jbGFzcyBFcGhOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYW4gRXBoTm9kZSwgYSBub2RlIHJlcHJlc2VudGluZyBzb21ldGhpbmcgdmVyeSBzcGVjaWFsXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgRXBoTm9kZVxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgRXBoTm9kZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgLy90aGlzLl9pbWFnZSA9IGltYWdlO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgRXBoTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIHJlY3RhbmdsZSB1c2luZyBFcGhFZmZlY3RcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgcmVjdGFuZ2xlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGRpbXMud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5fd2lkdGguZXZhbChjb250ZXh0KS52YWwsIFwiXCIpO1xuICAgICAgICBkaW1zLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl9oZWlnaHQuZXZhbChjb250ZXh0KS52YWwsIFwiXCIpO1xuICAgICAgICBsZXQgZSA9IG5ldyBFcGhFZmZlY3RfMS5FcGhFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBFcGhOb2RlIGVxdWFscyBhbm90aGVyIChpZiB0aGVpciB3aWR0aHMgYW5kIGhlaWdodHMgYXJlIGVxdWFsKVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHkgKG11c3QgYmUgYW4gRXBoTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgRXBoTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoLmVxdWFsc1ZhbChyaWdodC53aWR0aCkgJiYgdGhpcy5oZWlnaHQuZXF1YWxzVmFsKHJpZ2h0LmhlaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW92ZSgpIHsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEVwaE5vZGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJlcGgoXCIgKyB0aGlzLl93aWR0aC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5faGVpZ2h0LnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIEVwaE5vZGVcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd2lkdGggb2YgdGhlIEVwaE5vZGVcbiAgICAgKi9cbiAgICBzZXQgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBFcGhOb2RlXG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBFcGhOb2RlXG4gICAgICovXG4gICAgc2V0IGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5FcGhOb2RlID0gRXBoTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVwaE5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IExpbmVFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0xpbmVFZmZlY3RcIik7XG5jbGFzcyBMaW5lTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgTGluZU5vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYSBsaW5lXG4gICAgICogQHBhcmFtIGR4IHRoZSBydW4gb2YgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0gZHkgdGhlIHJpc2Ugb2YgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkeCwgZHksIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZHggPSBkeDtcbiAgICAgICAgdGhpcy5fZHkgPSBkeTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMaW5lTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGxpbmUgdXNpbmcgTGluZUVmZmVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBsaW5lIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGRpbXMud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5fZHguZXZhbChjb250ZXh0KS52YWwsIFwiXCIpO1xuICAgICAgICBkaW1zLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl9keS5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGxldCBlID0gbmV3IExpbmVFZmZlY3RfMS5MaW5lRWZmZWN0KHRoaXMpO1xuICAgICAgICBlLmRyYXcoY29udGV4dCwgZGltcywgYXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgTGluZU5vZGUgZXF1YWxzIGFub3RoZXIgKGlmIHRoZWlyIGR4IGFuZCBkeSBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhIExpbmVOb2RlKVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBMaW5lTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmR4LmVxdWFsc1ZhbChyaWdodC5keCkgJiYgdGhpcy5keS5lcXVhbHNWYWwocmlnaHQuZHkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vdmUoKSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsaW5lXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwibGluZShcIiArIHRoaXMuX2R4LnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLl9keS50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJ1biBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIGdldCBkeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBydW4gb2YgdGhlIGxpbmVcbiAgICAgKi9cbiAgICBzZXQgZHgoZHgpIHtcbiAgICAgICAgdGhpcy5fZHggPSBkeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmlzZSBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIGdldCBkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByaXNlIG9mIHRoZSBsaW5lXG4gICAgICovXG4gICAgc2V0IGR5KGR5KSB7XG4gICAgICAgIHRoaXMuX2R5ID0gZHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkxpbmVOb2RlID0gTGluZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgUmVjdGFuZ2xlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9SZWN0YW5nbGVFZmZlY3RcIik7XG5jbGFzcyBSZWN0YW5nbGVOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBSZWN0YW5nbGVOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBSZWN0YW5nbGVOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgcmVjdGFuZ2xlIHVzaW5nIFJlY3RhbmdsZUVmZmVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSByZWN0YW5nbGUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSBhc3QgVGhlIHByb2dyYW0gQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgZGltcy53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl93aWR0aC5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGRpbXMuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMuX2hlaWdodC5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGxldCBlID0gbmV3IFJlY3RhbmdsZUVmZmVjdF8xLlJlY3RhbmdsZUVmZmVjdCh0aGlzKTtcbiAgICAgICAgZS5kcmF3KGNvbnRleHQsIGRpbXMsIGFzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIFJlY3RhbmdsZU5vZGUgZXF1YWxzIGFub3RoZXIgKGlmIHRoZWlyIHdpZHRocyBhbmQgaGVpZ2h0cyBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhIFJlY3RhbmdsZU5vZGUpXG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIFJlY3RhbmdsZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy53aWR0aC5lcXVhbHNWYWwocmlnaHQud2lkdGgpICYmIHRoaXMuaGVpZ2h0LmVxdWFsc1ZhbChyaWdodC5oZWlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vdmUoKSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJyZWN0KFwiICsgdGhpcy5fd2lkdGgudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuX2hlaWdodC50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIHNldCB3aWR0aCh3aWR0aCkge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICovXG4gICAgc2V0IGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5SZWN0YW5nbGVOb2RlID0gUmVjdGFuZ2xlTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlY3RhbmdsZU5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIERpbWVuc2lvbnMge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBEaW1lbnNpb25zLCB3aGljaCBzdG9yZXMgb2JqZWN0IGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0geCBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0geSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0geiBUaGUgeiBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gc2NhbGUgVGhlIHNjYWxlIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gcmFkaXVzIFRoZSByYWRpdXMgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHosIHNjYWxlLCByYWRpdXMpIHtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICB0aGlzLl96ID0gejtcbiAgICAgICAgdGhpcy5fc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gcmFkaXVzIHx8IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgzMCwgXCJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRpbWVuc2lvbnNcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy55LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIHNldCB4KHZhbCkge1xuICAgICAgICB0aGlzLl94ID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgeSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgeSh2YWwpIHtcbiAgICAgICAgdGhpcy5feSA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeiBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgeigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3o7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHogY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgc2V0IHoodmFsKSB7XG4gICAgICAgIHRoaXMuX3ogPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJhZGl1cyBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IHJhZGl1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmFkaXVzIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgcmFkaXVzKHZhbCkge1xuICAgICAgICB0aGlzLl9yYWRpdXMgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNjYWxlIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgc2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2NhbGUgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIHNldCBzY2FsZSh2YWwpIHtcbiAgICAgICAgdGhpcy5fc2NhbGUgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd2lkdGggb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIHNldCB3aWR0aCh2YWwpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgaGVpZ2h0KHZhbCkge1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnZhdHVyZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGN1cnZhdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnZhdHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VydmF0dXJlIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgY3VydmF0dXJlKHZhbCkge1xuICAgICAgICB0aGlzLl9jdXJ2YXR1cmUgPSB2YWw7XG4gICAgfVxufVxuZXhwb3J0cy5EaW1lbnNpb25zID0gRGltZW5zaW9ucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpbWVuc2lvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBQcmludE5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIFByaW50Tm9kZSwgcmVwcmVzZW50aW5nIGFuIG9iamVjdCB0byBiZSBwcmludGVkXG4gICAgICogQHBhcmFtIHRvUHJpbnQgVGhlIG9iamVjdCB0byBiZSBwcmludGVkXG4gICAgICogQHBhcmFtIGNvb3Jkc0dpdmVuIFdoZXRoZXIgdGhlIHh5IGNvb3JkaW5hdGVzIHRvIHByaW50IHRoZSBvYmplY3QgaXMgZ2l2ZW5cbiAgICAgKiBAcGFyYW0gZGltZW5zaW9ucyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgb2JqZWN0IHRvIGJlIHByaW50ZWRcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b1ByaW50LCBjb29yZHNHaXZlbiwgZGltZW5zaW9ucywgd3MpIHtcbiAgICAgICAgdGhpcy5fc2NhbGUgPSAxO1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RvUHJpbnQgPSB0b1ByaW50O1xuICAgICAgICB0aGlzLl9jb29yZHNHaXZlbiA9IGNvb3Jkc0dpdmVuO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGltcyA9IGRpbWVuc2lvbnMgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0IHRvIGJlIHByaW50ZWRcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJwcmludChcIiArIHRoaXMudG9QcmludC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5kaW1zLnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBQcmludE5vZGVcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIFByaW50Tm9kZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpbnROb2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcoKSBvbiBwcmludE9wXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgdGhlIG9iamVjdCB0byBiZSBwcmludGVkIGFuZCBkcmF3cyBpdFxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCByZXMgPSB0aGlzLl90b1ByaW50LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLl9jb29yZHNHaXZlbikge1xuICAgICAgICAgICAgcmVzLmRyYXcoY29udGV4dCwgdGhpcy5fZGltcywgdGhpcyk7XG4gICAgICAgICAgICAvL2NoZWNrIGlmIHRoZSBlZmZlY3RzIGFycmF5IGFscmVhZHkgaGFzIHNvbWUgZWxlbWVudHNcbiAgICAgICAgfSAvKigpIGVsc2UgaWYgKGNvbnRleHQuZWZmZWN0cy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgfSovXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9iamVjdCB0byBiZSBwcmludGVkXG4gICAgICovXG4gICAgZ2V0IHRvUHJpbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b1ByaW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3QgdG8gYmUgcHJpbnRlZFxuICAgICAqL1xuICAgIGdldCBkaW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJpbnROb2RlID0gUHJpbnROb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJpbnROb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUmV0dXJuRXJyb3JfMSA9IHJlcXVpcmUoXCIuL1JldHVybkVycm9yXCIpO1xuY2xhc3MgUmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBSZXR1cm4gb2JqZWN0LCByZXByZXNlbnRpbmcgc29tZXRoaW5nIHRvIGJlIHJldHVybmVkIGluIGEgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gZXhwciBUaGUgZXhwcmVzc2lvbiB0byBiZSByZXR1cm5lZFxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGV4cHIsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZXhwciA9IGV4cHI7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgdGhlIGV4cHJlc3Npb24gdG8gYmUgcmV0dXJuZWQgYW5kIHJldHVybnMgdmlhIGEgUmV0dXJuRXJyb1xuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICAvLyBJZiByZXR1cm4gdmFsIGlzIGEgdmFyLCByZXR1cm5zIHRoYXQgdmFyJ3MgdmFsdWVcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuX2V4cHIuZXZhbChjb250ZXh0KTtcbiAgICAgICAgdGhyb3cgbmV3IFJldHVybkVycm9yXzEuUmV0dXJuRXJyb3IocmVzdWx0LCBjb250ZXh0LnJldElETG9va3VwKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBSZXR1cm4gbm9kZXNcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIFJldHVyblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgUmV0dXJuIG5vZGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJyZXR1cm4gXCIgKyB0aGlzLl9leHByLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIG5vZGVzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBSZXR1cm5cIik7XG4gICAgfVxufVxuZXhwb3J0cy5SZXR1cm4gPSBSZXR1cm47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXR1cm4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBSZXR1cm5FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgUmV0dXJuRXJyb3IsIGEgY3VzdG9tIGVycm9yIGNsYXNzIHRoYXQgd2UgYWJ1c2UgdG8gcmV0dXJuIHZhbHVlc1xuICAgICAqIEBwYXJhbSByZXRWYWwgVGhlIHZhbHVlIHRvIGJlIHJldHVybmVkXG4gICAgICogQHBhcmFtIElEIFRoZSBJRCBvZiB0aGUgdmFsdWUgdG8gYmUgcmV0dXJuZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXRWYWwsIElEKSB7XG4gICAgICAgIHN1cGVyKElEKTtcbiAgICAgICAgdGhpcy5yZXRWYWwgPSByZXRWYWw7XG4gICAgICAgIHRoaXMuSUQgPSBJRDtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFJldHVybkVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXR1cm5FcnJvciA9IFJldHVybkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmV0dXJuRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBzcGFjZV9saWZ0XzEgPSByZXF1aXJlKFwic3BhY2UtbGlmdFwiKTtcbmNsYXNzIFNjb3BlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgU2NvcGUsIGFuIG9iamVjdCBrZWVwaW5nIHRyYWNrIG9mIG9iamVjdHMgd2l0aGluIGEgcGFydGljdWxhciBjb250ZXh0XG4gICAgICogQHBhcmFtIHBhcmVudCBUaGUgcGFyZW50IFNjb3BlXG4gICAgICogQHBhcmFtIGVmZmVjdHMgRWZmZWN0cyB3aXRoaW4gdGhpcyBTY29wZVxuICAgICAqIEBwYXJhbSBteVN0YXRlIFRoZSBzY29wZSBzdGF0ZVxuICAgICAqIEBwYXJhbSBldmVudExvZyBUaGUgbG9nIG9mIGV2ZW50cyB0aGF0IG9jY3VycmVkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50LCBlZmZlY3RzLCBldmVudExvZykge1xuICAgICAgICB0aGlzLl9yZXRWYWxJRCA9IHNwYWNlX2xpZnRfMS5Ob25lO1xuICAgICAgICB0aGlzLl9jYW52YXMgPSBzcGFjZV9saWZ0XzEuTm9uZTtcbiAgICAgICAgdGhpcy5fZXZlbnRMb2cgPSBbXTsgLy8gVGhlIGV2ZW50IGxvZ1xuICAgICAgICB0aGlzLl9oYWRGdW5FdmFsID0gZmFsc2U7IC8vIFdhcyB0aGlzIGNyZWF0ZWQgaW4gYSBmdW5jdGlvbj9cbiAgICAgICAgLy9wdWJsaWMgZ2xvYmFsRnVuSUQgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB0aGlzLmdsb2JhbEZ1bklEID0gMTAwMDAwMDA7IC8vIFRoZSBnbG9iYWwgSUQgZm9yIGZ1bmN0aW9ucyBpbiB0aGlzIGNvbnRleHRcbiAgICAgICAgdGhpcy5fdmFyQmluZGluZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5fZWZmZWN0cyA9IGVmZmVjdHMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5fZXZlbnRMb2cgPSBldmVudExvZztcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAhPSBudWxsICYmIHRoaXMuX3BhcmVudC5faGFkRnVuRXZhbClcbiAgICAgICAgICAgIHRoaXMuX2hhZEZ1bkV2YWwgPSB0cnVlOyAvLyBjb3B5IGZ1bmN0aW9uIGV2YWwgZmxhZyBmcm9tIHBhcmVudFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgaW5mb3JtYXRpb24gZnJvbSB0aGlzIFNjb3BlIGludG8gYW5vdGhlciBTY29wZSBhbmQgcmV0dXJucyB0aGUgbmV3IFNjb3BlXG4gICAgICovXG4gICAgY29weSgpIHtcbiAgICAgICAgbGV0IHMgPSBuZXcgU2NvcGUodGhpcy5fcGFyZW50LCB0aGlzLl9lZmZlY3RzLCB0aGlzLl9ldmVudExvZyk7XG4gICAgICAgIHMudmFyQmluZGluZ3MgPSBuZXcgTWFwKHRoaXMuX3ZhckJpbmRpbmdzKTtcbiAgICAgICAgcy5jYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgICAgcy5ldmVudExvZyA9IHRoaXMuZXZlbnRMb2c7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNsYXJlcyBhIG5ldyB2YXJpYWJsZVxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0byBiZSBkZWNsYXJlZFxuICAgICAqL1xuICAgIGRlY2xhcmUobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5fdmFyQmluZGluZ3MuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY29wZSBhbHJlYWR5IGhhcyB2YXIgd2l0aCBuYW1lIFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmFyQmluZGluZ3Muc2V0KG5hbWUsIHNwYWNlX2xpZnRfMS5Ob25lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzaWducyBhIHZhbHVlIHRvIGEgdmFyaWFibGUgaW4gdGhpcyBDb250ZXh0XG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlXG4gICAgICovXG4gICAgYXNzaWduKG5hbWUsIHZhbCkge1xuICAgICAgICB0aGlzLl92YXJCaW5kaW5ncy5zZXQobmFtZSwgc3BhY2VfbGlmdF8xLlNvbWUodmFsKSk7IC8vU29tZSh2YWwpP1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyB1cCBhIHZhbHVlIHdpdGhpbiB0aGUgU2NvcGUgYW5kIGFsbCBpdHMgYW5jZXN0b3IgU2NvcGVzXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgdG8gc2VhcmNoIHdpdGhpblxuICAgICAqL1xuICAgIGxvb2t1cChuYW1lLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LnZhckJpbmRpbmdzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQudmFyQmluZGluZ3MuZ2V0KG5hbWUpLmlzRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjb250ZXh0LnZhckJpbmRpbmdzLmdldChuYW1lKS5nZXQoKSk7IC8vZXh0cmEgZ2V0IHRvIG1hbmFnZSBTb21lKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjb250ZXh0LnBhcmVudCA9PSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwKG5hbWUsIGNvbnRleHQucGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYXJpYWJsZSBjb3VsZCBub3QgYmUgZm91bmQuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyB1cCBhbmQgcmV0dXJucyB0aGUgcmV0dXJuIElEIHZhbHVlXG4gICAgICovXG4gICAgcmV0SURMb29rdXAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXRWYWxJRC5pc0RlZmluZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldFZhbElELmdldCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQucmV0SURMb29rdXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY2FsbGVyLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBNYXAgb2YgdmFyaWFibGUgYmluZGluZ3NcbiAgICAgKi9cbiAgICBnZXQgdmFyQmluZGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YXJCaW5kaW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgTWFwIG9mIHZhcmlhYmxlIGJpbmRpbmdzXG4gICAgICovXG4gICAgc2V0IHZhckJpbmRpbmdzKG0pIHtcbiAgICAgICAgdGhpcy5fdmFyQmluZGluZ3MgPSBtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgU2NvcGVcbiAgICAgKi9cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZXR1cm4gdmFsdWUgSURcbiAgICAgKi9cbiAgICBnZXQgcmV0VmFsSUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXRWYWxJRDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmV0dXJuIHZhbHVlIElEXG4gICAgICovXG4gICAgc2V0IHJldFZhbElEKHZhbCkge1xuICAgICAgICB0aGlzLl9yZXRWYWxJRCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSFRNTCBjYW52YXNcbiAgICAgKi9cbiAgICBnZXQgY2FudmFzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBIVE1MIGNhbnZhc1xuICAgICAqL1xuICAgIHNldCBjYW52YXModmFsKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZWZmZWN0cyBhcnJheVxuICAgICAqL1xuICAgIGdldCBlZmZlY3RzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWZmZWN0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZWZmZWN0cyBhcnJheVxuICAgICAqL1xuICAgIHNldCBlZmZlY3RzKGFycikge1xuICAgICAgICB0aGlzLl9lZmZlY3RzID0gYXJyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBldmVudCBsb2dcbiAgICAgKi9cbiAgICBnZXQgZXZlbnRMb2coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudExvZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZXZlbnQgbG9nXG4gICAgICovXG4gICAgc2V0IGV2ZW50TG9nKHVwZGF0ZSkge1xuICAgICAgICB0aGlzLl9ldmVudExvZyA9IHVwZGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgZWZmZWN0c1xuICAgICAqL1xuICAgIGdldCBtdWxTZWxBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX211bFNlbEFycmF5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhcnJheSBvZiBlZmZlY3RzXG4gICAgICovXG4gICAgc2V0IG11bFNlbEFycmF5KHVwZGF0ZSkge1xuICAgICAgICB0aGlzLl9tdWxTZWxBcnJheSA9IHVwZGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgU2NvcGUgd2FzIGNyZWF0ZWQgaW4gYSBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldCBoYWRGdW5FdmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFkRnVuRXZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoaXMgU2NvcGUgd2FzIGNyZWF0ZWQgaW4gYSBmdW5jdGlvblxuICAgICAqL1xuICAgIHNldCBoYWRGdW5FdmFsKHZhbCkge1xuICAgICAgICB0aGlzLl9oYWRGdW5FdmFsID0gdmFsO1xuICAgIH1cbn1cbmV4cG9ydHMuU2NvcGUgPSBTY29wZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjb3BlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU2NvcGVfMSA9IHJlcXVpcmUoXCIuL1Njb3BlXCIpO1xuY29uc3Qgc3BhY2VfbGlmdF8xID0gcmVxdWlyZShcInNwYWNlLWxpZnRcIik7XG5jbGFzcyBTZXF1ZW5jZU5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIFNlcXVlbmNlTm9kZSwgdGhlIGJ1aWxkaW5nIGJsb2NrIG9mIHRoZSBBU1RcbiAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbGVmdCBzaWRlIG9mIHRoZSBTZXF1ZW5jZVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgU2VxdWVuY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCkge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyB0aGUgY2hpbGRyZW4gaW4gcG9zdG9yZGVyIChsZWZ0LCByaWdodCwgcGFyZW50KVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgbGVmdFNjb3BlID0gbmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCwgY29udGV4dC5lZmZlY3RzLCBjb250ZXh0LmV2ZW50TG9nKTtcbiAgICAgICAgbGVmdFNjb3BlLmNhbnZhcyA9IHNwYWNlX2xpZnRfMS5Tb21lKGNvbnRleHQuY2FudmFzLmdldCgpKTtcbiAgICAgICAgLy90aHJvd2luZyBhd2F5IGFmdGVyIGV2YWxpbmdcbiAgICAgICAgdGhpcy5fbGVmdFZhbCA9IHRoaXMuX2xlZnQuZXZhbChsZWZ0U2NvcGUpO1xuICAgICAgICB0aGlzLl9yaWdodFZhbCA9IHRoaXMuX3JpZ2h0LmV2YWwobGVmdFNjb3BlKTsgLy8gbGVmdFNjb3BlIG1heSBiZSBtb2RpZmllZCBub3dcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VxdWVuY2VOb2RlcyBjYW5ub3QgYmUgZGlyZWN0bHkgZHJhd25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcoKSBvbiBTZXF1ZW5jZU5vZGVzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGRpcmVjdGx5IGNhbGxlZCBvbiBTZXF1ZW5jZU5vZGVzXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBTZXF1ZW5jZU5vZGVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEFTVFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fbGVmdC50b1N0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5fbGVmdC5uZXdMaW5lKCkgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiO1xcblwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yaWdodC5uZXdMaW5lKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLl9yaWdodC50b1N0cmluZygpICsgXCI7XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5fcmlnaHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZWZ0IGNoaWxkXG4gICAgICovXG4gICAgc2V0IGxlZnQobGVmdCkge1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGVmdCBjaGlsZFxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmlnaHQgY2hpbGRcbiAgICAgKi9cbiAgICBzZXQgcmlnaHQocmlnaHQpIHtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmlnaHQgY2hpbGRcbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGxlZnQgY2hpbGVcbiAgICAgKi9cbiAgICBnZXQgbGVmdFZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnRWYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSByaWdodCBjaGlsZVxuICAgICAqL1xuICAgIGdldCByaWdodFZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0VmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5TZXF1ZW5jZU5vZGUgPSBTZXF1ZW5jZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXF1ZW5jZU5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBpbmRleF8xID0gcmVxdWlyZShcIi4uLy4uL2luZGV4XCIpO1xuY29uc3QgaW5kZXhfMiA9IHJlcXVpcmUoXCIuLi8uLi9pbmRleFwiKTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xuY29uc3QgZGlmZl8xID0gcmVxdWlyZShcImRpZmZcIik7XG4oZnVuY3Rpb24gKCkge1xuICAgIGxldCBlZGl0b3IgPSAoKGUpID0+IHsgcmV0dXJuIGUuQ29kZU1pcnJvcjsgfSkoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dFwiKSk7XG4gICAgbGV0IGVkaXRvcldyYXBwZXIgPSBlZGl0b3IuZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImNhbnZhc1wiKTtcbiAgICBsZXQgcG9wVXAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBvcHVwXCIpO1xuICAgIGxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGxldCBsYXN0Q3Vyc29yUG9zID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgIGxldCBsYXN0UHJvZ3JhbSA9IFwiXCI7IC8vIFVzZWQgZm9yIGNvbXBhcmluZyBhbmQgaGlnaGxpZ2h0aW5nIGRpZmZzXG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBsZXQgYXN0O1xuICAgIGxldCBjb250ZXh0O1xuICAgIGxldCBtYXN0ZXJMb2cgPSBbXTtcbiAgICBsZXQgYWxyZWFkeUxvZ2dlZCA9IGZhbHNlO1xuICAgIGxldCBudW1Mb2dnZWQgPSAwO1xuICAgIGxldCBzZWxlY3RlZEVsZW1zID0gW107XG4gICAgbGV0IHNlbGVjdGVkID0gMDsgLy8gdGhlIG51bWJlciBvZiBzZWxlY3RlZCBlZmZlY3RzIGlmIG11bHRpcGx5IHNlbGVjdGluZ1xuICAgIGxldCBpc0NhbnZhc1NlbGVjdGVkID0gZmFsc2U7IC8vIENoZWNrIGlmIG1vdXNlIGlzIGNsaWNrZWQgb24gY2FudmFzXG4gICAgbGV0IGlzRG9pbmdETSA9IGZhbHNlOyAvLyBDaGVjayBpZiBkaXJlY3QgbWFuaXB1bGF0aW5nIGVmZmVjdHNcbiAgICBsZXQgY2hlY2twb2ludCA9IG51bGw7XG4gICAgbGV0IG1vZEdlbiA9IG5ldyBpbmRleF8yLk1vZHVsZUdlbmVyYXRvcigpO1xuICAgIGxldCBjaGVja3BvaW50SXNBY3RpdmUgPSBmYWxzZTtcbiAgICBsZXQgY2FudmFzSXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgIGxldCBnbG9iYWxJRCA9IDE7XG4gICAgbGV0IGhpZ2hsaWdodFRpbWVyID0gbnVsbDtcbiAgICBsZXQgcGFyc2VUaW1lciA9IG51bGw7XG4gICAgLyogTG9nZ2luZywgcGFyc2luZyAmIHJlbmRlcmluZyAqL1xuICAgIGZ1bmN0aW9uIHByaW50TG9nKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkxvZzogXCIpO1xuICAgICAgICBmb3IgKGxldCBlbGVtIG9mIG1hc3RlckxvZykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZWxlbS5hc3NlbWJsZUxvZygpKTtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMganVzdCBzYW1wbGUgdXNhZ2U7XG4gICAgICAgICAgICAvLyB5b3Ugc2hvdWxkIHJlcGxhY2UgcGFyYW1ldGVycyB3aXRoIHJlYWwgdmFsdWVzXG4gICAgICAgICAgICAvLyB0aGlzIG1pZ2h0IG5vdCBldmVuIGJlIHRoZSByaWdodCBwbGFjZSB0byBwdXQgdGhpc1xuICAgICAgICAgICAgaW5kZXhfMi5Mb2dFdmVudC5sb2dUb1JlbW90ZVNlcnZlcihlbGVtLmV2ZW50VHlwZSgpLCBcInNvbWVVVUlEXCIsIGVsZW0udG9KU09OKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlKCkge1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGxldCBpbnB1dFRleHQgPSBlZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgbGV0IGFzdE9wdCA9IGluZGV4XzEuUGFyc2VyLnBhcnNlKGlucHV0VGV4dCk7XG4gICAgICAgIGVmZmVjdHMubGVuZ3RoID0gMDsgLy8gc2xpZ2h0bHkgc2tldGNoIGNsZWFyaW5nIG1ldGhvZCB0byBtYWludGFpbiByZWZlcmVuY2UgdG8gb3JpZ2luYWwgYXJyYXlcbiAgICAgICAgaWYgKGFzdE9wdC5pc0RlZmluZWQoKSkge1xuICAgICAgICAgICAgYXN0ID0gYXN0T3B0LmdldCgpO1xuICAgICAgICAgICAgY29udGV4dCA9IG5ldyBpbmRleF8yLlNjb3BlKG51bGwsIGVmZmVjdHMsIG1hc3RlckxvZyk7XG4gICAgICAgICAgICBjb250ZXh0LmNhbnZhcyA9IHNwYWNlX2xpZnRfMS5Tb21lKGNhbnZhcyk7XG4gICAgICAgICAgICBhc3QuZXZhbChjb250ZXh0KTsgLy90aGlzIGlzIHdoZXJlIHdlIGRyYXcgdGhlIG9iamVjdHMgdG8gdGhlIHNjcmVlblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHByaW50TG9nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhbmltYXRpb24gZnVuY3Rpb24gdGhhdCBiYXNpY2FsbHkgcmVjdXJzaXZlbHkgY2FsbHMgaXRzZWxmLCBjbGVhcmluZyBhbmRcbiAgICAgKiByZWRyYXdpbmcgdG8gdGhlIGNhbnZhcyBhdCA2MGZwcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsgLy9jbGVhcnMgY2FudmFzXG4gICAgICAgIHNlbGVjdGVkID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlZmZlY3RzW2ldLnVwZGF0ZSgpO1xuICAgICAgICAgICAgaWYgKGVmZmVjdHNbaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEVsZW1zLnB1c2goZWZmZWN0c1tpXSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlZmZlY3RzW2ldLmdldEp1c3REcmFnZ2VkKCkpIHsgLy8gTG9ncyBkcmFnIGV2ZW50XG4gICAgICAgICAgICAgICAgY29udGV4dC5ldmVudExvZy5wdXNoKG5ldyBpbmRleF8yLkRyYWdFdmVudChlZmZlY3RzW2ldKSk7XG4gICAgICAgICAgICAgICAgbWFzdGVyTG9nLnB1c2goY29udGV4dC5ldmVudExvZ1tjb250ZXh0LmV2ZW50TG9nLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICBlZmZlY3RzW2ldLnNldEp1c3REcmFnZ2VkKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlZmZlY3RzW2ldLmlkT2JqID09IHVuZGVmaW5lZCkgeyAvLyBHaXZlcyBvYmplY3QgYW4gSUQgaWYgaXQgZG9lc24ndCBoYXZlIG9uZVxuICAgICAgICAgICAgICAgIGVmZmVjdHNbaV0uaW5pdElEKGdsb2JhbElEKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmV2ZW50TG9nLnB1c2gobmV3IGluZGV4XzIuSURFdmVudChlZmZlY3RzW2ldKSk7IC8vIExvZ3MgSURcbiAgICAgICAgICAgICAgICBnbG9iYWxJRCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIGhhdmUgaXRlcmF0ZWQgdGhyb3VnaCBhbGwgZWZmZWN0cyBhbmQgaGF2ZSBjb21wbGV0ZSBsaXN0IHRvIGxvZ1xuICAgICAgICBpZiAoc2VsZWN0ZWQgIT0gbnVtTG9nZ2VkKSB7IC8vIGlmIHNlbGVjdGlvbnMgaGF2ZSBjaGFuZ2VkLCBzaG91bGQgbG9nIGFnYWluXG4gICAgICAgICAgICBhbHJlYWR5TG9nZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbHJlYWR5TG9nZ2VkICYmIHNlbGVjdGVkID49IDIpIHsgLy8gbG9ncyBpZiBoYXNuJ3QgYWxyZWFkeVxuICAgICAgICAgICAgbnVtTG9nZ2VkID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICBjb250ZXh0LmV2ZW50TG9nLnB1c2gobmV3IGluZGV4XzIuU2VsZWN0RXZlbnQoc2VsZWN0ZWRFbGVtcykpO1xuICAgICAgICAgICAgbWFzdGVyTG9nLnB1c2goY29udGV4dC5ldmVudExvZ1tjb250ZXh0LmV2ZW50TG9nLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIGFscmVhZHlMb2dnZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGVkRWxlbXMgPSBbXTtcbiAgICAgICAgdXBkYXRlUHJvZ3JhbVRleHQoKTsgLy8gUHJvRGlyZWN0IE1hbmlwdWxhdGlvblxuICAgICAgICAvLyBEcmF3IGNoZWNrIHBvaW50c1xuICAgICAgICBpZiAoY2hlY2twb2ludElzQWN0aXZlKSB7XG4gICAgICAgICAgICBjaGVja3BvaW50Q2hlY2tzR29hbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja3BvaW50ICE9IG51bGwgJiYgY2hlY2twb2ludC5kcmF3R3VpZGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNoZWNrcG9pbnQuZHJhd0d1aWRlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgcHJvZ3JhbSB0ZXh0IGFuZCBoaWdobGlnaHQgYWxsIHRoZSBjaGFuZ2VzXG4gICAgKiovXG4gICAgZnVuY3Rpb24gdXBkYXRlUHJvZ3JhbVRleHQoKSB7XG4gICAgICAgIGlmICghYXN0IHx8ICFpc0RvaW5nRE0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3UHJvZ3JhbSA9IGFzdC50b1N0cmluZygpO1xuICAgICAgICBpZiAobGFzdFByb2dyYW0gIT0gbmV3UHJvZ3JhbSkge1xuICAgICAgICAgICAgZWRpdG9yLnNldFZhbHVlKG5ld1Byb2dyYW0pO1xuICAgICAgICAgICAgaGlnaGxpZ2h0RGlmZihuZXdQcm9ncmFtKTtcbiAgICAgICAgICAgIGxhc3RQcm9ncmFtID0gbmV3UHJvZ3JhbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNDYW52YXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgaXNEb2luZ0RNID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlnaGxpZ2h0IGRpZmZzIGluIGVkaXRvclxuICAgICAqIEBwYXJhbSBuZXdQcm9ncmFtIE5ldyBwcm9ncmFtIHRleHQgdG8gaGlnaGxpZ2h0XG4gICAgICogQHBhcmFtIHVwZGF0ZSBXaGV0aGVyIG9yIG5vdCB0byB1cGRhdGUgbGFzdCBwcm9ncmFtIHdpdGggbmV3IHByb2dyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoaWdobGlnaHREaWZmKG5ld1Byb2dyYW0sIHVwZGF0ZSkge1xuICAgICAgICBsZXQgY3VyTGluZSA9IDA7XG4gICAgICAgIGxldCBjdXJDaGFyID0gMDtcbiAgICAgICAgZGlmZl8xLmRpZmZDaGFycyhsYXN0UHJvZ3JhbSwgbmV3UHJvZ3JhbSkuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSByZXN1bHQudmFsdWUuc3BsaXQoL1xccj9cXG4vZyk7XG4gICAgICAgICAgICBsZXQgZW5kTGluZSA9IHJlc3VsdC5yZW1vdmVkID8gY3VyTGluZSA6IGN1ckxpbmUgKyBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGV0IGVuZENoYXIgPSByZXN1bHQucmVtb3ZlZCA/IGN1ckNoYXIgOlxuICAgICAgICAgICAgICAgICgoZW5kTGluZSA9PSBjdXJMaW5lID8gY3VyQ2hhciA6IDApICsgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuYWRkZWQgfHwgcmVzdWx0LnJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRlbmRzIHRoZSBoaWdobGlnaHRlZCBzZWN0aW9uIGFsbCB0aGUgd2F5IHRvIHRoZSBsZWZ0XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SGlnaGxpZ2h0Q2hhciA9IGN1ckNoYXI7XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0TGluZSA9IGVkaXRvci5nZXRMaW5lKGN1ckxpbmUpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFydEhpZ2hsaWdodENoYXIgPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBhbHBoYW51bWVyaWNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEvXlthLXowLTldKyQvaS50ZXN0KGZpcnN0TGluZVtzdGFydEhpZ2hsaWdodENoYXIgLSAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SGlnaGxpZ2h0Q2hhci0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFeHRlbmRzIHRvIHRoZSByaWdodFxuICAgICAgICAgICAgICAgIGxldCBlbmRIaWdodExpZ2h0Q2hhciA9IGVuZENoYXI7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RMaW5lID0gZWRpdG9yLmdldExpbmUoZW5kTGluZSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVuZEhpZ2h0TGlnaHRDaGFyIDwgbGFzdExpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghL15bYS16MC05XSskL2kudGVzdChsYXN0TGluZVtlbmRIaWdodExpZ2h0Q2hhcl0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbmRIaWdodExpZ2h0Q2hhcisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlZGl0b3IubWFya1RleHQoLy8gSGlnaGxpZ2h0IHRleHRcbiAgICAgICAgICAgICAgICB7IGxpbmU6IGN1ckxpbmUsIGNoOiBzdGFydEhpZ2hsaWdodENoYXIgfSwgLy8gU3RhcnRpbmcgcG9pbnRcbiAgICAgICAgICAgICAgICB7IGxpbmU6IGVuZExpbmUsIGNoOiBlbmRIaWdodExpZ2h0Q2hhciB9LCAvLyBJbmNsdXNpdmUgbGluZSwgZXhjbHVzaXZlIGNoYXJcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogXCJoaWdobGlnaHRlZC10ZXh0XCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJMaW5lID0gZW5kTGluZTtcbiAgICAgICAgICAgIGN1ckNoYXIgPSBlbmRDaGFyO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IHRoZSBjbGVhciBoaWdobGlnaHQgdGltZXJcbiAgICAgICAgaWYgKGhpZ2hsaWdodFRpbWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChoaWdobGlnaHRUaW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgaGlnaGxpZ2h0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVkaXRvci5nZXRBbGxNYXJrcygpLmZvckVhY2goKG1hcmspID0+IHtcbiAgICAgICAgICAgICAgICBtYXJrLmNsZWFyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHVzZXIgc3RvcHBlZCBkb2luZyBETTsgbG9nIG5vd1xuICAgICAgICAgICAgcHJpbnRMb2coKTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgLy8gVXBkYXRlIGxhc3QgcHJvZ3JhbSBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgbGFzdFByb2dyYW0gPSBuZXdQcm9ncmFtO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIEV2ZW50IGxpc3RlbmVycyAqL1xuICAgIGVkaXRvci5vbihcImtleXVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZWRpdG9yIGhhcyBiZWVuIG1vZGlmaWVkLCBvbmx5IHBhcnNlcyBpZiBtb2RpZmllZFxuICAgICAgICBpZiAoZWRpdG9yLmlzQ2xlYW4oKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWRpdG9yLm1hcmtDbGVhbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZVRpbWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChwYXJzZVRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZVRpbWVyID0gc2V0VGltZW91dChwYXJzZSwgMjAwKTtcbiAgICB9KTtcbiAgICBlZGl0b3Iub24oXCJibHVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGFzdEN1cnNvclBvcyA9IGVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICB9KTtcbiAgICAvLyBXaW5kb3cgZXZlbnRcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgICAgICBsZXQgbW91c2VZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgY2FudmFzIGlzIHNlbGVjdGVkXG4gICAgICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoY2FudmFzSXNEaXNhYmxlZCAmJiBtb3VzZVggPiByZWN0LmxlZnQgJiYgbW91c2VYIDwgcmVjdC5yaWdodCAmJlxuICAgICAgICAgICAgbW91c2VZID4gcmVjdC50b3AgJiYgbW91c2VZIDwgcmVjdC5ib3R0b20pIHtcbiAgICAgICAgICAgIHBvcFVwLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9wVXAuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFlZGl0b3IuaGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgaXNEb2luZ0RNID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlzRG9pbmdETSA9IGZhbHNlO1xuICAgIH0pO1xuICAgIC8vIENhbnZhcyBtb3VzZSBldmVudHNcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlzQ2FudmFzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpc0RvaW5nRE0gPSB0cnVlO1xuICAgIH0pO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlzQ2FudmFzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICAvKiBQYWxldHRlICovXG4gICAgbGV0IHBhbGV0dGVCdXR0b25zID0gW1xuICAgICAgICBcImVsbGlwc2VcIiwgXCJyZWN0XCIsIFwic3RyaW5nXCIsIFwibnVtYmVyXCIsXG4gICAgICAgIFwibGluZVwiLCBcImN1cnZlXCIsXG4gICAgICAgIFwiaGFwcHlcIiwgXCJzYWRcIiwgXCJhbmdyeVwiLCBcImNvb2xcIlxuICAgIF07XG4gICAgZm9yIChsZXQgYnV0dG9uTmFtZSBvZiBwYWxldHRlQnV0dG9ucykge1xuICAgICAgICBsZXQgcGFsZXR0ZUJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGJ1dHRvbk5hbWUpO1xuICAgICAgICBwYWxldHRlQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiBpbnNlcnROb2RlKGJ1dHRvbk5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgbmV3IG5vZGUgYXQgdGhlIGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uIGFuZCB1cGRhdGUgdGhlIGN1cnNvclxuICAgICAqKi9cbiAgICBmdW5jdGlvbiBpbnNlcnROb2RlKGJ1dHRvbk5hbWUpIHtcbiAgICAgICAgbGV0IG5ld05vZGUgPSBcIlwiO1xuICAgICAgICBzd2l0Y2ggKGJ1dHRvbk5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJlbGxpcHNlXCI6XG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IFwicHJpbnQoZWxsaXBzZSgxMDAsIDEwMCkpO1xcblwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJlY3RcIjpcbiAgICAgICAgICAgICAgICBuZXdOb2RlID0gXCJwcmludChyZWN0KDEwMCwgMTAwKSk7XFxuXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9ICdwcmludChcIm5ld1dvcmRcIik7XFxuJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBuZXdOb2RlID0gXCJwcmludCgxMCk7XFxuXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICAgICAgICAgIG5ld05vZGUgPSBcInByaW50KGxpbmUoMTAwLCAxMDApKTtcXG5cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjdXJ2ZVwiOlxuICAgICAgICAgICAgICAgIG5ld05vZGUgPSBcInByaW50KGN1cnZlKDEwMCwgMTAwLCAxMDApKTtcXG5cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJoYXBweVwiOlxuICAgICAgICAgICAgY2FzZSBcInNhZFwiOlxuICAgICAgICAgICAgY2FzZSBcImFuZ3J5XCI6XG4gICAgICAgICAgICBjYXNlIFwiY29vbFwiOlxuICAgICAgICAgICAgICAgIG5ld05vZGUgPSAncHJpbnQoZW1vamkoXCInICsgYnV0dG9uTmFtZSArICdcIiwgMTAwLCAxMDApKTtcXG4nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlByb2JsZW0gd2l0aCBcIiArIGJ1dHRvbk5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnNlcnQgYXQgY3Vyc29yIHBvc2l0aW9uICYgaGlnaGxpZ2h0IGNoYW5nZXNcbiAgICAgICAgZWRpdG9yLnJlcGxhY2VSYW5nZShuZXdOb2RlLCBsYXN0Q3Vyc29yUG9zKTtcbiAgICAgICAgaGlnaGxpZ2h0RGlmZihlZGl0b3IuZ2V0VmFsdWUoKSwgdHJ1ZSk7XG4gICAgICAgIC8vIFVwZGF0ZSBjdXJzb3IgJiByZWZvY3VzIGVkaXRvclxuICAgICAgICBsYXN0Q3Vyc29yUG9zLmxpbmUrKztcbiAgICAgICAgbGFzdEN1cnNvclBvcy5jaCA9IDA7XG4gICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgICBlZGl0b3Iuc2V0Q3Vyc29yKGxhc3RDdXJzb3JQb3MpO1xuICAgICAgICAvLyBQYXJzZVxuICAgICAgICBwYXJzZSgpO1xuICAgIH1cbiAgICAvL3Jlc2V0IGNoZWNrcG9pbnRcbiAgICAvLyBsZXQgcmVzZXRCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzZXQnKTtcbiAgICAvLyByZXNldEJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gICAgIGlmIChjaGVja3BvaW50Ll9zdGFydGVyQ29kZSAhPSBudWxsKSB7XG4gICAgLy8gICAgICAgICBlZGl0b3Iuc2V0VmFsdWUoY2hlY2twb2ludC5fc3RhcnRlckNvZGUpO1xuICAgIC8vICAgICAgICAgcGFyc2UoKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBjb250ZXh0LmV2ZW50TG9nLnB1c2gobmV3IENsZWFyRXZlbnQoKSk7XG4gICAgLy8gICAgIG1hc3RlckxvZy5wdXNoKGNvbnRleHQuZXZlbnRMb2dbY29udGV4dC5ldmVudExvZy5sZW5ndGggLSAxXSk7IC8vIERvZXMgdGhpcyBhY3R1YWxseSB3b3JrP1xuICAgIC8vICAgICBwcmludExvZygpO1xuICAgIC8vIH07XG4gICAgLyogTW9kdWxlcyAqL1xuICAgIC8qIC0tLSBmb3Igbm9uLURNIG1vZHVsZXMsIHdpbGwgYmUgZnVsbHkgaW1wbGVtZW50ZWQgaW4gYSBkYXkgb3IgMiAtIFF1YW4sIDEvMi8yMDE4IC0tLSAqL1xuICAgIC8qXG4gICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICA8YnV0dG9uIGlkPVwibDJjMVwiIGNsYXNzPVwiY2hlY2twb2ludCBidG4gYnRuLWJsb2NrXCI+Q2hlY2twb2ludCAxPC9idXR0b24+XG4gICAgPC9kaXY+XG4gICAgKi9cbiAgICAvL3NldCB1cCBDaGVja3BvaW50cyBzaWRlYmFyXG4gICAgbGV0IGxlc3NvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvbmUnKTtcbiAgICBpZiAobGVzc29uICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gJ3Jvdyc7XG4gICAgICAgIHZhciBidG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYnRuLmlkID0gXCJsMWMxXCI7XG4gICAgICAgIGJ0bi5jbGFzc05hbWUgPSBcImNoZWNrcG9pbnQgYnRuIGJ0bi1ibG9ja1wiO1xuICAgICAgICBidG4uaW5uZXJIVE1MID0gXCJDaGVja3BvaW50IDFcIjtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKGJ0bik7XG4gICAgICAgIGxlc3Nvbi5hcHBlbmRDaGlsZChkaXYpO1xuICAgIH1cbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgbGV0IGluc3RydWN0aW9ucyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnb2FsJyk7XG4gICAgbGV0IHJld2FyZEJveCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXdhcmQtY29udGFpbmVyJyk7XG4gICAgbGV0IGluc3RyTGFiZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5zdHItbGFiZWwnKTtcbiAgICAvL01hcCBtYWludGFpbmluZyBjb2RlIGxhc3QgdXNlZCBhdCBhIGNoZWNrcG9pbnRcbiAgICBsZXQgY3BDb2RlID0gbmV3IE1hcChbXG4gICAgICAgIFsnbDFjMScsIFwiXCJdLFxuICAgICAgICBbJ2wxYzInLCBcIlwiXSxcbiAgICAgICAgWydsMWMzJywgXCJcIl0sXG4gICAgICAgIFsnbDFjNCcsIFwiXCJdLFxuICAgICAgICBbJ2wyYzEnLCBcIlwiXSxcbiAgICAgICAgWydsMmMyJywgXCJcIl0sXG4gICAgICAgIFsnbDJjMycsIFwiXCJdLFxuICAgICAgICBbJ2wyYzQnLCBcIlwiXSxcbiAgICAgICAgWydsMmM1JywgXCJcIl0sXG4gICAgICAgIFsnbDJjNicsIFwiXCJdLFxuICAgICAgICBbJ2wyYzcnLCBcIlwiXSxcbiAgICAgICAgWydsM2MxJywgXCJcIl0sXG4gICAgICAgIFsnbDNjMicsIFwiXCJdLFxuICAgICAgICBbJ2wzYzMnLCBcIlwiXSxcbiAgICAgICAgWydsM2M0JywgXCJcIl0sXG4gICAgICAgIFsnbDNjNScsIFwiXCJdLFxuICAgICAgICBbJ2wzYzYnLCBcIlwiXSxcbiAgICAgICAgWydsNGMxJywgXCJcIl0sXG4gICAgICAgIFsnbDRjMicsIFwiXCJdXG4gICAgXSk7XG4gICAgLy9NYXAgbWFpbnRhaW5pbmcgd2hldGhlciBhIGNoZWNrcG9pbnQgaGFzIGJlZW4gY29tcGxldGVkXG4gICAgbGV0IGNwQ29tcGxldGlvbiA9IG5ldyBNYXAoW1xuICAgICAgICBbJ2wxYzEnLCBmYWxzZV0sXG4gICAgICAgIFsnbDFjMicsIGZhbHNlXSxcbiAgICAgICAgWydsMWMzJywgZmFsc2VdLFxuICAgICAgICBbJ2wxYzQnLCBmYWxzZV0sXG4gICAgICAgIFsnbDJjMScsIGZhbHNlXSxcbiAgICAgICAgWydsMmMyJywgZmFsc2VdLFxuICAgICAgICBbJ2wyYzMnLCBmYWxzZV0sXG4gICAgICAgIFsnbDJjNCcsIGZhbHNlXSxcbiAgICAgICAgWydsMmM1JywgZmFsc2VdLFxuICAgICAgICBbJ2wyYzYnLCBmYWxzZV0sXG4gICAgICAgIFsnbDJjNycsIGZhbHNlXSxcbiAgICAgICAgWydsM2MxJywgZmFsc2VdLFxuICAgICAgICBbJ2wzYzInLCBmYWxzZV0sXG4gICAgICAgIFsnbDNjMycsIGZhbHNlXSxcbiAgICAgICAgWydsM2M0JywgZmFsc2VdLFxuICAgICAgICBbJ2wzYzUnLCBmYWxzZV0sXG4gICAgICAgIFsnbDNjNicsIGZhbHNlXSxcbiAgICAgICAgWydsNGMxJywgZmFsc2VdLFxuICAgICAgICBbJ2w0YzInLCBmYWxzZV1cbiAgICBdKTtcbiAgICAvKiBrZWVwaW5nIHRyYWNrIG9mIGFuZCBkaXNwbGF5aW5nIHVzZXIncyBwcm9ncmVzcyAqL1xuICAgIGxldCBzdGFyQ291bnQgPSAwO1xuICAgIGxldCBzdGFyQm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhY2hpZXZlbWVudFwiKTtcbiAgICB1cGRhdGVTdGFyQm94KCk7XG4gICAgbGV0IGNwTmFtZXMgPSBbXG4gICAgICAgICdsMWMxJywgJ2wxYzInLCAnbDFjMycsICdsMWM0JyxcbiAgICAgICAgJ2wyYzEnLCAnbDJjMicsICdsMmMzJywgJ2wyYzQnLCAnbDJjNScsICdsMmM2JywgJ2wyYzcnLFxuICAgICAgICAnbDNjMScsICdsM2MyJywgJ2wzYzMnLCAnbDNjNCcsICdsM2M1JywgJ2wzYzYnXG4gICAgXTtcbiAgICAvL3RoaXMgaXMgZm9yIHRlc3RpbmcgdHV0b3JpYWxzXG4gICAgbGV0IHdvcmtpbmdDcCA9IFtcbiAgICAgICAgJ2wxYzEnLCAnbDFjMicsICdsMWMzJywgJ2wxYzQnLCAnbDJjMSdcbiAgICBdO1xuICAgIGZvciAobGV0IGNwIG9mIGNwTmFtZXMpIHtcbiAgICAgICAgbGV0IGNwQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY3ApO1xuICAgICAgICBjcEJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGFzdFByb2dyYW0gPSBcIlwiO1xuICAgICAgICAgICAgaW5pdENoZWNrcG9pbnQoY3ApO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbW9kdWxlIGNvcnJlc3BvbmRpbmcgdG8gYSBjaGVja3BvaW50IHBhc3NlZCBpbi5cbiAgICAgKiBTZXRzIHVwIHRoZSBpbnN0cnVjdGlvbiwgQ09ERSBhcmVhLCBhbmQgZ29hbCBib3ggYWNjb3JkaW5nbHkuXG4gICAgICogQHBhcmFtIGNwIHRoZSBuYW1lIG9mIHRoZSBjaGVja3BvaW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENoZWNrcG9pbnQoY3ApIHtcbiAgICAgICAgLy9zdG9yZSBjb2RlIHdyaXR0ZW4gb2Ygb2xkIGNoZWNrcG9pbnRcbiAgICAgICAgaWYgKGNoZWNrcG9pbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3BDb2RlLnNldChjaGVja3BvaW50Ll9uYW1lLCBlZGl0b3IuZ2V0VmFsdWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCJJbml0aWF0aW5nIGNoZWNrcG9pbnQgXCIgKyBjcCk7XG4gICAgICAgIGNoZWNrcG9pbnQgPSBtb2RHZW4uY3JlYXRlTW9kdWxlKGNwLCBjdHgsIGVkaXRvcik7XG4gICAgICAgIGluc3RyTGFiZWwuaW5uZXJIVE1MID0gY3AgKyBcIiAtIEdPQUxcIjtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zLmlubmVySFRNTCA9IGNoZWNrcG9pbnQuX2luc3RydWN0aW9ucztcbiAgICAgICAgLy9mcmVlemUvdW5mcmVlemUgdGhlIENPREUgYW5kIENBTlZBUyBhcmVhc1xuICAgICAgICBpZiAoY2hlY2twb2ludC5fY29uc3RyYWludCA9PSAnY29kZScpIHtcbiAgICAgICAgICAgIGVkaXRvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCB0cnVlKTtcbiAgICAgICAgICAgIGVkaXRvcldyYXBwZXIuc3R5bGUub3BhY2l0eSA9ICcwLjUnO1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kID0gJ3doaXRlJztcbiAgICAgICAgICAgIGNhbnZhc0lzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGVja3BvaW50Ll9jb25zdHJhaW50ID09ICdjYW52YXMnKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UpO1xuICAgICAgICAgICAgZWRpdG9yV3JhcHBlci5zdHlsZS5vcGFjaXR5ID0gJzEuMCc7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSAnI0MwQzBDMCc7XG4gICAgICAgICAgICBjYW52YXNJc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVkaXRvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSk7XG4gICAgICAgICAgICBlZGl0b3JXcmFwcGVyLnN0eWxlLm9wYWNpdHkgPSAnMS4wJztcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9ICd3aGl0ZSc7XG4gICAgICAgICAgICBjYW52YXNJc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZXN0b3JlIHByZXZpb3VzIGNvZGUgd3JpdHRlbiBpbiB0aGlzIGNoZWNrcG9pbnRcbiAgICAgICAgaWYgKGNwQ29kZS5nZXQoY2hlY2twb2ludC5fbmFtZSkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGVkaXRvci5zZXRWYWx1ZShjcENvZGUuZ2V0KGNoZWNrcG9pbnQuX25hbWUpKTtcbiAgICAgICAgICAgIHBhcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZXN0b3JlIGxhdGVzdCBpbnN0cnVjdGlvbiBhdCB0aGlzIGNoZWNrcG9pbnRcbiAgICAgICAgcG9wVXAuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgbGV0IGN1ckluc3RydWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnN0cnVjdGlvblwiKTtcbiAgICAgICAgaWYgKGN1ckluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN1ckluc3RydWN0aW9uLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja3BvaW50Lm51bUluc3RydWN0aW9ucyA+IDApIHtcbiAgICAgICAgICAgIGNoZWNrcG9pbnQucmVuZGVySW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vc2V0IHVwIHRoZSBpbnN0cnVjdGlvbiBhbmQgZ29hbCBib3hlc1xuICAgICAgICBpZiAoY3BDb21wbGV0aW9uLmdldChjcCkpIHtcbiAgICAgICAgICAgIHVwZGF0ZVJld2FyZEJveCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy9pbml0aWFsaXplIHN0YXJ0ZXIgY29kZSBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHRoaXMgY2hlY2twb2ludCBpcyByZWFjaGVkXG4gICAgICAgICAgICBpZiAoY2hlY2twb2ludC5fc3RhcnRlckNvZGUgIT0gbnVsbCAmJiBjcENvZGUuZ2V0KGNoZWNrcG9pbnQuX25hbWUpID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnNldFZhbHVlKGNoZWNrcG9pbnQuX3N0YXJ0ZXJDb2RlKTtcbiAgICAgICAgICAgICAgICBwYXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9zZXQgdXAgdGhlIGluc3RydWN0aW9uIGFuZCBnb2FsIGJveGVzXG4gICAgICAgICAgICByZXdhcmRCb3guc3R5bGUuYmFja2dyb3VuZCA9ICcjQzBDMEMwJztcbiAgICAgICAgICAgIGxldCByZXdhcmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmV3YXJkLXRleHQnKTtcbiAgICAgICAgICAgIHJld2FyZC5zdHlsZS5jb2xvciA9ICdibGFjayc7XG4gICAgICAgICAgICByZXdhcmQuaW5uZXJIVE1MID0gJ0NvbXBsZXRlIGdvYWwgdG8gZWFybiBhIHN0YXIhJztcbiAgICAgICAgICAgIGxldCByZXdhcmRJbWcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmV3YXJkLWltYWdlJyk7XG4gICAgICAgICAgICByZXdhcmRJbWcuc3JjID0gJ3BpY3MvZ3JleXN0YXIuc3ZnJztcbiAgICAgICAgICAgIHJld2FyZEltZy5hbHQgPSAnYSBzdGFyIHRvIGJlIGVhcm5lZCc7XG4gICAgICAgICAgICBsZXQgbmV4dEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZXh0Jyk7XG4gICAgICAgICAgICBuZXh0QnRuLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgICAgIGNoZWNrcG9pbnRJc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2twb2ludENoZWNrc0dvYWwoKSB7XG4gICAgICAgIGlmIChjaGVja3BvaW50LmNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykpIHtcbiAgICAgICAgICAgIHVwZGF0ZVJld2FyZEJveCgpO1xuICAgICAgICAgICAgY3BDb21wbGV0aW9uLnNldChjaGVja3BvaW50Ll9uYW1lLCB0cnVlKTtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXJCb3goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVSZXdhcmRCb3goKSB7XG4gICAgICAgIHJld2FyZEJveC5zdHlsZS5iYWNrZ3JvdW5kID0gJyM2NzNBQjcnO1xuICAgICAgICBjb25zb2xlLmxvZyhkb2N1bWVudCk7XG4gICAgICAgIGxldCByZXdhcmRUZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jld2FyZC10ZXh0Jyk7XG4gICAgICAgIHJld2FyZFRleHQuc3R5bGUuY29sb3IgPSAnI0Q4RDhEOCc7XG4gICAgICAgIHJld2FyZFRleHQuaW5uZXJIVE1MID0gXCJHb2FsIG1ldCEgQ2xpY2sgJ05leHQnIHRvIGdvIHRvIG5leHQgY2hlY2twb2ludCFcIjtcbiAgICAgICAgbGV0IHJld2FyZEltZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXdhcmQtaW1hZ2UnKTtcbiAgICAgICAgcmV3YXJkSW1nLnNyYyA9ICdwaWNzL3N0YXIuc3ZnJztcbiAgICAgICAgcmV3YXJkSW1nLmFsdCA9ICdzdGFyIGVhcm5lZCc7XG4gICAgICAgIGxldCBuZXh0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25leHQnKTtcbiAgICAgICAgbmV4dEJ0bi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgaW5zdHJ1Y3Rpb25zLnNjcm9sbFRvcCA9IGluc3RydWN0aW9ucy5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIGNoZWNrcG9pbnRJc0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBsZXQgbmV4dEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZXh0Jyk7XG4gICAgbmV4dEJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgbmV4dE1vZHVsZSA9IGNoZWNrcG9pbnQuX25leHRNb2R1bGU7XG4gICAgICAgIGlmIChuZXh0TW9kdWxlICE9ICcnKSB7XG4gICAgICAgICAgICBpbml0Q2hlY2twb2ludChuZXh0TW9kdWxlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHByZXZCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJldicpO1xuICAgIHByZXZCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IHByZXZNb2R1bGUgPSBjaGVja3BvaW50Ll9wcmV2TW9kdWxlO1xuICAgICAgICBpZiAocHJldk1vZHVsZSAhPSAnJykge1xuICAgICAgICAgICAgaW5pdENoZWNrcG9pbnQocHJldk1vZHVsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVN0YXJCb3goKSB7XG4gICAgICAgIHN0YXJDb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIHZhbCBvZiBjcENvbXBsZXRpb24udmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICBzdGFyQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFyQm94LmlubmVySFRNTCA9IHN0YXJDb3VudCArIFwiL1wiICsgY3BDb21wbGV0aW9uLnNpemU7XG4gICAgfVxuICAgIC8vY2FsbCB0byBhbmltYXRlXG4gICAgYW5pbWF0ZSgpO1xufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgVW5hcnlPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL1VuYXJ5T3BlcmF0aW9uXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jbGFzcyBOZWdPcCBleHRlbmRzIFVuYXJ5T3BlcmF0aW9uXzEuVW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIE5lZ2F0aW9uT3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gYmUgbmVnYXRlZCAobXVzdCBiZSBhIE51bWJlck5vZGUpXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFsLCB3cykge1xuICAgICAgICBzdXBlcih2YWwpO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSB2YWx1ZSBpbnRvIHRoZSBuZWdhdGl2ZSB2ZXJzaW9uXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCB2ID0gdGhpcy52YWwuZXZhbChjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgtdi52YWwsIFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOZWdPcHMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZWdhdGlvbiBvcHMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhIE5lZ09wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBOZWdPcFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgTmVnT3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCItXCIgKyB0aGlzLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLk5lZ09wID0gTmVnT3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OZWdPcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFVuYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBBYnN0cmFjdCBjbGFzcyBjb25zdHJ1Y3RvciBmb3IgVW5hcnkgT3BlcmF0aW9uc1xuICAgICAqIEBwYXJhbSBfdmFsIFRoZSBvYmplY3QgdG8gYmUgb3BlcmF0ZWQgb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfdmFsKSB7XG4gICAgICAgIHRoaXMuX3ZhbCA9IF92YWw7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IGRyYXcgbWV0aG9kIGZvciB1bmRyYXdhYmxlIFVuYXJ5T3BzXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFyeSBPcGVyYXRpb25zIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gVW5hcnlPcHNcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIFVuYXJ5T3BcIik7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFVuYXJ5T3AgdmFsdWVcbiAgICAgKi9cbiAgICBnZXQgdmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBVbmFyeU9wIHZhbHVlXG4gICAgICovXG4gICAgc2V0IHZhbCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWwgPSB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLlVuYXJ5T3BlcmF0aW9uID0gVW5hcnlPcGVyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VbmFyeU9wZXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFZhcmlhYmxlTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgVmFyaWFibGVOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgdmFyaWFibGUgbmFtZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyB1cCB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlIGluIHRoZSBjb250ZXh0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0Lmxvb2t1cCh0aGlzLl9uYW1lLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFyaWFibGVOb2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gdmFyaWFibGUgbm9kZXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIFZhcmlhYmxlTm9kZXNcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRpcmVjdGx5IGNvbXBhcmUgdmFycywgZXZhbCBmaXJzdFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFyaWFibGVOb2RlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5WYXJpYWJsZU5vZGUgPSBWYXJpYWJsZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WYXJpYWJsZU5vZGUuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VzVG9YTUwoY2hhbmdlcykge1xuICBsZXQgcmV0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8aW5zPicpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8ZGVsPicpO1xuICAgIH1cblxuICAgIHJldC5wdXNoKGVzY2FwZUhUTUwoY2hhbmdlLnZhbHVlKSk7XG5cbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICByZXQucHVzaCgnPC9pbnM+Jyk7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xuICAgICAgcmV0LnB1c2goJzwvZGVsPicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIVE1MKHMpIHtcbiAgbGV0IG4gPSBzO1xuICBuID0gbi5yZXBsYWNlKC8mL2csICcmYW1wOycpO1xuICBuID0gbi5yZXBsYWNlKC88L2csICcmbHQ7Jyk7XG4gIG4gPSBuLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgbiA9IG4ucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuXG4gIHJldHVybiBuO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgU2hhbGxvdyB1cGRhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4vKiogUGVyZm9ybXMgYSBzaGFsbG93IHVwZGF0ZSBvZiBhbiBvYmplY3QgdXNpbmcgYSBwYXJ0aWFsIG9iamVjdCBvZiB0aGUgc2FtZSBzaGFwZS4gQSBuZXcgb2JqZWN0IGlzIHJldHVybmVkLiAqL1xuZnVuY3Rpb24gdXBkYXRlKGhvc3QsIHNwZWMpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2xvbmUoaG9zdCk7XG4gICAgZm9yICh2YXIga2V5IGluIHNwZWMpIHtcbiAgICAgICAgdmFyIHNwZWNWYWx1ZSA9IHNwZWNba2V5XTtcbiAgICAgICAgaWYgKHNwZWNWYWx1ZSA9PT0gZXhwb3J0cy5ERUxFVEUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gc3BlY1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnVwZGF0ZSA9IHVwZGF0ZTtcbi8vIFdlIGxpZSBhYm91dCB0aGUgcHVibGljIHR5cGUgc28gdGhhdCBvbmx5IGEgcHJvcGVydHkgdGhhdCBpcyBvcHRpb25hbCBvciB0aGF0IGNhbiBiZSBhc3NpZ25lZCB0byB1bmRlZmluZWQgY2FuIGJlIERFTEVURSdkXG4vKiogTWFya2VyIHVzZWQgdG8gZGVsZXRlIGEga2V5ICovXG5leHBvcnRzLkRFTEVURSA9IHt9O1xudmFyIF9VcGRhdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9VcGRhdGVyKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGtleU9ySW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfVXBkYXRlcih7IHR5cGU6ICdhdCcsIHBhcmVudDogdGhpcywgZmllbGQ6IGtleU9ySW5kZXggfSk7XG4gICAgfTtcbiAgICBfVXBkYXRlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkb1NldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5jbG9uZUZvclVwZGF0ZSh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5uYW1lID09PSAnYWJvcnRlZCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIHZhciBjbG9uZWRUYXJnZXQgPSByZXN1bHQuY2xvbmVkVGFyZ2V0LCBsZWFmSG9zdCA9IHJlc3VsdC5sZWFmSG9zdCwgZmllbGQgPSByZXN1bHQuZmllbGQ7XG4gICAgICAgICAgICB2YWx1ZSA9PT0gZXhwb3J0cy5ERUxFVEUgPyBkZWxldGUgbGVhZkhvc3RbZmllbGRdIDogbGVhZkhvc3RbZmllbGRdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkVGFyZ2V0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYm91bmRUYXJnZXQgPSB0aGlzLmZpbmRCb3VuZFRhcmdldCgpO1xuICAgICAgICByZXR1cm4gYm91bmRUYXJnZXRcbiAgICAgICAgICAgID8gZG9TZXQoYm91bmRUYXJnZXQpXG4gICAgICAgICAgICA6IGRvU2V0O1xuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLm1vZGlmeSA9IGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZG9Nb2RpZnkgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMuY2xvbmVGb3JVcGRhdGUodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubmFtZSA9PT0gJ2Fib3J0ZWQnKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB2YXIgY2xvbmVkVGFyZ2V0ID0gcmVzdWx0LmNsb25lZFRhcmdldCwgbGVhZkhvc3QgPSByZXN1bHQubGVhZkhvc3QsIGZpZWxkID0gcmVzdWx0LmZpZWxkO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbW9kaWZpZXIobGVhZkhvc3RbZmllbGRdKTtcbiAgICAgICAgICAgIHZhbHVlID09PSBleHBvcnRzLkRFTEVURSA/IGRlbGV0ZSBsZWFmSG9zdFtmaWVsZF0gOiBsZWFmSG9zdFtmaWVsZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZWRUYXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBib3VuZFRhcmdldCA9IHRoaXMuZmluZEJvdW5kVGFyZ2V0KCk7XG4gICAgICAgIHJldHVybiBib3VuZFRhcmdldFxuICAgICAgICAgICAgPyBkb01vZGlmeShib3VuZFRhcmdldClcbiAgICAgICAgICAgIDogZG9Nb2RpZnk7XG4gICAgfTtcbiAgICBfVXBkYXRlci5wcm90b3R5cGUud2l0aERlZmF1bHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfVXBkYXRlcih7IHR5cGU6ICd3aXRoRGVmYXVsdCcsIHBhcmVudDogdGhpcywgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KTtcbiAgICB9O1xuICAgIF9VcGRhdGVyLnByb3RvdHlwZS5hYm9ydElmVW5kZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1VwZGF0ZXIoeyB0eXBlOiAnYWJvcnRJZlVuZGVmJywgcGFyZW50OiB0aGlzIH0pO1xuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLmZpbmRCb3VuZFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuZGF0YS50eXBlID09PSAncm9vdCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZGF0YS5ib3VuZFRhcmdldDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmRhdGEucGFyZW50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVXBkYXRlci5wcm90b3R5cGUucGFyZW50VXBkYXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1cGRhdGVycyA9IFt0aGlzXTtcbiAgICAgICAgdmFyIHBhcmVudFVwZGF0ZXIgPSB0aGlzLmRhdGEucGFyZW50O1xuICAgICAgICAvLyBJZ25vcmUgdGhlIHJvb3QgdXBkYXRlclxuICAgICAgICB3aGlsZSAocGFyZW50VXBkYXRlciAmJiBwYXJlbnRVcGRhdGVyLmRhdGEucGFyZW50KSB7XG4gICAgICAgICAgICB1cGRhdGVycy51bnNoaWZ0KHBhcmVudFVwZGF0ZXIpO1xuICAgICAgICAgICAgcGFyZW50VXBkYXRlciA9IHBhcmVudFVwZGF0ZXIuZGF0YS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVwZGF0ZXJzO1xuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLmdldE5leHRWYWx1ZSA9IGZ1bmN0aW9uIChwcmV2aW91c0hvc3QsIGhvc3QsIGZpZWxkLCBpc0xhc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS50eXBlID09PSAnYXQnKSB7XG4gICAgICAgICAgICB2YXIgbmV3RmllbGQgPSB0aGlzLmRhdGEuZmllbGQ7XG4gICAgICAgICAgICB2YXIgdmFsdWVfMSA9IGhvc3RbbmV3RmllbGRdO1xuICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IGlzT2JqZWN0T3JBcnJheSh2YWx1ZV8xKSA/IGNsb25lKHZhbHVlXzEpIDogdmFsdWVfMTtcbiAgICAgICAgICAgIHZhciBuZXdIb3N0XzEgPSBpc0xhc3QgPyBob3N0IDogbmV4dFZhbHVlO1xuICAgICAgICAgICAgaG9zdFt0aGlzLmRhdGEuZmllbGRdID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgaG9zdDogbmV3SG9zdF8xLCBmaWVsZDogbmV3RmllbGQgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBwcmV2aW91c0hvc3RbZmllbGRdO1xuICAgICAgICBpZiAodGhpcy5kYXRhLnR5cGUgPT09ICdhYm9ydElmVW5kZWYnICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGhvc3Q6IGhvc3QsIGZpZWxkOiBmaWVsZCwgYWJvcnRlZDogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhdGEudHlwZSA9PT0gJ3dpdGhEZWZhdWx0JyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gdGhpcy5kYXRhLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIHZhciBuZXdIb3N0XzIgPSBpc0xhc3QgPyBwcmV2aW91c0hvc3QgOiBuZXh0VmFsdWU7XG4gICAgICAgICAgICBwcmV2aW91c0hvc3RbZmllbGRdID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgaG9zdDogbmV3SG9zdF8yLCBmaWVsZDogZmllbGQgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3SG9zdCA9IGlzTGFzdCA/IHByZXZpb3VzSG9zdCA6IGhvc3Q7XG4gICAgICAgIHJldHVybiB7IGhvc3Q6IG5ld0hvc3QsIGZpZWxkOiBmaWVsZCB9O1xuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLmNsb25lRm9yVXBkYXRlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB2YXIgdXBkYXRlcnMgPSB0aGlzLnBhcmVudFVwZGF0ZXJzKCk7XG4gICAgICAgIHZhciBvYmogPSBjbG9uZSh0YXJnZXQpO1xuICAgICAgICB2YXIgcHJldmlvdXNIb3N0ID0gb2JqO1xuICAgICAgICB2YXIgaG9zdCA9IG9iajtcbiAgICAgICAgdmFyIGZpZWxkID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB1cGRhdGVyc1tpXS5nZXROZXh0VmFsdWUocHJldmlvdXNIb3N0LCBob3N0LCBmaWVsZCwgaSA9PT0gdXBkYXRlcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogJ2Fib3J0ZWQnIH07XG4gICAgICAgICAgICBwcmV2aW91c0hvc3QgPSBob3N0O1xuICAgICAgICAgICAgaG9zdCA9IHJlc3VsdC5ob3N0O1xuICAgICAgICAgICAgZmllbGQgPSByZXN1bHQuZmllbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdyZXN1bHQnLFxuICAgICAgICAgICAgY2xvbmVkVGFyZ2V0OiBvYmosXG4gICAgICAgICAgICBsZWFmSG9zdDogaG9zdCxcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIF9VcGRhdGVyO1xufSgpKTtcbmZ1bmN0aW9uIGlzT2JqZWN0T3JBcnJheShvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufVxuZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSlcbiAgICAgICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICAgIHZhciBjbG9uZWQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBjbG9uZWRba2V5XSA9IG9ialtrZXldOyB9KTtcbiAgICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gZGVlcFVwZGF0ZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gbmV3IF9VcGRhdGVyKHsgdHlwZTogJ3Jvb3QnLCBib3VuZFRhcmdldDogdGFyZ2V0IH0pO1xufVxuZXhwb3J0cy5kZWVwVXBkYXRlID0gZGVlcFVwZGF0ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENoYXJVdGlsO1xuKGZ1bmN0aW9uIChDaGFyVXRpbCkge1xuICAgIGNsYXNzIENoYXJTdHJlYW0ge1xuICAgICAgICBjb25zdHJ1Y3RvcihzLCBzdGFydHBvcywgZW5kcG9zLCBoYXNFT0YpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzRU9GID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBzO1xuICAgICAgICAgICAgaWYgKGhhc0VPRiAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0VPRiA9IGhhc0VPRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydHBvcyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0cG9zID0gMDsgLy8gbm90IHNwZWNpZmllZDsgc2V0IGRlZmF1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0cG9zID4gcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0cG9zID0gcy5sZW5ndGg7IC8vIHNlZWsgdG9vIGZhcjsgc2V0IEVPRlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydHBvcyA9IHN0YXJ0cG9zOyAvLyBzcGVjaWZpZWQgYW5kIGluIGJvdW5kc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZHBvcyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvcyA9IHMubGVuZ3RoOyAvLyBub3Qgc3BlY2lmaWVkOyBzZXQgZGVmYXVsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kcG9zID4gcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvcyA9IHMubGVuZ3RoOyAvLyBzZWVrIHRvbyBmYXI7IHNldCBFT0ZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9zID0gZW5kcG9zOyAvLyBzcGVjaWZpZWQgYW5kIGluIGJvdW5kc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRwb3MgPiB0aGlzLmVuZHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRwb3MgPSB0aGlzLmVuZHBvczsgLy8gaWYgdGhlIHVzZXIgZmxpcHBlZCBwb3NpdGlvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIG9mIHRoZSBlbmQgb2YgdGhlIGlucHV0IGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpc0VPRigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0VPRiAmJiB0aGlzLnN0YXJ0cG9zID09IHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgSmF2c2NyaXB0IHByaW1pdGl2ZSBzdHJpbmcgb2YgdGhlIHNsaWNlIG9mIGlucHV0XG4gICAgICAgICAqIHJlcHJlc2VudGVkIGJ5IHRoaXMgQ2hhclN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQuc3Vic3RyaW5nKHRoaXMuc3RhcnRwb3MsIHRoaXMuZW5kcG9zKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBDaGFyU3RyZWFtIHJlcHJlc2VudGluZyB0aGUgaW5wdXQgZnJvbSB0aGVcbiAgICAgICAgICogY3VycmVudCBzdGFydCBwb3NpdGlvbiB0byBhbiBlbmQgcG9zaXRpb24gbnVtIGNoYXJzIGZyb21cbiAgICAgICAgICogdGhlIGN1cnJlbnQgc3RhcnQgcG9zaXRpb24uICBJZiBzdGFydHBvcyArIG51bSA+IGVuZHBvcyxcbiAgICAgICAgICogdGhlIGN1cnJlbnQgQ2hhclN0cmVhbSBpcyByZXR1cm5lZC5cbiAgICAgICAgICogQHBhcmFtIG51bVxuICAgICAgICAgKi9cbiAgICAgICAgcGVlayhudW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0cG9zICsgbnVtID4gdGhpcy5lbmRwb3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXdIYXNFT0YgPSB0aGlzLnN0YXJ0cG9zICsgbnVtID09IHRoaXMuZW5kcG9zICYmIHRoaXMuaGFzRU9GO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbSh0aGlzLmlucHV0LCB0aGlzLnN0YXJ0cG9zLCB0aGlzLnN0YXJ0cG9zICsgbnVtLCBuZXdIYXNFT0YpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IENoYXJTdHJlYW0gcmVwcmVzZW50aW5nIHRoZSBzdHJpbmcgYWZ0ZXJcbiAgICAgICAgICogc2Vla2luZyBudW0gY2hhcmFjdGVycyBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gbnVtXG4gICAgICAgICAqL1xuICAgICAgICBzZWVrKG51bSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRwb3MgKyBudW0gPiB0aGlzLmVuZHBvcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbSh0aGlzLmlucHV0LCB0aGlzLmVuZHBvcywgdGhpcy5lbmRwb3MsIHRoaXMuaGFzRU9GKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbSh0aGlzLmlucHV0LCB0aGlzLnN0YXJ0cG9zICsgbnVtLCB0aGlzLmVuZHBvcywgdGhpcy5oYXNFT0YpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IENoYXJTdHJlYW0gcmVwcmVzZW50aW5nIHRoZSBoZWFkIG9mIHRoZSBpbnB1dCBhdFxuICAgICAgICAgKiB0aGUgY3VycmVudCBwb3NpdGlvbi4gIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIENoYXJTdHJlYW0gaXNcbiAgICAgICAgICogZW1wdHkuXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hhc0VPRiA9IHRoaXMuc3RhcnRwb3MgKyAxID09IHRoaXMuZW5kcG9zICYmIHRoaXMuaGFzRU9GO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbSh0aGlzLmlucHV0LCB0aGlzLnN0YXJ0cG9zLCB0aGlzLnN0YXJ0cG9zICsgMSwgbmV3SGFzRU9GKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGhlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBDaGFyU3RyZWFtIHJlcHJlc2VudGluZyB0aGUgdGFpbCBvZiB0aGUgaW5wdXQgYXRcbiAgICAgICAgICogdGhlIGN1cnJlbnQgcG9zaXRpb24uICBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBDaGFyU3RyZWFtIGlzXG4gICAgICAgICAqIGVtcHR5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGFpbCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENoYXJTdHJlYW0odGhpcy5pbnB1dCwgdGhpcy5zdGFydHBvcyArIDEsIHRoaXMuZW5kcG9zLCB0aGlzLmhhc0VPRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSB0YWlsIG9mIGFuIGVtcHR5IHN0cmluZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gaXMgZW1wdHkuIE5vdGVcbiAgICAgICAgICogdGhhdCBhIENoYXJTdHJlYW0gYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgY29udGFpbnMgYW4gZW1wdHlcbiAgICAgICAgICogc3RyaW5nIGJ1dCB0aGF0IGFuIGVtcHR5IHN0cmluZyBtYXkgbm90IGJlIHRoZSBlbmQtb2YtZmlsZSAoaS5lLixcbiAgICAgICAgICogaXNFT0YgaXMgZmFsc2UpLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNFbXB0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0cG9zID09IHRoaXMuZW5kcG9zO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyByZW1haW5pbmcgYXRcbiAgICAgICAgICogdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBsZW5ndGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmRwb3MgLSB0aGlzLnN0YXJ0cG9zO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzdWJzdHJpbmcgYmV0d2VlbiBzdGFydCBhbmQgZW5kIGF0IHRoZVxuICAgICAgICAgKiBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gc3RhcnQgdGhlIHN0YXJ0IGluZGV4IG9mIHRoZSBzdWJzdHJpbmcsIGluY2x1c2l2ZVxuICAgICAgICAgKiBAcGFyYW0gZW5kIHRoZSBlbmQgaW5kZXggb2YgdGhlIHN1YnN0cmluZywgZXhjbHVzaXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdWJzdHJpbmcoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQyID0gdGhpcy5zdGFydHBvcyArIHN0YXJ0O1xuICAgICAgICAgICAgY29uc3QgZW5kMiA9IHRoaXMuc3RhcnRwb3MgKyBlbmQ7XG4gICAgICAgICAgICBjb25zdCBuZXdIYXNFT0YgPSB0aGlzLmVuZHBvcyA9PSBlbmQyICYmIHRoaXMuaGFzRU9GO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFyU3RyZWFtKHRoaXMuaW5wdXQsIHN0YXJ0MiwgZW5kMiwgbmV3SGFzRU9GKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgY3VycmVudCBDaGFyU3RyZWFtIHdpdGhcbiAgICAgICAgICogdGhlIGdpdmVuIENoYXJTdHJlYW0uIE5vdGU6IHJldHVybmVkIG9iamVjdCBkb2VzIG5vdFxuICAgICAgICAgKiByZXVzZSBvcmlnaW5hbCBpbnB1dCBzdHJpbmcsIGFuZCBzdGFydHBvcyBhbmQgZW5kcG9zXG4gICAgICAgICAqIGFyZSByZXNldC4gSWYgdGhlIGdpdmVuIENoYXJTdHJlYW0gY29udGFpbnMgRU9GLCB0aGVcbiAgICAgICAgICogY29uY2F0ZW5hdGVkIENoYXJTdHJlYW0gd2lsbCBhbHNvIGNvbnRhaW4gRU9GLlxuICAgICAgICAgKiBAcGFyYW0gY3MgdGhlIENoYXJTdHJlYW0gdG8gY29uY2F0IHRvIHRoaXMgQ2hhclN0cmVhbVxuICAgICAgICAgKi9cbiAgICAgICAgY29uY2F0KGNzKSB7XG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy50b1N0cmluZygpICsgY3MudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbShzLCAwLCBzLmxlbmd0aCwgY3MuaGFzRU9GKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uY2F0ZW5hdGUgYW4gYXJyYXkgb2YgQ2hhclN0cmVhbSBvYmplY3RzIGludG8gYSBzaW5nbGVcbiAgICAgICAgICogQ2hhclN0cmVhbSBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSBjc3MgYSBDaGFyU3RyZWFtW11cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjb25jYXQoY3NzKSB7XG4gICAgICAgICAgICBpZiAoY3NzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFyU3RyZWFtKFwiXCIsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjcyA9IGNzc1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjcyA9IGNzLmNvbmNhdChjc3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2hhclV0aWwuQ2hhclN0cmVhbSA9IENoYXJTdHJlYW07XG59KShDaGFyVXRpbCA9IGV4cG9ydHMuQ2hhclV0aWwgfHwgKGV4cG9ydHMuQ2hhclV0aWwgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhcnN0cmVhbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcmltaXRpdmVzXzEgPSByZXF1aXJlKFwiLi9wcmltaXRpdmVzXCIpO1xuZXhwb3J0cy5QcmltaXRpdmVzID0gcHJpbWl0aXZlc18xLlByaW1pdGl2ZXM7XG52YXIgY2hhcnN0cmVhbV8xID0gcmVxdWlyZShcIi4vY2hhcnN0cmVhbVwiKTtcbmV4cG9ydHMuQ2hhclV0aWwgPSBjaGFyc3RyZWFtXzEuQ2hhclV0aWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNoYXJzdHJlYW1fMSA9IHJlcXVpcmUoXCIuL2NoYXJzdHJlYW1cIik7XG52YXIgUHJpbWl0aXZlcztcbihmdW5jdGlvbiAoUHJpbWl0aXZlcykge1xuICAgIGNsYXNzIEVPRk1hcmsge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgICAgICBzdGF0aWMgZ2V0IEluc3RhbmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlIHx8ICh0aGlzLl9pbnN0YW5jZSA9IG5ldyB0aGlzKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuRU9GTWFyayA9IEVPRk1hcms7XG4gICAgUHJpbWl0aXZlcy5FT0YgPSBFT0ZNYXJrLkluc3RhbmNlO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdWNjZXNzZnVsIHBhcnNlLlxuICAgICAqL1xuICAgIGNsYXNzIFN1Y2Nlc3Mge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgc3VjY2Vzc2Z1bCBwYXJzZS5cbiAgICAgICAgICogQHBhcmFtIGlzdHJlYW0gVGhlIHJlbWFpbmluZyBzdHJpbmcuXG4gICAgICAgICAqIEBwYXJhbSByZXMgVGhlIHJlc3VsdCBvZiB0aGUgcGFyc2VcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKGlzdHJlYW0sIHJlcykge1xuICAgICAgICAgICAgdGhpcy50YWcgPSBcInN1Y2Nlc3NcIjtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzdHJlYW0gPSBpc3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSByZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUHJpbWl0aXZlcy5TdWNjZXNzID0gU3VjY2VzcztcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgZmFpbGVkIHBhcnNlLlxuICAgICAqL1xuICAgIGNsYXNzIEZhaWx1cmUge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZmFpbGVkIHBhcnNlLlxuICAgICAgICAgKiBAcGFyYW0gaXN0cmVhbSBUaGUgc3RyaW5nLCB1bm1vZGlmaWVkLCB0aGF0IHdhcyBnaXZlbiB0byB0aGUgcGFyc2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoaXN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy50YWcgPSBcImZhaWx1cmVcIjtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzdHJlYW0gPSBpc3RyZWFtO1xuICAgICAgICB9XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuRmFpbHVyZSA9IEZhaWx1cmU7XG4gICAgLyoqXG4gICAgICogcmVzdWx0IHN1Y2NlZWRzIHdpdGhvdXQgY29uc3VtaW5nIGFueSBpbnB1dCwgYW5kIHJldHVybnMgdi5cbiAgICAgKiBAcGFyYW0gdiBUaGUgcmVzdWx0IG9mIHRoZSBwYXJzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQodikge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IG5ldyBTdWNjZXNzKGlzdHJlYW0sIHYpO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAvKipcbiAgICAgKiB6ZXJvIGZhaWxzIHdpdGhvdXQgY29uc3VtaW5nIGFueSBpbnB1dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6ZXJvKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnplcm8gPSB6ZXJvO1xuICAgIC8qKlxuICAgICAqIGl0ZW0gc3VjY2Vzc2Z1bGx5IGNvbnN1bWVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaWYgdGhlIGlucHV0XG4gICAgICogc3RyaW5nIGlzIG5vbi1lbXB0eSwgb3RoZXJ3aXNlIGl0IGZhaWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl0ZW0oKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzdHJlYW0uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKGlzdHJlYW0udGFpbCgpLCBpc3RyZWFtLmhlYWQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuaXRlbSA9IGl0ZW07XG4gICAgLyoqXG4gICAgICogYmluZCBpcyBhIGN1cnJpZWQgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHBhcnNlciBwIGFuZCByZXR1cm5zXG4gICAgICogYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgcGFyc2VyIGYgd2hpY2ggcmV0dXJucyB0aGUgY29tcG9zaXRpb25cbiAgICAgKiBvZiBwIGFuZCBmLiAgSWYgX2FueV8gb2YgdGhlIHBhcnNlcnMgZmFpbCwgdGhlIG9yaWdpbmFsIGlucHV0c3RyZWFtXG4gICAgICogaXMgcmV0dXJuZWQgaW4gdGhlIEZhaWx1cmUgb2JqZWN0IChpLmUuLCBiaW5kIGJhY2t0cmFja3MpLlxuICAgICAqIEBwYXJhbSBwIEEgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZChwKSB7XG4gICAgICAgIHJldHVybiAoZikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHIgPSBwKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoci50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvID0gZihyLnJlc3VsdCkoci5pbnB1dHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG8udGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjogcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90ZTogYmFja3RyYWNrcywgcmV0dXJuaW5nIG9yaWdpbmFsIGlzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOiByZXR1cm4gbmV3IEZhaWx1cmUoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5iaW5kID0gYmluZDtcbiAgICBmdW5jdGlvbiBkZWxheShwKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBwO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmRlbGF5ID0gZGVsYXk7XG4gICAgLyoqXG4gICAgICogc2VxIGlzIGEgY3VycmllZCBmdW5jdGlvbiB0aGF0IHRha2VzIGEgcGFyc2VyIHAsIGEgcGFyc2VyIHEsXG4gICAgICogYW5kIGEgZnVuY3Rpb24gZi4gSXQgYXBwbGllcyBwIHRvIHRoZSBpbnB1dCwgcGFzc2luZyB0aGVcbiAgICAgKiByZW1haW5pbmcgaW5wdXQgc3RyZWFtIHRvIHE7IHEgaXMgdGhlbiBhcHBsaWVkLiAgVGhlIGZ1bmN0aW9uXG4gICAgICogZiB0YWtlcyB0aGUgcmVzdWx0IG9mIHAgYW5kIHEsIGFzIGEgdHVwbGUsIGFuZCByZXR1cm5zXG4gICAgICogYSBzaW5nbGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwIEEgcGFyc2VyXG4gICAgICovXG4gICAgLy8gZXhwb3J0IGxldCBzZXEgPSBmdW5jdGlvbjxULFUsVj4ocDogSVBhcnNlcjxUPikge1xuICAgIC8vICAgICByZXR1cm4gKHE6IElQYXJzZXI8VT4pID0+IHtcbiAgICAvLyAgICAgICAgIHJldHVybiAoZjogKGU6IFtULFVdKSA9PiBWKSA9PiB7XG4gICAgLy8gICAgICAgICAgICAgcmV0dXJuIGJpbmQ8VCxWPihwKSgoeCkgPT4ge1xuICAgIC8vICAgICAgICAgICAgICAgICByZXR1cm4gYmluZDxVLFY+KHEpKCh5KSA9PiB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBsZXQgdHVwIDogW1QsVV0gPSBbeCx5XTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ8Vj4oZih0dXApKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgfSk7XG4gICAgLy8gICAgICAgICAgICAgfSk7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH07XG4gICAgLy8gfVxuICAgIGZ1bmN0aW9uIHNlcShwKSB7XG4gICAgICAgIHJldHVybiAocSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChmKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQocCkoKHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQocSkoKHkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0dXAgPSBbeCwgeV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0KGYodHVwKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5zZXEgPSBzZXE7XG4gICAgLyoqXG4gICAgICogc2F0IHRha2VzIGEgcHJlZGljYXRlIGFuZCB5aWVsZHMgYSBwYXJzZXIgdGhhdCBjb25zdW1lcyBhXG4gICAgICogc2luZ2xlIGNoYXJhY3RlciBpZiB0aGUgY2hhcmFjdGVyIHNhdGlzZmllcyB0aGUgcHJlZGljYXRlLFxuICAgICAqIG90aGVyd2lzZSBpdCBmYWlscy5cbiAgICAgKiBAcGFyYW0gcHJlZCBhIGNoYXJhY3RlciBwcmVkaWNhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYXQocHJlZCkge1xuICAgICAgICBsZXQgcHJlZDIgPSAoY3MpID0+IHByZWQoY3MudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBhID0gaXRlbSgpO1xuICAgICAgICBsZXQgYiA9ICh4KSA9PiB7XG4gICAgICAgICAgICBpZiAocHJlZDIoeCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0KHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGJpbmQoYSkoYik7XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuc2F0ID0gc2F0O1xuICAgIC8qKlxuICAgICAqIGNoYXIgdGFrZXMgYSBjaGFyYWN0ZXIgYW5kIHlpZWxkcyBhIHBhcnNlciB0aGF0IGNvbnN1bWVcbiAgICAgKiB0aGF0IGNoYXJhY3Rlci4gVGhlIHJldHVybmVkIHBhcnNlciBzdWNjZWVkcyBpZiB0aGUgbmV4dFxuICAgICAqIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQgc3RyZWFtIGlzIGMsIG90aGVyd2lzZSBpdCBmYWlscy5cbiAgICAgKiBAcGFyYW0gY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYXIoYykge1xuICAgICAgICBpZiAoYy5sZW5ndGggIT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hhciBwYXJzZXIgdGFrZXMgYSBzdHJpbmcgb2YgbGVuZ3RoIDEgKGkuZS4sIGEgY2hhcilcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNhdCh4ID0+IHggPT0gYyk7XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuY2hhciA9IGNoYXI7XG4gICAgLyoqXG4gICAgICogbGV0dGVyIHJldHVybnMgYSBwYXJzZXIgdGhhdCBjb25zdW1lcyBhIHNpbmdsZSBhbHBoYWJldGljXG4gICAgICogY2hhcmFjdGVyLCBmcm9tIGEteiwgcmVnYXJkbGVzcyBvZiBjYXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxldHRlcigpIHtcbiAgICAgICAgbGV0IGNvbnRhaW5zX2xldHRlciA9ICh4KSA9PiB7XG4gICAgICAgICAgICBsZXQgYV9sZXR0ZXIgPSAvW0EtWmEtel0vO1xuICAgICAgICAgICAgcmV0dXJuIHgubWF0Y2goYV9sZXR0ZXIpICE9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNhdChjb250YWluc19sZXR0ZXIpO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmxldHRlciA9IGxldHRlcjtcbiAgICAvKipcbiAgICAgKiBkaWdpdCByZXR1cm5zIGEgcGFyc2VyIHRoYXQgY29uc3VtZXMgYSBzaW5nbGUgbnVtZXJpY1xuICAgICAqIGNoYXJhY3RlciwgZnJvbSAwLTkuICBOb3RlIHRoYXQgdGhlIHR5cGUgb2YgdGhlIHJlc3VsdFxuICAgICAqIGlzIGEgc3RyaW5nLCBub3QgYSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlnaXQoKSB7XG4gICAgICAgIHJldHVybiBzYXQoeCA9PiB4ID09IFwiMFwiXG4gICAgICAgICAgICB8fCB4ID09IFwiMVwiXG4gICAgICAgICAgICB8fCB4ID09IFwiMlwiXG4gICAgICAgICAgICB8fCB4ID09IFwiM1wiXG4gICAgICAgICAgICB8fCB4ID09IFwiNFwiXG4gICAgICAgICAgICB8fCB4ID09IFwiNVwiXG4gICAgICAgICAgICB8fCB4ID09IFwiNlwiXG4gICAgICAgICAgICB8fCB4ID09IFwiN1wiXG4gICAgICAgICAgICB8fCB4ID09IFwiOFwiXG4gICAgICAgICAgICB8fCB4ID09IFwiOVwiKTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5kaWdpdCA9IGRpZ2l0O1xuICAgIC8qKlxuICAgICAqIHVwcGVyIHJldHVybnMgYSBwYXJzZXIgdGhhdCBjb25zdW1lcyBhIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICAgKiBpZiB0aGF0IGNoYXJhY3RlciBpcyB1cHBlcmNhc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBwZXIoKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgbGV0IG8xID0gbGV0dGVyKCkoaXN0cmVhbSk7XG4gICAgICAgICAgICBzd2l0Y2ggKG8xLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIGxldCBvMiA9IHNhdCh4ID0+IHggPT0geC50b1VwcGVyQ2FzZSgpKShvMS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG8yLnRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFpbHVyZShpc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZXZlciBoYXBwZW5zXCIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnVwcGVyID0gdXBwZXI7XG4gICAgLyoqXG4gICAgICogbG93ZXIgcmV0dXJucyBhIHBhcnNlciB0aGF0IGNvbnN1bWVzIGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAqIGlmIHRoYXQgY2hhcmFjdGVyIGlzIGxvd2VyY2FzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb3dlcigpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgbzEgPSBsZXR0ZXIoKShpc3RyZWFtKTtcbiAgICAgICAgICAgIHN3aXRjaCAobzEudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgbGV0IG8yID0gc2F0KHggPT4geCA9PSB4LnRvTG93ZXJDYXNlKCkpKG8xLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobzIudGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5ldmVyIGhhcHBlbnNcIik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMubG93ZXIgPSBsb3dlcjtcbiAgICAvKipcbiAgICAgKiBjaG9pY2Ugc3BlY2lmaWVzIGFuIG9yZGVyZWQgY2hvaWNlIGJldHdlZW4gdHdvIHBhcnNlcnMsXG4gICAgICogcDEgYW5kIHAyLiBUaGUgcmV0dXJuZWQgcGFyc2VyIHdpbGwgZmlyc3QgYXBwbHlcbiAgICAgKiBwYXJzZXIgcDEuICBJZiBwMSBzdWNjZWVkcywgcDEncyBPdXRjb21lIGlzIHJldHVybmVkLlxuICAgICAqIElmIHAxIGZhaWxzLCBwMiBpcyBhcHBsaWVkIGFuZCB0aGUgT3V0Y29tZSBvZiBwMiBpcyByZXR1cm5lZC5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBnaXZlbiB0byBwMSBhbmQgcDIgaXMgZXhhY3RseVxuICAgICAqIHRoZSBzYW1lIGlucHV0IHN0cmVhbS5cbiAgICAgKiBAcGFyYW0gcDEgQSBwYXJzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hvaWNlKHAxKSB7XG4gICAgICAgIHJldHVybiAocDIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBvID0gcDEoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDIoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5jaG9pY2UgPSBjaG9pY2U7XG4gICAgLyoqXG4gICAgICogYXBwZnVuIGFsbG93cyB0aGUgdXNlciB0byBhcHBseSBhIGZ1bmN0aW9uIGYgdG9cbiAgICAgKiB0aGUgcmVzdWx0IG9mIGEgcGFyc2VyIHAsIGFzc3VtaW5nIHRoYXQgcCBpcyBzdWNjZXNzZnVsLlxuICAgICAqIEBwYXJhbSBwIEEgcGFyc2VyLiAgVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgfD4+XG4gICAgICogZnVuY3Rpb24gZnJvbSBGUGFyc2VjLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFwcGZ1bihwKSB7XG4gICAgICAgIHJldHVybiAoZikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG8gPSBwKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2VzcyhvLmlucHV0c3RyZWFtLCBmKG8ucmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmFwcGZ1biA9IGFwcGZ1bjtcbiAgICAvKipcbiAgICAgKiBtYW55IHJlcGVhdGVkbHkgYXBwbGllcyB0aGUgcGFyc2VyIHAgdW50aWwgcCBmYWlscy4gbWFueSBhbHdheXNcbiAgICAgKiBzdWNjZWVkcywgZXZlbiBpZiBpdCBtYXRjaGVzIG5vdGhpbmcuICBtYW55IHRyaWVzIHRvIGd1YXJkXG4gICAgICogYWdhaW5zdCBhbiBpbmZpbml0ZSBsb29wIGJ5IHJhaXNpbmcgYW4gZXhjZXB0aW9uIGlmIHAgc3VjY2VlZHNcbiAgICAgKiB3aXRob3V0IGNoYW5naW5nIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICogQHBhcmFtIHBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYW55KHApIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgaXN0cmVhbTIgPSBpc3RyZWFtO1xuICAgICAgICAgICAgbGV0IG91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBzdWNjZWVkcyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoIWlzdHJlYW0yLmlzRW1wdHkoKSAmJiBzdWNjZWVkcykge1xuICAgICAgICAgICAgICAgIGxldCBvID0gcChpc3RyZWFtMik7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzdHJlYW0yID09IG8uaW5wdXRzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZXIgbG9vcHMgaW5maW5pdGVseS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3RyZWFtMiA9IG8uaW5wdXRzdHJlYW07XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2goby5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZWVkcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKGlzdHJlYW0yLCBvdXRwdXRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5tYW55ID0gbWFueTtcbiAgICAvKipcbiAgICAgKiBtYW55MSByZXBlYXRlZGx5IGFwcGxpZXMgdGhlIHBhcnNlciBwIHVudGlsIHAgZmFpbHMuIG1hbnkxIG11c3RcbiAgICAgKiBzdWNjZWVkIGF0IGxlYXN0IG9uY2UuICBtYW55MSB0cmllcyB0byBndWFyZCBhZ2FpbnN0IGFuIGluZmluaXRlXG4gICAgICogbG9vcCBieSByYWlzaW5nIGFuIGV4Y2VwdGlvbiBpZiBwIHN1Y2NlZWRzIHdpdGhvdXQgY2hhbmdpbmcgdGhlXG4gICAgICogcGFyc2VyIHN0YXRlLlxuICAgICAqIEBwYXJhbSBwXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFueTEocCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzZXEocCkobWFueShwKSkodHVwID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaGQgPSB0dXBbXCIwXCJdO1xuICAgICAgICAgICAgICAgIGxldCB0bCA9IHR1cFtcIjFcIl07XG4gICAgICAgICAgICAgICAgdGwudW5zaGlmdChoZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRsO1xuICAgICAgICAgICAgfSkoaXN0cmVhbSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMubWFueTEgPSBtYW55MTtcbiAgICAvKipcbiAgICAgKiBzdHIgeWllbGRzIGEgcGFyc2VyIGZvciB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICAqIEBwYXJhbSBzIEEgc3RyaW5nXG4gICAgICovXG4gICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYWN0dWFsbHkgYmUgYSBzZXF1ZW5jZSBvZiBwYXJzZXJzIGNvbnN0cnVjdGVkXG4gICAgLy8gZnJvbSB0aGUgc3RyaW5nIHNcbiAgICBmdW5jdGlvbiBzdHIocykge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIC8vIGVzY2FwZSByZWdleCBtZXRhY2hhcmFjdGVyc1xuICAgICAgICAgICAgLy8gKHRoaXMgbGlrZWx5IG5lZWRzIHdvcmspXG4gICAgICAgICAgICBsZXQgczIgPSBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4gICAgICAgICAgICBsZXQgcmUgPSBuZXcgUmVnRXhwKFwiXlwiICsgczIpO1xuICAgICAgICAgICAgaWYgKGlzdHJlYW0udG9TdHJpbmcoKS5tYXRjaChyZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW0gPSBpc3RyZWFtLnN1YnN0cmluZyhzLmxlbmd0aCwgaXN0cmVhbS5sZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gaXN0cmVhbS5zdWJzdHJpbmcoMCwgcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2VzcyhyZW0sIHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhaWx1cmUoaXN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuc3RyID0gc3RyO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwYXJzZXIgdGhhdCBzdWNjZWVkcyBvbmx5IGlmIHRoZSBlbmQgb2YgdGhlXG4gICAgICogaW5wdXQgaGFzIGJlZW4gcmVhY2hlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlb2YoKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzdHJlYW0uaXNFT0YoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2Vzcyhpc3RyZWFtLCBQcmltaXRpdmVzLkVPRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhaWx1cmUoaXN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuZW9mID0gZW9mO1xuICAgIC8qKlxuICAgICAqIGZyZXN1bHQgcmV0dXJucyBhIHBhcnNlciB0aGF0IGFwcGxpZXMgdGhlIHBhcnNlciBwLFxuICAgICAqIGFuZCBpZiBwIHN1Y2NlZWRzLCByZXR1cm5zIHRoZSB2YWx1ZSB4LlxuICAgICAqIEBwYXJhbSBwIGEgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJlc3VsdChwKSB7XG4gICAgICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQocCkoKHQpID0+IHJlc3VsdCh4KSkoaXN0cmVhbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmZyZXN1bHQgPSBmcmVzdWx0O1xuICAgIC8qKlxuICAgICAqIGxlZnQgcmV0dXJucyBhIHBhcnNlciB0aGF0IGFwcGxpZXMgdGhlIHBhcnNlciBwLFxuICAgICAqIHRoZW4gdGhlIHBhcnNlciBxLCBhbmQgaWYgYm90aCBhcmUgc3VjY2Vzc2Z1bCxcbiAgICAgKiByZXR1cm5zIHRoZSByZXN1bHQgb2YgcC5cbiAgICAgKiBAcGFyYW0gcCBhIHBhcnNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlZnQocCkge1xuICAgICAgICByZXR1cm4gKHEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiaW5kKHApKCh0KSA9PiBmcmVzdWx0KHEpKHQpKShpc3RyZWFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMubGVmdCA9IGxlZnQ7XG4gICAgLyoqXG4gICAgICogcmlnaHQgcmV0dXJucyBhIHBhcnNlciB0aGF0IGFwcGxpZXMgdGhlIHBhcnNlciBwLFxuICAgICAqIHRoZW4gdGhlIHBhcnNlciBxLCBhbmQgaWYgYm90aCBhcmUgc3VjY2Vzc2Z1bCxcbiAgICAgKiByZXR1cm5zIHRoZSByZXN1bHQgb2YgcS5cbiAgICAgKiBAcGFyYW0gcCBhIHBhcnNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJpZ2h0KHApIHtcbiAgICAgICAgcmV0dXJuIChxKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluZChwKShfID0+IHEpKGlzdHJlYW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5yaWdodCA9IHJpZ2h0O1xuICAgIC8qKlxuICAgICAqIGJldHdlZW4gcmV0dXJucyBhIHBhcnNlciB0aGF0IGFwcGxpZXMgdGhlIHBhcnNlclxuICAgICAqIHBvcGVuLCBwLCBhbmQgcGNsb3NlIGluIHNlcXVlbmNlLCBhbmQgaWYgYWxsIGFyZVxuICAgICAqIHN1Y2Nlc3NmdWwsIHJldHVybnMgdGhlIHJlc3VsdCBvZiBwLlxuICAgICAqIEBwYXJhbSBwb3BlbiB0aGUgZmlyc3QgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmV0d2Vlbihwb3Blbikge1xuICAgICAgICByZXR1cm4gKHBjbG9zZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChwKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGwgPSBsZWZ0KHApKHBjbG9zZSk7XG4gICAgICAgICAgICAgICAgbGV0IHIgPSByaWdodChwb3BlbikobCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmJldHdlZW4gPSBiZXR3ZWVuO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWJ1ZyBwYXJzZXIgdGFrZXMgYSBwYXJzZXIgcCBhbmQgYSBkZWJ1ZyBzdHJpbmcsXG4gICAgICogcHJpbnRpbmcgdGhlIGRlYnVnIHN0cmluZyBhcyBhIHNpZGUtZWZmZWN0IGJlZm9yZVxuICAgICAqIGFwcGx5aW5nIHAgdG8gdGhlIGlucHV0LlxuICAgICAqIEBwYXJhbSBwIGEgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVidWcocCkge1xuICAgICAgICByZXR1cm4gKGxhYmVsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImFwcGx5OiBcIiArIGxhYmVsKTtcbiAgICAgICAgICAgICAgICBsZXQgbyA9IHAoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzdWNjZXNzOiBcIiArIGxhYmVsICsgXCIsIHN0YXJ0cG9zOiBcIiArIGlzdHJlYW0uc3RhcnRwb3MgKyBcIiwgZW5kcG9zOiBcIiArIGlzdHJlYW0uZW5kcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJmYWlsdXJlOiBcIiArIGxhYmVsICsgXCIsIHN0YXJ0cG9zOiBcIiArIGlzdHJlYW0uc3RhcnRwb3MgKyBcIiwgZW5kcG9zOiBcIiArIGlzdHJlYW0uZW5kcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuZGVidWcgPSBkZWJ1ZztcbiAgICBsZXQgd3NjaGFycyA9IGNob2ljZShzYXQoYyA9PiBjID09ICcgJyB8fCBjID09ICdcXHQnKSkobmwoKSk7XG4gICAgLyoqXG4gICAgICogd3MgbWF0Y2hlcyB6ZXJvIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnM6XG4gICAgICogJyAnLCAnXFx0JywgJ1xcbicsIG9yICdcXHJcXG4nXG4gICAgICogd3MgcmV0dXJucyBtYXRjaGVkIHdoaXRlc3BhY2UgaW4gYSBzaW5nbGUgQ2hhclN0cmVhbSByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3MoKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgbGV0IG8gPSBtYW55KHdzY2hhcnMpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2VzcyhvLmlucHV0c3RyZWFtLCBjaGFyc3RyZWFtXzEuQ2hhclV0aWwuQ2hhclN0cmVhbS5jb25jYXQoby5yZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAvLyB3cyBuZXZlciBmYWlsc1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLndzID0gd3M7XG4gICAgLyoqXG4gICAgICogd3MxIG1hdGNoZXMgb25lIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnM6XG4gICAgICogJyAnLCAnXFx0JywgJ1xcbicsIG9yICdcXHJcXG4nXG4gICAgICogd3MxIHJldHVybnMgbWF0Y2hlZCB3aGl0ZXNwYWNlIGluIGEgc2luZ2xlIENoYXJTdHJlYW0gcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdzMSgpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgbyA9IG1hbnkxKHdzY2hhcnMpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2VzcyhvLmlucHV0c3RyZWFtLCBjaGFyc3RyZWFtXzEuQ2hhclV0aWwuQ2hhclN0cmVhbS5jb25jYXQoby5yZXN1bHQpKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy53czEgPSB3czE7XG4gICAgLyoqXG4gICAgICogbmwgbWF0Y2hlcyBhbmQgcmV0dXJucyBhIG5ld2xpbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmwoKSB7XG4gICAgICAgIHJldHVybiBQcmltaXRpdmVzLmNob2ljZShQcmltaXRpdmVzLnN0cihcIlxcblwiKSkoUHJpbWl0aXZlcy5zdHIoXCJcXHJcXG5cIikpO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLm5sID0gbmw7XG4gICAgZnVuY3Rpb24gZ3JvdXBCeShsaXN0LCBrZXlHZXR0ZXIpIHtcbiAgICAgICAgbGV0IG0gPSBuZXcgTWFwKCk7XG4gICAgICAgIGxpc3QuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5R2V0dGVyKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKCFtLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbS5zZXQoa2V5LCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY29sbGVjdGlvbiA9IG0uZ2V0KGtleSk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2goaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyU2F0KHN0cnMpIHtcbiAgICAgICAgLy8gc29ydCBzdHJpbmdzIGZpcnN0IGJ5IGxlbmd0aCwgYW5kIHRoZW4gbGV4aWNvZ3JhcGljYWxseTtcbiAgICAgICAgLy8gc2xpY2UoKSBjYWxsZWQgaGVyZSBzbyBhcyBub3QgdG8gbW9kaWZ5IG9yaWdpbmFsIGFycmF5XG4gICAgICAgIGxldCBzbWFwID0gZ3JvdXBCeShzdHJzLCBzID0+IHMubGVuZ3RoKTtcbiAgICAgICAgbGV0IHNpemVzID0gW107XG4gICAgICAgIC8vIGZpbmQgc2l6ZSBjbGFzc2VzO1xuICAgICAgICAvLyBhbHNvIHNvcnQgZWFjaCBzZXQgb2YgZXF1aXZhbGVudC1sZW5ndGggdmFsdWVzXG4gICAgICAgIHNtYXAuZm9yRWFjaCgodmFscywga2V5LCBtKSA9PiB7XG4gICAgICAgICAgICBzaXplcy5wdXNoKGtleSk7XG4gICAgICAgICAgICB2YWxzLnNvcnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNpemVzLnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAvLyBzdGFydCB3aXRoIHRoZSBzbWFsbGVzdCBzaXplIGNsYXNzICAgICAgIFxuICAgICAgICAgICAgZm9yIChsZXQgcGVla0luZGV4ID0gMDsgcGVla0luZGV4IDwgc2l6ZXMubGVuZ3RoOyBwZWVrSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIHNpemUgY2xhc3MsIHRyeSBtYXRjaGluZyBhbGwgb2ZcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3RyaW5nczsgaWYgb25lIGlzIGZvdW5kLCByZXR1cm4gdGhlXG4gICAgICAgICAgICAgICAgLy8gYXBwcm9wcmlhdGUgQ2hhclN0cmVhbTsgaWYgbm90LCBmYWlsLlxuICAgICAgICAgICAgICAgIGxldCBwZWVrID0gaXN0cmVhbS5wZWVrKHNpemVzW3BlZWtJbmRleF0pO1xuICAgICAgICAgICAgICAgIGxldCB0YWlsID0gaXN0cmVhbS5zZWVrKHNpemVzW3BlZWtJbmRleF0pO1xuICAgICAgICAgICAgICAgIGxldCBjYW5kaWRhdGVzID0gc21hcC5nZXQoc2l6ZXNbcGVla0luZGV4XSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY0luZGV4ID0gMDsgY0luZGV4IDwgY2FuZGlkYXRlcy5sZW5ndGg7IGNJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGVzW2NJbmRleF0gPT09IHBlZWsudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKHRhaWwsIHBlZWspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnN0clNhdCA9IHN0clNhdDtcbn0pKFByaW1pdGl2ZXMgPSBleHBvcnRzLlByaW1pdGl2ZXMgfHwgKGV4cG9ydHMuUHJpbWl0aXZlcyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmltaXRpdmVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0XzEgPSByZXF1aXJlKFwiLi4vbGlmdFwiKTtcbi8qKlxuICogQ29udmVydHMgYW4gQXJyYXktbGlrZSBvYmplY3QgKHN1Y2ggYXMgYW4gYXJndW1lbnRzIG9yIE5vZGVMaXN0IGluc3RhbmNlKSB0byBhIHJlZ3VsYXIgQXJyYXlcbiAqL1xuZnVuY3Rpb24gZnJvbUFycmF5TGlrZShhcnJheUxpa2UpIHtcbiAgICByZXR1cm4gbmV3IGxpZnRfMS5BcnJheU9wcyhbXS5zbGljZS5jYWxsKGFycmF5TGlrZSkpO1xufVxuZXhwb3J0cy5mcm9tQXJyYXlMaWtlID0gZnJvbUFycmF5TGlrZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0XzEgPSByZXF1aXJlKFwiLi4vbGlmdFwiKTtcbi8qXG4qIFJldHVybnMgYSBudW1iZXJbXSB3cmFwcGVyIHdpdGggYWxsIG51bWJlcnMgZnJvbSBzdGFydCB0byBzdG9wIChpbmNsdXNpdmUpLFxuKiBpbmNyZW1lbnRlZCBvciBkZWNyZW1lbnRlZCBieSBzdGVwLlxuKi9cbmZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RvcCA9IGFyZ3VtZW50c1swXSAtIDE7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGluY3JlYXNpbmcgPSBzdGVwID4gMDtcbiAgICB2YXIgbmV4dCA9IHN0YXJ0O1xuICAgIHdoaWxlICgoaW5jcmVhc2luZyAmJiBuZXh0IDw9IHN0b3ApIHx8ICghaW5jcmVhc2luZyAmJiBuZXh0ID49IHN0b3ApKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5leHQpO1xuICAgICAgICBuZXh0ID0gbmV4dCArIHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgbGlmdF8xLkFycmF5T3BzKHJlc3VsdCk7XG59XG5leHBvcnRzLnJhbmdlID0gcmFuZ2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5mdW5jdGlvbiB0dXBsZShhcnIpIHtcbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0cy50dXBsZSA9IHR1cGxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGlzXzEgPSByZXF1aXJlKFwiLi4vb2JqZWN0L2lzXCIpO1xudmFyIGN1cnJlbnRNZW1vSWQgPSAwO1xuLyoqXG4gKiBNZW1vaXplcyBhIGZ1bmN0aW9uIG9mIGFyYml0cmFyeSBhcml0eS5cbiAqIFRoaXMgaGFzIHR3byBtYWluIHVzZXM6XG4gKiAgIDEpIFJlZHVjaW5nIHRoZSBDUFUgdGltZSB0YWtlbiBieSBleHBlbnNpdmUgY2FsY3VsYXRpb25zIGF0IHRoZSBjb3N0IG9mIHNvbWUgbWVtb3J5IG92ZXJoZWFkXG4gKiAgIDIpIFByb2R1Y2luZyBzdGFibGUgcmVmZXJlbmNlcyBmb3IgYSBnaXZlbiBzZXQgb2YgYXJndW1lbnRzLiBVc2VmdWwgd2hlbiByZWx5aW5nIG9uIHJlZmVyZW5jZSBlcXVhbGl0eS5cbiAqXG4gKiBNZW1vaXplZCBmdW5jdGlvbnMga2VlcCBpbnRlcm5hbCBzdGF0ZS4gSWYgeW91IHdpc2ggdG8gY2xlYXIgdGhhdCBzdGF0ZSBlbnRpcmVseSwgeW91IGNhbiByZWNyZWF0ZSB0aGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuLCBvcHRpb25zKSB7XG4gICAgLy8gVGhlIHVuaXF1ZSBwcm9wZXJ0eSBuYW1lIHVzZWQgYnkgdGhpcyBtZW1vaXplIGZ1bmN0aW9uIGluc3RhbmNlLlxuICAgIC8vIFRoaXMgaXMgdXNlZCB0byBzdG9yZSB0aGUgaWQvcmVmZXJlbmNlIG9mIG9iamVjdCBhcmd1bWVudHMsIGFzIFdlYWsgbWFwcy9zZXRzIGFyZSB2ZXJ5IGxpbWl0ZWQuXG4gICAgdmFyIG1lbW9LZXkgPSBcIl9fbWVtb19fXCIgKyBjdXJyZW50TWVtb0lkKys7XG4gICAgdmFyIGxhc3RBcmdLZXlzID0gW107XG4gICAgdmFyIGNhY2hlU2l6ZSA9IChvcHRpb25zICYmIG9wdGlvbnMuY2FjaGVTaXplKSB8fCAzMDtcbiAgICB2YXIga2V5RnVuY3Rpb24gPSBvcHRpb25zICYmIG9wdGlvbnMua2V5O1xuICAgIC8vIFRoZSB1bmlxdWUgaWRzL3JlZmVyZW5jZXMgb2Ygb2JqZWN0cyBpbnNpZGUgdGhlIGFyaXR5TkNhY2hlIGNhY2hlXG4gICAgdmFyIG9iaklkID0gMDtcbiAgICB2YXIgYXJpdHkwQ2FjaGU7XG4gICAgdmFyIGFyaXR5TkNhY2hlO1xuICAgIHZhciBrZXlDYWNoZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIDAgYXJndW1lbnRzIGVkZ2UtY2FzZVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICghYXJpdHkwQ2FjaGUpXG4gICAgICAgICAgICAgICAgYXJpdHkwQ2FjaGUgPSBmdW4oKTtcbiAgICAgICAgICAgIHJldHVybiBhcml0eTBDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjdXN0b20ga2V5IGZ1bmN0aW9uXG4gICAgICAgIGVsc2UgaWYgKGtleUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBrZXlDYWNoZSA9IGtleUNhY2hlIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleUZ1bmN0aW9uLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGtleUNhY2hlW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGxhc3RBcmdLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICBsaW1pdENhY2hlU2l6ZShrZXlDYWNoZSwgbGFzdEFyZ0tleXMsIGNhY2hlU2l6ZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ga2V5Q2FjaGVba2V5XSA9IGZ1bi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTiBhcmd1bWVudHNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhcml0eU5DYWNoZSA9IGFyaXR5TkNhY2hlIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGtleSA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgICAgICAgdmFyIGFyZ0tleSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoaXNfMS5vYmplY3QoYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdLZXkgPSBhcmdbbWVtb0tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXJnS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb24gZW51bWVyYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFyZywgbWVtb0tleSwgeyB2YWx1ZTogXCJvYmpcIiArIG9iaklkKysgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdLZXkgPSBhcmdbbWVtb0tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ0tleSA9IGFyZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5ICs9IChhcmdLZXkgKyAnXycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGFyaXR5TkNhY2hlW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGxhc3RBcmdLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICBsaW1pdENhY2hlU2l6ZShhcml0eU5DYWNoZSwgbGFzdEFyZ0tleXMsIGNhY2hlU2l6ZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXJpdHlOQ2FjaGVba2V5XSA9IGZ1bi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5tZW1vaXplID0gbWVtb2l6ZTtcbmZ1bmN0aW9uIGxpbWl0Q2FjaGVTaXplKGNhY2hlLCBsYXN0QXJnS2V5cywgc2l6ZSkge1xuICAgIGlmIChsYXN0QXJnS2V5cy5sZW5ndGggPT09IHNpemUgKyAxKSB7XG4gICAgICAgIHZhciBrZXkgPSBsYXN0QXJnS2V5cy5zaGlmdCgpO1xuICAgICAgICBkZWxldGUgY2FjaGVba2V5XTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbGlmdF8xID0gcmVxdWlyZShcIi4vbGlmdFwiKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbGlmdF8xW1wiZGVmYXVsdFwiXTtcbnZhciBsaWZ0XzIgPSByZXF1aXJlKFwiLi9saWZ0XCIpO1xuZXhwb3J0cy5BcnJheU9wcyA9IGxpZnRfMi5BcnJheU9wcztcbmV4cG9ydHMuT2JqZWN0T3BzID0gbGlmdF8yLk9iamVjdE9wcztcbmV4cG9ydHMuTnVtYmVyT3BzID0gbGlmdF8yLk51bWJlck9wcztcbmV4cG9ydHMuU3RyaW5nT3BzID0gbGlmdF8yLlN0cmluZ09wcztcbmV4cG9ydHMuRGF0ZU9wcyA9IGxpZnRfMi5EYXRlT3BzO1xuZXhwb3J0cy5nZXRWYWx1ZSA9IGxpZnRfMi5nZXRWYWx1ZTtcbnZhciBpbW11cGRhdGVfMSA9IHJlcXVpcmUoXCJpbW11cGRhdGVcIik7XG5leHBvcnRzLnVwZGF0ZSA9IGltbXVwZGF0ZV8xLnVwZGF0ZTtcbmV4cG9ydHMuZGVlcFVwZGF0ZSA9IGltbXVwZGF0ZV8xLmRlZXBVcGRhdGU7XG5leHBvcnRzLkRFTEVURSA9IGltbXVwZGF0ZV8xLkRFTEVURTtcbnZhciBvcHRpb25fMSA9IHJlcXVpcmUoXCIuL29wdGlvblwiKTtcbmV4cG9ydHMuT3B0aW9uID0gb3B0aW9uXzEuT3B0aW9uO1xuZXhwb3J0cy5Ob25lID0gb3B0aW9uXzEuTm9uZTtcbmV4cG9ydHMuU29tZSA9IG9wdGlvbl8xLlNvbWU7XG52YXIgcmVzdWx0XzEgPSByZXF1aXJlKFwiLi9yZXN1bHRcIik7XG5leHBvcnRzLlJlc3VsdCA9IHJlc3VsdF8xLlJlc3VsdDtcbmV4cG9ydHMuT2sgPSByZXN1bHRfMS5PaztcbmV4cG9ydHMuRXJyID0gcmVzdWx0XzEuRXJyO1xudmFyIHJhbmdlXzEgPSByZXF1aXJlKFwiLi9hcnJheS9yYW5nZVwiKTtcbmV4cG9ydHMucmFuZ2UgPSByYW5nZV8xLnJhbmdlO1xudmFyIGZyb21BcnJheUxpa2VfMSA9IHJlcXVpcmUoXCIuL2FycmF5L2Zyb21BcnJheUxpa2VcIik7XG5leHBvcnRzLmZyb21BcnJheUxpa2UgPSBmcm9tQXJyYXlMaWtlXzEuZnJvbUFycmF5TGlrZTtcbnZhciB0dXBsZV8xID0gcmVxdWlyZShcIi4vYXJyYXkvdHVwbGVcIik7XG5leHBvcnRzLnR1cGxlID0gdHVwbGVfMS50dXBsZTtcbnZhciBzZXRfMSA9IHJlcXVpcmUoXCIuL29iamVjdC9zZXRcIik7XG5leHBvcnRzLlNldCA9IHNldF8xLlNldDtcbnZhciBtZW1vaXplXzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbi9tZW1vaXplXCIpO1xuZXhwb3J0cy5tZW1vaXplID0gbWVtb2l6ZV8xLm1lbW9pemU7XG52YXIgaXNUeXBlID0gcmVxdWlyZShcIi4vb2JqZWN0L2lzXCIpO1xuZXhwb3J0cy5pcyA9IGlzVHlwZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLkFycmF5T3BzKG9iaik7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgIHJldHVybiBuZXcgZXhwb3J0cy5EYXRlT3BzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuU3RyaW5nT3BzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuTnVtYmVyT3BzKG9iaik7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLk9iamVjdE9wcyhvYmopO1xufTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbGlmdDtcbmZ1bmN0aW9uIGdldFZhbHVlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ICYmIGlucHV0WydfaXNMaWZ0V3JhcHBlciddXG4gICAgICAgID8gaW5wdXQudmFsdWUoKVxuICAgICAgICA6IGlucHV0O1xufVxuZXhwb3J0cy5nZXRWYWx1ZSA9IGdldFZhbHVlO1xuZnVuY3Rpb24gbWFrZU9wcygpIHtcbiAgICB2YXIgT3BzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBPcHMoX3ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzTGlmdFdyYXBwZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIE9wcy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfTtcbiAgICAgICAgcmV0dXJuIE9wcztcbiAgICB9KCkpO1xuICAgIHJldHVybiBPcHM7XG59XG5leHBvcnRzLkFycmF5T3BzID0gbWFrZU9wcygpO1xuZXhwb3J0cy5PYmplY3RPcHMgPSBtYWtlT3BzKCk7XG5leHBvcnRzLk51bWJlck9wcyA9IG1ha2VPcHMoKTtcbmV4cG9ydHMuU3RyaW5nT3BzID0gbWFrZU9wcygpO1xuZXhwb3J0cy5EYXRlT3BzID0gbWFrZU9wcygpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuLyoqIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaXMgYW4gQXJyYXkgKi9cbmV4cG9ydHMuYXJyYXkgPSBBcnJheS5pc0FycmF5O1xuLyoqIFJldHVybnMgd2hldGhlciB0aGlzIG9iamVjdCBpcyBhIGZ1bmN0aW9uICovXG5mdW5jdGlvbiBmdW5jKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5leHBvcnRzLmZ1bmMgPSBmdW5jO1xuLyoqIFJldHVybnMgd2hldGhlciB0aGlzIG9iamVjdCBpcyBhIHN0cmluZyAqL1xuZnVuY3Rpb24gc3RyaW5nKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpO1xufVxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG4vKiogUmV0dXJucyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIGEgbnVtYmVyICovXG5mdW5jdGlvbiBudW1iZXIob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyk7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbi8qKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvYmplY3QgaXMgYSBib29sZWFuICovXG5mdW5jdGlvbiBib29sZWFuKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nKTtcbn1cbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XG4vKiogUmV0dXJucyB3aGV0aGVyIHRoaXMgdmFsdWUgaXMgYW4gb2JqZWN0IChlLmcgbm90IGEgcHJpbWl0aXZlOiBkYXRlcywgYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKSkgKi9cbmZ1bmN0aW9uIG9iamVjdChvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5leHBvcnRzLm9iamVjdCA9IG9iamVjdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0XzEgPSByZXF1aXJlKFwiLi4vbGlmdFwiKTtcbi8qKlxuICogQ3JlYXRlcyBhIFNldC1saWtlIG9iamVjdCAoc3RyaW5nIGtleXMsIHRydWUgdmFsdWVzKSBmcm9tIGEgbGlzdCBvZiBrZXlzXG4gKi9cbmZ1bmN0aW9uIFNldCgpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGtleXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiByZXN1bHRba2V5XSA9IHRydWU7IH0pO1xuICAgIHJldHVybiBuZXcgbGlmdF8xLk9iamVjdE9wcyhyZXN1bHQpO1xufVxuZXhwb3J0cy5TZXQgPSBTZXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbGlmdF8xID0gcmVxdWlyZShcIi4uL2xpZnRcIik7XG4vLyBUaGUgT3B0aW9uIGZhY3RvcnkgLyBzdGF0aWMgb2JqZWN0XG52YXIgT3B0aW9uT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzRGVmKHZhbHVlKSA/IFNvbWUodmFsdWUpIDogZXhwb3J0cy5Ob25lO1xufTtcbk9wdGlvbk9iamVjdC5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgaWYgKGV4cG9ydHMuT3B0aW9uLmlzT3B0aW9uKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZ2V0KCk7XG4gICAgICAgIGlmICghaXNEZWYodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTm9uZTtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gU29tZSh2YWx1ZXMpO1xufTtcbk9wdGlvbk9iamVjdC5pc09wdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICh2YWx1ZS50eXBlID09PSAnc29tZScgfHwgdmFsdWUudHlwZSA9PT0gJ25vbmUnKTtcbn07XG5mdW5jdGlvbiBtYWtlTm9uZSgpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuICAgIGZ1bmN0aW9uIHJldHVybk5vbmUoKSB7IHJldHVybiBleHBvcnRzLk5vbmU7IH1cbiAgICBzZWxmLnR5cGUgPSAnbm9uZSc7XG4gICAgc2VsZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH07XG4gICAgc2VsZi5pc0RlZmluZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICBzZWxmLmZvckVhY2ggPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgc2VsZi5tYXAgPSByZXR1cm5Ob25lO1xuICAgIHNlbGYuZmxhdE1hcCA9IHJldHVybk5vbmU7XG4gICAgc2VsZi5maWx0ZXIgPSByZXR1cm5Ob25lO1xuICAgIHNlbGYuZm9sZCA9IGZ1bmN0aW9uIChpZkVtcHR5KSB7IHJldHVybiBpZkVtcHR5KCk7IH07XG4gICAgc2VsZi5vckVsc2UgPSBmdW5jdGlvbiAoYWx0KSB7IHJldHVybiBhbHQoKTsgfTtcbiAgICBzZWxmLmdldE9yRWxzZSA9IGZ1bmN0aW9uIChhbHQpIHsgcmV0dXJuIGFsdDsgfTtcbiAgICBzZWxmLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWZ0XzFbXCJkZWZhdWx0XCJdKFtdKTsgfTtcbiAgICBzZWxmLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ05vbmUnOyB9O1xuICAgIHNlbGYudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9Tb21lKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuX1NvbWUucHJvdG90eXBlID0ge1xuICAgIHR5cGU6ICdzb21lJyxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfSxcbiAgICBpc0RlZmluZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgZm4odGhpcy52YWx1ZSk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcHRpb24obGlmdF8xLmdldFZhbHVlKGZuKHRoaXMudmFsdWUpKSk7XG4gICAgfSxcbiAgICBmbGF0TWFwOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKHRoaXMudmFsdWUpO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKHRoaXMudmFsdWUpID8gdGhpcyA6IGV4cG9ydHMuTm9uZTtcbiAgICB9LFxuICAgIGZvbGQ6IGZ1bmN0aW9uIChpZkVtcHR5LCBpZkRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGlmRGVmaW5lZCh0aGlzLnZhbHVlKTtcbiAgICB9LFxuICAgIG9yRWxzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldE9yRWxzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9LFxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxpZnRfMVtcImRlZmF1bHRcIl0oW3RoaXMudmFsdWVdKTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNvbWUoXCIgKyB0aGlzLnZhbHVlICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGlzRGVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLk9wdGlvbiA9IE9wdGlvbk9iamVjdDtcbi8qKiBDcmVhdGVzIGEgbmV3IFNvbWUgaW5zdGFuY2UgdXNpbmcgYSBub24gbnVsbGFibGUgdmFsdWUgKi9cbi8vIGV4dGVuZHMge30gdG8gcHJldmVudCBudWxsIGFuZCB1bmRlZmluZWQgYmVpbmcgcGFzc2VkXG5mdW5jdGlvbiBTb21lKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfU29tZSh2YWx1ZSk7XG59XG5leHBvcnRzLlNvbWUgPSBTb21lO1xuZXhwb3J0cy5Ob25lID0gbWFrZU5vbmUoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0XzEgPSByZXF1aXJlKFwiLi4vbGlmdFwiKTtcbnZhciBSZXN1bHRPYmplY3QgPSB7fTtcblJlc3VsdE9iamVjdC5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIG9rVmFsdWVzID0gW107XG4gICAgdmFyIGN1cnJlbnRSZXN1bHQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRSZXN1bHRfMSA9IGFycltpXTtcbiAgICAgICAgaWYgKCFjdXJyZW50UmVzdWx0XzEuaXNPaygpKVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRfMTtcbiAgICAgICAgb2tWYWx1ZXMucHVzaChjdXJyZW50UmVzdWx0XzEuZ2V0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gT2sob2tWYWx1ZXMpO1xufTtcblJlc3VsdE9iamVjdC5pc1Jlc3VsdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICh2YWx1ZS50eXBlID09PSAnb2snIHx8IHZhbHVlLnR5cGUgPT09ICdlcnInKTtcbn07XG5mdW5jdGlvbiBfT2sodmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xufVxuX09rLnByb3RvdHlwZSA9IHtcbiAgICB0eXBlOiAnb2snLFxuICAgIGlzT2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gT2sobGlmdF8xLmdldFZhbHVlKGZuKHRoaXMuX3ZhbHVlKSkpO1xuICAgIH0sXG4gICAgbWFwRXJyb3I6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZsYXRNYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4odGhpcy5fdmFsdWUpO1xuICAgIH0sXG4gICAgZm9sZDogZnVuY3Rpb24gKGlmRXJyLCBpZk9rKSB7XG4gICAgICAgIHJldHVybiBpZk9rKHRoaXMuX3ZhbHVlKTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIk9rKFwiICsgdGhpcy5fdmFsdWUgKyBcIilcIjtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxufTtcbmZ1bmN0aW9uIF9FcnIoZXJyb3IpIHtcbiAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xufVxuX0Vyci5wcm90b3R5cGUgPSB7XG4gICAgdHlwZTogJ2VycicsXG4gICAgaXNPazogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG1hcEVycm9yOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIEVycihmbih0aGlzLl9lcnJvcikpO1xuICAgIH0sXG4gICAgZmxhdE1hcDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZm9sZDogZnVuY3Rpb24gKGlmRXJyLCBpZk9rKSB7XG4gICAgICAgIHJldHVybiBpZkVycih0aGlzLl9lcnJvcik7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJFcnIoXCIgKyB0aGlzLl9lcnJvciArIFwiKVwiO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICB9XG59O1xuZXhwb3J0cy5SZXN1bHQgPSBSZXN1bHRPYmplY3Q7XG5mdW5jdGlvbiBPayh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX09rKHZhbHVlKTtcbn1cbmV4cG9ydHMuT2sgPSBPaztcbmZ1bmN0aW9uIEVycihlcnJvcikge1xuICAgIHJldHVybiBuZXcgX0VycihlcnJvcik7XG59XG5leHBvcnRzLkVyciA9IEVycjtcbiJdfQ==
