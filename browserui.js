(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Scope_1 = require("./lib/structural/Scope");
exports.Scope = Scope_1.Scope;
/* BINARY OPS */
var AssignOp_1 = require("./lib/binops/AssignOp");
exports.AssignOp = AssignOp_1.AssignOp;
var BinaryOperation_1 = require("./lib/binops/BinaryOperation");
exports.BinaryOperation = BinaryOperation_1.BinaryOperation;
var DivOp_1 = require("./lib/binops/DivOp");
exports.DivOp = DivOp_1.DivOp;
var MinusOp_1 = require("./lib/binops/MinusOp");
exports.MinusOp = MinusOp_1.MinusOp;
var MulOp_1 = require("./lib/binops/MulOp");
exports.MulOp = MulOp_1.MulOp;
var PlusOp_1 = require("./lib/binops/PlusOp");
exports.PlusOp = PlusOp_1.PlusOp;
var GreaterThan_1 = require("./lib/logic/GreaterThan");
exports.GreaterThan = GreaterThan_1.GreaterThan;
var GreaterThanEq_1 = require("./lib/logic/GreaterThanEq");
exports.GreaterThanEq = GreaterThanEq_1.GreaterThanEq;
var LessThan_1 = require("./lib/logic/LessThan");
exports.LessThan = LessThan_1.LessThan;
var LessThanEq_1 = require("./lib/logic/LessThanEq");
exports.LessThanEq = LessThanEq_1.LessThanEq;
var DeclareOp_1 = require("./lib/binops/DeclareOp");
exports.DeclareOp = DeclareOp_1.DeclareOp;
var And_1 = require("./lib/logic/And");
exports.And = And_1.And;
var Or_1 = require("./lib/logic/Or");
exports.Or = Or_1.Or;
var Equals_1 = require("./lib/logic/Equals");
exports.Equals = Equals_1.Equals;
var NotEqual_1 = require("./lib/logic/NotEqual");
exports.NotEqual = NotEqual_1.NotEqual;
var Increment_1 = require("./lib/binops/Increment");
exports.Increment = Increment_1.Increment;
var Decrement_1 = require("./lib/binops/Decrement");
exports.Decrement = Decrement_1.Decrement;
/* UNARY OPS */
var UnaryOperation_1 = require("./lib/unops/UnaryOperation");
exports.UnaryOperation = UnaryOperation_1.UnaryOperation;
var NegOp_1 = require("./lib/unops/NegOp");
exports.NegOp = NegOp_1.NegOp;
var Not_1 = require("./lib/logic/Not");
exports.Not = Not_1.Not;
/* DATA TYPES */
var ListNode_1 = require("./lib/lists/ListNode");
exports.ListNode = ListNode_1.ListNode;
var NumberNode_1 = require("./lib/prims/NumberNode");
exports.NumberNode = NumberNode_1.NumberNode;
var StringNode_1 = require("./lib/prims/StringNode");
exports.StringNode = StringNode_1.StringNode;
var BooleanNode_1 = require("./lib/prims/BooleanNode");
exports.BooleanNode = BooleanNode_1.BooleanNode;
var NOP_1 = require("./lib/prims/NOP");
exports.NOP = NOP_1.NOP;
/* VARIABLES */
var VariableNode_1 = require("./lib/vars/VariableNode");
exports.VariableNode = VariableNode_1.VariableNode;
/* CONTROL CONSTRUCTS */
var Conditional_1 = require("./lib/conditionals/Conditional");
exports.Conditional = Conditional_1.Conditional;
var FunApp_1 = require("./lib/funhouse/FunApp");
exports.FunApp = FunApp_1.FunApp;
var FunDef_1 = require("./lib/funhouse/FunDef");
exports.FunDef = FunDef_1.FunDef;
var SequenceNode_1 = require("./lib/structural/SequenceNode");
exports.SequenceNode = SequenceNode_1.SequenceNode;
var WhileNode_1 = require("./lib/loops/WhileNode");
exports.WhileNode = WhileNode_1.WhileNode;
var ForNode_1 = require("./lib/loops/ForNode");
exports.ForNode = ForNode_1.ForNode;
/* BUILTIN FUNCTIONS */
var ColorNode_1 = require("./lib/shapes/ColorNode");
exports.ColorNode = ColorNode_1.ColorNode;
var EllipseNode_1 = require("./lib/shapes/EllipseNode");
exports.EllipseNode = EllipseNode_1.EllipseNode;
var RectangleNode_1 = require("./lib/shapes/RectangleNode");
exports.RectangleNode = RectangleNode_1.RectangleNode;
var LineNode_1 = require("./lib/shapes/LineNode");
exports.LineNode = LineNode_1.LineNode;
var CurveNode_1 = require("./lib/shapes/CurveNode");
exports.CurveNode = CurveNode_1.CurveNode;
var EphNode_1 = require("./lib/shapes/EphNode");
exports.EphNode = EphNode_1.EphNode;
var PrintNode_1 = require("./lib/structural/PrintNode");
exports.PrintNode = PrintNode_1.PrintNode;
var Return_1 = require("./lib/structural/Return");
exports.Return = Return_1.Return;
var ReturnError_1 = require("./lib/structural/ReturnError");
exports.ReturnError = ReturnError_1.ReturnError;
var EllipseEffect_1 = require("./lib/effects/EllipseEffect");
exports.EllipseEffect = EllipseEffect_1.EllipseEffect;
var NumberEffect_1 = require("./lib/effects/NumberEffect");
exports.NumberEffect = NumberEffect_1.NumberEffect;
var StringEffect_1 = require("./lib/effects/StringEffect");
exports.StringEffect = StringEffect_1.StringEffect;
var Dimensions_1 = require("./lib/structural/Dimensions");
exports.Dimensions = Dimensions_1.Dimensions;
var RectangleEffect_1 = require("./lib/effects/RectangleEffect");
exports.RectangleEffect = RectangleEffect_1.RectangleEffect;
var LineEffect_1 = require("./lib/effects/LineEffect");
exports.LineEffect = LineEffect_1.LineEffect;
var CurveEffect_1 = require("./lib/effects/CurveEffect");
exports.CurveEffect = CurveEffect_1.CurveEffect;
var EphEffect_1 = require("./lib/effects/EphEffect");
exports.EphEffect = EphEffect_1.EphEffect;
/* EVENTS */
var LogEvent_1 = require("./lib/logging/LogEvent");
exports.LogEvent = LogEvent_1.LogEvent;
var ClearEvent_1 = require("./lib/logging/ClearEvent");
exports.ClearEvent = ClearEvent_1.ClearEvent;
var DragEvent_1 = require("./lib/logging/DragEvent");
exports.DragEvent = DragEvent_1.DragEvent;
var PaintEvent_1 = require("./lib/logging/PaintEvent");
exports.PaintEvent = PaintEvent_1.PaintEvent;
var ResizeEvent_1 = require("./lib/logging/ResizeEvent");
exports.ResizeEvent = ResizeEvent_1.ResizeEvent;
var SelectEvent_1 = require("./lib/logging/SelectEvent");
exports.SelectEvent = SelectEvent_1.SelectEvent;
var IDEvent_1 = require("./lib/logging/IDEvent");
exports.IDEvent = IDEvent_1.IDEvent;
var LessonOneCpOne_1 = require("./lib/modules/LessonOneCpOne");
exports.LessonOneCpOne = LessonOneCpOne_1.LessonOneCpOne;
var LessonOneCpTwo_1 = require("./lib/modules/LessonOneCpTwo");
exports.LessonOneCpTwo = LessonOneCpTwo_1.LessonOneCpTwo;
var LessonOneCpThree_1 = require("./lib/modules/LessonOneCpThree");
exports.LessonOneCpThree = LessonOneCpThree_1.LessonOneCpThree;
var LessonOneCpFour_1 = require("./lib/modules/LessonOneCpFour");
exports.LessonOneCpFour = LessonOneCpFour_1.LessonOneCpFour;
var LessonTwoCpOne_1 = require("./lib/modules/LessonTwoCpOne");
exports.LessonTwoCpOne = LessonTwoCpOne_1.LessonTwoCpOne;
var LessonTwoCpTwo_1 = require("./lib/modules/LessonTwoCpTwo");
exports.LessonTwoCpTwo = LessonTwoCpTwo_1.LessonTwoCpTwo;
var LessonTwoCpThree_1 = require("./lib/modules/LessonTwoCpThree");
exports.LessonTwoCpThree = LessonTwoCpThree_1.LessonTwoCpThree;
var LessonTwoCpFour_1 = require("./lib/modules/LessonTwoCpFour");
exports.LessonTwoCpFour = LessonTwoCpFour_1.LessonTwoCpFour;
var LessonTwoCpFive_1 = require("./lib/modules/LessonTwoCpFive");
exports.LessonTwoCpFive = LessonTwoCpFive_1.LessonTwoCpFive;
var LessonTwoCpSix_1 = require("./lib/modules/LessonTwoCpSix");
exports.LessonTwoCpSix = LessonTwoCpSix_1.LessonTwoCpSix;
var LessonTwoCpSeven_1 = require("./lib/modules/LessonTwoCpSeven");
exports.LessonTwoCpSeven = LessonTwoCpSeven_1.LessonTwoCpSeven;
var LessonThreeCpOne_1 = require("./lib/modules/LessonThreeCpOne");
exports.LessonThreeCpOne = LessonThreeCpOne_1.LessonThreeCpOne;
var LessonThreeCpTwo_1 = require("./lib/modules/LessonThreeCpTwo");
exports.LessonThreeCpTwo = LessonThreeCpTwo_1.LessonThreeCpTwo;
var LessonThreeCpThree_1 = require("./lib/modules/LessonThreeCpThree");
exports.LessonThreeCpThree = LessonThreeCpThree_1.LessonThreeCpThree;
var LessonThreeCpFour_1 = require("./lib/modules/LessonThreeCpFour");
exports.LessonThreeCpFour = LessonThreeCpFour_1.LessonThreeCpFour;
var LessonThreeCpFive_1 = require("./lib/modules/LessonThreeCpFive");
exports.LessonThreeCpFive = LessonThreeCpFive_1.LessonThreeCpFive;
var LessonThreeCpSix_1 = require("./lib/modules/LessonThreeCpSix");
exports.LessonThreeCpSix = LessonThreeCpSix_1.LessonThreeCpSix;
var LessonFourCpOne_1 = require("./lib/modules/LessonFourCpOne");
exports.LessonFourCpOne = LessonFourCpOne_1.LessonFourCpOne;
var LessonFourCpTwo_1 = require("./lib/modules/LessonFourCpTwo");
exports.LessonFourCpTwo = LessonFourCpTwo_1.LessonFourCpTwo;
/* PARSER */
var parser_1 = require("./lib/parser/parser");
exports.Parser = parser_1.Parser;

},{"./lib/binops/AssignOp":2,"./lib/binops/BinaryOperation":3,"./lib/binops/DeclareOp":4,"./lib/binops/Decrement":5,"./lib/binops/DivOp":6,"./lib/binops/Increment":7,"./lib/binops/MinusOp":8,"./lib/binops/MulOp":9,"./lib/binops/PlusOp":10,"./lib/conditionals/Conditional":11,"./lib/effects/CurveEffect":12,"./lib/effects/EllipseEffect":13,"./lib/effects/EphEffect":14,"./lib/effects/LineEffect":15,"./lib/effects/NumberEffect":16,"./lib/effects/RectangleEffect":17,"./lib/effects/StringEffect":18,"./lib/funhouse/FunApp":19,"./lib/funhouse/FunDef":20,"./lib/lists/ListNode":21,"./lib/logging/ClearEvent":22,"./lib/logging/DragEvent":24,"./lib/logging/IDEvent":25,"./lib/logging/LogEvent":26,"./lib/logging/PaintEvent":27,"./lib/logging/ResizeEvent":28,"./lib/logging/SelectEvent":29,"./lib/logic/And":30,"./lib/logic/Equals":31,"./lib/logic/GreaterThan":32,"./lib/logic/GreaterThanEq":33,"./lib/logic/LessThan":34,"./lib/logic/LessThanEq":35,"./lib/logic/Not":36,"./lib/logic/NotEqual":37,"./lib/logic/Or":38,"./lib/loops/ForNode":39,"./lib/loops/WhileNode":40,"./lib/modules/LessonFourCpOne":41,"./lib/modules/LessonFourCpTwo":42,"./lib/modules/LessonOneCpFour":43,"./lib/modules/LessonOneCpOne":44,"./lib/modules/LessonOneCpThree":45,"./lib/modules/LessonOneCpTwo":46,"./lib/modules/LessonThreeCpFive":47,"./lib/modules/LessonThreeCpFour":48,"./lib/modules/LessonThreeCpOne":49,"./lib/modules/LessonThreeCpSix":50,"./lib/modules/LessonThreeCpThree":51,"./lib/modules/LessonThreeCpTwo":52,"./lib/modules/LessonTwoCpFive":53,"./lib/modules/LessonTwoCpFour":54,"./lib/modules/LessonTwoCpOne":55,"./lib/modules/LessonTwoCpSeven":56,"./lib/modules/LessonTwoCpSix":57,"./lib/modules/LessonTwoCpThree":58,"./lib/modules/LessonTwoCpTwo":59,"./lib/parser/parser":60,"./lib/prims/BooleanNode":61,"./lib/prims/NOP":62,"./lib/prims/NumberNode":63,"./lib/prims/StringNode":64,"./lib/shapes/ColorNode":65,"./lib/shapes/CurveNode":66,"./lib/shapes/EllipseNode":67,"./lib/shapes/EphNode":68,"./lib/shapes/LineNode":69,"./lib/shapes/RectangleNode":70,"./lib/structural/Dimensions":71,"./lib/structural/PrintNode":72,"./lib/structural/Return":73,"./lib/structural/ReturnError":74,"./lib/structural/Scope":75,"./lib/structural/SequenceNode":76,"./lib/unops/NegOp":78,"./lib/unops/UnaryOperation":79,"./lib/vars/VariableNode":80}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const VariableNode_1 = require("../vars/VariableNode");
// left side is variable, right side is val
// Reassign new value to var
class AssignOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for an assignment operation
     * @param left The left side of the assignment (the var)
     * @param right The right side of the assignment (the value)
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        if (!(left instanceof VariableNode_1.VariableNode)) {
            throw new Error("The left hand side of the assignment must be a variable.");
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates assign op by assigning value to var
     * @param context The current context
     */
    eval(context) {
        if (this.left instanceof VariableNode_1.VariableNode) {
            let r = this.right.eval(context);
            context.assign(this.left.name, r);
            return r;
        }
        throw new Error("HALP (in AssignOp)");
    }
    /**
     * Returns a string representation of the AssignOp
     */
    toString() {
        return this._ws + this.left.toString() + ' = ' + this.right.toString();
    }
    /**
     * AssignOps can't be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on AssignOp
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.AssignOp = AssignOp;

},{"../vars/VariableNode":80,"./BinaryOperation":3}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BinaryOperation {
    /**
     * Constructor for the BinOp abstract class
     * @param _left The left side of the binary operation
     * @param _right The right side of the binary operation
     */
    constructor(_left, _right) {
        this._left = _left;
        this._right = _right;
        this._newLine = false;
    }
    ;
    /**
     * Draws the binary operation, if applicable
     * @param context The current program context
     * @param dims The dimensions
     * @param ast The AST
     */
    draw(context, dims, ast) { }
    /**
     * Checks if equal to another expression
     * @param right The right side of the equality
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on BinOp");
    }
    /**
     * Returns a string representation of the binary operation
     */
    toString() { return ""; }
    ;
    /**
     * Gets left side of the binary operation
     */
    get left() {
        return this._left;
    }
    /**
     * Sets left side of the binary operation
     */
    set left(left) {
        this._left = left;
    }
    /**
     * Gets right side of the binary operation
     */
    get right() {
        return this._right;
    }
    /**
     * Sets right side of the binary operation
     */
    set right(right) {
        this._right = right;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.BinaryOperation = BinaryOperation;

},{}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const VariableNode_1 = require("../vars/VariableNode");
// left side is variable, right side is val
// Declares new val
class DeclareOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the declare operation, which declares a variable for the first time
     * @param left The left side of the declare op (the variable)
     * @param right The right side of the op (the value)
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        if (!(left instanceof VariableNode_1.VariableNode)) {
            throw new Error("The left hand side of the assignment must be a variable.");
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the declaration by declaring the variable in the context and assigning the value
     * @param context The current program context
     */
    eval(context) {
        if (this.left instanceof VariableNode_1.VariableNode) {
            context.declare(this.left.name);
            let r = this.right.eval(context);
            context.assign(this.left.name, r);
            return r;
        }
        throw new Error("HALP (in DeclareOp)");
    }
    /**
     * Returns a string representation of the declare op
     */
    toString() {
        return this._ws + "var " + this.left.toString() + ' = ' + this.right.toString();
    }
    /**
     * DeclareOps cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called direcly on a DeclareOp
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.DeclareOp = DeclareOp;

},{"../vars/VariableNode":80,"./BinaryOperation":3}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const MinusOp_1 = require("./MinusOp");
const AssignOp_1 = require("./AssignOp");
const VariableNode_1 = require("../vars/VariableNode");
class Decrement {
    /**
     * Constructor for the decrement operation
     * @param variable The expression to be decremented
     * @param ws Preceding whitespace
     */
    constructor(variable, ws) {
        this.expr = variable;
        if (variable instanceof VariableNode_1.VariableNode) {
            this.innerRep = new AssignOp_1.AssignOp(variable, new MinusOp_1.MinusOp(variable, new NumberNode_1.NumberNode(1)));
        }
        else {
            this.innerRep = new MinusOp_1.MinusOp(variable, new NumberNode_1.NumberNode(1));
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the decrement op to a NumberNode
     * @param context The current program context
     */
    eval(context) {
        return this.innerRep.eval(context);
    }
    /**
     * Returns a string representation of the decrement op
     */
    toString() {
        return this._ws + this.expr.toString() + "--";
    }
    /**
     * Decrement ops can't be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on decrement
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.Decrement = Decrement;

},{"../prims/NumberNode":63,"../vars/VariableNode":80,"./AssignOp":2,"./MinusOp":8}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
class DivOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the division operation
     * @param left The dividend
     * @param right The divisor
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the division and evaluates into a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val / this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Division ops can't be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on a division op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the division
     */
    toString() {
        return this._ws + this.left.toString() + ' / ' + this.right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.DivOp = DivOp;

},{"../prims/NumberNode":63,"../structural/Scope":75,"./BinaryOperation":3}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PlusOp_1 = require("./PlusOp");
const AssignOp_1 = require("./AssignOp");
const VariableNode_1 = require("../vars/VariableNode");
class Increment {
    /**
     * Constructor for Increment
     * @param variable The expression to increment
     * @param ws Tracks preceding whitespace
     */
    constructor(variable, ws) {
        this.expr = variable;
        if (variable instanceof VariableNode_1.VariableNode) {
            this.innerRep = new AssignOp_1.AssignOp(variable, new PlusOp_1.PlusOp(variable, new NumberNode_1.NumberNode(1)));
        }
        else {
            this.innerRep = new PlusOp_1.PlusOp(variable, new NumberNode_1.NumberNode(1, ""));
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates increment into a number node
     * @param context The function scope
     */
    eval(context) {
        return this.innerRep.eval(context);
    }
    /**
     * Increments cannot be drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Cannot call equals directly on binops
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the increment expression
     */
    toString() {
        return this._ws + this.expr.toString() + "++";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.Increment = Increment;

},{"../prims/NumberNode":63,"../vars/VariableNode":80,"./AssignOp":2,"./PlusOp":10}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
class MinusOp extends BinaryOperation_1.BinaryOperation {
    /**
     * The constructor for the subtraction operation
     * @param left The minuend
     * @param right The subrahend
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the subtraction and evaluates to a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val - this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Subtraction ops can't be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on subtraction
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the subtraction op
     */
    toString() {
        return this._ws + this.left.toString() + ' - ' + this.right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.MinusOp = MinusOp;

},{"../prims/NumberNode":63,"../structural/Scope":75,"./BinaryOperation":3}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
class MulOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the multiplication operation
     * @param left The multiplicand
     * @param right The multiplier
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the multiplication and returns a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val * this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Returns a string representation of the multiplication op
     */
    toString() {
        return this._ws + this.left.toString() + ' * ' + this.right.toString();
    }
    /**
     * Multiplication ops cannot be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a multiplicaiton operation
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.MulOp = MulOp;

},{"../prims/NumberNode":63,"../structural/Scope":75,"./BinaryOperation":3}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
// left and right are both expressions
class PlusOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the addition operation
     * @param left The first addend
     * @param right The second addend
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the addition and returns a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val + this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Addition ops cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on an addition op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the addition op
     */
    toString() {
        return this._ws + this.left.toString() + ' + ' + this.right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.PlusOp = PlusOp;

},{"../prims/NumberNode":63,"../structural/Scope":75,"./BinaryOperation":3}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const BooleanNode_1 = require("../prims/BooleanNode");
const space_lift_1 = require("space-lift");
class Conditional {
    /**
     * The constructor for conditionals (if, else if, and else statements)
     * @param test The condition of the statement
     * @param trueBranch The branch to follow if the condition evaluates to true
     * @param falseBranch The branch to follow if the condition evaluates to false
     */
    constructor(test, trueBranch, falseBranch) {
        this._newLine = true;
        this._test = test;
        this._trueBranch = trueBranch;
        this._falseBranch = falseBranch;
    }
    /**
     * Checks the test result and returns the result of the true or false branch, depending on the test
     * @param context The current program context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        let res = this._test.eval(childCtx);
        if (!(res instanceof BooleanNode_1.BooleanNode)) {
            throw new Error("The condition must be a boolean expression.");
        }
        if (res.val) {
            return this._trueBranch.eval(childCtx);
        }
        else if (this._falseBranch != null) { // check if else/else if is null or undefined
            return this._falseBranch.eval(childCtx); // possibly a bad idea
        }
    }
    /**
     * Returns a string representation of the conditional statement
     */
    toString() {
        let res = 'if(' + this._test.toString() + ") {\n " + this._trueBranch.toString() + "}";
        if (this._falseBranch !== undefined) {
            res += '\nelse {\n ' + this._falseBranch.toString() + '}';
        }
        return res;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the true branch of the conditional
     */
    get trueBranch() {
        return this._trueBranch;
    }
    /**
     * Returns the false branch of the conditional
     */
    get falseBranch() {
        return this._falseBranch;
    }
    /**
     * Conditionals cannot be drawn directly
     */
    draw() {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a conditional
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on conditionals");
    }
}
exports.Conditional = Conditional;

},{"../prims/BooleanNode":61,"../structural/Scope":75,"space-lift":89}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class CurveEffect {
    constructor(curve) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._curve = curve;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        let curvature = this.curvature;
        this._ctx.beginPath();
        this._ctx.moveTo(x, y);
        let v = this.perpendicularVector(width, height);
        this._ctx.quadraticCurveTo((x + width / 2) + curvature * v[0], (y + height / 2) + curvature * v[1], x + width, y + height);
        this._ctx.strokeStyle = "#673AB7";
        this._ctx.stroke();
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    //a * w + b * h = 0
    perpendicularVector(w, h) {
        if (w == 0 && h == 0) {
            return [0, 0];
        }
        else if (w == 0) {
            return [1, 0];
        }
        else if (h == 0) {
            return [0, 1];
        }
        return [1, (-w) / h];
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) { // a corner guide is selected
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) { // a middle guide is selected
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else { //if no guides are selected, colors everything white
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._curve.dx = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._curve.dy = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._curve.dy = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._curve.dx = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._curve.dx = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._curve.dy = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._curve.dx = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._curve.dy = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.h > 10) { //as long as the height is > 10
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10) { // as long as width is > 10
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) { // sets the offsets depending on which corner is selected
                case 1: // top left
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w; // offset is bottom right
                    this._dragoffy = y + h;
                    break;
                case 2: // top right
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h; // offset is bottom left, etc
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) { // sets the offsets depending on which middle guide is selected
                case 5: // top middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2; // offset is bottom middle
                    this._dragoffy = y + h;
                    break;
                case 6: //right middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2; // offset is left middle etc
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) { // dragging
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) { // not selected
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isChangingDims = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a rectangle paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("rectangle", this.x, this.y);
    }
    /**
     * Logs a rectangle resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("rectangle with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs a rectangle click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("rectangle with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the rect
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the rect
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the rect
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the rect
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the curvature of the curve
     */
    get curvature() {
        return this._dims.curvature.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the rect is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the rect
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the rect has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the rect has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the rect is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " rectangle with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("rectangle with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to rectangle at " + this.x + ", " + this.y);
    }
}
exports.CurveEffect = CurveEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":63}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const NumberNode_1 = require("../prims/NumberNode");
const ClickEvent_1 = require("../logging/ClickEvent");
class EllipseEffect {
    constructor(circle) {
        this._corner = 0;
        this._isSelected = false; // Private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false; // Has this object just been dragged?
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._circle = circle;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        // logging
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        this._ctx.beginPath();
        this._ctx.ellipse(x, y, w / 2, h / 2, 0, 0, Math.PI * 2, false);
        //this._ctx.strokeStyle = "black";
        //this._ctx.stroke();
        this._ctx.fillStyle = "#D5B8FF";
        this._ctx.shadowColor = "#6C6C6C";
        this._ctx.shadowBlur = 15;
        //this._ctx.shadowOffsetX = 2;
        //this._ctx.shadowOffsetY = 2;
        this._ctx.fill();
        if (this._isSelected) {
            this.drawGuides(x - w / 2, y - h / 2, w, h, this._corner);
        }
    }
    /*
        private mouseMove = this.onMouseMove.bind(this);
        private mouseDown = this.onMouseDown.bind(this);
        private mouseUp = this.onMouseUp.bind(this);
        private shiftDown = this.onShiftDown.bind(this);
        private shiftUp = this.onShiftUp.bind(this);
        private mouseOutside = this.isMouseOutside.bind(this);
        private selectStart = function(e:any) { e.preventDefault(); return false; };
    */
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    removeEventListeners() {
        /*
        console.log("removing EventListners");
          this._canvas.removeEventListener('mousemove', this.mouseMove); // bind in order to maintain the meaning of 'this'
          this._canvas.removeEventListener('mousedown', this.mouseDown);
          this._canvas.removeEventListener('mouseup', this.mouseUp);
          window.removeEventListener('keydown', this.shiftDown);
          window.removeEventListener('keyup', this.shiftUp);
          window.removeEventListener('mousedown', this.mouseOutside);
          //makes it so that double clicking doesn't select text on the page
          this._canvas.removeEventListener('selectstart', this.selectStart, false);
          */
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        return Math.pow(mx - x, 2) / Math.pow(w / 2, 2) + Math.pow(my - y, 2) / Math.pow(h / 2, 2) <= 1;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - (x - w / 2);
        let ydif = my - (y - h / 2);
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - (x - w / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - x;
        ydif = my - (y - h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - (x - w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) {
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0 && corner > 4) {
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else {
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 14, this.h < 14);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 14, this.h < 14);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        //console.log("I'm an ellipse!");
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //console.log("ellipse dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 14 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     * @param widthTooSmall true if the width dimension is < 14
     * @param heightTooSmall true if the height dimension is < 14
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 14;
            this._circle.width = new NumberNode_1.NumberNode(14); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 14 / this._ratio;
            this._circle.height = new NumberNode_1.NumberNode(Math.round(14 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._initDistance = newDistance;
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 14;
            this._circle.height = new NumberNode_1.NumberNode(14); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 14 * this._ratio;
            this._circle.width = new NumberNode_1.NumberNode(Math.round(14 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._initDistance = newDistance;
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
            this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
            this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
            this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
            this._initDistance = newDistance;
        }
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (this._corner == 5 || this._corner == 7) { // if modifying height
            if (!heightTooSmall) {
                this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._initDistance = newDistance;
                this._ratio = this.w / this.h; // setting width/height ratio = to the new ratio
            }
            else {
                this._dims.height.eval(this._context).val = 14;
                this._circle.height = new NumberNode_1.NumberNode(14);
                this._ratio = this.w / this.h;
                if (newDistance - this._initDistance > 0) {
                    this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                    this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                    this._initDistance = newDistance;
                    this._ratio = this.w / this.h;
                }
            }
        }
        else { // modifying width
            if (!widthTooSmall) {
                this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._initDistance = newDistance;
                this._ratio = this.w / this.h;
            }
            else {
                this._dims.width.eval(this._context).val = 14;
                this._circle.width = new NumberNode_1.NumberNode(14);
                this._ratio = this.w / this.h;
                if (newDistance - this._initDistance > 0) {
                    this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                    this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                    this._initDistance = newDistance;
                    this._ratio = this.w / this.h;
                }
            }
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
            else {
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = guideContains;
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
            this._width1 = this.w;
            this._height1 = this.h;
            //this._size1 = Math.sqrt(Math.pow(this.w,2) + Math.pow(this.h,2)); // saving old size
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
        }
        else if (contains) { //simply selecting the shape or dragging
            this._x1 = this.x; // Saving original x and y
            this._y1 = this.y;
            this._isSelected = true;
            this._isDragging = true;
            this._context.eventLog.push(this.logClick());
            this._dragoffx = this._mouse.x - this.x;
            this._dragoffy = this._mouse.y - this.y;
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) { // probs only need dragging but oh well | isSel || selMul?
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
                //this._context.eventLog.push(this.logMove());
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            //console.log("resizing ellipse");
            this._isResizing = false;
            //let size2 = Math.sqrt(Math.pow(this.w,2) + Math.pow(this.h,2));
            //console.log("Size diff: " + Math.abs(this._size1 - size2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        // if(this._isSelectingMultiple){
        //     if(Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
        //         this._context.eventLog.push(this.logMove());
        //     }
        // }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("ellipse", this.x, this.y);
    }
    /**
     * Logs a resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("ellipse with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
        //Math.round(this._size1*100)/100, Math.round((Math.sqrt(Math.pow(this.w,2) + Math.pow(this.h,2))*100))/100);
    }
    /**
     * Logs a click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("ellipse with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the ellipse
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the ellipse
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the ellipse
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the ellipse
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the ellipse is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the ellipse
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the ellipse has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the ellipse has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the ellipse is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return (" ellipse with ID " + this.getID().toString() + " at " + this.x + ", " + this.y);
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("ellipse with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to ellipse at " + this.x + ", " + this.y);
    }
}
exports.EllipseEffect = EllipseEffect;
/**
 * Get's the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":63}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class EphEffect {
    constructor(eph) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._eph = eph;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ephImg = new Image();
            this._ephImg.src = './pics/demoncow.png';
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        //var imgObj = new Image();
        //let ctx = this._canvas.getContext('2d');
        // this._ephImg = new Image();
        // this._ephImg.src = './pics/demoncow.png';
        //imgObj.onload = function(){
        //this._ephImg.onload = function(){
        this._ctx.drawImage(this._ephImg, this.x, this.y, width, height);
        //this._ephImg.onload = function(){
        // this._ephImg.width = width;
        // this._ephImg.height = height;
        //}
        //}
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) {
            switch (corner) { //colors the coreph guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) {
            switch (corner) { //colors the coreph guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else {
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * @param event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //console.log("ephangle dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._eph.width = new NumberNode_1.NumberNode(10);
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._eph.height = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._eph.height = new NumberNode_1.NumberNode(10);
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._eph.width = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._eph.width = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._eph.height = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._eph.width = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._eph.height = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.w > 10 && this.h > 10) {
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._eph.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._eph.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._eph.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10 && this.h > 10) {
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._eph.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) {
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) {
                case 1:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h;
                    break;
                case 2:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h;
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
            //this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h / 2);
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) {
                case 5:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y + h;
                    break;
                case 6:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2;
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) {
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let eph = this._canvas.getBoundingClientRect();
        if (mouseX < eph.left || mouseX > eph.right || mouseY < eph.top || mouseY > eph.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs an eph paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("eph", this.x, this.y);
    }
    /**
     * Logs an eph resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("eph with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs an eph click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("eph with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Not implemented");
    }
    updateAST() {
        throw new Error("Not implemented");
    }
    /**
     * Returns the x position of the eph
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the eph
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the eph
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the eph
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the eph is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the image
     */
    get image() {
        return this._ephImg;
    }
    /**
     * Returns the ID of the eph
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the eph has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the eph has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the eph is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " eph with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("eph with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to eph at " + this.x + ", " + this.y);
    }
}
exports.EphEffect = EphEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let eph = canvas.getBoundingClientRect();
    return {
        x: event.clientX - eph.left,
        y: event.clientY - eph.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":63}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class LineEffect {
    constructor(line) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._line = line;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        this._ctx.moveTo(x, y);
        this._ctx.lineTo(x + width, y + height);
        this._ctx.strokeStyle = "#673AB7";
        this._ctx.stroke();
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) { // a corner guide is selected
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) { // a middle guide is selected
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else { //if no guides are selected, colors everything white
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._line.dx = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._line.dy = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._line.dy = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._line.dx = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._line.dx = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._line.dy = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._line.dx = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._line.dy = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.h > 10) { //as long as the height is > 10
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._line.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._line.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._line.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10) { // as long as width is > 10
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._line.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) { // sets the offsets depending on which corner is selected
                case 1: // top left
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w; // offset is bottom right
                    this._dragoffy = y + h;
                    break;
                case 2: // top right
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h; // offset is bottom left, etc
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) { // sets the offsets depending on which middle guide is selected
                case 5: // top middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2; // offset is bottom middle
                    this._dragoffy = y + h;
                    break;
                case 6: //right middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2; // offset is left middle etc
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) { // dragging
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) { // not selected
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isChangingDims = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a rectangle paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("rectangle", this.x, this.y);
    }
    /**
     * Logs a rectangle resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("rectangle with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs a rectangle click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("rectangle with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the rect
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the rect
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the rect
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the rect
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the rect is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the rect
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the rect has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the rect has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the rect is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " rectangle with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("rectangle with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to rectangle at " + this.x + ", " + this.y);
    }
}
exports.LineEffect = LineEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":63}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class NumberEffect {
    constructor(num) {
        this._fontSize = 20;
        this._corner = 0;
        this._isEditing = false;
        this._isListening = false;
        this._isDragging = false;
        this._isResizing = false;
        this._isSelectingMultiple = false;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._numberMetrics = {
            width: 0,
            height: 0,
            interval: 0,
            str: "",
            initMousePos: 0,
            cursorPos: 0
        };
        this._num = num;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas != undefined) {
            this._context = context;
            this._canvas = context.canvas.get();
            this._dims = dims;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this.update();
            // logging
            this._context.eventLog.push(this.logPaint()); // this.context or context?
            context.effects.push(this);
            this.addEventListeners();
        }
        else {
            console.log("canvas is NOT defined");
        }
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let fontDeets = this._fontSize + "px Courier New";
        this._ctx.font = fontDeets;
        this._ctx.fillStyle = "#673AB7";
        let str = this._num.toString();
        this._ctx.fillText(str, this.x, this.y);
        let numberDims = this._ctx.measureText(str);
        this._numberMetrics.width = numberDims.width;
        this._numberMetrics.height = this._fontSize;
        this._numberMetrics.str = str;
        this._numberMetrics.interval = this._numberMetrics.width / this._numberMetrics.str.length;
        if (this._isSelected) {
            this.drawTextGuides(this.x, this.y - this._fontSize, this._numberMetrics.width, this._numberMetrics.height, this._corner);
        }
        if (this._isEditing) {
            this.modifyTextCursor();
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        return (this.x <= mx) && (this.x + this._numberMetrics.width >= mx) &&
            (this.y - this._fontSize <= my) && (this.y >= my);
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let xdif = mx - (this.x + this._numberMetrics.width);
        let ydif = my - (this.y - this._fontSize);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) {
            this._isEditing = false;
            return 2;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawTextGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0) {
            switch (corner) { //colors the guide blue if selected
                case 2:
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue');
                    break;
            }
        }
        else {
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white');
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /* Event listener functions */
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isSelected && this._isDragging) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this._fontSize < 15);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        if (!this._isSelectingMultiple && this._isSelected && this.contains(this._mouse.x, this._mouse.y)) { //text editing
            if (!this._isListening) {
                window.addEventListener('keydown', this.modifyText.bind(this));
            }
            this._isListening = true;
            this._isEditing = true;
            this._isDragging = false;
            this._numberMetrics.initMousePos = this._mouse.x;
            this.modifyTextCursor();
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isEditing = false;
        }
        else {
            this._isEditing = false;
        }
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y) > 0, this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //("string dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Creates and moves the text edit cursor based on where the mouse is clicked
     */
    modifyTextCursor() {
        let leftWall = this.x; // the x position of the left most side of the bounding rectangle
        let xDif = this._numberMetrics.initMousePos - leftWall; // difference between mouse x and left wall
        let interval = this._numberMetrics.interval; // the text width divided by the length of the string
        let moveFactor = 0;
        if (xDif >= interval / 2 && xDif <= interval) {
            moveFactor = leftWall + interval;
            this._numberMetrics.cursorPos = interval;
        }
        else if (xDif <= interval / 2) {
            moveFactor = leftWall;
            this._numberMetrics.cursorPos = 0;
        }
        else if (xDif % interval >= interval / 2) {
            moveFactor = leftWall + interval * Math.ceil(xDif / interval);
            this._numberMetrics.cursorPos = interval * Math.ceil(xDif / interval);
        }
        else if (xDif % interval < interval / 2) {
            moveFactor = leftWall + interval * Math.floor(xDif / interval);
            this._numberMetrics.cursorPos = interval * Math.floor(xDif / interval);
        }
        this._ctx.moveTo(moveFactor, this.y - this._fontSize);
        this._ctx.lineTo(moveFactor, this.y);
        this._ctx.strokeStyle = "grey";
        this._ctx.stroke();
    }
    /**
     * This edits the string when editing text
     * @param event keydown event
     */
    modifyText(event) {
        if (this._isEditing) {
            let firstHalf;
            let secondHalf;
            let str = this._num.toString();
            let breakPoint = this._numberMetrics.cursorPos / this._numberMetrics.interval;
            firstHalf = str.substring(0, breakPoint);
            secondHalf = str.substring(breakPoint);
            if (event.keyCode == 37 && this._numberMetrics.initMousePos > this.x + this._numberMetrics.interval / 2) {
                this._numberMetrics.initMousePos -= this._numberMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 39 && this._numberMetrics.initMousePos < this.x + this._numberMetrics.width) {
                this._numberMetrics.initMousePos += this._numberMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 8 && str.length > 0) {
                firstHalf = firstHalf.substring(0, firstHalf.length - 1);
                str = firstHalf + secondHalf;
                this._num.val = Number(str);
                this._numberMetrics.initMousePos -= this._numberMetrics.interval;
                this.modifyTextCursor();
            }
            else {
                let keyName = event.key;
                if (keyName.length == 1) {
                    firstHalf += keyName;
                    str = firstHalf + secondHalf;
                    this._num.val = Number(str);
                    this._numberMetrics.initMousePos += this._numberMetrics.interval;
                    this.modifyTextCursor();
                }
            }
        }
    }
    /**
     * Modifies the font size of the text
     * If the text font is smaller than 15pt, it set's it equal to 15pt
     * @param isTooSmall true if the font size is < 15
     */
    modifyResize(isTooSmall) {
        if (isTooSmall) {
            this._fontSize = 15;
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._fontSize += (newDistance - this._initDistance) * 0.2;
                this._initDistance = newDistance;
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this._fontSize += (newDistance - this._initDistance) * 0.2;
            this._initDistance = newDistance;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x = this.x;
                this._y = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
            else {
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
                this._isDragging = true;
            }
            // if(this._context.mulSelected.mulSel){
            //     console.log("string effect mulSelected: " + this._context.mulSelected.mulSel);
            //     //if(this._context.mulSelected.val){
            //     this._context.eventLog.push(this.logSelected());
            //     //this.logSelected();
            // }
        }
        else if (guideContains) { //if the corner guides contain the mouse we are resizing
            this._isSelected = true;
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._context.eventLog.push(this.logClick());
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
            this._isResizing = true;
            this._size1 = this._fontSize; // saving old font size
        }
        else if (contains) {
            this._x = this.x; // Saving original x and y
            this._y = this.y;
            this._isSelected = true;
            this._context.eventLog.push(this.logClick());
            this._dragoffx = this._mouse.x - this.x;
            this._dragoffy = this._mouse.y - this.y;
            if (!this._isEditing) {
                this._isDragging = true;
            }
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
            this._isEditing = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x - this.x) > 1 || Math.abs(this._y - this.y) > 1) {
                this._justDragged = true;
                //this._context.eventLog.push(this.logMove());
            }
        }
        else if (this._isResizing && this._isSelected) {
            this._isResizing = false;
            if (Math.abs(this._size1 - this._fontSize) > 0) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._corner = 0;
        // console.log("string effect mulSelected: " + this._context.mulSelected.val);
        // if(this._context.mulSelected.val){
        //     this.logSelected();
        // }
        // if(this.isMultipleSelected){
        //     context.eventLog.push(new SelectEvent(selectedElems));
        //     masterLog.push(context.eventLog[context.eventLog.length - 1]);
        //     //console.log("multiple selected");
        // }
        // //this._context.eventLog.push(this.logMove());
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._isEditing = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent(this._num.toString(), this.x, this.y);
    }
    /**
     * Logs a resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent(this._num.toString() + " with ID " + this.getID().toString(), Math.round(this._size1 * 100) / 100, Math.round(this._fontSize * 100) / 100);
    }
    /**
     * Logs a click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent(this._num.toString() + " with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id, };
    }
    /**
     * Returns the canvas
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Sets the canvas
     * @param canvas The canvas to be assigned
     */
    set canvas(canvas) {
        this._canvas = canvas;
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the number
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the number
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
    * Returns whether or not the ellipse has just been dragged
    */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the ellipse has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the ellipse is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Returns whether or not this is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the number
     */
    get num() {
        return this._num.val;
    }
    /**
     * Returns the object ID
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " " + this._num.toString() + " with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return (this._num.toString() + " with ID " + this.getID().toString() + " from " + this._x + ", " + this._y + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to " + this._num.toString() + " at " + this.x + ", " + this.y);
    }
}
exports.NumberEffect = NumberEffect;
/**
 * Get's the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class RectangleEffect {
    constructor(rect) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._rect = rect;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        this._ctx.rect(x, y, width, height);
        //this._ctx.strokeStyle = "black";
        //this._ctx.stroke();
        this._ctx.fillStyle = "#d5b8ff";
        this._ctx.shadowColor = "#6C6C6C";
        this._ctx.shadowBlur = 15;
        //this._ctx.shadowOffsetX = 2;
        //this._ctx.shadowOffsetY = 2;
        this._ctx.fill();
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) { // a corner guide is selected
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) { // a middle guide is selected
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else { //if no guides are selected, colors everything white
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._rect.width = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._rect.height = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._rect.height = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._rect.width = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._rect.width = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._rect.height = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._rect.width = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._rect.height = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.h > 10) { //as long as the height is > 10
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._rect.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._rect.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._rect.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10) { // as long as width is > 10
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._rect.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) { // sets the offsets depending on which corner is selected
                case 1: // top left
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w; // offset is bottom right
                    this._dragoffy = y + h;
                    break;
                case 2: // top right
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h; // offset is bottom left, etc
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) { // sets the offsets depending on which middle guide is selected
                case 5: // top middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2; // offset is bottom middle
                    this._dragoffy = y + h;
                    break;
                case 6: //right middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2; // offset is left middle etc
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) { // dragging
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) { // not selected
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isChangingDims = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a rectangle paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("rectangle", this.x, this.y);
    }
    /**
     * Logs a rectangle resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("rectangle with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs a rectangle click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("rectangle with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the rect
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the rect
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the rect
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the rect
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the rect is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the rect
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the rect has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the rect has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the rect is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " rectangle with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("rectangle with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to rectangle at " + this.x + ", " + this.y);
    }
}
exports.RectangleEffect = RectangleEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":63}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class StringEffect {
    constructor(str) {
        this._fontSize = 20;
        //private _size2: number;
        this._corner = 0;
        this._isSelected = false; // Private bools
        this._isEditing = false;
        this._isListening = false;
        this._isDragging = false;
        this._isResizing = false;
        this._isSelectingMultiple = false;
        this._justDragged = false; // Has this object just been dragged?
        //private _log: string[];
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._textMetrics = {
            width: 0,
            height: 0,
            interval: 0,
            str: "",
            initMousePos: 0,
            cursorPos: 0
        };
        this._str = str;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas != undefined) {
            this._context = context;
            this._canvas = context.canvas.get();
            this._dims = dims;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this.update();
            // logging
            this._context.eventLog.push(this.logPaint()); // this.context or context?
            context.effects.push(this);
            this.addEventListeners();
        }
        else {
            console.log("canvas is NOT defined");
        }
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let fontDeets = this._fontSize + "px Courier New";
        this._ctx.font = fontDeets;
        this._ctx.fillStyle = "#673AB7";
        this._ctx.fillText(this._str.val, this.x, this.y);
        let textDims = this._ctx.measureText(this._str.val);
        this._textMetrics.width = textDims.width;
        this._textMetrics.height = this._fontSize;
        this._textMetrics.str = this._str.val;
        this._textMetrics.interval = this._textMetrics.width / this._textMetrics.str.length;
        if (this._isSelected) {
            this.drawTextGuides(this.x, this.y - this._fontSize, this._textMetrics.width, this._textMetrics.height, this._corner);
        }
        if (this._isEditing) {
            this.modifyTextCursor();
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        return (this.x <= mx) && (this.x + this._textMetrics.width >= mx) &&
            (this.y - this._fontSize <= my) && (this.y >= my);
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let xdif = mx - (this.x + this._textMetrics.width);
        let ydif = my - (this.y - this._fontSize);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) {
            this._isEditing = false;
            return 2;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawTextGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0) {
            switch (corner) { //colors the guide blue if selected
                case 2:
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue');
                    break;
            }
        }
        else {
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white');
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /* Event listener functions */
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isSelected && this._isDragging) {
            //console.log(this._str.val + " is being dragged.");
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this._fontSize < 15);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        if (!this._isSelectingMultiple && this._isSelected && this.contains(this._mouse.x, this._mouse.y)) { //text editing
            if (!this._isListening) {
                window.addEventListener('keydown', this.modifyText.bind(this));
            }
            this._isListening = true;
            this._isEditing = true;
            this._isDragging = false;
            //console.log(this._str.val + " is setting dragging to false");
            this._textMetrics.initMousePos = this._mouse.x;
            this.modifyTextCursor();
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isEditing = false;
        }
        else {
            this._isEditing = false;
        }
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y) > 0, this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //("string dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Creates and moves the text edit cursor based on where the mouse is clicked
     */
    modifyTextCursor() {
        let leftWall = this.x; // the x position of the left most side of the bounding rectangle
        let xDif = this._textMetrics.initMousePos - leftWall; // difference between mouse x and left wall
        let interval = this._textMetrics.interval; // the text width divided by the length of the string
        let moveFactor = 0;
        if (xDif >= interval / 2 && xDif <= interval) {
            moveFactor = leftWall + interval;
            this._textMetrics.cursorPos = interval;
        }
        else if (xDif <= interval / 2) {
            moveFactor = leftWall;
            this._textMetrics.cursorPos = 0;
        }
        else if (xDif % interval >= interval / 2) {
            moveFactor = leftWall + interval * Math.ceil(xDif / interval);
            this._textMetrics.cursorPos = interval * Math.ceil(xDif / interval);
        }
        else if (xDif % interval < interval / 2) {
            moveFactor = leftWall + interval * Math.floor(xDif / interval);
            this._textMetrics.cursorPos = interval * Math.floor(xDif / interval);
        }
        this._ctx.moveTo(moveFactor, this.y - this._fontSize);
        this._ctx.lineTo(moveFactor, this.y);
        this._ctx.strokeStyle = "grey";
        this._ctx.stroke();
    }
    /**
     * This edits the string when editing text
     * @param event keydown event
     */
    modifyText(event) {
        if (this._isEditing) {
            let firstHalf;
            let secondHalf;
            let breakPoint = this._textMetrics.cursorPos / this._textMetrics.interval;
            firstHalf = this._str.val.substring(0, breakPoint);
            secondHalf = this._str.val.substring(breakPoint);
            if (event.keyCode == 37 && this._textMetrics.initMousePos > this.x + this._textMetrics.interval / 2) {
                this._textMetrics.initMousePos -= this._textMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 39 && this._textMetrics.initMousePos < this.x + this._textMetrics.width) {
                this._textMetrics.initMousePos += this._textMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 8 && this._str.val.length > 0) {
                firstHalf = firstHalf.substring(0, firstHalf.length - 1);
                this._str.str = firstHalf + secondHalf;
                this._textMetrics.initMousePos -= this._textMetrics.interval;
                this.modifyTextCursor();
            }
            else {
                let keyName = event.key;
                if (keyName.length == 1) {
                    firstHalf += keyName;
                    this._str.str = firstHalf + secondHalf;
                    this._textMetrics.initMousePos += this._textMetrics.interval;
                    this.modifyTextCursor();
                }
            }
        }
    }
    /**
     * Modifies the font size of the text
     * If the text font is smaller than 15pt, it set's it equal to 15pt
     * @param isTooSmall true if the font size is < 15
     */
    modifyResize(isTooSmall) {
        if (isTooSmall) {
            this._fontSize = 15;
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._fontSize += (newDistance - this._initDistance) * 0.2;
                this._initDistance = newDistance;
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this._fontSize += (newDistance - this._initDistance) * 0.2;
            this._initDistance = newDistance;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
            else {
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
                this._isDragging = true;
            }
            // if(this._context.mulSelected.mulSel){
            //     console.log("string effect mulSelected: " + this._context.mulSelected.mulSel);
            //     //if(this._context.mulSelected.val){
            //     this._context.eventLog.push(this.logSelected());
            //     //this.logSelected();
            // }
        }
        else if (guideContains) { //if the corner guides contain the mouse we are resizing
            this._isSelected = true;
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._context.eventLog.push(this.logClick());
            //console.log(this._str.val + "is selected?" + this._selected);
            //console.log("state selection is " + this._str.val);
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
            this._isResizing = true;
            this._size1 = this._fontSize; // saving old font size
        }
        else if (contains) {
            this._x1 = this.x; // Saving original x and y
            this._y1 = this.y;
            this._isSelected = true;
            this._context.eventLog.push(this.logClick());
            //console.log(this._str.val + "is selected?" + this._selected);
            //console.log("state selection is " + this._str.val);
            this._dragoffx = this._mouse.x - this.x;
            this._dragoffy = this._mouse.y - this.y;
            if (!this._isEditing) {
                this._isDragging = true;
                //console.log(this._str.val + " is dragging? " + this._isDragging);
            }
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
            this._isEditing = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            //console.log(this._str.val + " logging drag");
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
                //this._context.eventLog.push(this.logMove());
            }
        }
        else if (this._isResizing && this._isSelected) {
            //console.log(this._str.val + " logging resize");
            this._isResizing = false;
            if (Math.abs(this._size1 - this._fontSize) > 0) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._corner = 0;
        // console.log("string effect mulSelected: " + this._context.mulSelected.val);
        // if(this._context.mulSelected.val){
        //     this.logSelected();
        // }
        // if(this.isMultipleSelected){
        //     context.eventLog.push(new SelectEvent(selectedElems));
        //     masterLog.push(context.eventLog[context.eventLog.length - 1]);
        //     //console.log("multiple selected");
        // }
        // //this._context.eventLog.push(this.logMove());
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._isEditing = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent(this._str.val, this.x, this.y);
    }
    /**
     * Logs a resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent(this._str.val + " with ID " + this.getID().toString(), Math.round(this._size1 * 100) / 100, Math.round(this._fontSize * 100) / 100);
    }
    /**
     * Logs a click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent(this._str.val + " with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id, };
    }
    /**
     * Returns the canvas
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Sets the canvas
     * @param canvas The canvas to be assigned
     */
    set canvas(canvas) {
        this._canvas = canvas;
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the ellipse
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the ellipse
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
    * Returns whether or not the ellipse has just been dragged
    */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the ellipse has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the ellipse is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Returns whether or not this is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the string
     */
    get str() {
        return this._str.val;
    }
    /**
     * Returns the object ID
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " " + this._str.val + " with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return (this._str.val + " with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to " + this._str.val + " at " + this.x + ", " + this.y);
    }
}
exports.StringEffect = StringEffect;
/**
 * Get's the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ReturnError_1 = require("../structural/ReturnError");
const space_lift_1 = require("space-lift");
// Application of a function. Assumes arg values passed in same order as FunDef args
class FunApp {
    /**
     * The constructor for a function application
     * @param name The name of the function
     * @param args Function arguments, if applicable
     * @param ws Preceding whitespace
     * @param defaultValue The default return value of the function, if any
     */
    constructor(name, args, ws, defaultValue) {
        this._defaultValue = undefined;
        this._newLine = false;
        this._name = name;
        this._args = args;
        this._defaultValue = defaultValue;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the function application
     * @param context
     */
    eval(context) {
        let fundef = context.lookup(this._name, context); // looking up function
        //let child = new Scope(fundef.scope); // avoiding overwrite; need to toss after returning
        let child = fundef.scope.copy(); // Copying definition scope
        // Assigns arg values to definition arguments
        if (this._args != null) {
            for (let i = 0; i < this._args.length; i++) { //lookups?
                //child.declare(this._funct.args[i]); // redeclare?
                child.assign(fundef.args[i], this._args[i]);
            }
        }
        let id = context.globalFunID; // Assigns an ID to the function
        context.globalFunID++;
        child.retValID = space_lift_1.Some(id); // new method
        // we only return a value with function application
        // if it is explicitly returned using a return statement;
        // we abuse JS exceptions for this purpose
        try {
            child.hadFunEval = true;
            fundef.body.eval(child);
            return this._defaultValue;
        }
        catch (e) {
            // make sure that we catch only the error intended for us
            if (e instanceof ReturnError_1.ReturnError && parseInt(e.ID) == id) {
                return e.retVal;
            }
            // error was not intended for us; rethrow
            throw e;
        }
        //return fundef.body.eval(child);
    }
    /**
     * Returns a string representation of the function application
     */
    toString() {
        let argsList = '';
        if (this._args.length > 0) {
            for (let i = 0; i < this._args.length - 1; i++) {
                argsList += this._args[i].toString() + ", ";
            }
            argsList += this._args[this._args.length - 1].toString();
        }
        return this._ws + this.name + '(' + argsList + ")";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Function applications cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a function application
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on functions");
    }
    /**
     * Returns the name of the function
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the arguments of the function
     */
    get args() {
        return this._args;
    }
}
exports.FunApp = FunApp;

},{"../structural/ReturnError":74,"space-lift":89}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
class FunDef {
    constructor(name, body, args, ws) {
        this._newLine = true;
        this._name = name;
        this._body = body;
        this._args = args;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    ;
    // Binds args in context of definition; no values
    // Binds name to parent context (cur context is new context)
    eval(context) {
        this._funScope = new Scope_1.Scope(context); // ************* copy????
        this._funScope.canvas = context.canvas;
        this._funScope.eventLog = context.eventLog;
        this._funScope.effects = context.effects;
        /*
        if(this._args != null){
            for(let entry of this._args){
                this._funScope.declare(entry);
            }
        }
        */
        context.declare(this._name); // assign with val function
        context.assign(this._name, this); // parent or current?
        return null;
    }
    newLine() {
        return this._newLine;
    }
    toString() {
        let argsList = '';
        if (this._args.length > 0) {
            for (let i = 0; i < this._args.length - 1; i++) {
                argsList += this._args[i] + ", ";
            }
            argsList += this._args[this._args.length - 1];
        }
        return this._ws + "fun " + this._name + "(" + argsList + ')' + ' {\n ' + this._body.toString() + '}';
    }
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    equalsVal(right) {
        throw new Error("Cannot call equals directly on functions");
    }
    // Get methods
    get name() {
        return this._name;
    }
    get body() {
        return this._body;
    }
    get args() {
        return this._args;
    }
    get scope() {
        return this._funScope;
    }
}
exports.FunDef = FunDef;

},{"../structural/Scope":75}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ListNode {
    /**
     * Constructor for an array-like list
     * @param list The list, stored in a TS array
     * @param ws Preceding whitespace
     */
    constructor(list, ws) {
        this._newLine = false;
        this._list = list;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates each element of the list and pushes it onto the internal representation
     * @param context
     */
    eval(context) {
        let evalList = [];
        for (let expr of this._list) {
            evalList.push(expr.eval(context));
        }
        return new ListNode(evalList);
    }
    /**
     * Returns a string representation of the list
     */
    toString() {
        let list = '';
        for (let i = 0; i < this._list.length - 1; i++) {
            list += this._list[i].toString() + ", ";
        }
        list += this._list[this._list.length - 1].toString();
        return this._ws + '[' + list + ']';
    }
    /**
     * Returns whether the list equals another list
     * @param right The right side of the equality (must be a ListNode)
     */
    equalsVal(right) {
        if (right instanceof ListNode) {
            for (let i = 0; i < this.list.length; i++) {
                if (!(this.list[i].equalsVal(right.list[i]))) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Draw cannot be called directly on a list
     */
    draw() {
        throw new Error("Cannot draw a ListNode");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the internal representation of the list
     */
    get list() {
        return this._list;
    }
}
exports.ListNode = ListNode;

},{}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class ClearEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for the Clear Event, which logs when the canvas is cleared
     * @param toLog What to log (spoiler: nothing)
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "clear";
    }
    /**
     * Assembles and returns message "Console cleared" with date and time attached
     */
    assembleLog() {
        let toPrint = "Console cleared";
        return this.logItem(toPrint);
    }
}
exports.ClearEvent = ClearEvent;

},{"./LogEvent":26}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class ClickEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Click Event, which logs when an object on the canvas is clicked
     * @param toLog The string representation of the object to log
     * @param x1 The x coordinate of the object to log
     * @param y1 The y coordinate of the object to log
     */
    constructor(toLog, x1, y1) {
        super(toLog, x1, y1);
        this.tag = "click";
    }
    /**
     * Assembles and returns message of form "Clicked on obj at x, y" with date and time attached
     */
    assembleLog() {
        let toPrint = "Clicked on " + this.toLog + " at " + this.x1.toString() + ", " + this.y1.toString();
        return this.logItem(toPrint);
    }
}
exports.ClickEvent = ClickEvent;

},{"./LogEvent":26}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class DragEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Drag Event, which logs when an object on the canvas is dragged
     * @param toLog The effect to log
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "drag";
        this._toPrint = this.assembleString();
    }
    /**
     * Assembles a log string using the Effect's toDragString() method
     */
    assembleString() {
        this._toPrint = this.toLog.toDragString();
        return this._toPrint;
    }
    /**
     * Assembles and returns final log message of form "Dragged obj from x1, y1 to x2, y2"
     * with date and time attached
     */
    assembleLog() {
        let print = "Dragged " + this._toPrint;
        return this.logItem(print);
    }
}
exports.DragEvent = DragEvent;

},{"./LogEvent":26}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class IDEvent extends LogEvent_1.LogEvent {
    /**
     * A constructor for an ID event, used when an object gets assigned an ID
     * @param toLog The effect to log
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "ID";
        this._toPrint = this.assembleString();
    }
    /**
     * Assembles string using the effect's toIDString() method
     */
    assembleString() {
        this._toPrint = this.toLog.toIDString();
        return this._toPrint;
    }
    /**
     * Assembles message of form "Assigned ID # to obj at x, y" with date and time attached
     */
    assembleLog() {
        let print = "Assigned ID " + this._toPrint;
        return this.logItem(print);
    }
}
exports.IDEvent = IDEvent;

},{"./LogEvent":26}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class LogEvent {
    /**
     * Abstract class constructor for a Log Event. Registers event time.
     * @param toLog The string, object, or array of objects to be logged
     * @param x1 Initial x position, if applicable
     * @param y1 Initial y position, if applicable
     * @param x2 Final x position, if applicable
     * @param y2 Final y position, if applicable
     */
    constructor(toLog, x1, y1, x2, y2) {
        let today = new Date();
        this._date = today.getFullYear() + '-' + (today.getMonth() + 1) + '-' + today.getDate();
        this._time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds();
        this._dateTime = this._date + ' ' + this._time;
        this._toLog = toLog;
        //this._toLogArray = toLogArray;
        this._x1 = x1;
        this._y1 = y1;
        this._x2 = x2;
        this._y2 = y2;
    }
    /**
     * Attaches date and time to log message
     * @param toLog The log message
     */
    logItem(toLog) {
        return " " + this._dateTime + ": " + toLog;
    }
    /**
     * Returns date-time string
     */
    get dateTime() {
        return this._dateTime;
    }
    /**
     * Returns string or effect(s) to be logged
     */
    get toLog() {
        return this._toLog;
    }
    /**
     * Returns event tag
     */
    get tag() {
        return this._tag;
    }
    /**
     * Sets tag string
     */
    set tag(tag) {
        this._tag = tag;
    }
    /**
     * Returns x1
     */
    get x1() {
        return this._x1;
    }
    /**
     * Returns y1
     */
    get y1() {
        return this._y1;
    }
    /**
     * Returns x2
     */
    get x2() {
        return this._x2;
    }
    /**
     * Returns y2
     */
    get y2() {
        return this._y2;
    }
}
exports.LogEvent = LogEvent;

},{}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class PaintEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Paint Event, used when an object is painted on the canvas
     * @param toLog The string representation of the object to be logged
     * @param x1 The x position of the object
     * @param y1 The y position of the object
     */
    constructor(toLog, x1, y1) {
        super(toLog, x1, y1);
        this.tag = "paint";
    }
    /**
     * Assembles and returns message of form "Painted obj at x, y" with date and time attached
     */
    assembleLog() {
        let toPrint = "Painted " + this.toLog + " at " + this.x1.toString() + ", " + this.y1.toString();
        return this.logItem(toPrint);
    }
}
exports.PaintEvent = PaintEvent;

},{"./LogEvent":26}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class ResizeEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for Resize Event, used when an object on the canvas is resized
     * @param toLog String representation of the object to be logged
     * @param x1 Initial x dimension of the object, or initial font size
     * @param y1 Initial y dimension of the object, or final font size
     * @param x2 Final x dimension of the object
     * @param y2 Final y dimension of the object
     */
    constructor(toLog, x1, y1, x2, y2) {
        super(toLog, x1, y1, x2, y2);
        this.tag = "resize";
    }
    /**
     * Assembles log message of form "Resized obj from size x1, y1 to size x1, y2" for rects and ellipses
     * or of form "Resized obj from size x1 to size y1" for strings
     * Has date and time attached
     */
    assembleLog() {
        if (this.x2 != undefined && this.y2 != undefined) {
            this.toPrint = "Resized " + this.toLog + " from size " + this.x1.toString() + " by " + this.y1.toString()
                + " to size " + this.x2.toString() + " by " + this.y2.toString();
        }
        else {
            this.toPrint = "Resized " + this.toLog + " from size " + this.x1.toString() + " to size " + this.y1.toString();
        }
        return this.logItem(this.toPrint);
    }
}
exports.ResizeEvent = ResizeEvent;

},{"./LogEvent":26}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class SelectEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Selection Event, used when multiple objects on the canvas are selected
     * @param toLog The array of objects selected
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "select";
        this._toPrint = this.assembleStrings();
    }
    /**
     * Assembles and returns a string representation of all the objects selected
     */
    assembleStrings() {
        let logStrings = [];
        for (let elem of this.toLog) {
            logStrings.push(elem.toSelString());
        }
        return "Selected" + logStrings;
    }
    /**
     * Returns the message with date and time attached
     */
    assembleLog() {
        return this.logItem(this._toPrint);
    }
}
exports.SelectEvent = SelectEvent;

},{"./LogEvent":26}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class And {
    /**
     * Constructor for logical 'and' (&&) operation
     * @param left The left side of the operation
     * @param right The right side of the operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the operation and returns a boolean of the result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof BooleanNode_1.BooleanNode && rhs instanceof BooleanNode_1.BooleanNode) {
            return new BooleanNode_1.BooleanNode(lhs.val && rhs.val);
        }
        else {
            throw new Error("The arguments to the 'and' operator must be booleans.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + ' and ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on the 'and' op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * The 'and' operation cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns the left side of the op
     */
    get left() {
        return this._left;
    }
    /**
     * Returns the right side of the op
     */
    get right() {
        return this._right;
    }
}
exports.And = And;

},{"../prims/BooleanNode":61}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class Equals {
    /**
     * Constructor for equality (==) operation
     * @param left The left side of the equality
     * @param right The right side of the equality
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the comparison and evaluates to a BooleanNode
     * @param context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        return new BooleanNode_1.BooleanNode(lhs.equalsVal(rhs));
    }
    /**
     * Returns a string representation of the equality op
     */
    toString() {
        return this._ws + this._left.toString() + ' equals ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals can't be called directly on an equality op
     * @param right
     */
    equalsVal(right) {
        throw new Error("well this is meta");
    }
    /**
     * Equality ops can't be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.Equals = Equals;

},{"../prims/BooleanNode":61}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class GreaterThan {
    /**
     * Constructor for GreaterThan (>) op
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs GreaterThan comparison and returns BooleanNode representation of result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val > rhs.val));
        }
        else {
            throw new Error("The arguments to the > operator must be numeric.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + " > " + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on GreaterThan op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * GreaterThan op cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.GreaterThan = GreaterThan;

},{"../prims/BooleanNode":61,"../prims/NumberNode":63}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class GreaterThanEq {
    /**
     * Constructor for GreaterThanEq (greater than or equal to, >=) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs GreaterThanEq operation and returns BooleanNode with result
     * @param context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val >= rhs.val));
        }
        else {
            throw new Error("The arguments to the >= operator must be numeric.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + ' >= ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on GreaterThanEq op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * GreaterThanEq op cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.GreaterThanEq = GreaterThanEq;

},{"../prims/BooleanNode":61,"../prims/NumberNode":63}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class LessThan {
    /**
     * Constructor for LessThan (<) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the LessThan comparison and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        //console.log(this._left.eval(context) + " is less than " + this._right.eval(context));
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            //console.log("They're both number nodes");
            //console.log(lhs.val + "<" + rhs.val);
            //let bool: boolean = lhs.val < rhs.val;
            //console.log("bool: " + bool);
            return (new BooleanNode_1.BooleanNode(lhs.val < rhs.val));
        }
        else {
            throw new Error("Arguments to less than must produce numeric values.");
        }
    }
    /**
     * Returns string representation of operation
     */
    toString() {
        return this._left.toString() + ' < ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on LessThan op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * LessThan op cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.LessThan = LessThan;

},{"../prims/BooleanNode":61,"../prims/NumberNode":63}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class LessThanEq {
    /**
     * Constructor for LessThanEq (less than or equal to, <=) operation
     * @param left The left side of the operation
     * @param right The right side of the operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the LessThanEq comparison and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val <= rhs.val));
        }
        else {
            throw new Error("The arguments to the <= operator must be numeric.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + " <= " + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on LessThanEq op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * LessThanEq ops cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.LessThanEq = LessThanEq;

},{"../prims/BooleanNode":61,"../prims/NumberNode":63}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class Not {
    /**
     * Constructor for the logical Not (!) operation
     * @param expr The expression to be operated on (must be a BooleanNode)
     * @param ws Preceding whitespace
     */
    constructor(expr, ws) {
        this._newLine = false;
        this._expr = expr;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the Not operation and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        let e = this._expr.eval(context);
        if (e instanceof BooleanNode_1.BooleanNode) {
            return new BooleanNode_1.BooleanNode(!e.val);
        }
        else {
            throw new Error("The argument to the ! operator must be boolean.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + "not " + this._expr.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on a Not op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * Not operations cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns expression to be operated on
     */
    get expr() {
        return this._expr;
    }
}
exports.Not = Not;

},{"../prims/BooleanNode":61}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class NotEqual {
    /**
     * Constructor for NotEqual (!=) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs NotEqual operation and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val !== rhs.val));
        }
        else {
            throw new Error("The arguments to the != operator must be numeric.");
        }
    }
    /**
     * Returns string representation of operation
     */
    toString() {
        return this._ws + this._left.toString() + " not equals " + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on a NotEqual op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * NotEqual ops cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.NotEqual = NotEqual;

},{"../prims/BooleanNode":61,"../prims/NumberNode":63}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class Or {
    /**
     * Constructor for logical 'or' (||) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs Or operation and returns BooleanNode with result
     * @param context Current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof BooleanNode_1.BooleanNode && rhs instanceof BooleanNode_1.BooleanNode) {
            return new BooleanNode_1.BooleanNode(lhs.val || rhs.val);
        }
        else {
            throw new Error("The arguments to the 'or' operator must be booleans.");
        }
    }
    /**
     * Returns string representation of operation
     */
    toString() {
        return this._ws + this._left.toString() + ' or ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on Or operation
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * Or operations cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.Or = Or;

},{"../prims/BooleanNode":61}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const BooleanNode_1 = require("../prims/BooleanNode");
const space_lift_1 = require("space-lift");
class ForNode {
    /**
     * Constructor for a For loop
     * @param init Initializes the variable used in the condition
     * @param cond The condition (must evaluate to BooleanNode)
     * @param post The postevaluation condition
     * @param body The body of the loop
     * @param ws Preceding whitespace
     */
    constructor(init, cond, post, body, ws) {
        this._newLine = true;
        this._init = init;
        this._cond = cond;
        this._post = post;
        this._body = body;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the For loop
     * @param context The current program context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        this._init.eval(childCtx); // initialize var
        let res = this._cond.eval(childCtx);
        if (!(res instanceof BooleanNode_1.BooleanNode)) {
            throw new Error("The condition must be a boolean expression.");
        }
        let ret;
        while (res.val) {
            ret = this._body.eval(childCtx);
            this._post.eval(childCtx);
            res = this._cond.eval(childCtx);
        }
        return ret;
    }
    /**
     * Equals cannot be called directly on ForNode
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on For loop");
    }
    /**
     * ForNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        return "Cannot call draw on For loop";
    }
    /**
     * Returns a string representation of the for loop
     */
    toString() {
        return this._ws + 'for(' + this._init.toString() + ", " + this._cond.toString() + ", " + this._post.toString() + ") {\n "
            + this._body.toString() + "}";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.ForNode = ForNode;

},{"../prims/BooleanNode":61,"../structural/Scope":75,"space-lift":89}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const BooleanNode_1 = require("../prims/BooleanNode");
const space_lift_1 = require("space-lift");
class WhileNode {
    /**
     * Constructor for a While loop
     * @param cond The While loop condition
     * @param body The body of the loop
     * @param ws Preceding whitespace
     */
    constructor(cond, body, ws) {
        this._newLine = true;
        this._cond = cond;
        this._body = body;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the body of the loop while the condition is true
     * @param context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        let res = this._cond.eval(childCtx);
        if (!(res instanceof BooleanNode_1.BooleanNode)) {
            throw new Error("The condition must be a boolean expression.");
        }
        let ret;
        while (res.val) {
            ret = this._body.eval(childCtx);
            res = this._cond.eval(childCtx);
        }
        return ret;
    }
    /**
     * Equals cannot be called directly on WhileNodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on While loop");
    }
    /**
     * WhileNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        return "Cannot call draw on While loop";
    }
    /**
     * Returns a string representation of the While loop
     */
    toString() {
        return this._ws + "while(" + this._cond.toString() + ") {\n " + this._body.toString() + "}";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.WhileNode = WhileNode;

},{"../prims/BooleanNode":61,"../structural/Scope":75,"space-lift":89}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonFourCpOne {
    constructor() {
        this._name = "l4c1";
        this._nextModule = 'l4c2';
        this._constraint = 'none';
        this._instructions = `<p> You've made it to the FINAL CHALLENGES! Complete these challenges to earn ETERNAL GLORY! </p>
    <p> Throughout this Hour of Code, you have learned: </p>
    <p> - How to print a word, circle, rectangle, and curve. </p>
    <p> - How to store any of the value above in a variable. </p>
    <p> - How to use if/else statement to check a condition about a variable. </p>
    <p> Each of the following challenges will test these concepts. Let's dive right in! </p>
    <p> Print a circle and put its height and width in one of the boxes to the side. Then print a rectangle and put its height and width in the box. </p>
    <p> CHALLENGE: Print a circle and rectangle. Put their respective width and height in the boxes provided. </p>`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonFourCpOne = LessonFourCpOne;

},{"../effects/EllipseEffect":13}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonFourCpTwo {
    constructor() {
        this._name = "l4c2";
        this._nextModule = 'l4c2';
        this._constraint = 'none';
        this._instructions = `<p> Yes! You got this! </p>
    <p> Now let's put those skills in if/else statements to work! </p>
    <p> Create a pair of if/else statements to print out to the CANVAS a claim of whether the circle is positioned ABOVE or BELOW the rectangle. </p>
    <p> CHALLENGE: Print a claim that states whether circle is ABOVE or BELOW the rectangle. </p>
    <p> HINT: Remember that the numbers in the print() statements determine the position of the shapes being printed. </p>`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonFourCpTwo = LessonFourCpTwo;

},{"../effects/EllipseEffect":13}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpFour {
    constructor() {
        this._name = "l1c4";
        this._prevModule = 'l1c2';
        this._nextModule = 'l2c1';
        this._constraint = 'canvas';
        this._instructions = `<p> Note that changing the first number in the print statement moves the words left or right, while changing the second number move them up or down. </p>
    <p> Now time for a challenge! Print the word "moo" on the CANVAS, and put it right in the center of the entire CANVAS. </p>
    <p> CHALLENGE: Print the word "moo" in the center of the CANVAS. </p>
    <p> HINT: Write print("moo", 50, 50) in the CODE area first, then change the numbers inside that print statement. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "moo") {
                if ((effect.x > 200 && effect.x < 300) && (effect.y > 200 && effect.y < 300)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpFour = LessonOneCpFour;

},{"../effects/StringEffect":18}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpOne {
    constructor() {
        this._name = "l1c1";
        this._nextModule = 'l1c2';
        this._constraint = 'none';
        this._instructions = `<p> To begin, let’s tell the computer to write something on the CANVAS. </p>
    <p> GOAL: write on the CANVAS. </p>
    <p> HINT: type in the CODE box: print("Hello, world!"), then hit the RUN button. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: write any string on CANVAS
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect) {
                if (effect.str !== "") {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpOne = LessonOneCpOne;

},{"../effects/StringEffect":18}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpThree {
    constructor() {
        this._name = "l1c3";
        this._prevModule = 'l1c2';
        this._nextModule = 'l1c4';
        this._constraint = 'canvas';
        this._instructions = `<p> Yep! Moving the words actually change the numbers in your CODE. </p>
    <p> Now the CANVAS has been frozen! Try changing your CODE to see if you can move the words to the bottom right corner. </p>
    <p> GOAL: Move the words to the bottom right of the CANVAS. </p>
    <p> HINT: Change one of the 2 numbers at a time, then click RUN to see how that changes the CANVAS.`;
        this.x = 10;
        this.y = 430;
    }
    drawGuides(ctx) {
        ctx.beginPath();
        ctx.rect(this.x, this.y, 100, 100);
        ctx.strokeStyle = '#6C6C6C';
        ctx.stroke();
        ctx.font = 20 + "px Courier New";
        ctx.fillStyle = '#6C6C6C';
        ctx.fillText("Put text", this.x, 390);
        ctx.fillText("in here", this.x, 410);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str !== "") {
                if (effect.x > this.x && effect.x < this.x + 100 && effect.y > this.y && effect.y < this.y + 100) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpThree = LessonOneCpThree;

},{"../effects/StringEffect":18}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpTwo {
    constructor() {
        this._name = "l1c2";
        this._nextModule = 'l1c3';
        this._constraint = 'code';
        this._instructions = `<p> You just told the computer to write words on the CANVAS! </p>
    <p> Now let's do something more interesting: click on the words on the CANVAS, then drag it inside the box at the top-right corner. Observe what happens to your code. </p>
    <p> GOAL: Move the words you just created inside the top-right box. </p>`;
        this.x = 390;
        this.y = 10;
    }
    drawGuides(ctx) {
        ctx.beginPath();
        ctx.rect(this.x, this.y, 100, 100);
        ctx.strokeStyle = '#6C6C6C';
        ctx.stroke();
        ctx.font = 20 + "px Courier New";
        ctx.fillStyle = '#6C6C6C';
        ctx.fillText("Put text", 390, 130);
        ctx.fillText("in here", 390, 150);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str !== "") {
                if (effect.x > this.x && effect.x < this.x + 100 && effect.y > this.y && effect.y < this.y + 100) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpTwo = LessonOneCpTwo;

},{"../effects/StringEffect":18}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpFive {
    constructor() {
        this._name = "l3c5";
        this._nextModule = 'l3c6';
        this._constraint = 'none';
        this._instructions = `<p> So we print a message to the CANVAS anytime c is exactly equal to 8. </p>
    <p> What if we want to print another message, "c is not equal to 8" any time c is not equal to 8? </p>
    <p> We do so by using an else statement. Observe the CODE above. </p>
    <p> When the condition inside the if() statement is satisfied, the code block inside the {} right after it would run. </p>
    <p> When that condition is not satisfied, the code block inside the {} after the else statement would run. </p>
    <p> GOAL: Change the value of c so that the line "c is NOT equal to 8." is printed on the CANVAS. </p>`;
        this._starterCode = `c = 8;
if(c == 8) {
  print("c is equal to 8.", 103, 143);
} else {
  print("c is NOT equal to 8.", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /c\s*=\s*[^8]\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "c is NOT equal to 8.") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpFive = LessonThreeCpFive;

},{"../effects/StringEffect":18}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpFour {
    constructor() {
        this._name = "l3c4";
        this._nextModule = 'l3c5';
        this._constraint = 'none';
        this._instructions = `<p> You can put an inequality condition in the if() clause, such as "a < 5" or "b > 20". </p>
    <p> You can also use an equality condition. Observe the CODE above with "c == 8". The 2 equal signs mean that you are checking whether c is exactly equal to 8 or not. </p>
    <p> Change the value of c so that the line "c is equal to 8." is printed on the CANVAS. </p>
    <p> GOAL: Change the value of c so that the line "c is equal to 8." is printed on the CANVAS. </p>`;
        this._starterCode = `c = 100;
if(c == 8) {
  print("c is equal to 8.", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /c\s*=\s*8\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "c is equal to 8.") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpFour = LessonThreeCpFour;

},{"../effects/StringEffect":18}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpOne {
    constructor() {
        this._name = "l3c1";
        this._nextModule = 'l3c2';
        this._constraint = 'none';
        this._instructions = `<p> We learned to tell the computer to print a lot of things. Unfortunately, the computer is kinda bad at math. </p>
    <p> Look at the CODE above. We let a = 5, then we print the value of a to the CANVAS. Then we print the line "a is less than 10". </p>
    <p> Since a = 5, and 5 < 10, we know that a is less than 10. But what would happen if we change the value of a to, say, 12? </p>
    <p> GOAL: change the value of a to 12. </p>
    <p> HINT: You can do this by changing the line a = 5 in the CODE area, or you can click on the number 5 on the CANVAS. </p>`;
        this._starterCode = `a = 5;
print(a, 118, 63);
print("a is less than 10", 103, 143);`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /a\s*=\s*12\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "a is less than 10") {
                //canvasIsCorrect = true;
                //break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpOne = LessonThreeCpOne;

},{"../effects/StringEffect":18}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonThreeCpSix {
    constructor() {
        this._name = "l3c6";
        this._nextModule = 'l4c1';
        this._constraint = 'none';
        this._instructions = `<p> Now that you know how to use if/else statements, let's put them all together! </p>
    <p> Above we have the CODE to draw 2 circles: circle A has height and width a, and circle B has height and width b. </p>
    <p> However, currently the claim that "Circle A is smaller than circle B." regardless of the circles' actual sizes. </p>
    <p> Create an if/else statement to print "Circle A is smaller than circle B." when it is actually so, and print "Circle A is bigger than circle B" otherwise. </p>
    <p> CHALLENGE: Create an if/else statement to print the correct claim about the sizes of the 2 circles. </p>`;
        this._starterCode = `a = 200;
print(a, 111, 103);
print(ellipse(a, a), 132, 287);
b = 100;
print(b, 337, 104);
print(ellipse(b, b), 371, 248);
print("Circle A is smaller than circle B.", 45, 453);
`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpSix = LessonThreeCpSix;

},{"../effects/EllipseEffect":13}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpThree {
    constructor() {
        this._name = "l3c3";
        this._nextModule = 'l3c4';
        this._constraint = 'none';
        this._instructions = `<p> if statements allow you to run a block of code inside the curly braces {} ONLY when the condition inside the if() clause is true. </p>
    <p> Let's have a quick challenge: observe the CODE above. Make it so that the line "b is greater than 20" is only printed on the CANVAS when b is actually greater than 20. </p>
    <p> GOAL: Make the line "b is greater than 20" only be printed on the CANVAS when b is actually greater than 20. Change b to a number greater than 20 to test. </p>`;
        this._starterCode = `b = 8;
if(b < 10) {
  print("b is greater than 20.", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /if\s*\(\s*b\s*>\s*20\s*\)/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "b is greater than 20.") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpThree = LessonThreeCpThree;

},{"../effects/StringEffect":18}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpTwo {
    constructor() {
        this._name = "l3c2";
        this._nextModule = 'l3c3';
        this._constraint = 'none';
        this._instructions = `<p> Did you notice the claim that "a is less than 10" did not change? a is now 12 and clearly greater than 10! </p>
    <p> What we want is for the computer to only print "a is less than 10" ONLY when the value of a is truly less than 10. </p>
    <p> To do so, we use an if statement. Observe the CODE above. All we changed was to put in an if statement that checks whether a < 10. If a is, the code inside the curly braces {} are executed. </p>
    <p> Change the value of a to 12, 10, 8 and observe what happens. </p>
    <p> GOAL: RUN the CODE with a = 12 or 10 or 8. </p>`;
        this._starterCode = `a = 12;
print(a, 118, 63);
if(a < 10) {
  print("a is less than 10", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /a\s*=\s*8\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "a is less than 10") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpTwo = LessonThreeCpTwo;

},{"../effects/StringEffect":18}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpFive {
    constructor() {
        this._name = "l2c5";
        this._nextModule = 'l2c6';
        this._constraint = 'none';
        this._instructions = `<p> Did you see the CANVAS changed? </p>
    <p> In our code, we make variable a refer to the words "moo moo", and variable b refer to an ellipse(100, 100). </p>
    <p> As a result, when we tell the computer to print a, it will print "moo moo", and when we tell the computer to print b, it will print a circle. </p>
    <p> Let's take this one step further: Create a new variable c, and make it refer to an ellipse(100, 100). Then write 2 statements to print c. What do you think would happen? </p>
    <p> GOAL: Create a variable c referring to an ellipse(100, 100), then write 2 print statements to print c. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let assignment = /c\s*=\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*;/g;
            let matchAssign = code.match(assignment);
            let print = /print\s*\(\s*c\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/g;
            let matchPrint = code.match(print);
            codeIsCorrect = matchAssign != null && matchAssign.length > 0 && matchPrint != null && matchPrint.length >= 2;
        }
        //check for correct CANVAS effects
        let circleCount = 0;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                circleCount += 1;
            }
        }
        return codeIsCorrect && circleCount >= 2;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpFive = LessonTwoCpFive;

},{"../effects/EllipseEffect":13}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpFour {
    constructor() {
        this._name = "l2c4";
        this._nextModule = 'l2c5';
        this._constraint = 'none';
        this._instructions = `<p> There's no limit to how many print statements the computer can understand, so you can write 1000 print statements, and the computer will draw 1000 things on the CANVAS for you! </p>
    <p> Time to take your coding to the next level. Let's learn about variables. </p>
    <p> Variables are simply names you give to the things that you draw. </p>
    <p> For example, take a look at the code above. Change the a in the print statement to b, and observe what happened on the CANVAS. </p>
    <p> GOAL: Change a to b in the print statement. </p>`;
        this._starterCode = `a = "moo moo";\nb = ellipse(100, 100);\nprint(a, 50, 70);`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*b\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (!canvasIsCorrect && effect instanceof EllipseEffect_1.EllipseEffect) {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpFour = LessonTwoCpFour;

},{"../effects/EllipseEffect":13}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpOne {
    constructor() {
        this._name = "l2c1";
        this._nextModule = 'l2c2';
        this._constraint = 'none';
        this._instructions = `<p> Printing only words is kinda boring, so let's learn to print some shapes on the CANVAS! </p>
    <p> In the print statement, replace "moo" with ellipse(100,100). Hit the RUN button to see what happens. </p>
    <p> GOAL: replace "moo" with ellipse(100,100) in the print statement above. </p>
    <p> HINT: Highlight "moo" - including the double quotes ", and replace that with ellipse(100, 100). KEEP EVERYTHING ELSE THE SAME. </p>`;
        this._starterCode = `
    print("moo", 50, 70)`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpOne = LessonTwoCpOne;

},{"../effects/EllipseEffect":13}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberEffect_1 = require("../effects/NumberEffect");
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpSeven {
    constructor() {
        this._name = "l2c7";
        this._nextModule = 'l3c1';
        this._constraint = 'none';
        this._instructions = `<p> Changing one circle changes c, which will then in turn change the other circle! </p>
    <p> Now let's put all we have learned to practice. </p>
    <p> Create a circle, and print out the size of that circle in the given box. </p>
    <p> IF we ever change the circle, we want the number in the box to change, too! </p>
    <p> CHALLENGE: Create a circle and print its size in the given box. </p>`;
        this.x = 10;
        this.y = 430;
    }
    drawGuides(ctx) {
        ctx.beginPath();
        ctx.rect(this.x, this.y, 100, 100);
        ctx.strokeStyle = '#6C6C6C';
        ctx.stroke();
        ctx.font = 20 + "px Courier New";
        ctx.fillStyle = '#6C6C6C';
        ctx.fillText("Put circle's size", this.x, 390);
        ctx.fillText("in here", this.x, 410);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof NumberEffect_1.NumberEffect && effect.num != null) {
                if (effect.x > this.x && effect.x < this.x + 100 && effect.y > this.y && effect.y < this.y + 100) {
                    let val = effect.num;
                    for (let effect2 of effects) {
                        if (effect2 instanceof EllipseEffect_1.EllipseEffect && (val == effect2.w || val == effect2.h)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpSeven = LessonTwoCpSeven;

},{"../effects/EllipseEffect":13,"../effects/NumberEffect":16}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpSix {
    constructor() {
        this._name = "l2c6";
        this._nextModule = 'l2c7';
        this._constraint = 'code';
        this._instructions = `<p> Now that you have drawn 2 circles both are called c, let's see what happens when you try to modify one of them. </p>
    <p> Click on one of the circles on the CANVAS, and try make it bigger. Observe what happens to your declaration of c. </p>
    <p> GOAL: Enlarge one of the circles referred to by c on the CANVAS. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                if (effect.w > 250 && effect.h > 250) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpSix = LessonTwoCpSix;

},{"../effects/EllipseEffect":13}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
const StringEffect_1 = require("../effects/StringEffect");
class LessonTwoCpThree {
    constructor() {
        this._name = "l2c3";
        this._nextModule = 'l2c4';
        this._constraint = 'none';
        this._instructions = `<p> So we can draw a circle and change it. But what if we want to draw both circles and words? </p>
    <p> Well, simple! Just write more print statements in the CODE area! </p>
    <p> GOAL: Draw 2 circles and a word on the CANVAS. </p>
    <p> HINT: Remember that the numbers right inside the ellipse(_,_) statement change the circle's sizes.`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        let stringExists = false;
        let circleCount = 0;
        for (let effect of effects) {
            if (!stringExists) {
                stringExists = effect instanceof StringEffect_1.StringEffect && effect.str !== "";
            }
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                circleCount += 1;
            }
        }
        return stringExists && circleCount >= 2;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpThree = LessonTwoCpThree;

},{"../effects/EllipseEffect":13,"../effects/StringEffect":18}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpTwo {
    /*
    `<p> So we can draw a circle and change it. But what if we want to draw both a circle and a word? </p>
    <p> Well, simple! Just write another print statement in the CODE area! </p>
    <p> GOAL: Draw 2 circles and a word on the CANVAS. </p>
    <p> HINT: Remember that the numbers right inside the ellipse(_,_) statement change the circle's sizes.`;
*/
    constructor() {
        this._name = "l2c2";
        this._nextModule = 'l2c3';
        this._constraint = 'code';
        this._instructions = `<p> We can write ellipse(100, 100) in the print statement to draw a circle on the CANVAS. </p>
    <p> What are the numbers (100, 100) for? I'm glad you asked... </p>
    <p> Because the CODE area is frozen again! Drag one of the 9 white tips around the circle on the CANVAS to see how the number changes! </p>
    <p> GOAL: Make the circle wider but shorter. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                if (effect.w > 200 && effect.h < 80) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpTwo = LessonTwoCpTwo;

},{"../effects/EllipseEffect":13}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pants_1 = require("pants");
const index_1 = require("../../index");
const space_lift_1 = require("space-lift");
var Parser;
(function (Parser) {
    /**
     * to be moved to Pants
     * number parses numbers by repeatedly applying the digit parser
     */
    function number() {
        return (istream) => {
            const o = pants_1.Primitives.many1(pants_1.Primitives.digit())(istream);
            switch (o.tag) {
                case "success":
                    let s = "";
                    for (let digit of o.result) {
                        s += digit.toString();
                    }
                    return new pants_1.Primitives.Success(o.inputstream, parseFloat(s));
                case "failure":
                    return o;
            }
        };
    }
    Parser.number = number;
    /**
     * to be moved to Pants
     * string is an arbitrary string parser that repeatedly applies the letter primitive
     * returns a CharStream representing the entire parsed string
     */
    function string() {
        let p = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.many1(pants_1.Primitives.letter()));
        let f = (xs) => pants_1.CharUtil.CharStream.concat(xs);
        return pants_1.Primitives.appfun(p)(f);
    }
    Parser.string = string;
    /**
     * to be moved to Pants
     * punctuation parses all possible punctuation characters
     */
    function punctuation() {
        return pants_1.Primitives.sat(x => x == "!"
            || x == "."
            || x == ','
            || x == ";"
            || x == '?'
            || x == "-"
            || x == "&"
            || x == '$'
            || x == ':'
            || x == '/'
            || x == '|'
            || x == '%'
            || x == '#'
            || x == "@"
            || x == "~"
            || x == '`'
            || x == '*'
            || x == '^'
            || x == '{'
            || x == '}'
            || x == "["
            || x == ']'
            || x == '('
            || x == ")"
            || x == "'"
            || x == "_");
    }
    Parser.punctuation = punctuation;
    let id = (x) => x;
    /**
     * parse is a function that wraps the input text in a CharStream
     * and passes it to the upper-level parse function
     * @param program a string representing program text
     */
    function parse(program) {
        program += "\n";
        let o = Parser.ExpressionParser(new pants_1.CharUtil.CharStream(program));
        switch (o.tag) {
            case "success":
                return space_lift_1.Some(o.result);
            case "failure":
                return space_lift_1.None;
        }
    }
    Parser.parse = parse;
    /**
     * Expression parser first searches for the first expression of a sequence and either
     * another expression or the end of the program (NOP) and returns a sequence node
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParser = i => {
        let f = (tup) => {
            return new index_1.SequenceNode(tup[0], tup[1]);
        };
        let p = pants_1.Primitives.seq(Parser.ExpressionParserNoSeq)(pants_1.Primitives.right(pants_1.Primitives.choice(pants_1.Primitives.char(';'))(pants_1.Primitives.nl()))(pants_1.Primitives.choice(pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser))(pants_1.Primitives.appfun(pants_1.Primitives.ws())(_ => new index_1.NOP()))))(f);
        return p(i);
    };
    /**
     * Searches through all possible expressions except for sequences
     * used to avoid infinite looping in upper level parse
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParserNoSeq = i => {
        let p1 = pants_1.Primitives.choice(lNumber())(lstring2());
        let p2 = pants_1.Primitives.choice(varNameParse())(p1);
        let p3 = pants_1.Primitives.choice(BoolParse())(p2);
        let p4 = pants_1.Primitives.choice(varDecParse())(p3);
        let p5 = pants_1.Primitives.choice(Parser.unOpsExpr)(p4);
        let p6 = pants_1.Primitives.choice(Declare())(p5);
        let p7 = pants_1.Primitives.choice(Parser.binOpExpr)(p6);
        let p8 = pants_1.Primitives.choice(LogicExpr())(p7);
        let p9 = pants_1.Primitives.choice(Parser.ListHead)(p8);
        let p10 = pants_1.Primitives.choice(Parser.funApp)(p9);
        let p11 = pants_1.Primitives.choice(Parser.returnParser)(p10);
        let p12 = pants_1.Primitives.choice(Parser.condParse)(p11);
        let p13 = pants_1.Primitives.choice(Parser.WhileLoop)(p12);
        let p14 = pants_1.Primitives.choice(Parser.ForLoop)(p13);
        let p15 = pants_1.Primitives.choice(Parser.funDef)(p14);
        return p15(i);
    };
    /**
     * Searches through all possible expressions except for binOp expressions
     * used to avoid infinite looping in the binary expression parser
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParserNoBinOp = i => {
        let p1 = pants_1.Primitives.choice(lNumber())(lstring2());
        let p2 = pants_1.Primitives.choice(varNameParse())(p1);
        let p3 = pants_1.Primitives.choice(BoolParse())(p2);
        let p4 = pants_1.Primitives.choice(varDecParse())(p3);
        let p5 = pants_1.Primitives.choice(Parser.unOpsExpr)(p4);
        let p6 = pants_1.Primitives.choice(Declare())(p5);
        let p7 = pants_1.Primitives.choice(Parser.ListHead)(p6);
        let p8 = pants_1.Primitives.choice(Parser.funApp)(p7);
        let p9 = pants_1.Primitives.choice(Parser.returnParser)(p8);
        let p10 = pants_1.Primitives.choice(Parser.condParse)(p9);
        let p11 = pants_1.Primitives.choice(Parser.WhileLoop)(p10);
        let p12 = pants_1.Primitives.choice(Parser.ForLoop)(p11);
        let p13 = pants_1.Primitives.choice(Parser.funDef)(p12);
        return p13(i);
    };
    /**
     * Searches through all possible expressions except for logical expressions
     * used to avoid infinite looping in the logical expression parser
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParserNoLogic = i => {
        let p1 = pants_1.Primitives.choice(lNumber())(lstring2());
        let p2 = pants_1.Primitives.choice(varNameParse())(p1);
        let p3 = pants_1.Primitives.choice(BoolParse())(p2);
        let p4 = pants_1.Primitives.choice(varDecParse())(p3);
        let p5 = pants_1.Primitives.choice(Parser.unOpsExpr)(p4);
        let p6 = pants_1.Primitives.choice(Declare())(p5);
        let p7 = pants_1.Primitives.choice(Parser.binOpExpr)(p6);
        let p8 = pants_1.Primitives.choice(Parser.ListHead)(p7);
        let p9 = pants_1.Primitives.choice(Parser.funApp)(p8);
        let p10 = pants_1.Primitives.choice(Parser.returnParser)(p9);
        let p11 = pants_1.Primitives.choice(Parser.condParse)(p10);
        let p12 = pants_1.Primitives.choice(Parser.WhileLoop)(p11);
        let p13 = pants_1.Primitives.choice(Parser.ForLoop)(p12);
        let p14 = pants_1.Primitives.choice(Parser.funDef)(p13);
        return p14(i);
    };
    /**
     * lNumber is used to wrap parsed numbers in NumberNodes for the AST
     */
    function lNumber() {
        return (istream) => {
            let o = number()(istream);
            switch (o.tag) {
                case "success":
                    return new pants_1.Primitives.Success(o.inputstream, new index_1.NumberNode(o.result));
                case "failure":
                    return o;
            }
        };
    }
    Parser.lNumber = lNumber;
    /**
     * binOpsChar parses all possible binary operators, such as + or -
     */
    function binOpsChar() {
        return (istream) => {
            return pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.sat(x => x == "+"
                || x == "-"
                || x == "/"
                || x == "="
                || x == "*"))(istream);
        };
    }
    Parser.binOpsChar = binOpsChar;
    /**
     * binOpsShort returns a tuple where the first element is the binary operator (CharStream)
     * and the second element is the expression to the right of the operator (Expression<{}>)
     */
    function binOpShort() {
        return pants_1.Primitives.seq(binOpsChar())(Parser.ExpressionParserNoSeq)((x) => x);
    }
    Parser.binOpShort = binOpShort;
    /**
     * binOpExpr parses all possible binary operation expressions and returns the
     * corresponding AST node construct (also parses postfix increments/decrements like i++)
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.binOpExpr = i => {
        var f = (tup) => {
            let lhs = tup[0];
            let op = tup[1][0];
            let rhs = tup[1][1];
            switch (op.toString()) {
                case "+":
                    return new index_1.PlusOp(lhs, rhs, ws);
                case "-":
                    return new index_1.MinusOp(lhs, rhs, ws);
                case "/":
                    return new index_1.DivOp(lhs, rhs, ws);
                case "*":
                    return new index_1.MulOp(lhs, rhs, ws);
                case "=":
                    return new index_1.AssignOp(lhs, rhs, ws);
                default:
                    throw new Error("Binary Operation not supported");
            }
        };
        let p1 = pants_1.Primitives.choice(Parser.ExpressionParserNoBinOp)(varDecParse());
        let p2 = binOpShort();
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let postPlus = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.ExpressionParserNoBinOp))(pants_1.Primitives.str('++'))(tup => { return new index_1.Increment(tup[0], ws); });
        let postMinus = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.ExpressionParserNoBinOp))(pants_1.Primitives.str('--'))(tup => { return new index_1.Decrement(tup[0], ws); });
        let binOp = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(p1))(p2)(f);
        return pants_1.Primitives.choice(binOp)(pants_1.Primitives.choice(postPlus)(postMinus))(i);
    };
    /**
     * unOpsChar parses all possible unary operators
     * Only negations are supported, but more can be added as needed
     * @param i nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.unOpsChar = i => {
        return pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char("-"))(i);
    };
    /**
     * unOpsExpr wraps a unary operation expression in the corresponding
     * AST node and returns it
     * @param i nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.unOpsExpr = i => {
        var f = (tup) => {
            return new index_1.NegOp(tup[1], ws);
        };
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        return pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.unOpsChar))(Parser.ExpressionParserNoSeq)(f)(i);
    };
    /**
     * lstring parses valid strings in the SWELL language
     * a valid string is surrounded by quotations and consists of letters, numbers, punctuation, and/or whitespace
     */
    function lstring() {
        let p1 = pants_1.Primitives.choice(pants_1.Primitives.choice(pants_1.Primitives.letter())(pants_1.Primitives.ws1()))(pants_1.Primitives.digit());
        //let p1 = Primitives.choice(Primitives.letter())(Primitives.ws1());
        let p = pants_1.Primitives.between(pants_1.Primitives.str("\""))(pants_1.Primitives.str("\""))(pants_1.Primitives.many(pants_1.Primitives.choice(p1)(punctuation())));
        let f = (xs) => pants_1.CharUtil.CharStream.concat(xs);
        return pants_1.Primitives.appfun(p)(f);
    }
    Parser.lstring = lstring;
    /**
     * lstring2 wraps strings parsed by lstring in StrinNode objects and returns them
     */
    function lstring2() {
        return (istream) => {
            let ws = "";
            let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
            let o = pants_1.Primitives.right(precedingWS)(lstring())(istream);
            switch (o.tag) {
                case "success":
                    return new pants_1.Primitives.Success(o.inputstream, new index_1.StringNode(o.result.toString(), ws));
                case "failure":
                    return o;
            }
        };
    }
    Parser.lstring2 = lstring2;
    /**
     * varNameParse parses valid variable names
     * variable names in SWELL begin with a lowercase char and are followed
     * by letters or digits
     */
    function varNameParse() {
        var f = (tup) => {
            return new index_1.VariableNode(tup[0].toString() + pants_1.CharUtil.CharStream.concat(tup[1]).toString(), ws);
        };
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let firstChar = pants_1.Primitives.right(precedingWS)(pants_1.Primitives.lower());
        let nextChars = pants_1.Primitives.many(pants_1.Primitives.choice(pants_1.Primitives.digit())(pants_1.Primitives.letter()));
        return pants_1.Primitives.seq(firstChar)(nextChars)(f);
    }
    Parser.varNameParse = varNameParse;
    /**
     * varDecParse parses valid variable declarations in the form "var x"
     * the parser then wraps the parsed value in a variable node for the AST
     */
    function varDecParse() {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str("var"));
        let varName = pants_1.Primitives.between(pants_1.Primitives.ws1())(pants_1.Primitives.ws())(varNameParse());
        let p = pants_1.Primitives.seq(p1)(varName)(tup => tup[1]);
        return p;
    }
    Parser.varDecParse = varDecParse;
    /**
     * Declare parses variable declarations in the form "var x = 2"
     * and returns a DeclareOp node
     */
    function Declare() {
        let eq = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('='));
        let p1 = pants_1.Primitives.left(varDecParse())(eq);
        return pants_1.Primitives.seq(p1)(Parser.ExpressionParserNoSeq)(tup => { return new index_1.DeclareOp(tup[0], tup[1]); });
    }
    Parser.Declare = Declare;
    /**
     * ListHead parses all lists in the SWELL language, including empty lists
     * Lists are surrounded by square brackets and each element is separated by a comma
     * returns a listNode object
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.ListHead = i => {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p0 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let p1 = pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.char('[')))(p0);
        var f = (tup) => {
            let hd = tup[0];
            let res = [hd];
            let tail = tup[1];
            for (let elem of tail) {
                res.push(elem);
            }
            return new index_1.ListNode(res, ws);
        };
        let p2 = pants_1.Primitives.seq(p1)(ListTail())(f);
        let p3 = pants_1.Primitives.appfun(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('[]')))(_ => new index_1.ListNode([], ws));
        return pants_1.Primitives.choice(p3)(p2)(i);
    };
    /**
     * List Tail parses second through last elements of a list, each separated by a comma
     * returns an array of Expressions that will be accessed by ListHead
     */
    function ListTail() {
        let p0 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char(','))(p0);
        let p2 = pants_1.Primitives.left(pants_1.Primitives.many(p1))(pants_1.Primitives.char(']'));
        return p2;
    }
    Parser.ListTail = ListTail;
    /**
     * funDefArgList parses argument lists for function definitions,
     * surrounded by parens and separated by commas
     * returns an array of the parameters
     */
    function funDefArgList() {
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char('('))(string());
        var f = (tup) => {
            let hd = tup[0].toString();
            let res = [hd];
            let tail = tup[1];
            for (let elem of tail) {
                res.push(elem.toString());
            }
            return res;
        };
        let p2 = pants_1.Primitives.seq(p1)(funDefArgListTail())(f);
        let p3 = pants_1.Primitives.appfun(pants_1.Primitives.str('()'))(_ => []);
        return pants_1.Primitives.choice(p3)(p2);
    }
    Parser.funDefArgList = funDefArgList;
    /**
     * funDefArgListTail parses the second through last elements of a function definition parameter list
     * parameters are separated by commas and end with a closing parens
     * returns an array of parameters, which is accessed by funDefArgList
     */
    function funDefArgListTail() {
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char(','))(string());
        let p2 = pants_1.Primitives.left(pants_1.Primitives.many(p1))(pants_1.Primitives.char(')'));
        return p2;
    }
    /**
     * funAppArgList parses argument lists for function applications, including empty args lists
     * the parser returns an array of Expression objects that represent the arguments
     */
    function funAppArgList() {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char('('))(expr);
        var f = (tup) => {
            let hd = tup[0];
            let res = [hd];
            let tail = tup[1];
            for (let elem of tail) {
                res.push(elem);
            }
            return res;
        };
        let p2 = pants_1.Primitives.seq(p1)(funAppArgListTail())(f);
        let p3 = pants_1.Primitives.appfun(pants_1.Primitives.str('()'))(_ => []);
        return pants_1.Primitives.choice(p3)(p2);
    }
    Parser.funAppArgList = funAppArgList;
    /**
     * funAppArgListTail parses the second through last elements of an argument list
     * each element is separated by a comma
     * returns an array of Expression objects, later accessed by funAppArgsList
     */
    function funAppArgListTail() {
        let comma = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char(','));
        let p1 = pants_1.Primitives.right(comma)(Parser.ExpressionParserNoSeq);
        let p2 = pants_1.Primitives.left(pants_1.Primitives.many(p1))(pants_1.Primitives.right(pants_1.Primitives.ws())(pants_1.Primitives.char(')')));
        return p2;
    }
    /**
     * returnParser parses valid return statements in the form "return x"
     * wraps the parsed value in a Return node for the AST
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.returnParser = i => {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p = pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('return')))(expr);
        var f = (e) => { return new index_1.Return(e, ws); };
        return pants_1.Primitives.appfun(p)(f)(i);
    };
    /**
     * funDef parses valid function definitions in the form "fun functionName(argList){ body;}"
     * the parser returns a funDef node for the AST
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.funDef = i => {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        return pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('fun')))(pants_1.Primitives.seq(
        /* function name */
        pants_1.Primitives.appfun(string())(cs => cs.toString()))(pants_1.Primitives.seq(
        /* function arguments */
        funDefArgList())(pants_1.Primitives.right(
        /* function body */
        pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{')))(pants_1.Primitives.left(pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser))(pants_1.Primitives.char('}'))))(id))(
        // create the AST node
        (tup) => {
            let fname = tup[0];
            let args = tup[1][0];
            let body = tup[1][1];
            return new index_1.FunDef(fname, body, args, ws);
        }))(i);
    };
    let printOffset = -1;
    /**
     * funApp parses valid function applications in the form "functionName(argsList)" and returns a funApp node
     * parser checks for built-in functions, like print, ellipse, and rect; and returns the valid AST node
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.funApp = i => {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        return pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(string()))(funAppArgList())(tup => {
            let fname = tup[0].toString();
            switch (fname) {
                case "print":
                    if (tup[1].length == 3) {
                        return new index_1.PrintNode(tup[1][0], new index_1.Dimensions(tup[1][1], tup[1][2], new index_1.NumberNode(1)), ws);
                    }
                    printOffset = (printOffset + 1) % 12;
                    return new index_1.PrintNode(tup[1][0], new index_1.Dimensions(new index_1.NumberNode(100 + 100 * (printOffset % 3)), new index_1.NumberNode(100 + 100 * (printOffset / 4)), new index_1.NumberNode(1)), ws);
                case "ellipse":
                    if (tup[1].length == 2) {
                        return new index_1.EllipseNode(tup[1][0], tup[1][1], ws);
                    }
                case "rect":
                    if (tup[1].length == 2) {
                        return new index_1.RectangleNode(tup[1][0], tup[1][1], ws);
                    }
                case "line":
                    if (tup[1].length == 2) {
                        return new index_1.LineNode(tup[1][0], tup[1][1], ws);
                    }
                case "curve":
                    if (tup[1].length == 3) {
                        return new index_1.CurveNode(tup[1][0], tup[1][1], tup[1][2], ws);
                    }
                case "eph":
                    if (tup[1].length == 2) {
                        return new index_1.EphNode(tup[1][0], tup[1][1], ws);
                    }
            }
            let args = tup[1];
            return new index_1.FunApp(fname, args, ws);
        })(i);
    };
    /**
     * BoolParse parses valid booleans, true and false, and returns a BooleanNode
     */
    function BoolParse() {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.appfun(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('true')))(_ => new index_1.BooleanNode(true, ws));
        let p2 = pants_1.Primitives.appfun(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('false')))(_ => new index_1.BooleanNode(false, ws));
        return pants_1.Primitives.choice(p1)(p2);
    }
    Parser.BoolParse = BoolParse;
    /**
     * logicChar parses all logical operators in the SWELL language and returns the consumed operator
     */
    function logicChar() {
        var logicChar = ["equals", '==', 'and', '>', '<', 'not equals', 'or'];
        var logicChar2 = ['>=', '<='];
        let p1 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.strSat(logicChar));
        let p2 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.strSat(logicChar2));
        return pants_1.Primitives.choice(p2)(p1);
    }
    Parser.logicChar = logicChar;
    /**
     * logicShort returns a tuple, where the first element represents the logical operator and
     * the second element is the expression to the right of the operator
     */
    function logicShort() {
        return pants_1.Primitives.seq(logicChar())(Parser.ExpressionParserNoSeq)((x) => x);
    }
    Parser.logicShort = logicShort;
    /**
     * logicExpr parses logical expressions and returns the corresponding AST node
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    function LogicExpr() {
        // TODO: Dan (2018-11-19), shouldn't parameterized type be BooleanNode?
        var f = (tup) => {
            let lhs = tup[0];
            let op = tup[1][0];
            let rhs = tup[1][1];
            switch (op.toString()) {
                case "equals":
                    return new index_1.Equals(lhs, rhs, ws);
                case "==":
                    return new index_1.Equals(lhs, rhs, ws);
                case "and":
                    return new index_1.And(lhs, rhs, ws);
                case ">":
                    return new index_1.GreaterThan(lhs, rhs, ws);
                case "<":
                    return new index_1.LessThan(lhs, rhs, ws);
                case ">=":
                    return new index_1.GreaterThanEq(lhs, rhs, ws);
                case "<=":
                    return new index_1.LessThanEq(lhs, rhs, ws);
                case "or":
                    return new index_1.Or(lhs, rhs, ws);
                case "not equals":
                    return new index_1.NotEqual(lhs, rhs, ws);
                default:
                    throw new Error("Logical expression not supported");
            }
        };
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let not = pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('not'));
        let p1 = pants_1.Primitives.right(not)(Parser.ExpressionParserNoSeq);
        let notExpr = pants_1.Primitives.appfun(p1)(x => new index_1.Not(x, ws));
        let logicExpr = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.ExpressionParserNoLogic))(logicShort())(f);
        return pants_1.Primitives.choice(notExpr)(logicExpr);
    }
    Parser.LogicExpr = LogicExpr;
    /**
     * IfParse parses valid if statements in the form "if(condition){ body; }"
     * returns an array where the first elem is the condition and the second is the body
     */
    function IfParse() {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let bodyParse = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let p1 = pants_1.Primitives.seq(pants_1.Primitives.str('if'))(pants_1.Primitives.char('('))(x => x);
        let cond = pants_1.Primitives.between(p1)(pants_1.Primitives.char(')'))(expr);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(bodyParse);
        return pants_1.Primitives.seq(cond)(body)(x => x);
    }
    Parser.IfParse = IfParse;
    /**
      * IfElseParse parses valid if else statements in the form "if(condition){ body; } else{ body2;}"
      * returns an array where the first elem is the condition and the second is the first body and the third is body2
      */
    function IfElseParse() {
        let e = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.str('else'));
        let body = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let body2 = pants_1.Primitives.between(pants_1.Primitives.str('{'))(pants_1.Primitives.str('}'))(body);
        let elseParse = pants_1.Primitives.right(e)(body2);
        var f = (tup) => {
            tup[0].push(tup[1]);
            return tup[0];
        };
        return pants_1.Primitives.seq(IfParse())(elseParse)(f);
    }
    Parser.IfElseParse = IfElseParse;
    /**
     * condParse parses possible conditional statements, including if and if/else statements
     * returns a Conditional node
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.condParse = i => {
        var f = (tup) => {
            if (tup.length == 3) {
                return new index_1.Conditional(tup[0], tup[1], tup[2]);
            }
            else {
                return new index_1.Conditional(tup[0], tup[1]);
            }
        };
        return pants_1.Primitives.appfun(pants_1.Primitives.choice(IfElseParse())(IfParse()))(f)(i);
    };
    /**
     * WhileLoop parses valid while loops in the form "while(condition) { body;}"
     * returns a WhileNode for the AST
     */
    Parser.WhileLoop = i => {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let bodyParse = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str("while")))(pants_1.Primitives.char('('))(x => x);
        let cond = pants_1.Primitives.between(p1)(pants_1.Primitives.char(')'))(expr);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(bodyParse);
        var f = (tup) => { return new index_1.WhileNode(tup[0], tup[1], ws); };
        return pants_1.Primitives.seq(cond)(body)(f)(i);
    };
    /**
     * ForLoop parses valid for loops in the form "for(initial, condition, post) { body;}" and returns a ForNode
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.ForLoop = i => {
        let args = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(funAppArgList());
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('for')))(args);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let expr = pants_1.Primitives.between(pants_1.Primitives.choice(pants_1.Primitives.ws())(pants_1.Primitives.nl()))(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(expr);
        var f = (tup) => {
            let init = tup[0][0];
            let cond = tup[0][1];
            let post = tup[0][2];
            let body = tup[1];
            return new index_1.ForNode(init, cond, post, body, ws);
        };
        return pants_1.Primitives.seq(p1)(body)(f)(i);
    };
    function singleComment() {
        let p1 = pants_1.Primitives.many1(pants_1.Primitives.item());
        let p2 = pants_1.Primitives.appfun(p1)(xs => pants_1.CharUtil.CharStream.concat(xs));
        return pants_1.Primitives.between(pants_1.Primitives.str('//'))(pants_1.Primitives.nl())(p2);
        //return Primitives.seq<CharUtil.CharStream, CharUtil.CharStream, CharUtil.CharStream[]>(Primitives.str('//'))(Primitives.nl())(x=>x);
    }
    Parser.singleComment = singleComment;
    function multiLineComment() {
        let p1 = pants_1.Primitives.many1(pants_1.Primitives.item());
        let p2 = pants_1.Primitives.appfun(p1)(xs => pants_1.CharUtil.CharStream.concat(xs));
        return pants_1.Primitives.between(pants_1.Primitives.str('\/**'))(pants_1.Primitives.str('*\/'))(p2);
    }
    Parser.multiLineComment = multiLineComment;
})(Parser = exports.Parser || (exports.Parser = {}));

},{"../../index":1,"pants":83,"space-lift":89}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BooleanNode {
    /**
     * Constructor for BooleanNode, a node representing a boolean
     * @param val The boolean value of the BooleanNode
     * @param ws Preceding white space
     */
    constructor(val, ws) {
        this._newLine = false;
        this._val = val;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    ;
    /**
     * Returns the BooleanNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * BooleanNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Returns whether this BooleanNode equals another
     * @param right The right side of the equality
     */
    equalsVal(right) {
        if (right instanceof BooleanNode) {
            return this.val === right.val;
        }
        return false;
    }
    /**
     * Returns a string representation of the BooleanNode
     */
    toString() {
        return this._ws + this._val;
    }
    /**
     * Returns the boolean value
     */
    get val() {
        return this._val;
    }
    /**
     * Sets the boolean value
     */
    set val(value) {
        this._val = value;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.BooleanNode = BooleanNode;

},{}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class NOP {
    constructor() {
        /* A NOP is a placeholder operation that evaluates to nothing */
        this._newLine = true;
    }
    /**
     * Returns the NOP
     * @param context
     */
    eval(context) {
        return this;
    }
    /**
     * NOPs cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("NOPs cannot be drawn.");
    }
    /**
     * Returns a string representation of the NOP
     */
    toString() {
        return "";
    }
    /**
     * Returns whether this NOP equals another (spoiler: it doesn't)
     * @param right
     */
    equalsVal(right) {
        return false;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.NOP = NOP;

},{}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberEffect_1 = require("../effects/NumberEffect");
// Nodes representing numbers
// Should abstract Node class implement Expression?
class NumberNode {
    /**
     * Constructor for a NumberNode, a node representing a number
     * @param val The number value
     * @param ws Preceding whitespace
     */
    constructor(val, ws) {
        this._newLine = false;
        this._val = val;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    ;
    /**
     * Returns this NumberNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * NumberNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        let e = new NumberEffect_1.NumberEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this NumberNode equals another NumberNode
     * @param right The right side of the equality (must be a NumberNode)
     */
    equalsVal(right) {
        if (right instanceof NumberNode) {
            return this.val === right.val;
        }
        return false;
    }
    /**
     * Returns a string representation of the NumberNode
     */
    toString() {
        return this._ws + this._val;
    }
    /**
     * Returns the number stored in the node
     */
    get val() {
        return this._val;
    }
    /**
     * Sets the value of the number stored in the node
     */
    set val(value) {
        this._val = value;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.NumberNode = NumberNode;

},{"../effects/NumberEffect":16}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class StringNode {
    /**
     * Constructor for a StringNode, a node representing a string
     * @param str The string stored in the node
     * @param ws Preceding whitespace
     */
    constructor(str, ws) {
        this._newLine = false;
        this._str = str;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this StringNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the String using StringEffect
     * @param context The current program context
     * @param dims The dimensions of the string to be drawn
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        let e = new StringEffect_1.StringEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this StringNode equals another StringNode
     * @param right The right side of the equality, must be a StringNode
     */
    equalsVal(right) {
        if (right instanceof StringNode) {
            return this.val === right.val;
        }
        return false;
    }
    /**
     * Returns a string representation of the StringNode
     */
    toString() {
        return this._ws + '\"' + this._str + '\"';
    }
    /**
     * Sets the string stored in the node
     */
    set str(value) {
        this._str = value;
    }
    /**
     * Returns the string stored in the node
     */
    get val() {
        return this._str;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.StringNode = StringNode;

},{"../effects/StringEffect":18}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ColorNode {
    /**
     * Constructor for a ColorNode, a node representing an RGB color
     */
    constructor(red, green, blue) {
        this._newLine = false;
        this._red = red;
        this._green = green;
        this._blue = blue;
    }
    ;
    /**
     * Evaluates into a string RGB value
     * @param context The current program context
     */
    eval(context) {
        return this._red + " " + this._green + " " + this._blue;
    }
    /**
     * ColorNodes cannot currently be drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Returns whether this ColorNode equals another ColorNode
     * @param right The right side of the equality (must be a BooleanNode)
     */
    equalsVal(right) {
        if (right instanceof ColorNode) {
            return (this.red === right.red && this.green === right.green && this.blue === right.blue);
        }
        return false;
    }
    /**
     * Returns a string representation of the ColorNode
     */
    toString() {
        return "";
    }
    /**
     * Returns the red value
     */
    get red() {
        return this._red;
    }
    /**
     * Sets the red value
     */
    set red(red) {
        this._red = red;
    }
    /**
     * Returns the green value
     */
    get green() {
        return this._green;
    }
    /**
     * Sets the green value
     */
    set green(green) {
        this._green = green;
    }
    /**
     * Returns the blue value
     */
    get blue() {
        return this._blue;
    }
    /**
     * Sets the blue value
     */
    set blue(blue) {
        this._blue = blue;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.ColorNode = ColorNode;

},{}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const CurveEffect_1 = require("../effects/CurveEffect");
class CurveNode {
    /**
     * Constructor for a CurveNode, a node representing a curve
     * @param dx the run of the curve
     * @param dy the rise of the curve
     * @param curvature how much the curve, umm, curves
     * @param ws Preceding whitespace
     */
    constructor(dx, dy, curvature, ws) {
        this._newLine = false;
        this._dx = dx;
        this._dy = dy;
        this._curvature = curvature;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this CurveNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the curve using CurveEffect
     * @param context The current program context
     * @param dims The line dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._dx.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._dy.eval(context).val, "");
        dims.curvature = new NumberNode_1.NumberNode(this._curvature.eval(context).val, "");
        let e = new CurveEffect_1.CurveEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this CurveNode equals another (if their dx, dy, and curvature are equal)
     * @param right The right side of the equality (must be a CurveNode)
     */
    equalsVal(right) {
        if (right instanceof CurveNode) {
            return (this.dx.equalsVal(right.dx) && this.dy.equalsVal(right.dy) && this.curvature.equalsVal(right.curvature));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the curve
     */
    toString() {
        return this._ws + "curve(" + this._dx.toString() + ", " + this._dy.toString() + ", " + this._curvature.toString() + ")";
    }
    /**
     * Returns the run of the curve
     */
    get dx() {
        return this._dx;
    }
    /**
     * Sets the run of the curve
     */
    set dx(dx) {
        this._dx = dx;
    }
    /**
     * Returns the rise of the curve
     */
    get dy() {
        return this._dy;
    }
    /**
     * Sets the rise of the curve
     */
    set dy(dy) {
        this._dy = dy;
    }
    /**
     * Returns the curvature of the curve
     */
    get curvature() {
        return this._curvature;
    }
    /**
     * Sets the curvature of the curve
     */
    set curvature(curvature) {
        this._curvature = curvature;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.CurveNode = CurveNode;

},{"../effects/CurveEffect":12,"../prims/NumberNode":63}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class EllipseNode {
    /**
     * Constructor for an EllipseNode, a node representing an ellipse
     * @param width The width of the ellipse
     * @param height The height of the ellipse
     * @param ws Preceding whitespace
     */
    constructor(width, height, ws) {
        this._newLine = false;
        this._width = width;
        this._height = height;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this EllipseNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the ellipse on the canvas using EllipseEffect
     * @param context The current program context
     * @param dims The dimensions of the ellipse
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = this._width;
        dims.height = this._height;
        let e = new EllipseEffect_1.EllipseEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this EllipseNode equals another EllipseNode (if their widths and heights are equal)
     * @param right The right side of the equality (must be an EllipseNode)
     */
    equalsVal(right) {
        if (right instanceof EllipseNode) {
            return (this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    /**
     * Returns a string representation of the ellipse
     */
    toString() {
        return this._ws + "ellipse(" + this._width.toString() + ", " + this._height.toString() + ")";
    }
    move() { }
    /**
     * Returns the ellipse width
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the ellipse width
     */
    set width(width) {
        this._width = width;
    }
    /**
    * Returns the ellipse height
    */
    get height() {
        return this._height;
    }
    /**
     * Sets the ellipse height
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.EllipseNode = EllipseNode;

},{"../effects/EllipseEffect":13}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const EphEffect_1 = require("../effects/EphEffect");
class EphNode {
    /**
     * Constructor for an EphNode, a node representing something very special
     * @param width The width of the EphNode
     * @param height The height of the EphNode
     * @param ws Preceding whitespace
     */
    constructor(width, height, ws) {
        this._newLine = false;
        //this._image = image;
        this._width = width;
        this._height = height;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this EphNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the rectangle using EphEffect
     * @param context The current program context
     * @param dims The rectangle dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._width.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._height.eval(context).val, "");
        let e = new EphEffect_1.EphEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this EphNode equals another (if their widths and heights are equal)
     * @param right The right side of the equality (must be an EphNode)
     */
    equalsVal(right) {
        if (right instanceof EphNode) {
            return (this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the EphNode
     */
    toString() {
        return this._ws + "eph(" + this._width.toString() + ", " + this._height.toString() + ")";
    }
    /**
     * Returns the width of the EphNode
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the EphNode
     */
    set width(width) {
        this._width = width;
    }
    /**
     * Returns the height of the EphNode
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the EphNode
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.EphNode = EphNode;

},{"../effects/EphEffect":14,"../prims/NumberNode":63}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const LineEffect_1 = require("../effects/LineEffect");
class LineNode {
    /**
     * Constructor for a LineNode, a node representing a line
     * @param dx the run of the line
     * @param dy the rise of the line
     * @param ws Preceding whitespace
     */
    constructor(dx, dy, ws) {
        this._newLine = false;
        this._dx = dx;
        this._dy = dy;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this LineNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the line using LineEffect
     * @param context The current program context
     * @param dims The line dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._dx.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._dy.eval(context).val, "");
        let e = new LineEffect_1.LineEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this LineNode equals another (if their dx and dy are equal)
     * @param right The right side of the equality (must be a LineNode)
     */
    equalsVal(right) {
        if (right instanceof LineNode) {
            return (this.dx.equalsVal(right.dx) && this.dy.equalsVal(right.dy));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the line
     */
    toString() {
        return this._ws + "line(" + this._dx.toString() + ", " + this._dy.toString() + ")";
    }
    /**
     * Returns the run of the line
     */
    get dx() {
        return this._dx;
    }
    /**
     * Sets the run of the line
     */
    set dx(dx) {
        this._dx = dx;
    }
    /**
     * Returns the rise of the line
     */
    get dy() {
        return this._dy;
    }
    /**
     * Sets the rise of the line
     */
    set dy(dy) {
        this._dy = dy;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.LineNode = LineNode;

},{"../effects/LineEffect":15,"../prims/NumberNode":63}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const RectangleEffect_1 = require("../effects/RectangleEffect");
class RectangleNode {
    /**
     * Constructor for a RectangleNode, a node representing a rectangle
     * @param width The width of the rectangle
     * @param height The height of the rectangle
     * @param ws Preceding whitespace
     */
    constructor(width, height, ws) {
        this._newLine = false;
        this._width = width;
        this._height = height;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this RectangleNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the rectangle using RectangleEffect
     * @param context The current program context
     * @param dims The rectangle dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._width.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._height.eval(context).val, "");
        let e = new RectangleEffect_1.RectangleEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this RectangleNode equals another (if their widths and heights are equal)
     * @param right The right side of the equality (must be a RectangleNode)
     */
    equalsVal(right) {
        if (right instanceof RectangleNode) {
            return (this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the rectangle
     */
    toString() {
        return this._ws + "rect(" + this._width.toString() + ", " + this._height.toString() + ")";
    }
    /**
     * Returns the width of the rectangle
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the rectangle
     */
    set width(width) {
        this._width = width;
    }
    /**
     * Returns the height of the rectangle
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the rectangle
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.RectangleNode = RectangleNode;

},{"../effects/RectangleEffect":17,"../prims/NumberNode":63}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
class Dimensions {
    /**
     * Constructor for Dimensions, which stores object dimensions
     * @param x The x coordinate of the object
     * @param y The y coordinate of the object
     * @param scale The scale of the object
     * @param radius The radius of the object
     */
    constructor(x, y, scale, radius) {
        this._x = x;
        this._y = y;
        this._scale = scale;
        this._radius = radius || new NumberNode_1.NumberNode(30, "");
    }
    /**
     * Returns a string representation of the dimensions
     */
    toString() {
        return this.x.toString() + ", " + this.y.toString();
    }
    /**
     * Returns the x coordinate of the object
     */
    get x() {
        return this._x;
    }
    /**
     * Sets the x coordinate of the object
     */
    set x(val) {
        this._x = val;
    }
    /**
     * Returns the y coordinate of the object
     */
    get y() {
        return this._y;
    }
    /**
     * Sets the y coordinate of the object
     */
    set y(val) {
        this._y = val;
    }
    /**
     * Returns the radius of the object
     */
    get radius() {
        return this._radius;
    }
    /**
     * Sets the radius of the object
     */
    set radius(val) {
        this._radius = val;
    }
    /**
     * Returns the scale of the object
     */
    get scale() {
        return this._scale;
    }
    /**
     * Sets the scale of the object
     */
    set scale(val) {
        this._scale = val;
    }
    /**
     * Returns the width of the object
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the object
     */
    set width(val) {
        this._width = val;
    }
    /**
     * Returns the height of the object
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the object
     */
    set height(val) {
        this._height = val;
    }
    /**
     * Returns the curvature of the object
     */
    get curvature() {
        return this._curvature;
    }
    /**
     * Sets the curvature of the object
     */
    set curvature(val) {
        this._curvature = val;
    }
}
exports.Dimensions = Dimensions;

},{"../prims/NumberNode":63}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class PrintNode {
    /**
     * Constructor for a PrintNode, representing an object to be printed
     * @param toPrint The object to be printed
     * @param dimensions The dimensions of the object to be printed
     * @param ws Preceding whitespace
     */
    constructor(toPrint, dimensions, ws) {
        this._scale = 1;
        this._newLine = false;
        this._toPrint = toPrint;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
        this._dims = dimensions || null;
    }
    /**
     * Returns a string representation of the object to be printed
     */
    toString() {
        return this._ws + "print(" + this.toPrint.toString() + ", " + this.dims.toString() + ")";
    }
    /**
     * Equals cannot be called directly on a PrintNode
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on PrintNode");
    }
    /**
     * PrintNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw() on printOp");
    }
    /**
     * Evaluates the object to be printed and draws it
     * @param context
     */
    eval(context) {
        let res = this._toPrint.eval(context);
        res.draw(context, this._dims, this);
        return res;
    }
    /**
     * Returns the object to be printed
     */
    get toPrint() {
        return this._toPrint;
    }
    /**
     * Returns the dimensions of the object to be printed
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.PrintNode = PrintNode;

},{}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ReturnError_1 = require("./ReturnError");
class Return {
    /**
     * Constructor for a Return object, representing something to be returned in a function
     * @param expr The expression to be returned
     * @param ws Preceding whitespace
     */
    constructor(expr, ws) {
        this._newLine = false;
        this._expr = expr;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the expression to be returned and returns via a ReturnErro
     * @param context The current program context
     */
    eval(context) {
        // If return val is a var, returns that var's value
        let result = this._expr.eval(context);
        throw new ReturnError_1.ReturnError(result, context.retIDLookup());
    }
    /**
     * Equals cannot be called directly on Return nodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on Return");
    }
    /**
     * Returns a string representation of the Return node
     */
    toString() {
        return this._ws + "return " + this._expr.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Return nodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw on Return");
    }
}
exports.Return = Return;

},{"./ReturnError":74}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ReturnError extends Error {
    /**
     * Constructor for ReturnError, a custom error class that we abuse to return values
     * @param retVal The value to be returned
     * @param ID The ID of the value to be returned
     */
    constructor(retVal, ID) {
        super(ID);
        this.retVal = retVal;
        this.ID = ID;
        Object.setPrototypeOf(this, ReturnError.prototype);
    }
}
exports.ReturnError = ReturnError;

},{}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const space_lift_1 = require("space-lift");
class Scope {
    /**
     * Constructor for Scope, an object keeping track of objects within a particular context
     * @param parent The parent Scope
     * @param effects Effects within this Scope
     * @param myState The scope state
     * @param eventLog The log of events that occurred
     */
    constructor(parent, effects, eventLog) {
        this._retValID = space_lift_1.None;
        this._canvas = space_lift_1.None;
        this._eventLog = []; // The event log
        this._hadFunEval = false; // Was this created in a function?
        //public globalFunID = Math.random();
        this.globalFunID = 10000000; // The global ID for functions in this context
        this._varBindings = new Map();
        this._parent = parent;
        this._effects = effects || null;
        this._eventLog = eventLog;
        if (this._parent != null && this._parent._hadFunEval)
            this._hadFunEval = true; // copy function eval flag from parent
    }
    /**
     * Copies information from this Scope into another Scope and returns the new Scope
     */
    copy() {
        let s = new Scope(this._parent, this._effects, this._eventLog);
        s.varBindings = new Map(this._varBindings);
        s.canvas = this.canvas;
        s.eventLog = this.eventLog;
        return s;
    }
    /**
     * Declares a new variable
     * @param name The name of the variable to be declared
     */
    declare(name) {
        if (this._varBindings.has(name)) {
            throw new Error("Scope already has var with name " + name);
        }
        this._varBindings.set(name, space_lift_1.None);
    }
    /**
     * Assigns a value to a variable in this Context
     * @param name The name of the variable
     * @param val The value of the variable
     */
    assign(name, val) {
        this._varBindings.set(name, space_lift_1.Some(val)); //Some(val)?
    }
    /**
     * Looks up a value within the Scope and all its ancestor Scopes
     * @param name The name of the value
     * @param context The context to search within
     */
    lookup(name, context) {
        if (context.varBindings.has(name)) {
            if (context.varBindings.get(name).isDefined()) {
                return (context.varBindings.get(name).get()); //extra get to manage Some()
            }
        }
        if (!(context.parent == null)) {
            return this.lookup(name, context.parent);
        }
        throw new Error("Variable could not be found.");
    }
    /**
     * Looks up and returns the return ID value
     */
    retIDLookup() {
        if (this._retValID.isDefined()) {
            return this._retValID.get();
        }
        else {
            if (this._parent) {
                return this._parent.retIDLookup();
            }
            else {
                throw new Error("Unknown caller.");
            }
        }
    }
    /**
     * Returns the Map of variable bindings
     */
    get varBindings() {
        return this._varBindings;
    }
    /**
     * Sets the Map of variable bindings
     */
    set varBindings(m) {
        this._varBindings = m;
    }
    /**
     * Returns the parent Scope
     */
    get parent() {
        return this._parent;
    }
    /**
     * Returns the return value ID
     */
    get retValID() {
        return this._retValID;
    }
    /**
     * Sets the return value ID
     */
    set retValID(val) {
        this._retValID = val;
    }
    /**
     * Returns the HTML canvas
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Sets the HTML canvas
     */
    set canvas(val) {
        this._canvas = val;
    }
    /**
     * Returns the effects array
     */
    get effects() {
        return this._effects;
    }
    /**
     * Sets the effects array
     */
    set effects(arr) {
        this._effects = arr;
    }
    /**
     * Returns the event log
     */
    get eventLog() {
        return this._eventLog;
    }
    /**
     * Sets the event log
     */
    set eventLog(update) {
        this._eventLog = update;
    }
    /**
     * Returns the array of effects
     */
    get mulSelArray() {
        return this._mulSelArray;
    }
    /**
     * Sets the array of effects
     */
    set mulSelArray(update) {
        this._mulSelArray = update;
    }
    /**
     * Returns whether this Scope was created in a function
     */
    get hadFunEval() {
        return this._hadFunEval;
    }
    /**
     * Sets whether this Scope was created in a function
     */
    set hadFunEval(val) {
        this._hadFunEval = val;
    }
}
exports.Scope = Scope;

},{"space-lift":89}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("./Scope");
const space_lift_1 = require("space-lift");
class SequenceNode {
    /**
     * Constructor for a SequenceNode, the building block of the AST
     * @param left The left side of the Sequence
     * @param right The right side of the Sequence
     */
    constructor(left, right) {
        this._newLine = true;
        this._left = left;
        this._right = right;
    }
    /**
     * Evaluates the children in postorder (left, right, parent)
     * @param context The current program context
     */
    eval(context) {
        let leftScope = new Scope_1.Scope(context, context.effects, context.eventLog);
        leftScope.canvas = space_lift_1.Some(context.canvas.get());
        //throwing away after evaling
        this._leftVal = this._left.eval(leftScope);
        this._rightVal = this._right.eval(leftScope); // leftScope may be modified now
    }
    /**
     * SequenceNodes cannot be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw() on SequenceNodes");
    }
    /**
     * Equals cannot be directly called on SequenceNodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on SequenceNode");
    }
    /**
     * Returns a string representation of the AST
     */
    toString() {
        let result = this._left.toString();
        if (this._left.newLine() == true) {
            result += '\n';
        }
        else {
            result += ";\n";
        }
        if (this._right.newLine() == false) {
            result += this._right.toString() + ";";
        }
        else {
            result += this._right.toString();
        }
        return result;
    }
    /**
     * Returns the left child
     */
    set left(left) {
        this._left = left;
    }
    /**
     * Sets the left child
     */
    get left() {
        return this._left;
    }
    /**
     * Returns the right child
     */
    set right(right) {
        this._right = right;
    }
    /**
     * Sets the right child
     */
    get right() {
        return this._right;
    }
    /**
     * Returns the value of the left chile
     */
    get leftVal() {
        return this._leftVal;
    }
    /**
     * Returns the value of the right chile
     */
    get rightVal() {
        return this._rightVal;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.SequenceNode = SequenceNode;

},{"./Scope":75,"space-lift":89}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../../index");
const index_2 = require("../../index");
const index_3 = require("../../index");
const index_4 = require("../../index");
const index_5 = require("../../index");
const index_6 = require("../../index");
const space_lift_1 = require("space-lift");
let canvas = document.querySelector('canvas');
let ctx = canvas.getContext("2d");
let inputBox = document.getElementById('input');
let lastWorkingInputText = "";
//the effects array that holds all the text, ellipses, and rectangles
let effects = [];
let ast;
let context;
let showDebug = true; // flag to show or hide debug button
let masterLog = [];
let selectedElems = [];
let textBoxSelected; //sees if the text box is selected
let isPainting; //tests to see if you're painting to the canvas
let checkpointIsActive = false;
let checkpoint = null;
let canvasIsDisabled = false;
let selected = 0; //the number of selected effects if multiply selecting
let alreadyLogged = false;
let numLogged = 0;
let globalID = 1;
let eph;
/*
let bugButton = document.getElementById('debug');
if(!showDebug){
    bugButton.style.visibility='hidden';
}

bugButton.onclick = function(){
    printLog();
}
*/
/**
 * <div class="col-item">
 *  <button id='paint' style="background-color:#DFB534"> Run </button>
 * </div>
 *
 * Put this in html file for Run button's styling
 */
//let paintButton = document.getElementById('paint');
/**
 * makes the paint button paint text from the textarea to the canvas!
 */
/*
paintButton.onclick = function () {
    effects.length = 0; // slightly sketch clearing method to maintain reference to original array
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    isPainting = true;
    let inputText = inputBox.value;

    let astOpt = Parser.parse(inputText);
    if(astOpt.isDefined()){
        ast = astOpt.get();
        context = new Scope(null, effects, masterLog);
        context.canvas = Some(canvas);
        ast.eval(context); //this is where we draw the objects to the screen
    } else {
        let error = "error text";
        alert("Quan: so something with this syntax error: " + error);
    }

    //let paintEvt = new PaintEvent(inputText); // will need to get from ast when that's implemented

    // Adding context log to master log
    //logEvent.push(paintEvt.assembleLog());
    printLog();
    //event1.logItem();
    // }
};
*/
//clears the canvas!
let resetButton = document.getElementById('reset');
resetButton.onclick = function () {
    if (checkpoint._starterCode != null) {
        textBoxSelected = true;
        inputBox.value = checkpoint._starterCode;
    }
    context.eventLog.push(new index_2.ClearEvent());
    masterLog.push(context.eventLog[context.eventLog.length - 1]); // Does this actually work?
    printLog();
    //let clearEvt = new ClearEvent();
    //logEvent.push(clearEvt.assembleLog());
    //console.log("Log: " + logEvent);
};
let timer = null;
inputBox.onkeydown = function () {
    if (timer != null) {
        clearTimeout(timer);
    }
    timer = setTimeout(parse, 200);
};
function parse() {
    effects.length = 0; // slightly sketch clearing method to maintain reference to original array
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let inputText = inputBox.value;
    let astOpt = index_1.Parser.parse(inputText);
    if (astOpt.isDefined()) {
        ast = astOpt.get();
        context = new index_2.Scope(null, effects, masterLog);
        context.canvas = space_lift_1.Some(canvas);
        ast.eval(context); //this is where we draw the objects to the screen
        lastWorkingInputText = inputText;
    }
    //let paintEvt = new PaintEvent(inputText); // will need to get from ast when that's implemented
    // Adding context log to master log
    //logEvent.push(paintEvt.assembleLog());
    printLog();
    //event1.logItem();
    // }
}
/**
 * The animation function that basically recursively calls itself, clearing and
 * redrawing to the canvas at 60fps.
 */
function animate() {
    requestAnimationFrame(animate);
    ctx.clearRect(0, 0, canvas.width, canvas.height); //clears canvas
    selected = 0;
    for (let i = 0; i < effects.length; i++) {
        effects[i].update();
        if (effects[i].selected) {
            selectedElems.push(effects[i]);
            selected++;
        }
        if (effects[i].getJustDragged()) { // Logs drag event
            context.eventLog.push(new index_2.DragEvent(effects[i]));
            masterLog.push(context.eventLog[context.eventLog.length - 1]);
            effects[i].setJustDragged(false);
        }
        if (effects[i].idObj == undefined) { // Gives object an ID if it doesn't have one
            effects[i].initID(globalID);
            context.eventLog.push(new index_2.IDEvent(effects[i])); // Logs ID
            globalID++;
            //console.log(effects[i].getID());
        }
        // if(((effects[i] as EllipseEffect).justDragged)){
        //     //context.eventLog.push(new DragEvent(effects[i]));
        // }
    }
    // at this point, have iterated through all effects and have complete list to log
    if (selected != numLogged) { // if selections have changed, should log again
        alreadyLogged = false;
    }
    if (!alreadyLogged && selected >= 2) { // logs if hasn't already
        numLogged = selected;
        context.eventLog.push(new index_2.SelectEvent(selectedElems));
        masterLog.push(context.eventLog[context.eventLog.length - 1]);
        alreadyLogged = true;
    }
    //This does the prodirect manipulation, passing the new strings to the text box
    let inputText = inputBox.value;
    if (textBoxSelected && inputText !== lastWorkingInputText) {
        /*      effects.length = 0; // slightly sketch clearing method to maintain reference to original array
              ctx.clearRect(0, 0, canvas.width, canvas.height);
        
              //isPainting = true;
              //let inputText = inputBox.value;
        
              let astOpt = Parser.parse(inputText);
              if(astOpt.isDefined()){
                  ast = astOpt.get();
                  context = new Scope(null, effects, masterLog);
                  context.canvas = Some(canvas);
                  ast.eval(context); //this is where we draw the objects to the screen
                  lastWorkingInputText = inputText;
              } /*else {
                  let error = "error text";
                  alert("Quan: so something with this syntax error: " + error);
              }*/
        //let paintEvt = new PaintEvent(inputText); // will need to get from ast when that's implemented
        // Adding context log to master log
        //logEvent.push(paintEvt.assembleLog());
        printLog();
        //event1.logItem();
        // }
    }
    else if (ast != undefined && !textBoxSelected /* && !isPainting */) {
        let newInput = ast.toString();
        inputBox.value = newInput;
    }
    if (checkpointIsActive) {
        checkpointChecksGoal();
    }
    if (checkpoint != null && checkpoint.drawGuides != null) {
        checkpoint.drawGuides(ctx);
        /*
              if (checkpoint._name == "l1c3") {
                ctx.beginPath();
                ctx.rect(10, 430, 100, 100);
                ctx.strokeStyle = '#6C6C6C';
                ctx.stroke();
        
                ctx.font = 20 + "px Courier New";
                ctx.fillStyle = '#6C6C6C';
                ctx.fillText("Put text", 10, 390);
                ctx.fillText("in here", 10, 410);
              }
        */
    }
    selectedElems = [];
}
//checks to see whether the text box is selected
window.addEventListener('mousedown', isInputBoxSelected);
/**
 * This function manages the state of the UI when the text box is selected and when it isn't.
 * If it is inside the text box, isPainting is false and textBoxSelected is true.
 * If it's not, if it's inside the paint button, then isPainting = true.
 * @param event the mouse down event
 */
function isInputBoxSelected(event) {
    let mouseX = event.clientX;
    let mouseY = event.clientY;
    let rect = inputBox.getBoundingClientRect();
    if (mouseX > rect.left && mouseX < rect.right && mouseY > rect.top && mouseY < rect.bottom) {
        //isPainting = false;
        textBoxSelected = true;
    }
    else {
        /*
          let paintButton = document.getElementById('paint');
          rect = paintButton.getBoundingClientRect();
          if(mouseX > rect.left && mouseX < rect.right && mouseY > rect.top && mouseY < rect.bottom) {
              isPainting = true;
          }
          else {
              isPainting = false;
          }
          */
        textBoxSelected = false;
    }
}
//checks to see whether the text box is selected
window.addEventListener('mousedown', disabledCanvasIsSelected);
/**
 * This function handles the case when a disabled canvas is selected.
 * @param event the mouse down event
 */
function disabledCanvasIsSelected(event) {
    let mouseX = event.clientX;
    let mouseY = event.clientY;
    let rect = canvas.getBoundingClientRect();
    let popUp = document.getElementById('popup');
    if (canvasIsDisabled && mouseX > rect.left && mouseX < rect.right && mouseY > rect.top && mouseY < rect.bottom) {
        popUp.style.display = 'block';
    }
    else {
        popUp.style.display = 'none';
    }
}
function printLog() {
    console.log("Log: ");
    for (let elem of masterLog) {
        console.log(elem.assembleLog());
    }
}
let paletteButtons = [
    "ellipse", "rect", "string", "number",
    "line", "curve"
];
for (let buttonName of paletteButtons) {
    let paletteButton = document.getElementById(buttonName);
    paletteButton.onclick = function () {
        textBoxSelected = true;
        printNewNode(buttonName);
    };
}
function printNewNode(buttonName) {
    let printLine = "";
    switch (buttonName) {
        case "ellipse":
            printLine = "print(ellipse(100,100));";
            break;
        case "rect":
            printLine = "print(rect(100,100));";
            break;
        case "string":
            printLine = 'print("newWord");';
            break;
        case "number":
            printLine = "print(10);";
            break;
        case "line":
            printLine = "print(line(100,100));";
            break;
        case "curve":
            printLine = "print(curve(100,100,100));";
            break;
        default:
            console.log("Problem with " + buttonName);
    }
    inputBox.value += printLine;
    parse();
}
let instructions = document.getElementById('instructions');
let goalBox = document.getElementById('goal-container');
let instrLabel = document.getElementById('instr-label');
//Map maintaining code last used at a checkpoint
let cpCode = new Map([
    ['l1c1', ""],
    ['l1c2', ""],
    ['l1c3', ""],
    ['l1c4', ""],
    ['l2c1', ""],
    ['l2c2', ""],
    ['l2c3', ""],
    ['l2c4', ""],
    ['l2c5', ""],
    ['l2c6', ""],
    ['l2c7', ""],
    ['l3c1', ""],
    ['l3c2', ""],
    ['l3c3', ""],
    ['l3c4', ""],
    ['l3c5', ""],
    ['l3c6', ""],
    ['l4c1', ""],
    ['l4c2', ""]
]);
//Map maintaining whether a checkpoint has been completed
let cpCompletion = new Map([
    ['l1c1', false],
    ['l1c2', false],
    ['l1c3', false],
    ['l1c4', false],
    ['l2c1', false],
    ['l2c2', false],
    ['l2c3', false],
    ['l2c4', false],
    ['l2c5', false],
    ['l2c6', false],
    ['l2c7', false],
    ['l3c1', false],
    ['l3c2', false],
    ['l3c3', false],
    ['l3c4', false],
    ['l3c5', false],
    ['l3c6', false],
    ['l4c1', false],
    ['l4c2', false]
]);
let checkpoints = new Map([
    ['l1c1', () => new index_3.LessonOneCpOne()],
    ['l1c2', () => new index_3.LessonOneCpTwo()],
    ['l1c3', () => new index_3.LessonOneCpThree()],
    ['l1c4', () => new index_3.LessonOneCpFour()],
    ['l2c1', () => new index_4.LessonTwoCpOne()],
    ['l2c2', () => new index_4.LessonTwoCpTwo()],
    ['l2c3', () => new index_4.LessonTwoCpThree()],
    ['l2c4', () => new index_4.LessonTwoCpFour()],
    ['l2c5', () => new index_4.LessonTwoCpFive()],
    ['l2c6', () => new index_4.LessonTwoCpSix()],
    ['l2c7', () => new index_4.LessonTwoCpSeven()],
    ['l3c1', () => new index_5.LessonThreeCpOne()],
    ['l3c2', () => new index_5.LessonThreeCpTwo()],
    ['l3c3', () => new index_5.LessonThreeCpThree()],
    ['l3c4', () => new index_5.LessonThreeCpFour()],
    ['l3c5', () => new index_5.LessonThreeCpFive()],
    ['l3c6', () => new index_5.LessonThreeCpSix()],
    ['l4c1', () => new index_6.LessonFourCpOne()],
    ['l4c2', () => new index_6.LessonFourCpTwo()]
]);
for (let cp of checkpoints.keys()) {
    let cpButton = document.getElementById(cp);
    cpButton.onclick = function () {
        initCheckpoint(cp);
    };
}
/**
 * Creates a module corresponding to a checkpoint passed in.
 * Sets up the instruction, CODE area, and goal box accordingly.
 * @param cp: the name of the checkpoint
 */
function initCheckpoint(cp) {
    if (checkpoints.has(cp)) {
        if (checkpoint != null) {
            cpCode.set(checkpoint._name, inputBox.value);
        }
        console.log("Initiating checkpoint " + cp);
        checkpoint = checkpoints.get(cp)();
        instrLabel.innerHTML = cp + " - INSTRUCTIONS";
        instructions.innerHTML = checkpoint._instructions;
        //set up the CODE and CANVAS areas
        if (checkpoint._constraint == 'code') {
            inputBox.setAttribute('disabled', 'disabled');
            inputBox.style.opacity = '0.5';
            canvas.style.pointerEvents = "auto";
            canvas.style.background = '#EBEBEB';
            canvasIsDisabled = false;
        }
        else if (checkpoint._constraint == 'canvas') {
            inputBox.removeAttribute('disabled');
            inputBox.style.opacity = '1.0';
            canvas.style.pointerEvents = "none";
            canvas.style.background = '#C0C0C0';
            canvasIsDisabled = true;
        }
        else {
            inputBox.removeAttribute('disabled');
            inputBox.style.opacity = '1.0';
            canvas.style.pointerEvents = "auto";
            canvas.style.background = '#EBEBEB';
            canvasIsDisabled = false;
        }
        let popUp = document.getElementById('popup');
        popUp.style.display = 'none';
        if (cpCode.get(checkpoint._name) !== "") {
            textBoxSelected = true;
            inputBox.value = cpCode.get(checkpoint._name);
        }
        //set up the instruction and goal boxes
        if (cpCompletion.get(cp)) {
            updateGoalBox();
        }
        else {
            if (checkpoint._starterCode != null) {
                textBoxSelected = true;
                inputBox.value = checkpoint._starterCode;
            }
            goalBox.style.background = '#C0C0C0';
            let goalText = document.getElementById('goal-text');
            goalText.style.color = 'black';
            goalText.innerHTML = 'Complete goal to earn a star!';
            let goalImg = document.getElementById('goal-image');
            goalImg.src = 'pics/greystar.svg';
            goalImg.alt = 'a star to be earned';
            let nextBtn = document.getElementById('next');
            nextBtn.style.display = 'none';
            instructions.scrollTop = 0;
            checkpointIsActive = true;
        }
    }
}
function checkpointChecksGoal() {
    if (checkpoint.checkGoal(document, effects)) {
        updateGoalBox();
        cpCompletion.set(checkpoint._name, true);
    }
}
function updateGoalBox() {
    goalBox.style.background = '#673AB7';
    console.log(document);
    let goalText = document.getElementById('goal-text');
    goalText.style.color = '#D8D8D8';
    goalText.innerHTML = 'Goal met!';
    let goalImg = document.getElementById('goal-image');
    goalImg.src = 'pics/star.svg';
    goalImg.alt = 'star earned';
    let nextBtn = document.getElementById('next');
    nextBtn.style.display = 'block';
    instructions.innerHTML += "\nHooray! Goal met! Click 'Next' to proceed to next checkpoint!";
    instructions.scrollTop = instructions.scrollHeight;
    checkpointIsActive = false;
}
let nextButton = document.getElementById('next');
nextButton.onclick = function () {
    let nextModule = checkpoint._nextModule;
    if (nextModule != '') {
        initCheckpoint(nextModule);
    }
};
let prevButton = document.getElementById('prev');
prevButton.onclick = function () {
    let prevModule = checkpoint._prevModule;
    if (prevModule != '') {
        initCheckpoint(prevModule);
    }
};
//call to animate
animate();
//--------------------------------------------------------------
/* test lines of S.W.E.L.L. code

print("hello world", 180, 421);
print(ellipse(75, 50), 100, 100);
print(rect(60, 70), 250, 250);

print("hello");
print("world");

Our sample program
print("hello world");
print(ellipse(130, 100));
*/

},{"../../index":1,"space-lift":89}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const UnaryOperation_1 = require("./UnaryOperation");
const NumberNode_1 = require("../prims/NumberNode");
class NegOp extends UnaryOperation_1.UnaryOperation {
    /**
     * Constructor for a NegationOperation
     * @param val The value to be negated (must be a NumberNode)
     * @param ws Preceding whitespace
     */
    constructor(val, ws) {
        super(val);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the value into the negative version
     * @param context The current program context
     */
    eval(context) {
        let v = this.val.eval(context);
        return new NumberNode_1.NumberNode(-v.val, "");
    }
    /**
     * NegOps cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Negation ops cannot be drawn directly");
    }
    /**
     * Equals cannot be called directly on a NegOp
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on NegOp");
    }
    /**
     * Returns a string representation of the NegOp
     */
    toString() {
        return this._ws + "-" + this.val;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.NegOp = NegOp;

},{"../prims/NumberNode":63,"./UnaryOperation":79}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class UnaryOperation {
    /**
     * Abstract class constructor for Unary Operations
     * @param _val The object to be operated on
     */
    constructor(_val) {
        this._val = _val;
        this._newLine = false;
    }
    ;
    /**
     * Abstract draw method for undrawable UnaryOps
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Unary Operations cannot be drawn directly");
    }
    /**
     * Equals cannot be called directly on UnaryOps
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on UnaryOp");
    }
    ;
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the UnaryOp value
     */
    get val() {
        return this._val;
    }
    /**
     * Sets the UnaryOp value
     */
    set val(value) {
        this._val = value;
    }
}
exports.UnaryOperation = UnaryOperation;

},{}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class VariableNode {
    /**
     * Constructor for a VariableNode, a node representing a variable
     * @param name The variable name
     * @param ws Preceding whitespace
     */
    constructor(name, ws) {
        this._newLine = false;
        this._name = name;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Looks up the value of the variable in the context
     * @param context The current program context
     */
    eval(context) {
        return context.lookup(this._name, context);
    }
    /**
     * VariableNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw on variable nodes");
    }
    /**
     * Equals cannot be called directly on VariableNodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot directly compare vars, eval first");
    }
    /**
     * Returns a string representation of the VariableNode
     */
    toString() {
        return this._ws + this._name;
    }
    /**
     * Returns the name of the variable
     */
    get name() {
        return this._name;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.VariableNode = VariableNode;

},{}],81:[function(require,module,exports){
"use strict";
//--------------------------------------
//  Shallow update
//--------------------------------------
exports.__esModule = true;
/** Performs a shallow update of an object using a partial object of the same shape. A new object is returned. */
function update(host, spec) {
    var result = clone(host);
    for (var key in spec) {
        var specValue = spec[key];
        if (specValue === exports.DELETE) {
            delete result[key];
        }
        else {
            result[key] = specValue;
        }
    }
    return result;
}
exports.update = update;
// We lie about the public type so that only a property that is optional or that can be assigned to undefined can be DELETE'd
/** Marker used to delete a key */
exports.DELETE = {};
var _Updater = /** @class */ (function () {
    function _Updater(data) {
        this.data = data;
    }
    _Updater.prototype.at = function (keyOrIndex) {
        return new _Updater({ type: 'at', parent: this, field: keyOrIndex });
    };
    _Updater.prototype.set = function (value) {
        var _this = this;
        var doSet = function (target) {
            var result = _this.cloneForUpdate(target);
            if (result.name === 'aborted')
                return target;
            var clonedTarget = result.clonedTarget, leafHost = result.leafHost, field = result.field;
            value === exports.DELETE ? delete leafHost[field] : leafHost[field] = value;
            return clonedTarget;
        };
        var boundTarget = this.findBoundTarget();
        return boundTarget
            ? doSet(boundTarget)
            : doSet;
    };
    _Updater.prototype.modify = function (modifier) {
        var _this = this;
        var doModify = function (target) {
            var result = _this.cloneForUpdate(target);
            if (result.name === 'aborted')
                return target;
            var clonedTarget = result.clonedTarget, leafHost = result.leafHost, field = result.field;
            var value = modifier(leafHost[field]);
            value === exports.DELETE ? delete leafHost[field] : leafHost[field] = value;
            return clonedTarget;
        };
        var boundTarget = this.findBoundTarget();
        return boundTarget
            ? doModify(boundTarget)
            : doModify;
    };
    _Updater.prototype.withDefault = function (value) {
        return new _Updater({ type: 'withDefault', parent: this, defaultValue: value });
    };
    _Updater.prototype.abortIfUndef = function () {
        return new _Updater({ type: 'abortIfUndef', parent: this });
    };
    _Updater.prototype.findBoundTarget = function () {
        var current = this;
        while (true) {
            if (current.data.type === 'root')
                return current.data.boundTarget;
            current = current.data.parent;
        }
    };
    _Updater.prototype.parentUpdaters = function () {
        var updaters = [this];
        var parentUpdater = this.data.parent;
        // Ignore the root updater
        while (parentUpdater && parentUpdater.data.parent) {
            updaters.unshift(parentUpdater);
            parentUpdater = parentUpdater.data.parent;
        }
        return updaters;
    };
    _Updater.prototype.getNextValue = function (previousHost, host, field, isLast) {
        if (this.data.type === 'at') {
            var newField = this.data.field;
            var value_1 = host[newField];
            var nextValue = isObjectOrArray(value_1) ? clone(value_1) : value_1;
            var newHost_1 = isLast ? host : nextValue;
            host[this.data.field] = nextValue;
            return { host: newHost_1, field: newField };
        }
        var value = previousHost[field];
        if (this.data.type === 'abortIfUndef' && value === undefined) {
            return { host: host, field: field, aborted: true };
        }
        if (this.data.type === 'withDefault' && value === undefined) {
            var nextValue = this.data.defaultValue;
            var newHost_2 = isLast ? previousHost : nextValue;
            previousHost[field] = nextValue;
            return { host: newHost_2, field: field };
        }
        var newHost = isLast ? previousHost : host;
        return { host: newHost, field: field };
    };
    _Updater.prototype.cloneForUpdate = function (target) {
        var updaters = this.parentUpdaters();
        var obj = clone(target);
        var previousHost = obj;
        var host = obj;
        var field = '';
        for (var i = 0; i < updaters.length; i++) {
            var result = updaters[i].getNextValue(previousHost, host, field, i === updaters.length - 1);
            if (result.aborted)
                return { name: 'aborted' };
            previousHost = host;
            host = result.host;
            field = result.field;
        }
        return {
            name: 'result',
            clonedTarget: obj,
            leafHost: host,
            field: field
        };
    };
    return _Updater;
}());
function isObjectOrArray(obj) {
    return obj !== null && typeof obj === 'object';
}
function clone(obj) {
    if (Array.isArray(obj))
        return obj.slice();
    var cloned = {};
    Object.keys(obj).forEach(function (key) { cloned[key] = obj[key]; });
    return cloned;
}
function deepUpdate(target) {
    return new _Updater({ type: 'root', boundTarget: target });
}
exports.deepUpdate = deepUpdate;

},{}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CharUtil;
(function (CharUtil) {
    class CharStream {
        constructor(s, startpos, endpos, hasEOF) {
            this.hasEOF = true;
            this.input = s;
            if (hasEOF != undefined) {
                this.hasEOF = hasEOF;
            }
            if (startpos == undefined) {
                this.startpos = 0; // not specified; set default
            }
            else if (startpos > s.length) {
                this.startpos = s.length; // seek too far; set EOF
            }
            else {
                this.startpos = startpos; // specified and in bounds
            }
            if (endpos == undefined) {
                this.endpos = s.length; // not specified; set default
            }
            else if (endpos > s.length) {
                this.endpos = s.length; // seek too far; set EOF
            }
            else {
                this.endpos = endpos; // specified and in bounds
            }
            if (this.startpos > this.endpos) {
                this.startpos = this.endpos; // if the user flipped positions
            }
        }
        /**
         * Returns true of the end of the input has been reached.
         */
        isEOF() {
            return this.hasEOF && this.startpos == this.input.length;
        }
        /**
         * Returns a Javscript primitive string of the slice of input
         * represented by this CharStream.
         */
        toString() {
            return this.input.substring(this.startpos, this.endpos);
        }
        /**
         * Returns a new CharStream representing the input from the
         * current start position to an end position num chars from
         * the current start position.  If startpos + num > endpos,
         * the current CharStream is returned.
         * @param num
         */
        peek(num) {
            if (this.startpos + num > this.endpos) {
                return this;
            }
            else {
                let newHasEOF = this.startpos + num == this.endpos && this.hasEOF;
                return new CharStream(this.input, this.startpos, this.startpos + num, newHasEOF);
            }
        }
        /**
         * Returns a new CharStream representing the string after
         * seeking num characters from the current position.
         * @param num
         */
        seek(num) {
            if (this.startpos + num > this.endpos) {
                return new CharStream(this.input, this.endpos, this.endpos, this.hasEOF);
            }
            else {
                return new CharStream(this.input, this.startpos + num, this.endpos, this.hasEOF);
            }
        }
        /**
         * Returns a new CharStream representing the head of the input at
         * the current position.  Throws an exception if the CharStream is
         * empty.
         */
        head() {
            if (!this.isEmpty()) {
                const newHasEOF = this.startpos + 1 == this.endpos && this.hasEOF;
                return new CharStream(this.input, this.startpos, this.startpos + 1, newHasEOF);
            }
            else {
                throw new Error("Cannot get the head of an empty string.");
            }
        }
        /**
         * Returns a new CharStream representing the tail of the input at
         * the current position.  Throws an exception if the CharStream is
         * empty.
         */
        tail() {
            if (!this.isEmpty()) {
                return new CharStream(this.input, this.startpos + 1, this.endpos, this.hasEOF);
            }
            else {
                throw new Error("Cannot get the tail of an empty string.");
            }
        }
        /**
         * Returns true if the input at the current position is empty. Note
         * that a CharStream at the end of the input contains an empty
         * string but that an empty string may not be the end-of-file (i.e.,
         * isEOF is false).
         */
        isEmpty() {
            return this.startpos == this.endpos;
        }
        /**
         * Returns the number of characters remaining at
         * the current position.
         */
        length() {
            return this.endpos - this.startpos;
        }
        /**
         * Returns the substring between start and end at the
         * current position.
         * @param start the start index of the substring, inclusive
         * @param end the end index of the substring, exclusive
         */
        substring(start, end) {
            const start2 = this.startpos + start;
            const end2 = this.startpos + end;
            const newHasEOF = this.endpos == end2 && this.hasEOF;
            return new CharStream(this.input, start2, end2, newHasEOF);
        }
        /**
         * Returns the concatenation of the current CharStream with
         * the given CharStream. Note: returned object does not
         * reuse original input string, and startpos and endpos
         * are reset. If the given CharStream contains EOF, the
         * concatenated CharStream will also contain EOF.
         * @param cs the CharStream to concat to this CharStream
         */
        concat(cs) {
            const s = this.toString() + cs.toString();
            return new CharStream(s, 0, s.length, cs.hasEOF);
        }
        /**
         * Concatenate an array of CharStream objects into a single
         * CharStream object.
         * @param css a CharStream[]
         */
        static concat(css) {
            if (css.length == 0) {
                return new CharStream("", 0, 0, false);
            }
            else {
                let cs = css[0];
                for (let i = 1; i < css.length; i++) {
                    cs = cs.concat(css[i]);
                }
                return cs;
            }
        }
    }
    CharUtil.CharStream = CharStream;
})(CharUtil = exports.CharUtil || (exports.CharUtil = {}));

},{}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var primitives_1 = require("./primitives");
exports.Primitives = primitives_1.Primitives;
var charstream_1 = require("./charstream");
exports.CharUtil = charstream_1.CharUtil;

},{"./charstream":82,"./primitives":84}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const charstream_1 = require("./charstream");
var Primitives;
(function (Primitives) {
    class EOFMark {
        constructor() { }
        static get Instance() {
            return this._instance || (this._instance = new this());
        }
    }
    Primitives.EOFMark = EOFMark;
    Primitives.EOF = EOFMark.Instance;
    /**
     * Represents a successful parse.
     */
    class Success {
        /**
         * Returns an object representing a successful parse.
         * @param istream The remaining string.
         * @param res The result of the parse
         */
        constructor(istream, res) {
            this.tag = "success";
            this.inputstream = istream;
            this.result = res;
        }
    }
    Primitives.Success = Success;
    /**
     * Represents a failed parse.
     */
    class Failure {
        /**
         * Returns an object representing a failed parse.
         * @param istream The string, unmodified, that was given to the parser.
         */
        constructor(istream) {
            this.tag = "failure";
            this.inputstream = istream;
        }
    }
    Primitives.Failure = Failure;
    /**
     * result succeeds without consuming any input, and returns v.
     * @param v The result of the parse.
     */
    function result(v) {
        return (istream) => new Success(istream, v);
    }
    Primitives.result = result;
    /**
     * zero fails without consuming any input.
     */
    function zero() {
        return (istream) => new Failure(istream);
    }
    Primitives.zero = zero;
    /**
     * item successfully consumes the first character if the input
     * string is non-empty, otherwise it fails.
     */
    function item() {
        return (istream) => {
            if (istream.isEmpty()) {
                return new Failure(istream);
            }
            else {
                return new Success(istream.tail(), istream.head());
            }
        };
    }
    Primitives.item = item;
    /**
     * bind is a curried function that takes a parser p and returns
     * a function that takes a parser f which returns the composition
     * of p and f.  If _any_ of the parsers fail, the original inputstream
     * is returned in the Failure object (i.e., bind backtracks).
     * @param p A parser
     */
    function bind(p) {
        return (f) => {
            return (istream) => {
                let r = p(istream);
                switch (r.tag) {
                    case "success":
                        let o = f(r.result)(r.inputstream);
                        switch (o.tag) {
                            case "success": return o;
                            case "failure":
                                // note: backtracks, returning original istream
                                return new Failure(istream);
                        }
                    case "failure": return new Failure(istream);
                }
            };
        };
    }
    Primitives.bind = bind;
    function delay(p) {
        return () => p;
    }
    Primitives.delay = delay;
    /**
     * seq is a curried function that takes a parser p, a parser q,
     * and a function f. It applies p to the input, passing the
     * remaining input stream to q; q is then applied.  The function
     * f takes the result of p and q, as a tuple, and returns
     * a single result.
     * @param p A parser
     */
    // export let seq = function<T,U,V>(p: IParser<T>) {
    //     return (q: IParser<U>) => {
    //         return (f: (e: [T,U]) => V) => {
    //             return bind<T,V>(p)((x) => {
    //                 return bind<U,V>(q)((y) => {
    //                     let tup : [T,U] = [x,y];
    //                     return result<V>(f(tup));
    //                 });
    //             });
    //         }
    //     };
    // }
    function seq(p) {
        return (q) => {
            return (f) => {
                return bind(p)((x) => {
                    return bind(q)((y) => {
                        let tup = [x, y];
                        return result(f(tup));
                    });
                });
            };
        };
    }
    Primitives.seq = seq;
    /**
     * sat takes a predicate and yields a parser that consumes a
     * single character if the character satisfies the predicate,
     * otherwise it fails.
     * @param pred a character predicate
     */
    function sat(pred) {
        let pred2 = (cs) => pred(cs.toString());
        let a = item();
        let b = (x) => {
            if (pred2(x)) {
                return result(x);
            }
            else {
                return zero();
            }
        };
        return bind(a)(b);
    }
    Primitives.sat = sat;
    /**
     * char takes a character and yields a parser that consume
     * that character. The returned parser succeeds if the next
     * character in the input stream is c, otherwise it fails.
     * @param c
     */
    function char(c) {
        if (c.length != 1) {
            throw new Error("char parser takes a string of length 1 (i.e., a char)");
        }
        return sat(x => x == c);
    }
    Primitives.char = char;
    /**
     * letter returns a parser that consumes a single alphabetic
     * character, from a-z, regardless of case.
     */
    function letter() {
        let contains_letter = (x) => {
            let a_letter = /[A-Za-z]/;
            return x.match(a_letter) != undefined;
        };
        return sat(contains_letter);
    }
    Primitives.letter = letter;
    /**
     * digit returns a parser that consumes a single numeric
     * character, from 0-9.  Note that the type of the result
     * is a string, not a number.
     */
    function digit() {
        return sat(x => x == "0"
            || x == "1"
            || x == "2"
            || x == "3"
            || x == "4"
            || x == "5"
            || x == "6"
            || x == "7"
            || x == "8"
            || x == "9");
    }
    Primitives.digit = digit;
    /**
     * upper returns a parser that consumes a single character
     * if that character is uppercase.
     */
    function upper() {
        return (istream) => {
            let o1 = letter()(istream);
            switch (o1.tag) {
                case "success":
                    let o2 = sat(x => x == x.toUpperCase())(o1.result);
                    switch (o2.tag) {
                        case "success":
                            return o1;
                        case "failure":
                            return new Failure(istream);
                    }
                    break;
                case "failure":
                    return o1;
            }
            throw new Error("never happens");
        };
    }
    Primitives.upper = upper;
    /**
     * lower returns a parser that consumes a single character
     * if that character is lowercase.
     */
    function lower() {
        return (istream) => {
            let o1 = letter()(istream);
            switch (o1.tag) {
                case "success":
                    let o2 = sat(x => x == x.toLowerCase())(o1.result);
                    switch (o2.tag) {
                        case "success":
                            return o1;
                        case "failure":
                            return new Failure(istream);
                    }
                    break;
                case "failure":
                    return o1;
            }
            throw new Error("never happens");
        };
    }
    Primitives.lower = lower;
    /**
     * choice specifies an ordered choice between two parsers,
     * p1 and p2. The returned parser will first apply
     * parser p1.  If p1 succeeds, p1's Outcome is returned.
     * If p1 fails, p2 is applied and the Outcome of p2 is returned.
     * Note that the input stream given to p1 and p2 is exactly
     * the same input stream.
     * @param p1 A parser.
     */
    function choice(p1) {
        return (p2) => {
            return (istream) => {
                let o = p1(istream);
                switch (o.tag) {
                    case "success":
                        return o;
                    case "failure":
                        return p2(istream);
                }
            };
        };
    }
    Primitives.choice = choice;
    /**
     * appfun allows the user to apply a function f to
     * the result of a parser p, assuming that p is successful.
     * @param p A parser.  This is the same as the |>>
     * function from FParsec.
     */
    function appfun(p) {
        return (f) => {
            return (istream) => {
                let o = p(istream);
                switch (o.tag) {
                    case "success":
                        return new Success(o.inputstream, f(o.result));
                    case "failure":
                        return o;
                }
            };
        };
    }
    Primitives.appfun = appfun;
    /**
     * many repeatedly applies the parser p until p fails. many always
     * succeeds, even if it matches nothing.  many tries to guard
     * against an infinite loop by raising an exception if p succeeds
     * without changing the parser state.
     * @param p
     */
    function many(p) {
        return (istream) => {
            let istream2 = istream;
            let outputs = [];
            let succeeds = true;
            while (!istream2.isEmpty() && succeeds) {
                let o = p(istream2);
                switch (o.tag) {
                    case "success":
                        if (istream2 == o.inputstream) {
                            throw new Error("Parser loops infinitely.");
                        }
                        istream2 = o.inputstream;
                        outputs.push(o.result);
                        break;
                    case "failure":
                        succeeds = false;
                        break;
                }
            }
            return new Success(istream2, outputs);
        };
    }
    Primitives.many = many;
    /**
     * many1 repeatedly applies the parser p until p fails. many1 must
     * succeed at least once.  many1 tries to guard against an infinite
     * loop by raising an exception if p succeeds without changing the
     * parser state.
     * @param p
     */
    function many1(p) {
        return (istream) => {
            return seq(p)(many(p))(tup => {
                let hd = tup["0"];
                let tl = tup["1"];
                tl.unshift(hd);
                return tl;
            })(istream);
        };
    }
    Primitives.many1 = many1;
    /**
     * str yields a parser for the given string.
     * @param s A string
     */
    // TODO: this should actually be a sequence of parsers constructed
    // from the string s
    function str(s) {
        return (istream) => {
            // escape regex metacharacters
            // (this likely needs work)
            let s2 = s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
            let re = new RegExp("^" + s2);
            if (istream.toString().match(re)) {
                const rem = istream.substring(s.length, istream.length());
                const res = istream.substring(0, s.length);
                return new Success(rem, res);
            }
            else {
                return new Failure(istream);
            }
        };
    }
    Primitives.str = str;
    /**
     * Returns a parser that succeeds only if the end of the
     * input has been reached.
     */
    function eof() {
        return (istream) => {
            if (istream.isEOF()) {
                return new Success(istream, Primitives.EOF);
            }
            else {
                return new Failure(istream);
            }
        };
    }
    Primitives.eof = eof;
    /**
     * fresult returns a parser that applies the parser p,
     * and if p succeeds, returns the value x.
     * @param p a parser
     */
    function fresult(p) {
        return (x) => {
            return (istream) => {
                return bind(p)((t) => result(x))(istream);
            };
        };
    }
    Primitives.fresult = fresult;
    /**
     * left returns a parser that applies the parser p,
     * then the parser q, and if both are successful,
     * returns the result of p.
     * @param p a parser
     */
    function left(p) {
        return (q) => {
            return (istream) => {
                return bind(p)((t) => fresult(q)(t))(istream);
            };
        };
    }
    Primitives.left = left;
    /**
     * right returns a parser that applies the parser p,
     * then the parser q, and if both are successful,
     * returns the result of q.
     * @param p a parser
     */
    function right(p) {
        return (q) => {
            return (istream) => {
                return bind(p)(_ => q)(istream);
            };
        };
    }
    Primitives.right = right;
    /**
     * between returns a parser that applies the parser
     * popen, p, and pclose in sequence, and if all are
     * successful, returns the result of p.
     * @param popen the first parser
     */
    function between(popen) {
        return (pclose) => {
            return (p) => {
                let l = left(p)(pclose);
                let r = right(popen)(l);
                return r;
            };
        };
    }
    Primitives.between = between;
    /**
     * The debug parser takes a parser p and a debug string,
     * printing the debug string as a side-effect before
     * applying p to the input.
     * @param p a parser
     */
    function debug(p) {
        return (label) => {
            return (istream) => {
                console.log("apply: " + label);
                let o = p(istream);
                switch (o.tag) {
                    case "success":
                        console.log("success: " + label + ", startpos: " + istream.startpos + ", endpos: " + istream.endpos);
                        break;
                    case "failure":
                        console.log("failure: " + label + ", startpos: " + istream.startpos + ", endpos: " + istream.endpos);
                        break;
                }
                return o;
            };
        };
    }
    Primitives.debug = debug;
    let wschars = choice(sat(c => c == ' ' || c == '\t'))(nl());
    /**
     * ws matches zero or more of the following whitespace characters:
     * ' ', '\t', '\n', or '\r\n'
     * ws returns matched whitespace in a single CharStream result.
     */
    function ws() {
        return (istream) => {
            let o = many(wschars)(istream);
            switch (o.tag) {
                case "success":
                    return new Success(o.inputstream, charstream_1.CharUtil.CharStream.concat(o.result));
                // ws never fails
            }
        };
    }
    Primitives.ws = ws;
    /**
     * ws1 matches one or more of the following whitespace characters:
     * ' ', '\t', '\n', or '\r\n'
     * ws1 returns matched whitespace in a single CharStream result.
     */
    function ws1() {
        return (istream) => {
            let o = many1(wschars)(istream);
            switch (o.tag) {
                case "success":
                    return new Success(o.inputstream, charstream_1.CharUtil.CharStream.concat(o.result));
                case "failure":
                    return o;
            }
        };
    }
    Primitives.ws1 = ws1;
    /**
     * nl matches and returns a newline.
     */
    function nl() {
        return Primitives.choice(Primitives.str("\n"))(Primitives.str("\r\n"));
    }
    Primitives.nl = nl;
    function groupBy(list, keyGetter) {
        let m = new Map();
        list.forEach((item) => {
            const key = keyGetter(item);
            if (!m.has(key)) {
                m.set(key, []);
            }
            let collection = m.get(key);
            collection.push(item);
        });
        return m;
    }
    function strSat(strs) {
        // sort strings first by length, and then lexicograpically;
        // slice() called here so as not to modify original array
        let smap = groupBy(strs, s => s.length);
        let sizes = [];
        // find size classes;
        // also sort each set of equivalent-length values
        smap.forEach((vals, key, m) => {
            sizes.push(key);
            vals.sort();
        });
        sizes.sort();
        return (istream) => {
            // start with the smallest size class       
            for (let peekIndex = 0; peekIndex < sizes.length; peekIndex++) {
                // for each size class, try matching all of
                // the strings; if one is found, return the
                // appropriate CharStream; if not, fail.
                let peek = istream.peek(sizes[peekIndex]);
                let tail = istream.seek(sizes[peekIndex]);
                let candidates = smap.get(sizes[peekIndex]);
                for (let cIndex = 0; cIndex < candidates.length; cIndex++) {
                    if (candidates[cIndex] === peek.toString()) {
                        return new Success(tail, peek);
                    }
                }
            }
            return new Failure(istream);
        };
    }
    Primitives.strSat = strSat;
})(Primitives = exports.Primitives || (exports.Primitives = {}));

},{"./charstream":82}],85:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
/**
 * Converts an Array-like object (such as an arguments or NodeList instance) to a regular Array
 */
function fromArrayLike(arrayLike) {
    return new lift_1.ArrayOps([].slice.call(arrayLike));
}
exports.fromArrayLike = fromArrayLike;

},{"../lift":90}],86:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
/*
* Returns a number[] wrapper with all numbers from start to stop (inclusive),
* incremented or decremented by step.
*/
function range(start, stop, step) {
    if (arguments.length === 1) {
        stop = arguments[0] - 1;
        start = 0;
    }
    step = step || 1;
    var result = [];
    var increasing = step > 0;
    var next = start;
    while ((increasing && next <= stop) || (!increasing && next >= stop)) {
        result.push(next);
        next = next + step;
    }
    return new lift_1.ArrayOps(result);
}
exports.range = range;

},{"../lift":90}],87:[function(require,module,exports){
"use strict";
exports.__esModule = true;
function tuple(arr) {
    return arr;
}
exports.tuple = tuple;

},{}],88:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var is_1 = require("../object/is");
var currentMemoId = 0;
/**
 * Memoizes a function of arbitrary arity.
 * This has two main uses:
 *   1) Reducing the CPU time taken by expensive calculations at the cost of some memory overhead
 *   2) Producing stable references for a given set of arguments. Useful when relying on reference equality.
 *
 * Memoized functions keep internal state. If you wish to clear that state entirely, you can recreate the function.
 */
function memoize(fun, options) {
    // The unique property name used by this memoize function instance.
    // This is used to store the id/reference of object arguments, as Weak maps/sets are very limited.
    var memoKey = "__memo__" + currentMemoId++;
    var lastArgKeys = [];
    var cacheSize = (options && options.cacheSize) || 30;
    var keyFunction = options && options.key;
    // The unique ids/references of objects inside the arityNCache cache
    var objId = 0;
    var arity0Cache;
    var arityNCache;
    var keyCache;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // 0 arguments edge-case
        if (args.length === 0) {
            if (!arity0Cache)
                arity0Cache = fun();
            return arity0Cache;
        }
        // custom key function
        else if (keyFunction) {
            keyCache = keyCache || {};
            var key = keyFunction.apply(null, args);
            var result = keyCache[key];
            if (!result) {
                lastArgKeys.push(key);
                limitCacheSize(keyCache, lastArgKeys, cacheSize);
                result = keyCache[key] = fun.apply(null, args);
            }
            return result;
        }
        // N arguments
        else {
            arityNCache = arityNCache || {};
            var key = '';
            for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                var argKey = void 0;
                if (is_1.object(arg)) {
                    argKey = arg[memoKey];
                    if (!argKey) {
                        // Non enumerable
                        Object.defineProperty(arg, memoKey, { value: "obj" + objId++ });
                        argKey = arg[memoKey];
                    }
                }
                else {
                    argKey = arg;
                }
                key += (argKey + '_');
            }
            var result = arityNCache[key];
            if (!result) {
                lastArgKeys.push(key);
                limitCacheSize(arityNCache, lastArgKeys, cacheSize);
                result = arityNCache[key] = fun.apply(null, args);
            }
            return result;
        }
    };
}
exports.memoize = memoize;
function limitCacheSize(cache, lastArgKeys, size) {
    if (lastArgKeys.length === size + 1) {
        var key = lastArgKeys.shift();
        delete cache[key];
    }
}

},{"../object/is":91}],89:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("./lift");
exports["default"] = lift_1["default"];
var lift_2 = require("./lift");
exports.ArrayOps = lift_2.ArrayOps;
exports.ObjectOps = lift_2.ObjectOps;
exports.NumberOps = lift_2.NumberOps;
exports.StringOps = lift_2.StringOps;
exports.DateOps = lift_2.DateOps;
exports.getValue = lift_2.getValue;
var immupdate_1 = require("immupdate");
exports.update = immupdate_1.update;
exports.deepUpdate = immupdate_1.deepUpdate;
exports.DELETE = immupdate_1.DELETE;
var option_1 = require("./option");
exports.Option = option_1.Option;
exports.None = option_1.None;
exports.Some = option_1.Some;
var result_1 = require("./result");
exports.Result = result_1.Result;
exports.Ok = result_1.Ok;
exports.Err = result_1.Err;
var range_1 = require("./array/range");
exports.range = range_1.range;
var fromArrayLike_1 = require("./array/fromArrayLike");
exports.fromArrayLike = fromArrayLike_1.fromArrayLike;
var tuple_1 = require("./array/tuple");
exports.tuple = tuple_1.tuple;
var set_1 = require("./object/set");
exports.Set = set_1.Set;
var memoize_1 = require("./function/memoize");
exports.memoize = memoize_1.memoize;
var isType = require("./object/is");
exports.is = isType;

},{"./array/fromArrayLike":85,"./array/range":86,"./array/tuple":87,"./function/memoize":88,"./lift":90,"./object/is":91,"./object/set":92,"./option":93,"./result":94,"immupdate":81}],90:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift = function (obj) {
    if (obj instanceof Array)
        return new exports.ArrayOps(obj);
    if (obj instanceof Date)
        return new exports.DateOps(obj);
    if (typeof obj === 'string')
        return new exports.StringOps(obj);
    if (typeof obj === 'number')
        return new exports.NumberOps(obj);
    return new exports.ObjectOps(obj);
};
exports["default"] = lift;
function getValue(input) {
    return input && input['_isLiftWrapper']
        ? input.value()
        : input;
}
exports.getValue = getValue;
function makeOps() {
    var Ops = /** @class */ (function () {
        function Ops(_value) {
            this._value = _value;
            this._isLiftWrapper = true;
        }
        Ops.prototype.value = function () { return this._value; };
        return Ops;
    }());
    return Ops;
}
exports.ArrayOps = makeOps();
exports.ObjectOps = makeOps();
exports.NumberOps = makeOps();
exports.StringOps = makeOps();
exports.DateOps = makeOps();

},{}],91:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/** Returns whether an object is an Array */
exports.array = Array.isArray;
/** Returns whether this object is a function */
function func(obj) {
    return (typeof obj === 'function');
}
exports.func = func;
/** Returns whether this object is a string */
function string(obj) {
    return (typeof obj === 'string');
}
exports.string = string;
/** Returns whether this object is a number */
function number(obj) {
    return (typeof obj === 'number');
}
exports.number = number;
/** Returns whether this object is a boolean */
function boolean(obj) {
    return (typeof obj === 'boolean');
}
exports.boolean = boolean;
/** Returns whether this value is an object (e.g not a primitive: dates, arrays, functions, objects, regexes, `new Number(0)`, and `new String('')) */
function object(obj) {
    var type = typeof obj;
    return (type == 'object' || type == 'function');
}
exports.object = object;

},{}],92:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
/**
 * Creates a Set-like object (string keys, true values) from a list of keys
 */
function Set() {
    var keys = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        keys[_i] = arguments[_i];
    }
    var result = {};
    keys.forEach(function (key) { return result[key] = true; });
    return new lift_1.ObjectOps(result);
}
exports.Set = Set;

},{"../lift":90}],93:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
// The Option factory / static object
var OptionObject = function (value) {
    return isDef(value) ? Some(value) : exports.None;
};
OptionObject.all = function (arr) {
    var values = [];
    for (var i = 0; i < arr.length; i++) {
        var value = arr[i];
        if (exports.Option.isOption(value))
            value = value.get();
        if (!isDef(value))
            return exports.None;
        values.push(value);
    }
    return Some(values);
};
OptionObject.isOption = function (value) {
    return !!value && (value.type === 'some' || value.type === 'none');
};
function makeNone() {
    var self = {};
    function returnNone() { return exports.None; }
    self.type = 'none';
    self.get = function () { return undefined; };
    self.isDefined = function () { return false; };
    self.forEach = function () { };
    self.map = returnNone;
    self.flatMap = returnNone;
    self.filter = returnNone;
    self.fold = function (ifEmpty) { return ifEmpty(); };
    self.orElse = function (alt) { return alt(); };
    self.getOrElse = function (alt) { return alt; };
    self.toArray = function () { return lift_1["default"]([]); };
    self.toString = function () { return 'None'; };
    self.toJSON = function () { return null; };
    return self;
}
function _Some(value) {
    this.value = value;
}
_Some.prototype = {
    type: 'some',
    get: function () {
        return this.value;
    },
    isDefined: function () {
        return true;
    },
    forEach: function (fn) {
        fn(this.value);
    },
    map: function (fn) {
        return exports.Option(lift_1.getValue(fn(this.value)));
    },
    flatMap: function (fn) {
        return fn(this.value);
    },
    filter: function (fn) {
        return fn(this.value) ? this : exports.None;
    },
    fold: function (ifEmpty, ifDefined) {
        return ifDefined(this.value);
    },
    orElse: function () {
        return this;
    },
    getOrElse: function () {
        return this.value;
    },
    toArray: function () {
        return lift_1["default"]([this.value]);
    },
    toString: function () {
        return "Some(" + this.value + ")";
    },
    toJSON: function () {
        return this.value;
    }
};
function isDef(value) {
    return value !== null && value !== undefined;
}
exports.Option = OptionObject;
/** Creates a new Some instance using a non nullable value */
// extends {} to prevent null and undefined being passed
function Some(value) {
    return new _Some(value);
}
exports.Some = Some;
exports.None = makeNone();

},{"../lift":90}],94:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
var ResultObject = {};
ResultObject.all = function (arr) {
    var okValues = [];
    var currentResult;
    for (var i = 0; i < arr.length; i++) {
        var currentResult_1 = arr[i];
        if (!currentResult_1.isOk())
            return currentResult_1;
        okValues.push(currentResult_1.get());
    }
    return Ok(okValues);
};
ResultObject.isResult = function (value) {
    return !!value && (value.type === 'ok' || value.type === 'err');
};
function _Ok(value) {
    this._value = value;
}
_Ok.prototype = {
    type: 'ok',
    isOk: function () {
        return true;
    },
    map: function (fn) {
        return Ok(lift_1.getValue(fn(this._value)));
    },
    mapError: function (fn) {
        return this;
    },
    flatMap: function (fn) {
        return fn(this._value);
    },
    fold: function (ifErr, ifOk) {
        return ifOk(this._value);
    },
    toString: function () {
        return "Ok(" + this._value + ")";
    },
    get: function () {
        return this._value;
    }
};
function _Err(error) {
    this._error = error;
}
_Err.prototype = {
    type: 'err',
    isOk: function () {
        return false;
    },
    map: function (fn) {
        return this;
    },
    mapError: function (fn) {
        return Err(fn(this._error));
    },
    flatMap: function (fn) {
        return this;
    },
    fold: function (ifErr, ifOk) {
        return ifErr(this._error);
    },
    toString: function () {
        return "Err(" + this._error + ")";
    },
    get: function () {
        return this._error;
    }
};
exports.Result = ResultObject;
function Ok(value) {
    return new _Ok(value);
}
exports.Ok = Ok;
function Err(error) {
    return new _Err(error);
}
exports.Err = Err;

},{"../lift":90}]},{},[77])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImRpc3QvaW5kZXguanMiLCJkaXN0L2xpYi9iaW5vcHMvQXNzaWduT3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvQmluYXJ5T3BlcmF0aW9uLmpzIiwiZGlzdC9saWIvYmlub3BzL0RlY2xhcmVPcC5qcyIsImRpc3QvbGliL2Jpbm9wcy9EZWNyZW1lbnQuanMiLCJkaXN0L2xpYi9iaW5vcHMvRGl2T3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvSW5jcmVtZW50LmpzIiwiZGlzdC9saWIvYmlub3BzL01pbnVzT3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvTXVsT3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvUGx1c09wLmpzIiwiZGlzdC9saWIvY29uZGl0aW9uYWxzL0NvbmRpdGlvbmFsLmpzIiwiZGlzdC9saWIvZWZmZWN0cy9DdXJ2ZUVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvRWxsaXBzZUVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvRXBoRWZmZWN0LmpzIiwiZGlzdC9saWIvZWZmZWN0cy9MaW5lRWZmZWN0LmpzIiwiZGlzdC9saWIvZWZmZWN0cy9OdW1iZXJFZmZlY3QuanMiLCJkaXN0L2xpYi9lZmZlY3RzL1JlY3RhbmdsZUVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvU3RyaW5nRWZmZWN0LmpzIiwiZGlzdC9saWIvZnVuaG91c2UvRnVuQXBwLmpzIiwiZGlzdC9saWIvZnVuaG91c2UvRnVuRGVmLmpzIiwiZGlzdC9saWIvbGlzdHMvTGlzdE5vZGUuanMiLCJkaXN0L2xpYi9sb2dnaW5nL0NsZWFyRXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL0NsaWNrRXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL0RyYWdFdmVudC5qcyIsImRpc3QvbGliL2xvZ2dpbmcvSURFdmVudC5qcyIsImRpc3QvbGliL2xvZ2dpbmcvTG9nRXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL1BhaW50RXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL1Jlc2l6ZUV2ZW50LmpzIiwiZGlzdC9saWIvbG9nZ2luZy9TZWxlY3RFdmVudC5qcyIsImRpc3QvbGliL2xvZ2ljL0FuZC5qcyIsImRpc3QvbGliL2xvZ2ljL0VxdWFscy5qcyIsImRpc3QvbGliL2xvZ2ljL0dyZWF0ZXJUaGFuLmpzIiwiZGlzdC9saWIvbG9naWMvR3JlYXRlclRoYW5FcS5qcyIsImRpc3QvbGliL2xvZ2ljL0xlc3NUaGFuLmpzIiwiZGlzdC9saWIvbG9naWMvTGVzc1RoYW5FcS5qcyIsImRpc3QvbGliL2xvZ2ljL05vdC5qcyIsImRpc3QvbGliL2xvZ2ljL05vdEVxdWFsLmpzIiwiZGlzdC9saWIvbG9naWMvT3IuanMiLCJkaXN0L2xpYi9sb29wcy9Gb3JOb2RlLmpzIiwiZGlzdC9saWIvbG9vcHMvV2hpbGVOb2RlLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Gb3VyQ3BPbmUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvbkZvdXJDcFR3by5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uT25lQ3BGb3VyLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25PbmVDcE9uZS5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uT25lQ3BUaHJlZS5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uT25lQ3BUd28uanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BGaXZlLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25UaHJlZUNwRm91ci5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcE9uZS5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFNpeC5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFRocmVlLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25UaHJlZUNwVHdvLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Ud29DcEZpdmUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwRm91ci5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVHdvQ3BPbmUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwU2V2ZW4uanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwU2l4LmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFRocmVlLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFR3by5qcyIsImRpc3QvbGliL3BhcnNlci9wYXJzZXIuanMiLCJkaXN0L2xpYi9wcmltcy9Cb29sZWFuTm9kZS5qcyIsImRpc3QvbGliL3ByaW1zL05PUC5qcyIsImRpc3QvbGliL3ByaW1zL051bWJlck5vZGUuanMiLCJkaXN0L2xpYi9wcmltcy9TdHJpbmdOb2RlLmpzIiwiZGlzdC9saWIvc2hhcGVzL0NvbG9yTm9kZS5qcyIsImRpc3QvbGliL3NoYXBlcy9DdXJ2ZU5vZGUuanMiLCJkaXN0L2xpYi9zaGFwZXMvRWxsaXBzZU5vZGUuanMiLCJkaXN0L2xpYi9zaGFwZXMvRXBoTm9kZS5qcyIsImRpc3QvbGliL3NoYXBlcy9MaW5lTm9kZS5qcyIsImRpc3QvbGliL3NoYXBlcy9SZWN0YW5nbGVOb2RlLmpzIiwiZGlzdC9saWIvc3RydWN0dXJhbC9EaW1lbnNpb25zLmpzIiwiZGlzdC9saWIvc3RydWN0dXJhbC9QcmludE5vZGUuanMiLCJkaXN0L2xpYi9zdHJ1Y3R1cmFsL1JldHVybi5qcyIsImRpc3QvbGliL3N0cnVjdHVyYWwvUmV0dXJuRXJyb3IuanMiLCJkaXN0L2xpYi9zdHJ1Y3R1cmFsL1Njb3BlLmpzIiwiZGlzdC9saWIvc3RydWN0dXJhbC9TZXF1ZW5jZU5vZGUuanMiLCJkaXN0L2xpYi91aS91aS5qcyIsImRpc3QvbGliL3Vub3BzL05lZ09wLmpzIiwiZGlzdC9saWIvdW5vcHMvVW5hcnlPcGVyYXRpb24uanMiLCJkaXN0L2xpYi92YXJzL1ZhcmlhYmxlTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9pbW11cGRhdGUvY29tbW9uanMvaW1tdXBkYXRlLmpzIiwibm9kZV9tb2R1bGVzL3BhbnRzL2xpYi9jaGFyc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3BhbnRzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYW50cy9saWIvcHJpbWl0aXZlcy5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL2FycmF5L2Zyb21BcnJheUxpa2UuanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9hcnJheS9yYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL2FycmF5L3R1cGxlLmpzIiwibm9kZV9tb2R1bGVzL3NwYWNlLWxpZnQvY29tbW9uanMvZnVuY3Rpb24vbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NwYWNlLWxpZnQvY29tbW9uanMvbGlmdC5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL29iamVjdC9pcy5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL29iamVjdC9zZXQuanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9vcHRpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9yZXN1bHQvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcndCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaHZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3J2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9wQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNjb3BlXzEgPSByZXF1aXJlKFwiLi9saWIvc3RydWN0dXJhbC9TY29wZVwiKTtcbmV4cG9ydHMuU2NvcGUgPSBTY29wZV8xLlNjb3BlO1xuLyogQklOQVJZIE9QUyAqL1xudmFyIEFzc2lnbk9wXzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL0Fzc2lnbk9wXCIpO1xuZXhwb3J0cy5Bc3NpZ25PcCA9IEFzc2lnbk9wXzEuQXNzaWduT3A7XG52YXIgQmluYXJ5T3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL0JpbmFyeU9wZXJhdGlvblwiKTtcbmV4cG9ydHMuQmluYXJ5T3BlcmF0aW9uID0gQmluYXJ5T3BlcmF0aW9uXzEuQmluYXJ5T3BlcmF0aW9uO1xudmFyIERpdk9wXzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL0Rpdk9wXCIpO1xuZXhwb3J0cy5EaXZPcCA9IERpdk9wXzEuRGl2T3A7XG52YXIgTWludXNPcF8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9NaW51c09wXCIpO1xuZXhwb3J0cy5NaW51c09wID0gTWludXNPcF8xLk1pbnVzT3A7XG52YXIgTXVsT3BfMSA9IHJlcXVpcmUoXCIuL2xpYi9iaW5vcHMvTXVsT3BcIik7XG5leHBvcnRzLk11bE9wID0gTXVsT3BfMS5NdWxPcDtcbnZhciBQbHVzT3BfMSA9IHJlcXVpcmUoXCIuL2xpYi9iaW5vcHMvUGx1c09wXCIpO1xuZXhwb3J0cy5QbHVzT3AgPSBQbHVzT3BfMS5QbHVzT3A7XG52YXIgR3JlYXRlclRoYW5fMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9HcmVhdGVyVGhhblwiKTtcbmV4cG9ydHMuR3JlYXRlclRoYW4gPSBHcmVhdGVyVGhhbl8xLkdyZWF0ZXJUaGFuO1xudmFyIEdyZWF0ZXJUaGFuRXFfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9HcmVhdGVyVGhhbkVxXCIpO1xuZXhwb3J0cy5HcmVhdGVyVGhhbkVxID0gR3JlYXRlclRoYW5FcV8xLkdyZWF0ZXJUaGFuRXE7XG52YXIgTGVzc1RoYW5fMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9MZXNzVGhhblwiKTtcbmV4cG9ydHMuTGVzc1RoYW4gPSBMZXNzVGhhbl8xLkxlc3NUaGFuO1xudmFyIExlc3NUaGFuRXFfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9MZXNzVGhhbkVxXCIpO1xuZXhwb3J0cy5MZXNzVGhhbkVxID0gTGVzc1RoYW5FcV8xLkxlc3NUaGFuRXE7XG52YXIgRGVjbGFyZU9wXzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL0RlY2xhcmVPcFwiKTtcbmV4cG9ydHMuRGVjbGFyZU9wID0gRGVjbGFyZU9wXzEuRGVjbGFyZU9wO1xudmFyIEFuZF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2ljL0FuZFwiKTtcbmV4cG9ydHMuQW5kID0gQW5kXzEuQW5kO1xudmFyIE9yXzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvT3JcIik7XG5leHBvcnRzLk9yID0gT3JfMS5PcjtcbnZhciBFcXVhbHNfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9FcXVhbHNcIik7XG5leHBvcnRzLkVxdWFscyA9IEVxdWFsc18xLkVxdWFscztcbnZhciBOb3RFcXVhbF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2ljL05vdEVxdWFsXCIpO1xuZXhwb3J0cy5Ob3RFcXVhbCA9IE5vdEVxdWFsXzEuTm90RXF1YWw7XG52YXIgSW5jcmVtZW50XzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL0luY3JlbWVudFwiKTtcbmV4cG9ydHMuSW5jcmVtZW50ID0gSW5jcmVtZW50XzEuSW5jcmVtZW50O1xudmFyIERlY3JlbWVudF8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9EZWNyZW1lbnRcIik7XG5leHBvcnRzLkRlY3JlbWVudCA9IERlY3JlbWVudF8xLkRlY3JlbWVudDtcbi8qIFVOQVJZIE9QUyAqL1xudmFyIFVuYXJ5T3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9saWIvdW5vcHMvVW5hcnlPcGVyYXRpb25cIik7XG5leHBvcnRzLlVuYXJ5T3BlcmF0aW9uID0gVW5hcnlPcGVyYXRpb25fMS5VbmFyeU9wZXJhdGlvbjtcbnZhciBOZWdPcF8xID0gcmVxdWlyZShcIi4vbGliL3Vub3BzL05lZ09wXCIpO1xuZXhwb3J0cy5OZWdPcCA9IE5lZ09wXzEuTmVnT3A7XG52YXIgTm90XzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvTm90XCIpO1xuZXhwb3J0cy5Ob3QgPSBOb3RfMS5Ob3Q7XG4vKiBEQVRBIFRZUEVTICovXG52YXIgTGlzdE5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9saXN0cy9MaXN0Tm9kZVwiKTtcbmV4cG9ydHMuTGlzdE5vZGUgPSBMaXN0Tm9kZV8xLkxpc3ROb2RlO1xudmFyIE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuZXhwb3J0cy5OdW1iZXJOb2RlID0gTnVtYmVyTm9kZV8xLk51bWJlck5vZGU7XG52YXIgU3RyaW5nTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3ByaW1zL1N0cmluZ05vZGVcIik7XG5leHBvcnRzLlN0cmluZ05vZGUgPSBTdHJpbmdOb2RlXzEuU3RyaW5nTm9kZTtcbnZhciBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuZXhwb3J0cy5Cb29sZWFuTm9kZSA9IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGU7XG52YXIgTk9QXzEgPSByZXF1aXJlKFwiLi9saWIvcHJpbXMvTk9QXCIpO1xuZXhwb3J0cy5OT1AgPSBOT1BfMS5OT1A7XG4vKiBWQVJJQUJMRVMgKi9cbnZhciBWYXJpYWJsZU5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi92YXJzL1ZhcmlhYmxlTm9kZVwiKTtcbmV4cG9ydHMuVmFyaWFibGVOb2RlID0gVmFyaWFibGVOb2RlXzEuVmFyaWFibGVOb2RlO1xuLyogQ09OVFJPTCBDT05TVFJVQ1RTICovXG52YXIgQ29uZGl0aW9uYWxfMSA9IHJlcXVpcmUoXCIuL2xpYi9jb25kaXRpb25hbHMvQ29uZGl0aW9uYWxcIik7XG5leHBvcnRzLkNvbmRpdGlvbmFsID0gQ29uZGl0aW9uYWxfMS5Db25kaXRpb25hbDtcbnZhciBGdW5BcHBfMSA9IHJlcXVpcmUoXCIuL2xpYi9mdW5ob3VzZS9GdW5BcHBcIik7XG5leHBvcnRzLkZ1bkFwcCA9IEZ1bkFwcF8xLkZ1bkFwcDtcbnZhciBGdW5EZWZfMSA9IHJlcXVpcmUoXCIuL2xpYi9mdW5ob3VzZS9GdW5EZWZcIik7XG5leHBvcnRzLkZ1bkRlZiA9IEZ1bkRlZl8xLkZ1bkRlZjtcbnZhciBTZXF1ZW5jZU5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zdHJ1Y3R1cmFsL1NlcXVlbmNlTm9kZVwiKTtcbmV4cG9ydHMuU2VxdWVuY2VOb2RlID0gU2VxdWVuY2VOb2RlXzEuU2VxdWVuY2VOb2RlO1xudmFyIFdoaWxlTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL2xvb3BzL1doaWxlTm9kZVwiKTtcbmV4cG9ydHMuV2hpbGVOb2RlID0gV2hpbGVOb2RlXzEuV2hpbGVOb2RlO1xudmFyIEZvck5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb29wcy9Gb3JOb2RlXCIpO1xuZXhwb3J0cy5Gb3JOb2RlID0gRm9yTm9kZV8xLkZvck5vZGU7XG4vKiBCVUlMVElOIEZVTkNUSU9OUyAqL1xudmFyIENvbG9yTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3NoYXBlcy9Db2xvck5vZGVcIik7XG5leHBvcnRzLkNvbG9yTm9kZSA9IENvbG9yTm9kZV8xLkNvbG9yTm9kZTtcbnZhciBFbGxpcHNlTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3NoYXBlcy9FbGxpcHNlTm9kZVwiKTtcbmV4cG9ydHMuRWxsaXBzZU5vZGUgPSBFbGxpcHNlTm9kZV8xLkVsbGlwc2VOb2RlO1xudmFyIFJlY3RhbmdsZU5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zaGFwZXMvUmVjdGFuZ2xlTm9kZVwiKTtcbmV4cG9ydHMuUmVjdGFuZ2xlTm9kZSA9IFJlY3RhbmdsZU5vZGVfMS5SZWN0YW5nbGVOb2RlO1xudmFyIExpbmVOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvc2hhcGVzL0xpbmVOb2RlXCIpO1xuZXhwb3J0cy5MaW5lTm9kZSA9IExpbmVOb2RlXzEuTGluZU5vZGU7XG52YXIgQ3VydmVOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvc2hhcGVzL0N1cnZlTm9kZVwiKTtcbmV4cG9ydHMuQ3VydmVOb2RlID0gQ3VydmVOb2RlXzEuQ3VydmVOb2RlO1xudmFyIEVwaE5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zaGFwZXMvRXBoTm9kZVwiKTtcbmV4cG9ydHMuRXBoTm9kZSA9IEVwaE5vZGVfMS5FcGhOb2RlO1xudmFyIFByaW50Tm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3N0cnVjdHVyYWwvUHJpbnROb2RlXCIpO1xuZXhwb3J0cy5QcmludE5vZGUgPSBQcmludE5vZGVfMS5QcmludE5vZGU7XG52YXIgUmV0dXJuXzEgPSByZXF1aXJlKFwiLi9saWIvc3RydWN0dXJhbC9SZXR1cm5cIik7XG5leHBvcnRzLlJldHVybiA9IFJldHVybl8xLlJldHVybjtcbnZhciBSZXR1cm5FcnJvcl8xID0gcmVxdWlyZShcIi4vbGliL3N0cnVjdHVyYWwvUmV0dXJuRXJyb3JcIik7XG5leHBvcnRzLlJldHVybkVycm9yID0gUmV0dXJuRXJyb3JfMS5SZXR1cm5FcnJvcjtcbnZhciBFbGxpcHNlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi9saWIvZWZmZWN0cy9FbGxpcHNlRWZmZWN0XCIpO1xuZXhwb3J0cy5FbGxpcHNlRWZmZWN0ID0gRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3Q7XG52YXIgTnVtYmVyRWZmZWN0XzEgPSByZXF1aXJlKFwiLi9saWIvZWZmZWN0cy9OdW1iZXJFZmZlY3RcIik7XG5leHBvcnRzLk51bWJlckVmZmVjdCA9IE51bWJlckVmZmVjdF8xLk51bWJlckVmZmVjdDtcbnZhciBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuL2xpYi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmV4cG9ydHMuU3RyaW5nRWZmZWN0ID0gU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0O1xudmFyIERpbWVuc2lvbnNfMSA9IHJlcXVpcmUoXCIuL2xpYi9zdHJ1Y3R1cmFsL0RpbWVuc2lvbnNcIik7XG5leHBvcnRzLkRpbWVuc2lvbnMgPSBEaW1lbnNpb25zXzEuRGltZW5zaW9ucztcbnZhciBSZWN0YW5nbGVFZmZlY3RfMSA9IHJlcXVpcmUoXCIuL2xpYi9lZmZlY3RzL1JlY3RhbmdsZUVmZmVjdFwiKTtcbmV4cG9ydHMuUmVjdGFuZ2xlRWZmZWN0ID0gUmVjdGFuZ2xlRWZmZWN0XzEuUmVjdGFuZ2xlRWZmZWN0O1xudmFyIExpbmVFZmZlY3RfMSA9IHJlcXVpcmUoXCIuL2xpYi9lZmZlY3RzL0xpbmVFZmZlY3RcIik7XG5leHBvcnRzLkxpbmVFZmZlY3QgPSBMaW5lRWZmZWN0XzEuTGluZUVmZmVjdDtcbnZhciBDdXJ2ZUVmZmVjdF8xID0gcmVxdWlyZShcIi4vbGliL2VmZmVjdHMvQ3VydmVFZmZlY3RcIik7XG5leHBvcnRzLkN1cnZlRWZmZWN0ID0gQ3VydmVFZmZlY3RfMS5DdXJ2ZUVmZmVjdDtcbnZhciBFcGhFZmZlY3RfMSA9IHJlcXVpcmUoXCIuL2xpYi9lZmZlY3RzL0VwaEVmZmVjdFwiKTtcbmV4cG9ydHMuRXBoRWZmZWN0ID0gRXBoRWZmZWN0XzEuRXBoRWZmZWN0O1xuLyogRVZFTlRTICovXG52YXIgTG9nRXZlbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dnaW5nL0xvZ0V2ZW50XCIpO1xuZXhwb3J0cy5Mb2dFdmVudCA9IExvZ0V2ZW50XzEuTG9nRXZlbnQ7XG52YXIgQ2xlYXJFdmVudF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2dpbmcvQ2xlYXJFdmVudFwiKTtcbmV4cG9ydHMuQ2xlYXJFdmVudCA9IENsZWFyRXZlbnRfMS5DbGVhckV2ZW50O1xudmFyIERyYWdFdmVudF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2dpbmcvRHJhZ0V2ZW50XCIpO1xuZXhwb3J0cy5EcmFnRXZlbnQgPSBEcmFnRXZlbnRfMS5EcmFnRXZlbnQ7XG52YXIgUGFpbnRFdmVudF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2dpbmcvUGFpbnRFdmVudFwiKTtcbmV4cG9ydHMuUGFpbnRFdmVudCA9IFBhaW50RXZlbnRfMS5QYWludEV2ZW50O1xudmFyIFJlc2l6ZUV2ZW50XzEgPSByZXF1aXJlKFwiLi9saWIvbG9nZ2luZy9SZXNpemVFdmVudFwiKTtcbmV4cG9ydHMuUmVzaXplRXZlbnQgPSBSZXNpemVFdmVudF8xLlJlc2l6ZUV2ZW50O1xudmFyIFNlbGVjdEV2ZW50XzEgPSByZXF1aXJlKFwiLi9saWIvbG9nZ2luZy9TZWxlY3RFdmVudFwiKTtcbmV4cG9ydHMuU2VsZWN0RXZlbnQgPSBTZWxlY3RFdmVudF8xLlNlbGVjdEV2ZW50O1xudmFyIElERXZlbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dnaW5nL0lERXZlbnRcIik7XG5leHBvcnRzLklERXZlbnQgPSBJREV2ZW50XzEuSURFdmVudDtcbnZhciBMZXNzb25PbmVDcE9uZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uT25lQ3BPbmVcIik7XG5leHBvcnRzLkxlc3Nvbk9uZUNwT25lID0gTGVzc29uT25lQ3BPbmVfMS5MZXNzb25PbmVDcE9uZTtcbnZhciBMZXNzb25PbmVDcFR3b18xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uT25lQ3BUd29cIik7XG5leHBvcnRzLkxlc3Nvbk9uZUNwVHdvID0gTGVzc29uT25lQ3BUd29fMS5MZXNzb25PbmVDcFR3bztcbnZhciBMZXNzb25PbmVDcFRocmVlXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25PbmVDcFRocmVlXCIpO1xuZXhwb3J0cy5MZXNzb25PbmVDcFRocmVlID0gTGVzc29uT25lQ3BUaHJlZV8xLkxlc3Nvbk9uZUNwVGhyZWU7XG52YXIgTGVzc29uT25lQ3BGb3VyXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25PbmVDcEZvdXJcIik7XG5leHBvcnRzLkxlc3Nvbk9uZUNwRm91ciA9IExlc3Nvbk9uZUNwRm91cl8xLkxlc3Nvbk9uZUNwRm91cjtcbnZhciBMZXNzb25Ud29DcE9uZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVHdvQ3BPbmVcIik7XG5leHBvcnRzLkxlc3NvblR3b0NwT25lID0gTGVzc29uVHdvQ3BPbmVfMS5MZXNzb25Ud29DcE9uZTtcbnZhciBMZXNzb25Ud29DcFR3b18xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVHdvQ3BUd29cIik7XG5leHBvcnRzLkxlc3NvblR3b0NwVHdvID0gTGVzc29uVHdvQ3BUd29fMS5MZXNzb25Ud29DcFR3bztcbnZhciBMZXNzb25Ud29DcFRocmVlXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFRocmVlXCIpO1xuZXhwb3J0cy5MZXNzb25Ud29DcFRocmVlID0gTGVzc29uVHdvQ3BUaHJlZV8xLkxlc3NvblR3b0NwVGhyZWU7XG52YXIgTGVzc29uVHdvQ3BGb3VyXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Ud29DcEZvdXJcIik7XG5leHBvcnRzLkxlc3NvblR3b0NwRm91ciA9IExlc3NvblR3b0NwRm91cl8xLkxlc3NvblR3b0NwRm91cjtcbnZhciBMZXNzb25Ud29DcEZpdmVfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwRml2ZVwiKTtcbmV4cG9ydHMuTGVzc29uVHdvQ3BGaXZlID0gTGVzc29uVHdvQ3BGaXZlXzEuTGVzc29uVHdvQ3BGaXZlO1xudmFyIExlc3NvblR3b0NwU2l4XzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFNpeFwiKTtcbmV4cG9ydHMuTGVzc29uVHdvQ3BTaXggPSBMZXNzb25Ud29DcFNpeF8xLkxlc3NvblR3b0NwU2l4O1xudmFyIExlc3NvblR3b0NwU2V2ZW5fMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwU2V2ZW5cIik7XG5leHBvcnRzLkxlc3NvblR3b0NwU2V2ZW4gPSBMZXNzb25Ud29DcFNldmVuXzEuTGVzc29uVHdvQ3BTZXZlbjtcbnZhciBMZXNzb25UaHJlZUNwT25lXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25UaHJlZUNwT25lXCIpO1xuZXhwb3J0cy5MZXNzb25UaHJlZUNwT25lID0gTGVzc29uVGhyZWVDcE9uZV8xLkxlc3NvblRocmVlQ3BPbmU7XG52YXIgTGVzc29uVGhyZWVDcFR3b18xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFR3b1wiKTtcbmV4cG9ydHMuTGVzc29uVGhyZWVDcFR3byA9IExlc3NvblRocmVlQ3BUd29fMS5MZXNzb25UaHJlZUNwVHdvO1xudmFyIExlc3NvblRocmVlQ3BUaHJlZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFRocmVlXCIpO1xuZXhwb3J0cy5MZXNzb25UaHJlZUNwVGhyZWUgPSBMZXNzb25UaHJlZUNwVGhyZWVfMS5MZXNzb25UaHJlZUNwVGhyZWU7XG52YXIgTGVzc29uVGhyZWVDcEZvdXJfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BGb3VyXCIpO1xuZXhwb3J0cy5MZXNzb25UaHJlZUNwRm91ciA9IExlc3NvblRocmVlQ3BGb3VyXzEuTGVzc29uVGhyZWVDcEZvdXI7XG52YXIgTGVzc29uVGhyZWVDcEZpdmVfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BGaXZlXCIpO1xuZXhwb3J0cy5MZXNzb25UaHJlZUNwRml2ZSA9IExlc3NvblRocmVlQ3BGaXZlXzEuTGVzc29uVGhyZWVDcEZpdmU7XG52YXIgTGVzc29uVGhyZWVDcFNpeF8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFNpeFwiKTtcbmV4cG9ydHMuTGVzc29uVGhyZWVDcFNpeCA9IExlc3NvblRocmVlQ3BTaXhfMS5MZXNzb25UaHJlZUNwU2l4O1xudmFyIExlc3NvbkZvdXJDcE9uZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uRm91ckNwT25lXCIpO1xuZXhwb3J0cy5MZXNzb25Gb3VyQ3BPbmUgPSBMZXNzb25Gb3VyQ3BPbmVfMS5MZXNzb25Gb3VyQ3BPbmU7XG52YXIgTGVzc29uRm91ckNwVHdvXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Gb3VyQ3BUd29cIik7XG5leHBvcnRzLkxlc3NvbkZvdXJDcFR3byA9IExlc3NvbkZvdXJDcFR3b18xLkxlc3NvbkZvdXJDcFR3bztcbi8qIFBBUlNFUiAqL1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4vbGliL3BhcnNlci9wYXJzZXJcIik7XG5leHBvcnRzLlBhcnNlciA9IHBhcnNlcl8xLlBhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmluYXJ5T3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9CaW5hcnlPcGVyYXRpb25cIik7XG5jb25zdCBWYXJpYWJsZU5vZGVfMSA9IHJlcXVpcmUoXCIuLi92YXJzL1ZhcmlhYmxlTm9kZVwiKTtcbi8vIGxlZnQgc2lkZSBpcyB2YXJpYWJsZSwgcmlnaHQgc2lkZSBpcyB2YWxcbi8vIFJlYXNzaWduIG5ldyB2YWx1ZSB0byB2YXJcbmNsYXNzIEFzc2lnbk9wIGV4dGVuZHMgQmluYXJ5T3BlcmF0aW9uXzEuQmluYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYW4gYXNzaWdubWVudCBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbGVmdCBzaWRlIG9mIHRoZSBhc3NpZ25tZW50ICh0aGUgdmFyKVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgYXNzaWdubWVudCAodGhlIHZhbHVlKVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICBzdXBlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmICghKGxlZnQgaW5zdGFuY2VvZiBWYXJpYWJsZU5vZGVfMS5WYXJpYWJsZU5vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGFzc2lnbm1lbnQgbXVzdCBiZSBhIHZhcmlhYmxlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIGFzc2lnbiBvcCBieSBhc3NpZ25pbmcgdmFsdWUgdG8gdmFyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0IGluc3RhbmNlb2YgVmFyaWFibGVOb2RlXzEuVmFyaWFibGVOb2RlKSB7XG4gICAgICAgICAgICBsZXQgciA9IHRoaXMucmlnaHQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnRleHQuYXNzaWduKHRoaXMubGVmdC5uYW1lLCByKTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhBTFAgKGluIEFzc2lnbk9wKVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQXNzaWduT3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5sZWZ0LnRvU3RyaW5nKCkgKyAnID0gJyArIHRoaXMucmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzaWduT3BzIGNhbid0IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW4ndCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gQXNzaWduT3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGJpbmFyeSBvcGVyYXRpb25zXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzaWduT3AgPSBBc3NpZ25PcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzc2lnbk9wLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQmluYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIEJpbk9wIGFic3RyYWN0IGNsYXNzXG4gICAgICogQHBhcmFtIF9sZWZ0IFRoZSBsZWZ0IHNpZGUgb2YgdGhlIGJpbmFyeSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gX3JpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBiaW5hcnkgb3BlcmF0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX2xlZnQsIF9yaWdodCkge1xuICAgICAgICB0aGlzLl9sZWZ0ID0gX2xlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gX3JpZ2h0O1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYmluYXJ5IG9wZXJhdGlvbiwgaWYgYXBwbGljYWJsZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIGFzdCBUaGUgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHsgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBlcXVhbCB0byBhbm90aGVyIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBCaW5PcFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmluYXJ5IG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gXCJcIjsgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZXRzIGxlZnQgc2lkZSBvZiB0aGUgYmluYXJ5IG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBsZWZ0IHNpZGUgb2YgdGhlIGJpbmFyeSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBzZXQgbGVmdChsZWZ0KSB7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHJpZ2h0IHNpZGUgb2YgdGhlIGJpbmFyeSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyByaWdodCBzaWRlIG9mIHRoZSBiaW5hcnkgb3BlcmF0aW9uXG4gICAgICovXG4gICAgc2V0IHJpZ2h0KHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkJpbmFyeU9wZXJhdGlvbiA9IEJpbmFyeU9wZXJhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpbmFyeU9wZXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJpbmFyeU9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vQmluYXJ5T3BlcmF0aW9uXCIpO1xuY29uc3QgVmFyaWFibGVOb2RlXzEgPSByZXF1aXJlKFwiLi4vdmFycy9WYXJpYWJsZU5vZGVcIik7XG4vLyBsZWZ0IHNpZGUgaXMgdmFyaWFibGUsIHJpZ2h0IHNpZGUgaXMgdmFsXG4vLyBEZWNsYXJlcyBuZXcgdmFsXG5jbGFzcyBEZWNsYXJlT3AgZXh0ZW5kcyBCaW5hcnlPcGVyYXRpb25fMS5CaW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgZGVjbGFyZSBvcGVyYXRpb24sIHdoaWNoIGRlY2xhcmVzIGEgdmFyaWFibGUgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgc2lkZSBvZiB0aGUgZGVjbGFyZSBvcCAodGhlIHZhcmlhYmxlKVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgb3AgKHRoZSB2YWx1ZSlcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgc3VwZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoIShsZWZ0IGluc3RhbmNlb2YgVmFyaWFibGVOb2RlXzEuVmFyaWFibGVOb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxlZnQgaGFuZCBzaWRlIG9mIHRoZSBhc3NpZ25tZW50IG11c3QgYmUgYSB2YXJpYWJsZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyB0aGUgZGVjbGFyYXRpb24gYnkgZGVjbGFyaW5nIHRoZSB2YXJpYWJsZSBpbiB0aGUgY29udGV4dCBhbmQgYXNzaWduaW5nIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0IGluc3RhbmNlb2YgVmFyaWFibGVOb2RlXzEuVmFyaWFibGVOb2RlKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlY2xhcmUodGhpcy5sZWZ0Lm5hbWUpO1xuICAgICAgICAgICAgbGV0IHIgPSB0aGlzLnJpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgICAgICBjb250ZXh0LmFzc2lnbih0aGlzLmxlZnQubmFtZSwgcik7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIQUxQIChpbiBEZWNsYXJlT3ApXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkZWNsYXJlIG9wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwidmFyIFwiICsgdGhpcy5sZWZ0LnRvU3RyaW5nKCkgKyAnID0gJyArIHRoaXMucmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjbGFyZU9wcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbid0IGJlIGNhbGxlZCBkaXJlY2x5IG9uIGEgRGVjbGFyZU9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBiaW5hcnkgb3BlcmF0aW9uc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLkRlY2xhcmVPcCA9IERlY2xhcmVPcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlY2xhcmVPcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgTWludXNPcF8xID0gcmVxdWlyZShcIi4vTWludXNPcFwiKTtcbmNvbnN0IEFzc2lnbk9wXzEgPSByZXF1aXJlKFwiLi9Bc3NpZ25PcFwiKTtcbmNvbnN0IFZhcmlhYmxlTm9kZV8xID0gcmVxdWlyZShcIi4uL3ZhcnMvVmFyaWFibGVOb2RlXCIpO1xuY2xhc3MgRGVjcmVtZW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIGRlY3JlbWVudCBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gdmFyaWFibGUgVGhlIGV4cHJlc3Npb24gdG8gYmUgZGVjcmVtZW50ZWRcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2YXJpYWJsZSwgd3MpIHtcbiAgICAgICAgdGhpcy5leHByID0gdmFyaWFibGU7XG4gICAgICAgIGlmICh2YXJpYWJsZSBpbnN0YW5jZW9mIFZhcmlhYmxlTm9kZV8xLlZhcmlhYmxlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5pbm5lclJlcCA9IG5ldyBBc3NpZ25PcF8xLkFzc2lnbk9wKHZhcmlhYmxlLCBuZXcgTWludXNPcF8xLk1pbnVzT3AodmFyaWFibGUsIG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbm5lclJlcCA9IG5ldyBNaW51c09wXzEuTWludXNPcCh2YXJpYWJsZSwgbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBkZWNyZW1lbnQgb3AgdG8gYSBOdW1iZXJOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlubmVyUmVwLmV2YWwoY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRlY3JlbWVudCBvcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLmV4cHIudG9TdHJpbmcoKSArIFwiLS1cIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjcmVtZW50IG9wcyBjYW4ndCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2FuJ3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGRlY3JlbWVudFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5EZWNyZW1lbnQgPSBEZWNyZW1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWNyZW1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCaW5hcnlPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL0JpbmFyeU9wZXJhdGlvblwiKTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgRGl2T3AgZXh0ZW5kcyBCaW5hcnlPcGVyYXRpb25fMS5CaW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgZGl2aXNpb24gb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGRpdmlkZW5kXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSBkaXZpc29yXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHN1cGVyKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBkaXZpc2lvbiBhbmQgZXZhbHVhdGVzIGludG8gYSBzaW5nbGUgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMubGVmdC5ldmFsKG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpKS5ldmFsKGNvbnRleHQpLnZhbCAvIHRoaXMucmlnaHQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXZpc2lvbiBvcHMgY2FuJ3QgYmUgZGlyZWN0bHkgZHJhd25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbid0IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhIGRpdmlzaW9uIG9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBiaW5hcnkgb3BlcmF0aW9uc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGl2aXNpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5sZWZ0LnRvU3RyaW5nKCkgKyAnIC8gJyArIHRoaXMucmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLkRpdk9wID0gRGl2T3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaXZPcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgUGx1c09wXzEgPSByZXF1aXJlKFwiLi9QbHVzT3BcIik7XG5jb25zdCBBc3NpZ25PcF8xID0gcmVxdWlyZShcIi4vQXNzaWduT3BcIik7XG5jb25zdCBWYXJpYWJsZU5vZGVfMSA9IHJlcXVpcmUoXCIuLi92YXJzL1ZhcmlhYmxlTm9kZVwiKTtcbmNsYXNzIEluY3JlbWVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIEluY3JlbWVudFxuICAgICAqIEBwYXJhbSB2YXJpYWJsZSBUaGUgZXhwcmVzc2lvbiB0byBpbmNyZW1lbnRcbiAgICAgKiBAcGFyYW0gd3MgVHJhY2tzIHByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFyaWFibGUsIHdzKSB7XG4gICAgICAgIHRoaXMuZXhwciA9IHZhcmlhYmxlO1xuICAgICAgICBpZiAodmFyaWFibGUgaW5zdGFuY2VvZiBWYXJpYWJsZU5vZGVfMS5WYXJpYWJsZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJSZXAgPSBuZXcgQXNzaWduT3BfMS5Bc3NpZ25PcCh2YXJpYWJsZSwgbmV3IFBsdXNPcF8xLlBsdXNPcCh2YXJpYWJsZSwgbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyUmVwID0gbmV3IFBsdXNPcF8xLlBsdXNPcCh2YXJpYWJsZSwgbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEsIFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIGluY3JlbWVudCBpbnRvIGEgbnVtYmVyIG5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgZnVuY3Rpb24gc2NvcGVcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXJSZXAuZXZhbChjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5jcmVtZW50cyBjYW5ub3QgYmUgZHJhd25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGJpbm9wc1xuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluY3JlbWVudCBleHByZXNzaW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuZXhwci50b1N0cmluZygpICsgXCIrK1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5jcmVtZW50ID0gSW5jcmVtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5jcmVtZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmluYXJ5T3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9CaW5hcnlPcGVyYXRpb25cIik7XG5jb25zdCBTY29wZV8xID0gcmVxdWlyZShcIi4uL3N0cnVjdHVyYWwvU2NvcGVcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIE1pbnVzT3AgZXh0ZW5kcyBCaW5hcnlPcGVyYXRpb25fMS5CaW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHN1YnRyYWN0aW9uIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBtaW51ZW5kXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSBzdWJyYWhlbmRcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgc3VwZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIHN1YnRyYWN0aW9uIGFuZCBldmFsdWF0ZXMgdG8gYSBzaW5nbGUgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMubGVmdC5ldmFsKG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpKS5ldmFsKGNvbnRleHQpLnZhbCAtIHRoaXMucmlnaHQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdGlvbiBvcHMgY2FuJ3QgYmUgZGlyZWN0bHkgZHJhd25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbid0IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBzdWJ0cmFjdGlvblxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHN1YnRyYWN0aW9uIG9wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMubGVmdC50b1N0cmluZygpICsgJyAtICcgKyB0aGlzLnJpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5NaW51c09wID0gTWludXNPcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1pbnVzT3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCaW5hcnlPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL0JpbmFyeU9wZXJhdGlvblwiKTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgTXVsT3AgZXh0ZW5kcyBCaW5hcnlPcGVyYXRpb25fMS5CaW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgbXVsdGlwbGljYXRpb24gb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIG11bHRpcGxpY2FuZFxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgbXVsdGlwbGllclxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICBzdXBlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgbXVsdGlwbGljYXRpb24gYW5kIHJldHVybnMgYSBzaW5nbGUgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMubGVmdC5ldmFsKG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpKS5ldmFsKGNvbnRleHQpLnZhbCAqIHRoaXMucmlnaHQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtdWx0aXBsaWNhdGlvbiBvcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLmxlZnQudG9TdHJpbmcoKSArICcgKiAnICsgdGhpcy5yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWNhdGlvbiBvcHMgY2Fubm90IGJlIGRpcmVjdGx5IGRyYXduXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgbXVsdGlwbGljYWl0b24gb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBiaW5hcnkgb3BlcmF0aW9uc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLk11bE9wID0gTXVsT3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NdWxPcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJpbmFyeU9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vQmluYXJ5T3BlcmF0aW9uXCIpO1xuY29uc3QgU2NvcGVfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3R1cmFsL1Njb3BlXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG4vLyBsZWZ0IGFuZCByaWdodCBhcmUgYm90aCBleHByZXNzaW9uc1xuY2xhc3MgUGx1c09wIGV4dGVuZHMgQmluYXJ5T3BlcmF0aW9uXzEuQmluYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIGFkZGl0aW9uIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBmaXJzdCBhZGRlbmRcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHNlY29uZCBhZGRlbmRcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgc3VwZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIGFkZGl0aW9uIGFuZCByZXR1cm5zIGEgc2luZ2xlIE51bWJlck5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLmxlZnQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwgKyB0aGlzLnJpZ2h0LmV2YWwobmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCkpLmV2YWwoY29udGV4dCkudmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkaXRpb24gb3BzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhbiBhZGRpdGlvbiBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGFkZGl0aW9uIG9wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMubGVmdC50b1N0cmluZygpICsgJyArICcgKyB0aGlzLnJpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5QbHVzT3AgPSBQbHVzT3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QbHVzT3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTY29wZV8xID0gcmVxdWlyZShcIi4uL3N0cnVjdHVyYWwvU2NvcGVcIik7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY29uc3Qgc3BhY2VfbGlmdF8xID0gcmVxdWlyZShcInNwYWNlLWxpZnRcIik7XG5jbGFzcyBDb25kaXRpb25hbCB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBjb25kaXRpb25hbHMgKGlmLCBlbHNlIGlmLCBhbmQgZWxzZSBzdGF0ZW1lbnRzKVxuICAgICAqIEBwYXJhbSB0ZXN0IFRoZSBjb25kaXRpb24gb2YgdGhlIHN0YXRlbWVudFxuICAgICAqIEBwYXJhbSB0cnVlQnJhbmNoIFRoZSBicmFuY2ggdG8gZm9sbG93IGlmIHRoZSBjb25kaXRpb24gZXZhbHVhdGVzIHRvIHRydWVcbiAgICAgKiBAcGFyYW0gZmFsc2VCcmFuY2ggVGhlIGJyYW5jaCB0byBmb2xsb3cgaWYgdGhlIGNvbmRpdGlvbiBldmFsdWF0ZXMgdG8gZmFsc2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXN0LCB0cnVlQnJhbmNoLCBmYWxzZUJyYW5jaCkge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdGVzdCA9IHRlc3Q7XG4gICAgICAgIHRoaXMuX3RydWVCcmFuY2ggPSB0cnVlQnJhbmNoO1xuICAgICAgICB0aGlzLl9mYWxzZUJyYW5jaCA9IGZhbHNlQnJhbmNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIHRlc3QgcmVzdWx0IGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIHRydWUgb3IgZmFsc2UgYnJhbmNoLCBkZXBlbmRpbmcgb24gdGhlIHRlc3RcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGNoaWxkQ3R4ID0gbmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCwgY29udGV4dC5lZmZlY3RzLCBjb250ZXh0LmV2ZW50TG9nKTtcbiAgICAgICAgY2hpbGRDdHguY2FudmFzID0gc3BhY2VfbGlmdF8xLlNvbWUoY29udGV4dC5jYW52YXMuZ2V0KCkpO1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5fdGVzdC5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgaWYgKCEocmVzIGluc3RhbmNlb2YgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjb25kaXRpb24gbXVzdCBiZSBhIGJvb2xlYW4gZXhwcmVzc2lvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcy52YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cnVlQnJhbmNoLmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2ZhbHNlQnJhbmNoICE9IG51bGwpIHsgLy8gY2hlY2sgaWYgZWxzZS9lbHNlIGlmIGlzIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmFsc2VCcmFuY2guZXZhbChjaGlsZEN0eCk7IC8vIHBvc3NpYmx5IGEgYmFkIGlkZWFcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb25kaXRpb25hbCBzdGF0ZW1lbnRcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlcyA9ICdpZignICsgdGhpcy5fdGVzdC50b1N0cmluZygpICsgXCIpIHtcXG4gXCIgKyB0aGlzLl90cnVlQnJhbmNoLnRvU3RyaW5nKCkgKyBcIn1cIjtcbiAgICAgICAgaWYgKHRoaXMuX2ZhbHNlQnJhbmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlcyArPSAnXFxuZWxzZSB7XFxuICcgKyB0aGlzLl9mYWxzZUJyYW5jaC50b1N0cmluZygpICsgJ30nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJ1ZSBicmFuY2ggb2YgdGhlIGNvbmRpdGlvbmFsXG4gICAgICovXG4gICAgZ2V0IHRydWVCcmFuY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cnVlQnJhbmNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmYWxzZSBicmFuY2ggb2YgdGhlIGNvbmRpdGlvbmFsXG4gICAgICovXG4gICAgZ2V0IGZhbHNlQnJhbmNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFsc2VCcmFuY2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmRpdGlvbmFscyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgY29uZGl0aW9uYWxcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGNvbmRpdGlvbmFsc1wiKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbmRpdGlvbmFsID0gQ29uZGl0aW9uYWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25kaXRpb25hbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgUGFpbnRFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUGFpbnRFdmVudFwiKTtcbmNvbnN0IFJlc2l6ZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9SZXNpemVFdmVudFwiKTtcbmNvbnN0IENsaWNrRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL0NsaWNrRXZlbnRcIik7XG5jbGFzcyBDdXJ2ZUVmZmVjdCB7XG4gICAgY29uc3RydWN0b3IoY3VydmUpIHtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBwcml2YXRlIGJvb2xzXG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JhdGlvID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnggPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IDA7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX21vdXNlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY3VydmUgPSBjdXJ2ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIGV2YWx1YXRpbmcgbm9kZXMgKFN0cmluZ05vZGUsIEVsbGlwc2VOb2RlLCBldGMpXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyBhbGwgcGFyYW1zIHRvIHByaXZhdGUgdmFyaWFibGVzIGFuZCBkcmF3cyB0aGUgaW5pdGlhbCBvYmplY3QgdG8gdGhlIGNhbnZhc1xuICAgICAqIGJ5IGNhbGxpbmcgdXBkYXRlKClcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgcGFyZW50IFNjb3BlIHRoYXQgY29udGFpbnMgdGhlIGNhbnZhcyBhbW9uZyBvdGhlciB0aGluZ3NcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgb2JqZWN0J3MgZGltZW5zaW9ucyBpbmNsdWRpbmcgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBhc3QgVW5uZWNlc3Nhcnkgbm93LCB1c2VkIHRvIGJlIHRoZSBwYXJlbnQgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY2FudmFzLmlzRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zID0gZGltcztcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IGNvbnRleHQuY2FudmFzLmdldCgpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgY3R4ID0gY29udGV4dC5jYW52YXMuZ2V0KCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1BhaW50KCkpO1xuICAgICAgICBjb250ZXh0LmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gZHJhdyBhbmQgcmVkcmF3IHRoZSBvYmplY3Qgd2hlbiBtYW5pcHVsYXRpb25zIGFyZSBtYWRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudztcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuaDtcbiAgICAgICAgbGV0IGN1cnZhdHVyZSA9IHRoaXMuY3VydmF0dXJlO1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIGxldCB2ID0gdGhpcy5wZXJwZW5kaWN1bGFyVmVjdG9yKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLl9jdHgucXVhZHJhdGljQ3VydmVUbygoeCArIHdpZHRoIC8gMikgKyBjdXJ2YXR1cmUgKiB2WzBdLCAoeSArIGhlaWdodCAvIDIpICsgY3VydmF0dXJlICogdlsxXSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gXCIjNjczQUI3XCI7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0d1aWRlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0aGlzLl9jb3JuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vYSAqIHcgKyBiICogaCA9IDBcbiAgICBwZXJwZW5kaWN1bGFyVmVjdG9yKHcsIGgpIHtcbiAgICAgICAgaWYgKHcgPT0gMCAmJiBoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodyA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gWzEsIDBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFswLCAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzEsICgtdykgLyBoXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gb25lIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7IC8vIGJpbmQgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIG1lYW5pbmcgb2YgJ3RoaXMnXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25TaGlmdERvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25TaGlmdFVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy9tYWtlcyBpdCBzbyB0aGF0IGRvdWJsZSBjbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0ZXh0IG9uIHRoZSBwYWdlXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uIChlKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGZhbHNlOyB9LCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIGFub3RoZXIgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvZiB0aGUgb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgY29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAobXggPiB4ICYmIG14IDwgeCArIHcgJiYgbXkgPiB5ICYmIG15IDwgeSArIGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciA+IDAgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvbmUgb2YgdGhlIGNvcm5lci9zaWRlIGd1aWRlcywgcmV0dXJucyAwIGlmIG5vdFxuICAgICAqIFRoZSBjb3JuZXIgZ3VpZGVzIGFyZSBudW1iZXJlZCAxLTQgd2l0aCAxIGJlaW5nIHRoZSB0b3AgbGVmdCwgMiBiZWluZyB0aGUgdG9wIHJpZ2h0LCBhbmQgc28gb24uXG4gICAgICogVGhlIG1pZGRsZSBndWlkZXMgYXJlIG51bWJlcmVkIDUtOCwgd2l0aCA1IGJlaW5nIHRoZSB0b3AgbWlkZGxlLCA2IGJlaW5nIHRoZSByaWdodCBtaWRkbGUsIGFuZCBzbyBvbi5cbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ3VpZGVDb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGxldCB4ZGlmID0gbXggLSB4O1xuICAgICAgICBsZXQgeWRpZiA9IG15IC0geTtcbiAgICAgICAgLyogQ29ybmVyIEd1aWRlcyAqL1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIGxlZnRcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogTWlkZGxlIEd1aWRlcyAqL1xuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0geTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGFuZCBndWlkZXMgZm9yIHRoZSBvYmplY3Qgd2hlbiB0aGUgb2JqZWN0IGlzIHNlbGVjdGVkXG4gICAgICogSWYgb25lIG9mIHRoZSBndWlkZXMgaXMgc2VsZWN0ZWQsIGl0IGNvbG9ycyB0aGF0IGd1aWRlIGJsdWVcbiAgICAgKiBAcGFyYW0geCB0aGUgeCBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0geSB0aGUgeSBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb3JuZXIgdGhlIG51bWJlciBvZiB0aGUgY29ybmVyIHRvIGJlIGNvbG9yZWQgYmx1ZSAoaWYgYW55IGF0IGFsbCwgaWYgMCwgYWxsIGFyZSB3aGl0ZSlcbiAgICAgKi9cbiAgICBkcmF3R3VpZGVzKHgsIHksIHcsIGgsIGNvcm5lcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKGNvcm5lciAhPT0gMCAmJiBjb3JuZXIgPD0gNCkgeyAvLyBhIGNvcm5lciBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcnJlY3QgZ3VpZGUgYmx1ZVxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3JuZXIgIT09IDApIHsgLy8gYSBtaWRkbGUgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vaWYgbm8gZ3VpZGVzIGFyZSBzZWxlY3RlZCwgY29sb3JzIGV2ZXJ5dGhpbmcgd2hpdGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBtZXRob2QgdGhhdCBkcmF3cyBhIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB4IHggY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHkgeSBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gdyB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29sb3IgY29sb3Igb2YgdGhlIHJlY3RhbmdsZSdzIGZpbGxcbiAgICAgKi9cbiAgICBkcmF3U3F1YXJlKHgsIHksIHcsIGgsIGNvbG9yKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBtb3ZlcyB3aXRoaW4gdGhlIGNhbnZhcy5cbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiwgY2FsbHMgdGhlIG1vZGlmeSBtZXRob2RzIGlmIHRoZSBib29sZWFucyBzYXRpc2Z5IHRoZW0uXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICB0aGlzLmdldE1vdXNlUG9zaXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlEcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZXNpemluZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZSh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQ2hhbmdpbmdEaW1zICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltcyh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5U3RhdGUodGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpLCB0aGlzLmNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSB1bmNsaWNrcy5cbiAgICAgKiBDYWxscyBtb2RpZnlSZXNldCB0byByZXNldCBkcmFnZ2luZyBhbmQgcmVzaXppbmcgYm9vbGVhbnMgYW1vbmcgb3RoZXJzLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2V1cCBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VVcChldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyBwcmVzc2VkIGRvd25cbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSBwcmVzc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcmVsZWFzZWRcbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSByZWxlYXNlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdFVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBNb2RpZmljYXRpb24gZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGRyYWcgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBtb2RpZnlEcmFnKCkge1xuICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS54IC0gdGhpcy5fZHJhZ29mZng7XG4gICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLl9kcmFnb2ZmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkICh3aGVuIGEgY29ybmVyIGd1aWRlIGlzIGNsaWNrZWQgYW5kIGRyYWdnZWQpLlxuICAgICAqXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMCBhbmQgdGhlIG90aGVyIGVxdWFsIHRvXG4gICAgICogMTAgZGl2aWRlZCBvciBtdWx0aXBsaWVkIGJ5IHRoZSByYXRpbyBvZiB3aWR0aC9oZWlnaHQgdG8ga2VlcCBpdCB0aGUgc2FtZS5cbiAgICAgKlxuICAgICAqIFRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIGlzIGRvbmUgYnkgY2FsbGluZyB0aGUgaGVscGVyIG1ldGhvZCBtb2RpZnlSZXNpemVIZWxwZXIuXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7IC8vIHNldCBmb3IgdGhlIHByb2RpcmVjdCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTAgLyB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fY3VydmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApOyAvLyBzZXQgZm9yIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgKiB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTAgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIHRoZSByZWN0YW5nbGUgb3JpZ2luYXRlcyBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgYW5kIG5vdCB0aGUgY2VudGVyLFxuICAgICAqIGl0IGNoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXMgd2VsbCBpZiBndWlkZXMgMSwgMiwgb3IgNCBhcmUgc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdEaXN0YW5jZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbW91c2UgYW5kIHRoZSBsb2NhdGlvbiBvcHBvc2l0ZSB0byBpdFxuICAgICAqIChpZiB0b3AgcmlnaHQgZ3VpZGUgaXMgY2xpY2tlZCwgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhhdCBhbmQgdGhlIGJvdHRvbSBsZWZ0IGd1aWRlIGlzIG5ld0Rpc3RhbmNlKVxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSkge1xuICAgICAgICBpZiAodGhpcy53ID4gMTAgJiYgdGhpcy5oID4gMTApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQoKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAvIHRoaXMuX3JhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgIHRoaXMuX2N1cnZlLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgdGhpcy5fY3VydmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZC5cbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDEwLlxuICAgICAqIENhbGxzIG1vZGlmeUNoYW5nZURpbXNIZWxwZXIgdG8gYWN0dWFsbHkgZG8gdGhlIHdvcmtcbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fY3VydmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyA1IG9yIDggYXJlIHNlbGVjdGVkXG4gICAgICovXG4gICAgbW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oID4gMTApIHsgLy9hcyBsb25nIGFzIHRoZSBoZWlnaHQgaXMgPiAxMFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudyA+IDEwKSB7IC8vIGFzIGxvbmcgYXMgd2lkdGggaXMgPiAxMFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VydmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyBkZXBlbmRpbmcgb24gdGhlIG1vdXNlIHBvc2l0aW9uIHdoZW4gY2FsbGVkIChvbk1vdXNlRG93bilcbiAgICAgKiBlLmcuIGlmIHRoZSBtb3VzZSBpcyB3aXRoaW4gdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSB3aGVuIHRoaXMgaXMgY2FsbGVkLCBpc1NlbGVjdGVkID0gdHJ1ZVxuICAgICAqIEBwYXJhbSBndWlkZUNvbnRhaW5zXG4gICAgICogQHBhcmFtIGNvbnRhaW5zXG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGUoZ3VpZGVDb250YWlucywgY29udGFpbnMpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7IC8vcHJlcGFyZXMgdGhlIG9iamVjdCBmb3IgZHJhZ2dpbmcgd2hldGhlciBpdCBpcyBwZXJzb25hbGx5IHNlbGVjdGVkIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5feTEgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiAwICYmIGd1aWRlQ29udGFpbnMgPD0gNCkgeyAvL3Jlc2l6aW5nXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSB0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSk7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQxID0gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy5fd2lkdGgxID0gdGhpcy53O1xuICAgICAgICAgICAgLy90aGlzLl9zaXplMSA9IE1hdGguc3FydChNYXRoLnBvdyh3LDIpICsgTWF0aC5wb3coaCwyKSk7IC8vIHNpemUgaXMgZGlhZ29uYWwgbGVuZ3RoXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikgeyAvLyBzZXRzIHRoZSBvZmZzZXRzIGRlcGVuZGluZyBvbiB3aGljaCBjb3JuZXIgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7IC8vIG9mZnNldCBpcyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7IC8vIG9mZnNldCBpcyBib3R0b20gbGVmdCwgZXRjXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gNCkgeyAvL2NoYW5naW5nIHNoYXBlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gZ3VpZGVDb250YWlucztcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7IC8vIHNldHMgdGhlIG9mZnNldHMgZGVwZW5kaW5nIG9uIHdoaWNoIG1pZGRsZSBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgNTogLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdyAvIDIsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdyAvIDI7IC8vIG9mZnNldCBpcyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogLy9yaWdodCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoIC8gMjsgLy8gb2Zmc2V0IGlzIGxlZnQgbWlkZGxlIGV0Y1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWlucykgeyAvLyBkcmFnZ2luZ1xuICAgICAgICAgICAgdGhpcy5feDEgPSB4OyAvLyBTYXZpbmcgb3JpZ2luYWwgeCBhbmQgeVxuICAgICAgICAgICAgdGhpcy5feTEgPSB5O1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy8gbm90IHNlbGVjdGVkXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyB0byBmYWxzZSAobGlrZSBkcmFnZ2luZywgcmVzaXppbmcsIGV0Yykgd2hlbiB0aGUgbW91c2UgaXMgcmVsZWFzZWRcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0gdGhpcy54KSA+IDEgfHwgTWF0aC5hYnModGhpcy5feTEgLSB0aGlzLnkpID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodGhpcy5faXNSZXNpemluZyB8fCB0aGlzLl9pc0NoYW5naW5nRGltcykgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHNpemUyID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMudywgMikgKyBNYXRoLnBvdyh0aGlzLmgsIDIpKTtcbiAgICAgICAgICAgIGlmICgoTWF0aC5hYnModGhpcy5fd2lkdGgxIC0gdGhpcy53KSA+IDApIHx8IChNYXRoLmFicyh0aGlzLl9oZWlnaHQxIC0gdGhpcy5oKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUmVzaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICovXG4gICAgZ2V0TW91c2VQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbW91c2UueCA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLng7XG4gICAgICAgIHRoaXMuX21vdXNlLnkgPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzQ2hhbmdpbmdEaW1zLCBhbmQgaXNTZWxlY3RlZCB0byBmYWxzZSBpZiB0aGUgbW91c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgaXNNb3VzZU91dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1vdXNlWCA8IHJlY3QubGVmdCB8fCBtb3VzZVggPiByZWN0LnJpZ2h0IHx8IG1vdXNlWSA8IHJlY3QudG9wIHx8IG1vdXNlWSA+IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIHBhaW50IGV2ZW50XG4gICAgICovXG4gICAgbG9nUGFpbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpbnRFdmVudF8xLlBhaW50RXZlbnQoXCJyZWN0YW5nbGVcIiwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIHJlc2l6ZSBldmVudFxuICAgICAqL1xuICAgIGxvZ1Jlc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVFdmVudF8xLlJlc2l6ZUV2ZW50KFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgTWF0aC5yb3VuZCh0aGlzLl93aWR0aDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuX2hlaWdodDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMudyAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5oICogMTAwKSAvIDEwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZWN0YW5nbGUgY2xpY2sgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dDbGljaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGlja0V2ZW50XzEuQ2xpY2tFdmVudChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIGFzc2lnbnMgYW4gSUQgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIGlkIFRoZSBJRCB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIGluaXRJRChpZCkge1xuICAgICAgICB0aGlzLmlkT2JqID0geyBfaWQ6IGlkIH07XG4gICAgfVxuICAgIGFzdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHggcG9zaXRpb24gb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VydmF0dXJlIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIGdldCBjdXJ2YXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLmN1cnZhdHVyZS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRGltZW5zaW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgZGltcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZE9iai5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICovXG4gICAgZ2V0SnVzdERyYWdnZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdXN0RHJhZ2dlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldEp1c3REcmFnZ2VkKHZhbCkge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBpcyBkcmFnZ2luZ1xuICAgICAqL1xuICAgIGdldCBpc0RyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEcmFnZ2luZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBzZWxlY3Rpb24gZXZlbnRzXG4gICAgICovXG4gICAgdG9TZWxTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIiByZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBkcmFnIGV2ZW50c1xuICAgICovXG4gICAgdG9EcmFnU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94MSArIFwiLCBcIiArIHRoaXMuX3kxICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gcmVjdGFuZ2xlIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG59XG5leHBvcnRzLkN1cnZlRWZmZWN0ID0gQ3VydmVFZmZlY3Q7XG4vKipcbiAqIEdldHMgdGhlIG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZXMgaW4gcmVsYXRpb24gdG8gdGhlIGNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB0aGUgY2FudmFzIG9iamVjdFxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0TW91c2VQb3MoY2FudmFzLCBldmVudCkge1xuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB4MSB4IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB5MSB5IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB4MiB4IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKiBAcGFyYW0geTIgeSBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MiwgMikgKyBNYXRoLnBvdyh5MSAtIHkyLCAyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DdXJ2ZUVmZmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBhaW50RXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1BhaW50RXZlbnRcIik7XG5jb25zdCBSZXNpemVFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUmVzaXplRXZlbnRcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IENsaWNrRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL0NsaWNrRXZlbnRcIik7XG5jbGFzcyBFbGxpcHNlRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihjaXJjbGUpIHtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBQcml2YXRlIGJvb2xzXG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7IC8vIEhhcyB0aGlzIG9iamVjdCBqdXN0IGJlZW4gZHJhZ2dlZD9cbiAgICAgICAgdGhpcy5fcmF0aW8gPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gMDtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5fbW91c2UgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jaXJjbGUgPSBjaXJjbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiBldmFsdWF0aW5nIG5vZGVzIChTdHJpbmdOb2RlLCBFbGxpcHNlTm9kZSwgZXRjKVxuICAgICAqIFRoaXMgbWV0aG9kIGFzc2lnbnMgYWxsIHBhcmFtcyB0byBwcml2YXRlIHZhcmlhYmxlcyBhbmQgZHJhd3MgdGhlIGluaXRpYWwgb2JqZWN0IHRvIHRoZSBjYW52YXNcbiAgICAgKiBieSBjYWxsaW5nIHVwZGF0ZSgpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIHBhcmVudCBTY29wZSB0aGF0IGNvbnRhaW5zIHRoZSBjYW52YXMgYW1vbmcgb3RoZXIgdGhpbmdzXG4gICAgICogQHBhcmFtIGRpbXMgVGhlIG9iamVjdCdzIGRpbWVuc2lvbnMgaW5jbHVkaW5nIHggYW5kIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gYXN0IFVubmVjZXNzYXJ5IG5vdywgdXNlZCB0byBiZSB0aGUgcGFyZW50IEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNhbnZhcy5pc0RlZmluZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZGltcyA9IGRpbXM7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBjb250ZXh0LmNhbnZhcy5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgbGV0IGN0eCA9IGNvbnRleHQuY2FudmFzLmdldCgpLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb2dnaW5nXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1BhaW50KCkpO1xuICAgICAgICBjb250ZXh0LmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gZHJhdyBhbmQgcmVkcmF3IHRoZSBvYmplY3Qgd2hlbiBtYW5pcHVsYXRpb25zIGFyZSBtYWRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHguZWxsaXBzZSh4LCB5LCB3IC8gMiwgaCAvIDIsIDAsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgICAgIC8vdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICAvL3RoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IFwiI0Q1QjhGRlwiO1xuICAgICAgICB0aGlzLl9jdHguc2hhZG93Q29sb3IgPSBcIiM2QzZDNkNcIjtcbiAgICAgICAgdGhpcy5fY3R4LnNoYWRvd0JsdXIgPSAxNTtcbiAgICAgICAgLy90aGlzLl9jdHguc2hhZG93T2Zmc2V0WCA9IDI7XG4gICAgICAgIC8vdGhpcy5fY3R4LnNoYWRvd09mZnNldFkgPSAyO1xuICAgICAgICB0aGlzLl9jdHguZmlsbCgpO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3R3VpZGVzKHggLSB3IC8gMiwgeSAtIGggLyAyLCB3LCBoLCB0aGlzLl9jb3JuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICAgIHByaXZhdGUgbW91c2VNb3ZlID0gdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICBwcml2YXRlIG1vdXNlRG93biA9IHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgcHJpdmF0ZSBtb3VzZVVwID0gdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgcHJpdmF0ZSBzaGlmdERvd24gPSB0aGlzLm9uU2hpZnREb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHByaXZhdGUgc2hpZnRVcCA9IHRoaXMub25TaGlmdFVwLmJpbmQodGhpcyk7XG4gICAgICAgIHByaXZhdGUgbW91c2VPdXRzaWRlID0gdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpO1xuICAgICAgICBwcml2YXRlIHNlbGVjdFN0YXJ0ID0gZnVuY3Rpb24oZTphbnkpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZmFsc2U7IH07XG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBvbmUgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTsgLy8gYmluZCBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgbWVhbmluZyBvZiAndGhpcydcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vblNoaWZ0RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vblNoaWZ0VXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmlzTW91c2VPdXRzaWRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL21ha2VzIGl0IHNvIHRoYXQgZG91YmxlIGNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRleHQgb24gdGhlIHBhZ2VcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgZnVuY3Rpb24gKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZmFsc2U7IH0sIGZhbHNlKTtcbiAgICB9XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIC8qXG4gICAgICAgIGNvbnNvbGUubG9nKFwicmVtb3ZpbmcgRXZlbnRMaXN0bmVyc1wiKTtcbiAgICAgICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZU1vdmUpOyAvLyBiaW5kIGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBtZWFuaW5nIG9mICd0aGlzJ1xuICAgICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlRG93bik7XG4gICAgICAgICAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNlVXApO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5zaGlmdERvd24pO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuc2hpZnRVcCk7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2VPdXRzaWRlKTtcbiAgICAgICAgICAvL21ha2VzIGl0IHNvIHRoYXQgZG91YmxlIGNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRleHQgb24gdGhlIHBhZ2VcbiAgICAgICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCB0aGlzLnNlbGVjdFN0YXJ0LCBmYWxzZSk7XG4gICAgICAgICAgKi9cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb2YgdGhlIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSwgZmFsc2UgaWYgb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KG14IC0geCwgMikgLyBNYXRoLnBvdyh3IC8gMiwgMikgKyBNYXRoLnBvdyhteSAtIHksIDIpIC8gTWF0aC5wb3coaCAvIDIsIDIpIDw9IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgPiAwIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb25lIG9mIHRoZSBjb3JuZXIvc2lkZSBndWlkZXMsIHJldHVybnMgMCBpZiBub3RcbiAgICAgKiBUaGUgY29ybmVyIGd1aWRlcyBhcmUgbnVtYmVyZWQgMS00IHdpdGggMSBiZWluZyB0aGUgdG9wIGxlZnQsIDIgYmVpbmcgdGhlIHRvcCByaWdodCwgYW5kIHNvIG9uLlxuICAgICAqIFRoZSBtaWRkbGUgZ3VpZGVzIGFyZSBudW1iZXJlZCA1LTgsIHdpdGggNSBiZWluZyB0aGUgdG9wIG1pZGRsZSwgNiBiZWluZyB0aGUgcmlnaHQgbWlkZGxlLCBhbmQgc28gb24uXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGd1aWRlQ29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBsZXQgeGRpZiA9IG14IC0gKHggLSB3IC8gMik7XG4gICAgICAgIGxldCB5ZGlmID0gbXkgLSAoeSAtIGggLyAyKTtcbiAgICAgICAgLyogQ29ybmVyIEd1aWRlcyAqL1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIGxlZnRcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4IC0gdyAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICB9XG4gICAgICAgIC8qIE1pZGRsZSBHdWlkZXMgKi9cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgLSBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0geTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCAtIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0geTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBhbmQgZ3VpZGVzIGZvciB0aGUgb2JqZWN0IHdoZW4gdGhlIG9iamVjdCBpcyBzZWxlY3RlZFxuICAgICAqIElmIG9uZSBvZiB0aGUgZ3VpZGVzIGlzIHNlbGVjdGVkLCBpdCBjb2xvcnMgdGhhdCBndWlkZSBibHVlXG4gICAgICogQHBhcmFtIHggdGhlIHggY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHkgdGhlIHkgY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHcgdGhlIHdpZHRoIG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29ybmVyIHRoZSBudW1iZXIgb2YgdGhlIGNvcm5lciB0byBiZSBjb2xvcmVkIGJsdWUgKGlmIGFueSBhdCBhbGwsIGlmIDAsIGFsbCBhcmUgd2hpdGUpXG4gICAgICovXG4gICAgZHJhd0d1aWRlcyh4LCB5LCB3LCBoLCBjb3JuZXIpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmIChjb3JuZXIgIT09IDAgJiYgY29ybmVyIDw9IDQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29ybmVyICE9PSAwICYmIGNvcm5lciA+IDQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgbWV0aG9kIHRoYXQgZHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geCB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5IHkgY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHcgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIGNvbG9yIG9mIHRoZSByZWN0YW5nbGUncyBmaWxsXG4gICAgICovXG4gICAgZHJhd1NxdWFyZSh4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgd2l0aGluIHRoZSBjYW52YXMuXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24sIGNhbGxzIHRoZSBtb2RpZnkgbWV0aG9kcyBpZiB0aGUgYm9vbGVhbnMgc2F0aXNmeSB0aGVtLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRNb3VzZVBvc2l0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5RHJhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemUodGhpcy53IDwgMTQsIHRoaXMuaCA8IDE0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0NoYW5naW5nRGltcyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXModGhpcy53IDwgMTQsIHRoaXMuaCA8IDE0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIGNsaWNrcyBpbnNpZGUgdGhlIGNhbnZhcy5cbiAgICAgKiBNb2RpZmllcyB0aGUgc3RhdGUgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGd1aWRlcyBjb250YWluIHRoZSBtb3VzZSBvciB0aGUgYm91bmRpbmcgcmVjdCBjb250YWlucyB0aGUgbW91c2UuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVN0YXRlKHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSwgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgdW5jbGlja3MuXG4gICAgICogQ2FsbHMgbW9kaWZ5UmVzZXQgdG8gcmVzZXQgZHJhZ2dpbmcgYW5kIHJlc2l6aW5nIGJvb2xlYW5zIGFtb25nIG90aGVycy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNldXAgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkknbSBhbiBlbGxpcHNlIVwiKTtcbiAgICAgICAgdGhpcy5tb2RpZnlSZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcHJlc3NlZCBkb3duXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcHJlc3NlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdERvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHJlbGVhc2VkXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcmVsZWFzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnRVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogTW9kaWZpY2F0aW9uIGZ1bmN0aW9ucyAqL1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBpbiBvcmRlciB0byBkcmFnIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgbW9kaWZ5RHJhZygpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImVsbGlwc2UgZHJhZ29mZng6IFwiICsgdGhpcy5fZHJhZ29mZngpO1xuICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS54IC0gdGhpcy5fZHJhZ29mZng7XG4gICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLl9kcmFnb2ZmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkICh3aGVuIGEgY29ybmVyIGd1aWRlIGlzIGNsaWNrZWQgYW5kIGRyYWdnZWQpLlxuICAgICAqXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxNCBhbmQgdGhlIG90aGVyIGVxdWFsIHRvXG4gICAgICogMTAgZGl2aWRlZCBvciBtdWx0aXBsaWVkIGJ5IHRoZSByYXRpbyBvZiB3aWR0aC9oZWlnaHQgdG8ga2VlcCBpdCB0aGUgc2FtZS5cbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxNFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTRcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNpemUod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgaWYgKHdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxNDtcbiAgICAgICAgICAgIHRoaXMuX2NpcmNsZS53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxNCk7IC8vIHNldCBmb3IgdGhlIHByb2RpcmVjdCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTQgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2NpcmNsZS5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxNCAvIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDI7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDIgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDE0O1xuICAgICAgICAgICAgdGhpcy5fY2lyY2xlLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxNCk7IC8vIHNldCBmb3IgdGhlIHByb2RpcmVjdCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxNCAqIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fY2lyY2xlLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTQgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyIC8gdGhpcy5fcmF0aW87XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDI7XG4gICAgICAgICAgICB0aGlzLl9jaXJjbGUud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyIC8gdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9jaXJjbGUuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQuXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMC5cbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgIGlmICh0aGlzLl9jb3JuZXIgPT0gNSB8fCB0aGlzLl9jb3JuZXIgPT0gNykgeyAvLyBpZiBtb2RpZnlpbmcgaGVpZ2h0XG4gICAgICAgICAgICBpZiAoIWhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDIgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7IC8vIHNldHRpbmcgd2lkdGgvaGVpZ2h0IHJhdGlvID0gdG8gdGhlIG5ldyByYXRpb1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxNDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDE0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyIC8gdGhpcy5fcmF0aW87XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gbW9kaWZ5aW5nIHdpZHRoXG4gICAgICAgICAgICBpZiAoIXdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDE0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxNCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyBkZXBlbmRpbmcgb24gdGhlIG1vdXNlIHBvc2l0aW9uIHdoZW4gY2FsbGVkIChvbk1vdXNlRG93bilcbiAgICAgKiBlLmcuIGlmIHRoZSBtb3VzZSBpcyB3aXRoaW4gdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSB3aGVuIHRoaXMgaXMgY2FsbGVkLCBpc1NlbGVjdGVkID0gdHJ1ZVxuICAgICAqIEBwYXJhbSBndWlkZUNvbnRhaW5zXG4gICAgICogQHBhcmFtIGNvbnRhaW5zXG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGUoZ3VpZGVDb250YWlucywgY29udGFpbnMpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy9wcmVwYXJlcyB0aGUgb2JqZWN0IGZvciBkcmFnZ2luZyB3aGV0aGVyIGl0IGlzIHBlcnNvbmFsbHkgc2VsZWN0ZWQgb3Igbm90XG4gICAgICAgICAgICBpZiAoY29udGFpbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94MSA9IHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl95MSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gMCAmJiBndWlkZUNvbnRhaW5zIDw9IDQpIHsgLy9yZXNpemluZ1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gZ3VpZGVDb250YWlucztcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy54O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLnk7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICB0aGlzLl93aWR0aDEgPSB0aGlzLnc7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQxID0gdGhpcy5oO1xuICAgICAgICAgICAgLy90aGlzLl9zaXplMSA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLncsMikgKyBNYXRoLnBvdyh0aGlzLmgsMikpOyAvLyBzYXZpbmcgb2xkIHNpemVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gNCkgeyAvL2NoYW5naW5nIHNoYXBlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gZ3VpZGVDb250YWlucztcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy54O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLnk7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbnMpIHsgLy9zaW1wbHkgc2VsZWN0aW5nIHRoZSBzaGFwZSBvciBkcmFnZ2luZ1xuICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLng7IC8vIFNhdmluZyBvcmlnaW5hbCB4IGFuZCB5XG4gICAgICAgICAgICB0aGlzLl95MSA9IHRoaXMueTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHRoaXMueDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgdG8gZmFsc2UgKGxpa2UgZHJhZ2dpbmcsIHJlc2l6aW5nLCBldGMpIHdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkXG4gICAgICovXG4gICAgbW9kaWZ5UmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHsgLy8gcHJvYnMgb25seSBuZWVkIGRyYWdnaW5nIGJ1dCBvaCB3ZWxsIHwgaXNTZWwgfHwgc2VsTXVsP1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0gdGhpcy54KSA+IDEgfHwgTWF0aC5hYnModGhpcy5feTEgLSB0aGlzLnkpID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvL3RoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ01vdmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHRoaXMuX2lzUmVzaXppbmcgfHwgdGhpcy5faXNDaGFuZ2luZ0RpbXMpICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJyZXNpemluZyBlbGxpcHNlXCIpO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy9sZXQgc2l6ZTIgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53LDIpICsgTWF0aC5wb3codGhpcy5oLDIpKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTaXplIGRpZmY6IFwiICsgTWF0aC5hYnModGhpcy5fc2l6ZTEgLSBzaXplMikpO1xuICAgICAgICAgICAgaWYgKChNYXRoLmFicyh0aGlzLl93aWR0aDEgLSB0aGlzLncpID4gMCkgfHwgKE1hdGguYWJzKHRoaXMuX2hlaWdodDEgLSB0aGlzLmgpID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dSZXNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYodGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSl7XG4gICAgICAgIC8vICAgICBpZihNYXRoLmFicyh0aGlzLl94MSAtIHRoaXMueCkgPiAxIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0gdGhpcy55KSA+IDEpIHtcbiAgICAgICAgLy8gICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dNb3ZlKCkpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICovXG4gICAgZ2V0TW91c2VQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbW91c2UueCA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLng7XG4gICAgICAgIHRoaXMuX21vdXNlLnkgPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzQ2hhbmdpbmdEaW1zLCBhbmQgaXNTZWxlY3RlZCB0byBmYWxzZSBpZiB0aGUgbW91c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgaXNNb3VzZU91dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1vdXNlWCA8IHJlY3QubGVmdCB8fCBtb3VzZVggPiByZWN0LnJpZ2h0IHx8IG1vdXNlWSA8IHJlY3QudG9wIHx8IG1vdXNlWSA+IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSBwYWludCBldmVudFxuICAgICAqL1xuICAgIGxvZ1BhaW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhaW50RXZlbnRfMS5QYWludEV2ZW50KFwiZWxsaXBzZVwiLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZXNpemUgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dSZXNpemUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplRXZlbnRfMS5SZXNpemVFdmVudChcImVsbGlwc2Ugd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCBNYXRoLnJvdW5kKHRoaXMuX3dpZHRoMSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5faGVpZ2h0MSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy53ICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLmggKiAxMDApIC8gMTAwKTtcbiAgICAgICAgLy9NYXRoLnJvdW5kKHRoaXMuX3NpemUxKjEwMCkvMTAwLCBNYXRoLnJvdW5kKChNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53LDIpICsgTWF0aC5wb3codGhpcy5oLDIpKSoxMDApKS8xMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgY2xpY2sgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dDbGljaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGlja0V2ZW50XzEuQ2xpY2tFdmVudChcImVsbGlwc2Ugd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCBhc3NpZ25zIGFuIElEIHRvIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSBpZCBUaGUgSUQgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBpbml0SUQoaWQpIHtcbiAgICAgICAgdGhpcy5pZE9iaiA9IHsgX2lkOiBpZCB9O1xuICAgIH1cbiAgICBhc3QoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBlbGxpcHNlXG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIGVsbGlwc2VcbiAgICAgKi9cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGVsbGlwc2VcbiAgICAgKi9cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgZWxsaXBzZVxuICAgICAqL1xuICAgIGdldCBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERpbWVuc2lvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIGVsbGlwc2VcbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRPYmouX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqL1xuICAgIGdldEp1c3REcmFnZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fanVzdERyYWdnZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIGVsbGlwc2UgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBzZXRKdXN0RHJhZ2dlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVsbGlwc2UgaXMgZHJhZ2dpbmdcbiAgICAgKi9cbiAgICBnZXQgaXNEcmFnZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRHJhZ2dpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3Igc2VsZWN0aW9uIGV2ZW50c1xuICAgICAqL1xuICAgIHRvU2VsU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKFwiIGVsbGlwc2Ugd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgZHJhZyBldmVudHNcbiAgICAqL1xuICAgIHRvRHJhZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChcImVsbGlwc2Ugd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgZnJvbSBcIiArIHRoaXMuX3gxICsgXCIsIFwiICsgdGhpcy5feTEgKyBcIiB0byBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgSUQgYXNzaWdubWVudCBldmVudHNcbiAgICAgKi9cbiAgICB0b0lEU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaWRPYmouX2lkLnRvU3RyaW5nKCkgKyBcIiB0byBlbGxpcHNlIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG59XG5leHBvcnRzLkVsbGlwc2VFZmZlY3QgPSBFbGxpcHNlRWZmZWN0O1xuLyoqXG4gKiBHZXQncyB0aGUgbW91c2UgeCBhbmQgeSBjb29yZGluYXRlcyBpbiByZWxhdGlvbiB0byB0aGUgY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHRoZSBjYW52YXMgb2JqZWN0XG4gKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICovXG5mdW5jdGlvbiBnZXRNb3VzZVBvcyhjYW52YXMsIGV2ZW50KSB7XG4gICAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHgxIHggY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHkxIHkgY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHgyIHggY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSB5MiB5IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgyLCAyKSArIE1hdGgucG93KHkxIC0geTIsIDIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVsbGlwc2VFZmZlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IFBhaW50RXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1BhaW50RXZlbnRcIik7XG5jb25zdCBSZXNpemVFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUmVzaXplRXZlbnRcIik7XG5jb25zdCBDbGlja0V2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9DbGlja0V2ZW50XCIpO1xuY2xhc3MgRXBoRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihlcGgpIHtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBwcml2YXRlIGJvb2xzXG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JhdGlvID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnggPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IDA7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX21vdXNlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZXBoID0gZXBoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gZXZhbHVhdGluZyBub2RlcyAoU3RyaW5nTm9kZSwgRWxsaXBzZU5vZGUsIGV0YylcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3NpZ25zIGFsbCBwYXJhbXMgdG8gcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIGRyYXdzIHRoZSBpbml0aWFsIG9iamVjdCB0byB0aGUgY2FudmFzXG4gICAgICogYnkgY2FsbGluZyB1cGRhdGUoKVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBwYXJlbnQgU2NvcGUgdGhhdCBjb250YWlucyB0aGUgY2FudmFzIGFtb25nIG90aGVyIHRoaW5nc1xuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBvYmplY3QncyBkaW1lbnNpb25zIGluY2x1ZGluZyB4IGFuZCB5IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGFzdCBVbm5lY2Vzc2FyeSBub3csIHVzZWQgdG8gYmUgdGhlIHBhcmVudCBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBpZiAoY29udGV4dC5jYW52YXMuaXNEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMgPSBkaW1zO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gY29udGV4dC5jYW52YXMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0LmNhbnZhcy5nZXQoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICB0aGlzLl9lcGhJbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2VwaEltZy5zcmMgPSAnLi9waWNzL2RlbW9uY293LnBuZyc7XG4gICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUGFpbnQoKSk7XG4gICAgICAgIGNvbnRleHQuZWZmZWN0cy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBpbiBvcmRlciB0byBkcmF3IGFuZCByZWRyYXcgdGhlIG9iamVjdCB3aGVuIG1hbmlwdWxhdGlvbnMgYXJlIG1hZGVcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy53O1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5oO1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIC8vdmFyIGltZ09iaiA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAvL2xldCBjdHggPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgLy8gdGhpcy5fZXBoSW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIC8vIHRoaXMuX2VwaEltZy5zcmMgPSAnLi9waWNzL2RlbW9uY293LnBuZyc7XG4gICAgICAgIC8vaW1nT2JqLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vdGhpcy5fZXBoSW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuX2N0eC5kcmF3SW1hZ2UodGhpcy5fZXBoSW1nLCB0aGlzLngsIHRoaXMueSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIC8vdGhpcy5fZXBoSW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIHRoaXMuX2VwaEltZy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAvLyB0aGlzLl9lcGhJbWcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAvL31cbiAgICAgICAgLy99XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdHdWlkZXMoeCwgeSwgd2lkdGgsIGhlaWdodCwgdGhpcy5fY29ybmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBvbmUgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vblNoaWZ0RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vblNoaWZ0VXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmlzTW91c2VPdXRzaWRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL21ha2VzIGl0IHNvIHRoYXQgZG91YmxlIGNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRleHQgb24gdGhlIHBhZ2VcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgZnVuY3Rpb24gKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZmFsc2U7IH0sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gYW5vdGhlciBmZWxsIHN3b29wXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9mIHRoZSBvYmplY3QncyBib3VuZGluZyByZWN0YW5nbGUsIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBjb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGlmIChteCA+IHggJiYgbXggPCB4ICsgdyAmJiBteSA+IHkgJiYgbXkgPCB5ICsgaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbnVtYmVyID4gMCBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9uZSBvZiB0aGUgY29ybmVyL3NpZGUgZ3VpZGVzLCByZXR1cm5zIDAgaWYgbm90XG4gICAgICogVGhlIGNvcm5lciBndWlkZXMgYXJlIG51bWJlcmVkIDEtNCB3aXRoIDEgYmVpbmcgdGhlIHRvcCBsZWZ0LCAyIGJlaW5nIHRoZSB0b3AgcmlnaHQsIGFuZCBzbyBvbi5cbiAgICAgKiBUaGUgbWlkZGxlIGd1aWRlcyBhcmUgbnVtYmVyZWQgNS04LCB3aXRoIDUgYmVpbmcgdGhlIHRvcCBtaWRkbGUsIDYgYmVpbmcgdGhlIHJpZ2h0IG1pZGRsZSwgYW5kIHNvIG9uLlxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBndWlkZUNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgbGV0IHhkaWYgPSBteCAtIHg7XG4gICAgICAgIGxldCB5ZGlmID0gbXkgLSB5O1xuICAgICAgICAvKiBDb3JuZXIgR3VpZGVzICovXG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgfVxuICAgICAgICAvKiBNaWRkbGUgR3VpZGVzICovXG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICB5ZGlmID0gbXkgLSB5O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIG1pZGRsZVxuICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9taWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiA2O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGgpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgcmV0dXJuIDc7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9taWRkbGUgbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBib3VuZGluZyByZWN0YW5nbGUgYW5kIGd1aWRlcyBmb3IgdGhlIG9iamVjdCB3aGVuIHRoZSBvYmplY3QgaXMgc2VsZWN0ZWRcbiAgICAgKiBJZiBvbmUgb2YgdGhlIGd1aWRlcyBpcyBzZWxlY3RlZCwgaXQgY29sb3JzIHRoYXQgZ3VpZGUgYmx1ZVxuICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB5IHRoZSB5IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB3IHRoZSB3aWR0aCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggdGhlIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvcm5lciB0aGUgbnVtYmVyIG9mIHRoZSBjb3JuZXIgdG8gYmUgY29sb3JlZCBibHVlIChpZiBhbnkgYXQgYWxsLCBpZiAwLCBhbGwgYXJlIHdoaXRlKVxuICAgICAqL1xuICAgIGRyYXdHdWlkZXMoeCwgeSwgdywgaCwgY29ybmVyKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAoY29ybmVyICE9PSAwICYmIGNvcm5lciA8PSA0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgY29yZXBoIGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29ybmVyICE9PSAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgY29yZXBoIGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgbWV0aG9kIHRoYXQgZHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geCB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5IHkgY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHcgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIGNvbG9yIG9mIHRoZSByZWN0YW5nbGUncyBmaWxsXG4gICAgICovXG4gICAgZHJhd1NxdWFyZSh4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgd2l0aGluIHRoZSBjYW52YXMuXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24sIGNhbGxzIHRoZSBtb2RpZnkgbWV0aG9kcyBpZiB0aGUgYm9vbGVhbnMgc2F0aXNmeSB0aGVtLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRNb3VzZVBvc2l0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5RHJhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemUodGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0NoYW5naW5nRGltcyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXModGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIGNsaWNrcyBpbnNpZGUgdGhlIGNhbnZhcy5cbiAgICAgKiBNb2RpZmllcyB0aGUgc3RhdGUgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGd1aWRlcyBjb250YWluIHRoZSBtb3VzZSBvciB0aGUgYm91bmRpbmcgcmVjdCBjb250YWlucyB0aGUgbW91c2UuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVN0YXRlKHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSwgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgdW5jbGlja3MuXG4gICAgICogQ2FsbHMgbW9kaWZ5UmVzZXQgdG8gcmVzZXQgZHJhZ2dpbmcgYW5kIHJlc2l6aW5nIGJvb2xlYW5zIGFtb25nIG90aGVycy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNldXAgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlSZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcHJlc3NlZCBkb3duXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcHJlc3NlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdERvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdFVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBNb2RpZmljYXRpb24gZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGRyYWcgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBtb2RpZnlEcmFnKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiZXBoYW5nbGUgZHJhZ29mZng6IFwiICsgdGhpcy5fZHJhZ29mZngpO1xuICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS54IC0gdGhpcy5fZHJhZ29mZng7XG4gICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLl9kcmFnb2ZmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkICh3aGVuIGEgY29ybmVyIGd1aWRlIGlzIGNsaWNrZWQgYW5kIGRyYWdnZWQpLlxuICAgICAqXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMCBhbmQgdGhlIG90aGVyIGVxdWFsIHRvXG4gICAgICogMTAgZGl2aWRlZCBvciBtdWx0aXBsaWVkIGJ5IHRoZSByYXRpbyBvZiB3aWR0aC9oZWlnaHQgdG8ga2VlcCBpdCB0aGUgc2FtZS5cbiAgICAgKlxuICAgICAqIFRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIGlzIGRvbmUgYnkgY2FsbGluZyB0aGUgaGVscGVyIG1ldGhvZCBtb2RpZnlSZXNpemVIZWxwZXIuXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9lcGgud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMCAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fZXBoLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDEwIC8gdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2VwaC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwICogdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9lcGgud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyAxLCAyLCBvciA0IGFyZSBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0Rpc3RhbmNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBtb3VzZSBhbmQgdGhlIGxvY2F0aW9uIG9wcG9zaXRlIHRvIGl0XG4gICAgICogKGlmIHRvcCByaWdodCBndWlkZSBpcyBjbGlja2VkLCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGFuZCB0aGUgYm90dG9tIGxlZnQgZ3VpZGUgaXMgbmV3RGlzdGFuY2UpXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgdGhpcy5fZXBoLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgdGhpcy5fZXBoLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkLlxuICAgICAqIElmIGFueSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgdG9vIHNtYWxsLCBpdCBzZXRzIHRoZW0gZXF1YWwgdG8gMTAuXG4gICAgICogQ2FsbHMgbW9kaWZ5Q2hhbmdlRGltc0hlbHBlciB0byBhY3R1YWxseSBkbyB0aGUgd29ya1xuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqL1xuICAgIG1vZGlmeUNoYW5nZURpbXMod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgaWYgKHdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2VwaC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fZXBoLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGUgcmVjdGFuZ2xlIG9yaWdpbmF0ZXMgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIGFuZCBub3QgdGhlIGNlbnRlcixcbiAgICAgKiBpdCBjaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFzIHdlbGwgaWYgZ3VpZGVzIDUgb3IgOCBhcmUgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VwaC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VwaC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VwaC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53ID4gMTAgJiYgdGhpcy5oID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VwaC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIGRlcGVuZGluZyBvbiB0aGUgbW91c2UgcG9zaXRpb24gd2hlbiBjYWxsZWQgKG9uTW91c2VEb3duKVxuICAgICAqIGUuZy4gaWYgdGhlIG1vdXNlIGlzIHdpdGhpbiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIHdoZW4gdGhpcyBpcyBjYWxsZWQsIGlzU2VsZWN0ZWQgPSB0cnVlXG4gICAgICogQHBhcmFtIGd1aWRlQ29udGFpbnNcbiAgICAgKiBAcGFyYW0gY29udGFpbnNcbiAgICAgKi9cbiAgICBtb2RpZnlTdGF0ZShndWlkZUNvbnRhaW5zLCBjb250YWlucykge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kxID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gMCAmJiBndWlkZUNvbnRhaW5zIDw9IDQpIHsgLy9yZXNpemluZ1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gdGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0MSA9IHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoMSA9IHRoaXMudztcbiAgICAgICAgICAgIC8vdGhpcy5fc2l6ZTEgPSBNYXRoLnNxcnQoTWF0aC5wb3codywyKSArIE1hdGgucG93KGgsMikpOyAvLyBzaXplIGlzIGRpYWdvbmFsIGxlbmd0aFxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5ICsgaCAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiA0KSB7IC8vY2hhbmdpbmcgc2hhcGUgZGltZW5zaW9uc1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSBndWlkZUNvbnRhaW5zO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5ICsgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgdGhpcy5feDEgPSB4OyAvLyBTYXZpbmcgb3JpZ2luYWwgeCBhbmQgeVxuICAgICAgICAgICAgdGhpcy5feTEgPSB5O1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIHRvIGZhbHNlIChsaWtlIGRyYWdnaW5nLCByZXNpemluZywgZXRjKSB3aGVuIHRoZSBtb3VzZSBpcyByZWxlYXNlZFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB0aGlzLngpID4gMSB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHRoaXMueSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh0aGlzLl9pc1Jlc2l6aW5nIHx8IHRoaXMuX2lzQ2hhbmdpbmdEaW1zKSAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc2l6ZTIgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53LCAyKSArIE1hdGgucG93KHRoaXMuaCwgMikpO1xuICAgICAgICAgICAgaWYgKChNYXRoLmFicyh0aGlzLl93aWR0aDEgLSB0aGlzLncpID4gMCkgfHwgKE1hdGguYWJzKHRoaXMuX2hlaWdodDEgLSB0aGlzLmgpID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dSZXNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKi9cbiAgICBnZXRNb3VzZVBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLl9tb3VzZS54ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueDtcbiAgICAgICAgdGhpcy5fbW91c2UueSA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNDaGFuZ2luZ0RpbXMsIGFuZCBpc1NlbGVjdGVkIHRvIGZhbHNlIGlmIHRoZSBtb3VzZSBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBpc01vdXNlT3V0c2lkZShldmVudCkge1xuICAgICAgICBsZXQgbW91c2VYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgbGV0IG1vdXNlWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIGxldCBlcGggPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtb3VzZVggPCBlcGgubGVmdCB8fCBtb3VzZVggPiBlcGgucmlnaHQgfHwgbW91c2VZIDwgZXBoLnRvcCB8fCBtb3VzZVkgPiBlcGguYm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYW4gZXBoIHBhaW50IGV2ZW50XG4gICAgICovXG4gICAgbG9nUGFpbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpbnRFdmVudF8xLlBhaW50RXZlbnQoXCJlcGhcIiwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGFuIGVwaCByZXNpemUgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dSZXNpemUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplRXZlbnRfMS5SZXNpemVFdmVudChcImVwaCB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIE1hdGgucm91bmQodGhpcy5fd2lkdGgxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLl9oZWlnaHQxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLncgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuaCAqIDEwMCkgLyAxMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGFuIGVwaCBjbGljayBldmVudFxuICAgICAqL1xuICAgIGxvZ0NsaWNrKCkge1xuICAgICAgICByZXR1cm4gbmV3IENsaWNrRXZlbnRfMS5DbGlja0V2ZW50KFwiZXBoIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgYXNzaWducyBhbiBJRCB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgaW5pdElEKGlkKSB7XG4gICAgICAgIHRoaXMuaWRPYmogPSB7IF9pZDogaWQgfTtcbiAgICB9XG4gICAgYXN0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIHVwZGF0ZUFTVCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBlcGhcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgZXBoXG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBlcGhcbiAgICAgKi9cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgZXBoXG4gICAgICovXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRGltZW5zaW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgZGltcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVwaCBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGltYWdlXG4gICAgICovXG4gICAgZ2V0IGltYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXBoSW1nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgZXBoXG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkT2JqLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZXBoIGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqL1xuICAgIGdldEp1c3REcmFnZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fanVzdERyYWdnZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIGVwaCBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldEp1c3REcmFnZ2VkKHZhbCkge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZXBoIGlzIGRyYWdnaW5nXG4gICAgICovXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIHNlbGVjdGlvbiBldmVudHNcbiAgICAgKi9cbiAgICB0b1NlbFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiIGVwaCB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIGRyYWcgZXZlbnRzXG4gICAgKi9cbiAgICB0b0RyYWdTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoXCJlcGggd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgZnJvbSBcIiArIHRoaXMuX3gxICsgXCIsIFwiICsgdGhpcy5feTEgKyBcIiB0byBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgSUQgYXNzaWdubWVudCBldmVudHNcbiAgICAgKi9cbiAgICB0b0lEU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaWRPYmouX2lkLnRvU3RyaW5nKCkgKyBcIiB0byBlcGggYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXBoRWZmZWN0ID0gRXBoRWZmZWN0O1xuLyoqXG4gKiBHZXRzIHRoZSBtb3VzZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGluIHJlbGF0aW9uIHRvIHRoZSBjYW52YXNcbiAqIEBwYXJhbSBjYW52YXMgdGhlIGNhbnZhcyBvYmplY3RcbiAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGdldE1vdXNlUG9zKGNhbnZhcywgZXZlbnQpIHtcbiAgICBsZXQgZXBoID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSBlcGgubGVmdCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIGVwaC50b3BcbiAgICB9O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0geDEgeCBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geTEgeSBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geDIgeCBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICogQHBhcmFtIHkyIHkgY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDIsIDIpICsgTWF0aC5wb3coeTEgLSB5MiwgMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXBoRWZmZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBQYWludEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9QYWludEV2ZW50XCIpO1xuY29uc3QgUmVzaXplRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1Jlc2l6ZUV2ZW50XCIpO1xuY29uc3QgQ2xpY2tFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvQ2xpY2tFdmVudFwiKTtcbmNsYXNzIExpbmVFZmZlY3Qge1xuICAgIGNvbnN0cnVjdG9yKGxpbmUpIHtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBwcml2YXRlIGJvb2xzXG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JhdGlvID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnggPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IDA7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX21vdXNlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbGluZSA9IGxpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiBldmFsdWF0aW5nIG5vZGVzIChTdHJpbmdOb2RlLCBFbGxpcHNlTm9kZSwgZXRjKVxuICAgICAqIFRoaXMgbWV0aG9kIGFzc2lnbnMgYWxsIHBhcmFtcyB0byBwcml2YXRlIHZhcmlhYmxlcyBhbmQgZHJhd3MgdGhlIGluaXRpYWwgb2JqZWN0IHRvIHRoZSBjYW52YXNcbiAgICAgKiBieSBjYWxsaW5nIHVwZGF0ZSgpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIHBhcmVudCBTY29wZSB0aGF0IGNvbnRhaW5zIHRoZSBjYW52YXMgYW1vbmcgb3RoZXIgdGhpbmdzXG4gICAgICogQHBhcmFtIGRpbXMgVGhlIG9iamVjdCdzIGRpbWVuc2lvbnMgaW5jbHVkaW5nIHggYW5kIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gYXN0IFVubmVjZXNzYXJ5IG5vdywgdXNlZCB0byBiZSB0aGUgcGFyZW50IEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNhbnZhcy5pc0RlZmluZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZGltcyA9IGRpbXM7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBjb250ZXh0LmNhbnZhcy5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgbGV0IGN0eCA9IGNvbnRleHQuY2FudmFzLmdldCgpLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dQYWludCgpKTtcbiAgICAgICAgY29udGV4dC5lZmZlY3RzLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGluIG9yZGVyIHRvIGRyYXcgYW5kIHJlZHJhdyB0aGUgb2JqZWN0IHdoZW4gbWFuaXB1bGF0aW9ucyBhcmUgbWFkZVxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnc7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmg7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgdGhpcy5fY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSBcIiM2NzNBQjdcIjtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3R3VpZGVzKHgsIHksIHdpZHRoLCBoZWlnaHQsIHRoaXMuX2Nvcm5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gb25lIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7IC8vIGJpbmQgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIG1lYW5pbmcgb2YgJ3RoaXMnXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25TaGlmdERvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25TaGlmdFVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy9tYWtlcyBpdCBzbyB0aGF0IGRvdWJsZSBjbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0ZXh0IG9uIHRoZSBwYWdlXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uIChlKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGZhbHNlOyB9LCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIGFub3RoZXIgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvZiB0aGUgb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgY29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAobXggPiB4ICYmIG14IDwgeCArIHcgJiYgbXkgPiB5ICYmIG15IDwgeSArIGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciA+IDAgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvbmUgb2YgdGhlIGNvcm5lci9zaWRlIGd1aWRlcywgcmV0dXJucyAwIGlmIG5vdFxuICAgICAqIFRoZSBjb3JuZXIgZ3VpZGVzIGFyZSBudW1iZXJlZCAxLTQgd2l0aCAxIGJlaW5nIHRoZSB0b3AgbGVmdCwgMiBiZWluZyB0aGUgdG9wIHJpZ2h0LCBhbmQgc28gb24uXG4gICAgICogVGhlIG1pZGRsZSBndWlkZXMgYXJlIG51bWJlcmVkIDUtOCwgd2l0aCA1IGJlaW5nIHRoZSB0b3AgbWlkZGxlLCA2IGJlaW5nIHRoZSByaWdodCBtaWRkbGUsIGFuZCBzbyBvbi5cbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ3VpZGVDb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGxldCB4ZGlmID0gbXggLSB4O1xuICAgICAgICBsZXQgeWRpZiA9IG15IC0geTtcbiAgICAgICAgLyogQ29ybmVyIEd1aWRlcyAqL1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIGxlZnRcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogTWlkZGxlIEd1aWRlcyAqL1xuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0geTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGFuZCBndWlkZXMgZm9yIHRoZSBvYmplY3Qgd2hlbiB0aGUgb2JqZWN0IGlzIHNlbGVjdGVkXG4gICAgICogSWYgb25lIG9mIHRoZSBndWlkZXMgaXMgc2VsZWN0ZWQsIGl0IGNvbG9ycyB0aGF0IGd1aWRlIGJsdWVcbiAgICAgKiBAcGFyYW0geCB0aGUgeCBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0geSB0aGUgeSBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb3JuZXIgdGhlIG51bWJlciBvZiB0aGUgY29ybmVyIHRvIGJlIGNvbG9yZWQgYmx1ZSAoaWYgYW55IGF0IGFsbCwgaWYgMCwgYWxsIGFyZSB3aGl0ZSlcbiAgICAgKi9cbiAgICBkcmF3R3VpZGVzKHgsIHksIHcsIGgsIGNvcm5lcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKGNvcm5lciAhPT0gMCAmJiBjb3JuZXIgPD0gNCkgeyAvLyBhIGNvcm5lciBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcnJlY3QgZ3VpZGUgYmx1ZVxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3JuZXIgIT09IDApIHsgLy8gYSBtaWRkbGUgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vaWYgbm8gZ3VpZGVzIGFyZSBzZWxlY3RlZCwgY29sb3JzIGV2ZXJ5dGhpbmcgd2hpdGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBtZXRob2QgdGhhdCBkcmF3cyBhIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB4IHggY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHkgeSBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gdyB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29sb3IgY29sb3Igb2YgdGhlIHJlY3RhbmdsZSdzIGZpbGxcbiAgICAgKi9cbiAgICBkcmF3U3F1YXJlKHgsIHksIHcsIGgsIGNvbG9yKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBtb3ZlcyB3aXRoaW4gdGhlIGNhbnZhcy5cbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiwgY2FsbHMgdGhlIG1vZGlmeSBtZXRob2RzIGlmIHRoZSBib29sZWFucyBzYXRpc2Z5IHRoZW0uXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICB0aGlzLmdldE1vdXNlUG9zaXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlEcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZXNpemluZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZSh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQ2hhbmdpbmdEaW1zICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltcyh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5U3RhdGUodGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpLCB0aGlzLmNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSB1bmNsaWNrcy5cbiAgICAgKiBDYWxscyBtb2RpZnlSZXNldCB0byByZXNldCBkcmFnZ2luZyBhbmQgcmVzaXppbmcgYm9vbGVhbnMgYW1vbmcgb3RoZXJzLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2V1cCBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VVcChldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyBwcmVzc2VkIGRvd25cbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSBwcmVzc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcmVsZWFzZWRcbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSByZWxlYXNlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdFVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBNb2RpZmljYXRpb24gZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGRyYWcgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBtb2RpZnlEcmFnKCkge1xuICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS54IC0gdGhpcy5fZHJhZ29mZng7XG4gICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLl9kcmFnb2ZmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkICh3aGVuIGEgY29ybmVyIGd1aWRlIGlzIGNsaWNrZWQgYW5kIGRyYWdnZWQpLlxuICAgICAqXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMCBhbmQgdGhlIG90aGVyIGVxdWFsIHRvXG4gICAgICogMTAgZGl2aWRlZCBvciBtdWx0aXBsaWVkIGJ5IHRoZSByYXRpbyBvZiB3aWR0aC9oZWlnaHQgdG8ga2VlcCBpdCB0aGUgc2FtZS5cbiAgICAgKlxuICAgICAqIFRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIGlzIGRvbmUgYnkgY2FsbGluZyB0aGUgaGVscGVyIG1ldGhvZCBtb2RpZnlSZXNpemVIZWxwZXIuXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9saW5lLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTsgLy8gc2V0IGZvciB0aGUgcHJvZGlyZWN0IG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMCAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fbGluZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDEwIC8gdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApOyAvLyBzZXQgZm9yIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgKiB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2xpbmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyAxLCAyLCBvciA0IGFyZSBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0Rpc3RhbmNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBtb3VzZSBhbmQgdGhlIGxvY2F0aW9uIG9wcG9zaXRlIHRvIGl0XG4gICAgICogKGlmIHRvcCByaWdodCBndWlkZSBpcyBjbGlja2VkLCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGFuZCB0aGUgYm90dG9tIGxlZnQgZ3VpZGUgaXMgbmV3RGlzdGFuY2UpXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgdGhpcy5fbGluZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW87XG4gICAgICAgIHRoaXMuX2xpbmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZC5cbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDEwLlxuICAgICAqIENhbGxzIG1vZGlmeUNoYW5nZURpbXNIZWxwZXIgdG8gYWN0dWFsbHkgZG8gdGhlIHdvcmtcbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9saW5lLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9saW5lLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIHRoZSByZWN0YW5nbGUgb3JpZ2luYXRlcyBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgYW5kIG5vdCB0aGUgY2VudGVyLFxuICAgICAqIGl0IGNoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXMgd2VsbCBpZiBndWlkZXMgNSBvciA4IGFyZSBzZWxlY3RlZFxuICAgICAqL1xuICAgIG1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKSB7XG4gICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaCA+IDEwKSB7IC8vYXMgbG9uZyBhcyB0aGUgaGVpZ2h0IGlzID4gMTBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLncgPiAxMCkgeyAvLyBhcyBsb25nIGFzIHdpZHRoIGlzID4gMTBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyBkZXBlbmRpbmcgb24gdGhlIG1vdXNlIHBvc2l0aW9uIHdoZW4gY2FsbGVkIChvbk1vdXNlRG93bilcbiAgICAgKiBlLmcuIGlmIHRoZSBtb3VzZSBpcyB3aXRoaW4gdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSB3aGVuIHRoaXMgaXMgY2FsbGVkLCBpc1NlbGVjdGVkID0gdHJ1ZVxuICAgICAqIEBwYXJhbSBndWlkZUNvbnRhaW5zXG4gICAgICogQHBhcmFtIGNvbnRhaW5zXG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGUoZ3VpZGVDb250YWlucywgY29udGFpbnMpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7IC8vcHJlcGFyZXMgdGhlIG9iamVjdCBmb3IgZHJhZ2dpbmcgd2hldGhlciBpdCBpcyBwZXJzb25hbGx5IHNlbGVjdGVkIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5feTEgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiAwICYmIGd1aWRlQ29udGFpbnMgPD0gNCkgeyAvL3Jlc2l6aW5nXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSB0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSk7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQxID0gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy5fd2lkdGgxID0gdGhpcy53O1xuICAgICAgICAgICAgLy90aGlzLl9zaXplMSA9IE1hdGguc3FydChNYXRoLnBvdyh3LDIpICsgTWF0aC5wb3coaCwyKSk7IC8vIHNpemUgaXMgZGlhZ29uYWwgbGVuZ3RoXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikgeyAvLyBzZXRzIHRoZSBvZmZzZXRzIGRlcGVuZGluZyBvbiB3aGljaCBjb3JuZXIgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7IC8vIG9mZnNldCBpcyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7IC8vIG9mZnNldCBpcyBib3R0b20gbGVmdCwgZXRjXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gNCkgeyAvL2NoYW5naW5nIHNoYXBlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gZ3VpZGVDb250YWlucztcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7IC8vIHNldHMgdGhlIG9mZnNldHMgZGVwZW5kaW5nIG9uIHdoaWNoIG1pZGRsZSBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgNTogLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdyAvIDIsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdyAvIDI7IC8vIG9mZnNldCBpcyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogLy9yaWdodCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoIC8gMjsgLy8gb2Zmc2V0IGlzIGxlZnQgbWlkZGxlIGV0Y1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWlucykgeyAvLyBkcmFnZ2luZ1xuICAgICAgICAgICAgdGhpcy5feDEgPSB4OyAvLyBTYXZpbmcgb3JpZ2luYWwgeCBhbmQgeVxuICAgICAgICAgICAgdGhpcy5feTEgPSB5O1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy8gbm90IHNlbGVjdGVkXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyB0byBmYWxzZSAobGlrZSBkcmFnZ2luZywgcmVzaXppbmcsIGV0Yykgd2hlbiB0aGUgbW91c2UgaXMgcmVsZWFzZWRcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0gdGhpcy54KSA+IDEgfHwgTWF0aC5hYnModGhpcy5feTEgLSB0aGlzLnkpID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodGhpcy5faXNSZXNpemluZyB8fCB0aGlzLl9pc0NoYW5naW5nRGltcykgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHNpemUyID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMudywgMikgKyBNYXRoLnBvdyh0aGlzLmgsIDIpKTtcbiAgICAgICAgICAgIGlmICgoTWF0aC5hYnModGhpcy5fd2lkdGgxIC0gdGhpcy53KSA+IDApIHx8IChNYXRoLmFicyh0aGlzLl9oZWlnaHQxIC0gdGhpcy5oKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUmVzaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICovXG4gICAgZ2V0TW91c2VQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbW91c2UueCA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLng7XG4gICAgICAgIHRoaXMuX21vdXNlLnkgPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzQ2hhbmdpbmdEaW1zLCBhbmQgaXNTZWxlY3RlZCB0byBmYWxzZSBpZiB0aGUgbW91c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgaXNNb3VzZU91dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1vdXNlWCA8IHJlY3QubGVmdCB8fCBtb3VzZVggPiByZWN0LnJpZ2h0IHx8IG1vdXNlWSA8IHJlY3QudG9wIHx8IG1vdXNlWSA+IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIHBhaW50IGV2ZW50XG4gICAgICovXG4gICAgbG9nUGFpbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpbnRFdmVudF8xLlBhaW50RXZlbnQoXCJyZWN0YW5nbGVcIiwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIHJlc2l6ZSBldmVudFxuICAgICAqL1xuICAgIGxvZ1Jlc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVFdmVudF8xLlJlc2l6ZUV2ZW50KFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgTWF0aC5yb3VuZCh0aGlzLl93aWR0aDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuX2hlaWdodDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMudyAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5oICogMTAwKSAvIDEwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZWN0YW5nbGUgY2xpY2sgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dDbGljaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGlja0V2ZW50XzEuQ2xpY2tFdmVudChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIGFzc2lnbnMgYW4gSUQgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIGlkIFRoZSBJRCB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIGluaXRJRChpZCkge1xuICAgICAgICB0aGlzLmlkT2JqID0geyBfaWQ6IGlkIH07XG4gICAgfVxuICAgIGFzdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHggcG9zaXRpb24gb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRGltZW5zaW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgZGltcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZE9iai5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICovXG4gICAgZ2V0SnVzdERyYWdnZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdXN0RHJhZ2dlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldEp1c3REcmFnZ2VkKHZhbCkge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBpcyBkcmFnZ2luZ1xuICAgICAqL1xuICAgIGdldCBpc0RyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEcmFnZ2luZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBzZWxlY3Rpb24gZXZlbnRzXG4gICAgICovXG4gICAgdG9TZWxTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIiByZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBkcmFnIGV2ZW50c1xuICAgICovXG4gICAgdG9EcmFnU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94MSArIFwiLCBcIiArIHRoaXMuX3kxICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gcmVjdGFuZ2xlIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG59XG5leHBvcnRzLkxpbmVFZmZlY3QgPSBMaW5lRWZmZWN0O1xuLyoqXG4gKiBHZXRzIHRoZSBtb3VzZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGluIHJlbGF0aW9uIHRvIHRoZSBjYW52YXNcbiAqIEBwYXJhbSBjYW52YXMgdGhlIGNhbnZhcyBvYmplY3RcbiAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGdldE1vdXNlUG9zKGNhbnZhcywgZXZlbnQpIHtcbiAgICBsZXQgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0LFxuICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gcmVjdC50b3BcbiAgICB9O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0geDEgeCBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geTEgeSBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geDIgeCBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICogQHBhcmFtIHkyIHkgY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDIsIDIpICsgTWF0aC5wb3coeTEgLSB5MiwgMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGluZUVmZmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBhaW50RXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1BhaW50RXZlbnRcIik7XG5jb25zdCBSZXNpemVFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUmVzaXplRXZlbnRcIik7XG5jb25zdCBDbGlja0V2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9DbGlja0V2ZW50XCIpO1xuY2xhc3MgTnVtYmVyRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihudW0pIHtcbiAgICAgICAgdGhpcy5fZm9udFNpemUgPSAyMDtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzTGlzdGVuaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSAwO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9tb3VzZSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MgPSB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGludGVydmFsOiAwLFxuICAgICAgICAgICAgc3RyOiBcIlwiLFxuICAgICAgICAgICAgaW5pdE1vdXNlUG9zOiAwLFxuICAgICAgICAgICAgY3Vyc29yUG9zOiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX251bSA9IG51bTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIGV2YWx1YXRpbmcgbm9kZXMgKFN0cmluZ05vZGUsIEVsbGlwc2VOb2RlLCBldGMpXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyBhbGwgcGFyYW1zIHRvIHByaXZhdGUgdmFyaWFibGVzIGFuZCBkcmF3cyB0aGUgaW5pdGlhbCBvYmplY3QgdG8gdGhlIGNhbnZhc1xuICAgICAqIGJ5IGNhbGxpbmcgdXBkYXRlKClcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgcGFyZW50IFNjb3BlIHRoYXQgY29udGFpbnMgdGhlIGNhbnZhcyBhbW9uZyBvdGhlciB0aGluZ3NcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgb2JqZWN0J3MgZGltZW5zaW9ucyBpbmNsdWRpbmcgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBhc3QgVW5uZWNlc3Nhcnkgbm93LCB1c2VkIHRvIGJlIHRoZSBwYXJlbnQgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY2FudmFzICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBjb250ZXh0LmNhbnZhcy5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMgPSBkaW1zO1xuICAgICAgICAgICAgbGV0IGN0eCA9IGNvbnRleHQuY2FudmFzLmdldCgpLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAvLyBsb2dnaW5nXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dQYWludCgpKTsgLy8gdGhpcy5jb250ZXh0IG9yIGNvbnRleHQ/XG4gICAgICAgICAgICBjb250ZXh0LmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2FudmFzIGlzIE5PVCBkZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBpbiBvcmRlciB0byBkcmF3IGFuZCByZWRyYXcgdGhlIG9iamVjdCB3aGVuIG1hbmlwdWxhdGlvbnMgYXJlIG1hZGVcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCBmb250RGVldHMgPSB0aGlzLl9mb250U2l6ZSArIFwicHggQ291cmllciBOZXdcIjtcbiAgICAgICAgdGhpcy5fY3R4LmZvbnQgPSBmb250RGVldHM7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBcIiM2NzNBQjdcIjtcbiAgICAgICAgbGV0IHN0ciA9IHRoaXMuX251bS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFRleHQoc3RyLCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIGxldCBudW1iZXJEaW1zID0gdGhpcy5fY3R4Lm1lYXN1cmVUZXh0KHN0cik7XG4gICAgICAgIHRoaXMuX251bWJlck1ldHJpY3Mud2lkdGggPSBudW1iZXJEaW1zLndpZHRoO1xuICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmhlaWdodCA9IHRoaXMuX2ZvbnRTaXplO1xuICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLnN0ciA9IHN0cjtcbiAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5pbnRlcnZhbCA9IHRoaXMuX251bWJlck1ldHJpY3Mud2lkdGggLyB0aGlzLl9udW1iZXJNZXRyaWNzLnN0ci5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdUZXh0R3VpZGVzKHRoaXMueCwgdGhpcy55IC0gdGhpcy5fZm9udFNpemUsIHRoaXMuX251bWJlck1ldHJpY3Mud2lkdGgsIHRoaXMuX251bWJlck1ldHJpY3MuaGVpZ2h0LCB0aGlzLl9jb3JuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIG9uZSBmZWxsIHN3b29wXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpOyAvLyBiaW5kIGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBtZWFuaW5nIG9mICd0aGlzJ1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uU2hpZnREb3duLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uU2hpZnRVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaXNNb3VzZU91dHNpZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vbWFrZXMgaXQgc28gdGhhdCBkb3VibGUgY2xpY2tpbmcgZG9lc24ndCBzZWxlY3QgdGV4dCBvbiB0aGUgcGFnZVxuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBmdW5jdGlvbiAoZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IHJldHVybiBmYWxzZTsgfSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBhbm90aGVyIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb2YgdGhlIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSwgZmFsc2UgaWYgb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICByZXR1cm4gKHRoaXMueCA8PSBteCkgJiYgKHRoaXMueCArIHRoaXMuX251bWJlck1ldHJpY3Mud2lkdGggPj0gbXgpICYmXG4gICAgICAgICAgICAodGhpcy55IC0gdGhpcy5fZm9udFNpemUgPD0gbXkpICYmICh0aGlzLnkgPj0gbXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbnVtYmVyID4gMCBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9uZSBvZiB0aGUgY29ybmVyL3NpZGUgZ3VpZGVzLCByZXR1cm5zIDAgaWYgbm90XG4gICAgICogVGhlIGNvcm5lciBndWlkZXMgYXJlIG51bWJlcmVkIDEtNCB3aXRoIDEgYmVpbmcgdGhlIHRvcCBsZWZ0LCAyIGJlaW5nIHRoZSB0b3AgcmlnaHQsIGFuZCBzbyBvbi5cbiAgICAgKiBUaGUgbWlkZGxlIGd1aWRlcyBhcmUgbnVtYmVyZWQgNS04LCB3aXRoIDUgYmVpbmcgdGhlIHRvcCBtaWRkbGUsIDYgYmVpbmcgdGhlIHJpZ2h0IG1pZGRsZSwgYW5kIHNvIG9uLlxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBndWlkZUNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeGRpZiA9IG14IC0gKHRoaXMueCArIHRoaXMuX251bWJlck1ldHJpY3Mud2lkdGgpO1xuICAgICAgICBsZXQgeWRpZiA9IG15IC0gKHRoaXMueSAtIHRoaXMuX2ZvbnRTaXplKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkge1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBhbmQgZ3VpZGVzIGZvciB0aGUgb2JqZWN0IHdoZW4gdGhlIG9iamVjdCBpcyBzZWxlY3RlZFxuICAgICAqIElmIG9uZSBvZiB0aGUgZ3VpZGVzIGlzIHNlbGVjdGVkLCBpdCBjb2xvcnMgdGhhdCBndWlkZSBibHVlXG4gICAgICogQHBhcmFtIHggdGhlIHggY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHkgdGhlIHkgY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHcgdGhlIHdpZHRoIG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29ybmVyIHRoZSBudW1iZXIgb2YgdGhlIGNvcm5lciB0byBiZSBjb2xvcmVkIGJsdWUgKGlmIGFueSBhdCBhbGwsIGlmIDAsIGFsbCBhcmUgd2hpdGUpXG4gICAgICovXG4gICAgZHJhd1RleHRHdWlkZXMoeCwgeSwgdywgaCwgY29ybmVyKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAoY29ybmVyICE9PSAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgZ3VpZGUgYmx1ZSBpZiBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltcGxlIG1ldGhvZCB0aGF0IGRyYXdzIGEgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHggeCBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geSB5IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB3IHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb2xvciBjb2xvciBvZiB0aGUgcmVjdGFuZ2xlJ3MgZmlsbFxuICAgICAqL1xuICAgIGRyYXdTcXVhcmUoeCwgeSwgdywgaCwgY29sb3IpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvKiBFdmVudCBsaXN0ZW5lciBmdW5jdGlvbnMgKi9cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIHdpdGhpbiB0aGUgY2FudmFzLlxuICAgICAqIEdldHMgdGhlIG1vdXNlIHBvc2l0aW9uLCBjYWxscyB0aGUgbW9kaWZ5IG1ldGhvZHMgaWYgdGhlIGJvb2xlYW5zIHNhdGlzZnkgdGhlbS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZ2V0TW91c2VQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCAmJiB0aGlzLl9pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeURyYWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jlc2l6aW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplKHRoaXMuX2ZvbnRTaXplIDwgMTUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSAmJiB0aGlzLl9pc1NlbGVjdGVkICYmIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpIHsgLy90ZXh0IGVkaXRpbmdcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMubW9kaWZ5VGV4dC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2lzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmluaXRNb3VzZVBvcyA9IHRoaXMuX21vdXNlLng7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGlmeVN0YXRlKHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSA+IDAsIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIHVuY2xpY2tzLlxuICAgICAqIENhbGxzIG1vZGlmeVJlc2V0IHRvIHJlc2V0IGRyYWdnaW5nIGFuZCByZXNpemluZyBib29sZWFucyBhbW9uZyBvdGhlcnMuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZXVwIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5UmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHByZXNzZWQgZG93blxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHByZXNzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnREb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyByZWxlYXNlZFxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHJlbGVhc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0VXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIE1vZGlmaWNhdGlvbiBmdW5jdGlvbnMgKi9cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgaW4gb3JkZXIgdG8gZHJhZyB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIG1vZGlmeURyYWcoKSB7XG4gICAgICAgIC8vKFwic3RyaW5nIGRyYWdvZmZ4OiBcIiArIHRoaXMuX2RyYWdvZmZ4KTtcbiAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueCAtIHRoaXMuX2RyYWdvZmZ4O1xuICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy5fZHJhZ29mZnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIG1vdmVzIHRoZSB0ZXh0IGVkaXQgY3Vyc29yIGJhc2VkIG9uIHdoZXJlIHRoZSBtb3VzZSBpcyBjbGlja2VkXG4gICAgICovXG4gICAgbW9kaWZ5VGV4dEN1cnNvcigpIHtcbiAgICAgICAgbGV0IGxlZnRXYWxsID0gdGhpcy54OyAvLyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgbGVmdCBtb3N0IHNpZGUgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAgICBsZXQgeERpZiA9IHRoaXMuX251bWJlck1ldHJpY3MuaW5pdE1vdXNlUG9zIC0gbGVmdFdhbGw7IC8vIGRpZmZlcmVuY2UgYmV0d2VlbiBtb3VzZSB4IGFuZCBsZWZ0IHdhbGxcbiAgICAgICAgbGV0IGludGVydmFsID0gdGhpcy5fbnVtYmVyTWV0cmljcy5pbnRlcnZhbDsgLy8gdGhlIHRleHQgd2lkdGggZGl2aWRlZCBieSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmdcbiAgICAgICAgbGV0IG1vdmVGYWN0b3IgPSAwO1xuICAgICAgICBpZiAoeERpZiA+PSBpbnRlcnZhbCAvIDIgJiYgeERpZiA8PSBpbnRlcnZhbCkge1xuICAgICAgICAgICAgbW92ZUZhY3RvciA9IGxlZnRXYWxsICsgaW50ZXJ2YWw7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmN1cnNvclBvcyA9IGludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHhEaWYgPD0gaW50ZXJ2YWwgLyAyKSB7XG4gICAgICAgICAgICBtb3ZlRmFjdG9yID0gbGVmdFdhbGw7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmN1cnNvclBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeERpZiAlIGludGVydmFsID49IGludGVydmFsIC8gMikge1xuICAgICAgICAgICAgbW92ZUZhY3RvciA9IGxlZnRXYWxsICsgaW50ZXJ2YWwgKiBNYXRoLmNlaWwoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuY3Vyc29yUG9zID0gaW50ZXJ2YWwgKiBNYXRoLmNlaWwoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4RGlmICUgaW50ZXJ2YWwgPCBpbnRlcnZhbCAvIDIpIHtcbiAgICAgICAgICAgIG1vdmVGYWN0b3IgPSBsZWZ0V2FsbCArIGludGVydmFsICogTWF0aC5mbG9vcih4RGlmIC8gaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5jdXJzb3JQb3MgPSBpbnRlcnZhbCAqIE1hdGguZmxvb3IoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdHgubW92ZVRvKG1vdmVGYWN0b3IsIHRoaXMueSAtIHRoaXMuX2ZvbnRTaXplKTtcbiAgICAgICAgdGhpcy5fY3R4LmxpbmVUbyhtb3ZlRmFjdG9yLCB0aGlzLnkpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSBcImdyZXlcIjtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGVkaXRzIHRoZSBzdHJpbmcgd2hlbiBlZGl0aW5nIHRleHRcbiAgICAgKiBAcGFyYW0gZXZlbnQga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG1vZGlmeVRleHQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRWRpdGluZykge1xuICAgICAgICAgICAgbGV0IGZpcnN0SGFsZjtcbiAgICAgICAgICAgIGxldCBzZWNvbmRIYWxmO1xuICAgICAgICAgICAgbGV0IHN0ciA9IHRoaXMuX251bS50b1N0cmluZygpO1xuICAgICAgICAgICAgbGV0IGJyZWFrUG9pbnQgPSB0aGlzLl9udW1iZXJNZXRyaWNzLmN1cnNvclBvcyAvIHRoaXMuX251bWJlck1ldHJpY3MuaW50ZXJ2YWw7XG4gICAgICAgICAgICBmaXJzdEhhbGYgPSBzdHIuc3Vic3RyaW5nKDAsIGJyZWFrUG9pbnQpO1xuICAgICAgICAgICAgc2Vjb25kSGFsZiA9IHN0ci5zdWJzdHJpbmcoYnJlYWtQb2ludCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNyAmJiB0aGlzLl9udW1iZXJNZXRyaWNzLmluaXRNb3VzZVBvcyA+IHRoaXMueCArIHRoaXMuX251bWJlck1ldHJpY3MuaW50ZXJ2YWwgLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5pbml0TW91c2VQb3MgLT0gdGhpcy5fbnVtYmVyTWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzkgJiYgdGhpcy5fbnVtYmVyTWV0cmljcy5pbml0TW91c2VQb3MgPCB0aGlzLnggKyB0aGlzLl9udW1iZXJNZXRyaWNzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5pbml0TW91c2VQb3MgKz0gdGhpcy5fbnVtYmVyTWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gOCAmJiBzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpcnN0SGFsZiA9IGZpcnN0SGFsZi5zdWJzdHJpbmcoMCwgZmlyc3RIYWxmLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIHN0ciA9IGZpcnN0SGFsZiArIHNlY29uZEhhbGY7XG4gICAgICAgICAgICAgICAgdGhpcy5fbnVtLnZhbCA9IE51bWJlcihzdHIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuaW5pdE1vdXNlUG9zIC09IHRoaXMuX251bWJlck1ldHJpY3MuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQga2V5TmFtZSA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5TmFtZS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEhhbGYgKz0ga2V5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gZmlyc3RIYWxmICsgc2Vjb25kSGFsZjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbnVtLnZhbCA9IE51bWJlcihzdHIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmluaXRNb3VzZVBvcyArPSB0aGlzLl9udW1iZXJNZXRyaWNzLmludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9kaWZpZXMgdGhlIGZvbnQgc2l6ZSBvZiB0aGUgdGV4dFxuICAgICAqIElmIHRoZSB0ZXh0IGZvbnQgaXMgc21hbGxlciB0aGFuIDE1cHQsIGl0IHNldCdzIGl0IGVxdWFsIHRvIDE1cHRcbiAgICAgKiBAcGFyYW0gaXNUb29TbWFsbCB0cnVlIGlmIHRoZSBmb250IHNpemUgaXMgPCAxNVxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZShpc1Rvb1NtYWxsKSB7XG4gICAgICAgIGlmIChpc1Rvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9mb250U2l6ZSA9IDE1O1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250U2l6ZSArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMC4yO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAwLjI7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyBkZXBlbmRpbmcgb24gdGhlIG1vdXNlIHBvc2l0aW9uIHdoZW4gY2FsbGVkIChvbk1vdXNlRG93bilcbiAgICAgKiBlLmcuIGlmIHRoZSBtb3VzZSBpcyB3aXRoaW4gdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSB3aGVuIHRoaXMgaXMgY2FsbGVkLCBpc1NlbGVjdGVkID0gdHJ1ZVxuICAgICAqIEBwYXJhbSBndWlkZUNvbnRhaW5zXG4gICAgICogQHBhcmFtIGNvbnRhaW5zXG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGUoZ3VpZGVDb250YWlucywgY29udGFpbnMpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy9wcmVwYXJlcyB0aGUgb2JqZWN0IGZvciBkcmFnZ2luZyB3aGV0aGVyIGl0IGlzIHBlcnNvbmFsbHkgc2VsZWN0ZWQgb3Igbm90XG4gICAgICAgICAgICBpZiAoY29udGFpbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZih0aGlzLl9jb250ZXh0Lm11bFNlbGVjdGVkLm11bFNlbCl7XG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJzdHJpbmcgZWZmZWN0IG11bFNlbGVjdGVkOiBcIiArIHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQubXVsU2VsKTtcbiAgICAgICAgICAgIC8vICAgICAvL2lmKHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQudmFsKXtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dTZWxlY3RlZCgpKTtcbiAgICAgICAgICAgIC8vICAgICAvL3RoaXMubG9nU2VsZWN0ZWQoKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zKSB7IC8vaWYgdGhlIGNvcm5lciBndWlkZXMgY29udGFpbiB0aGUgbW91c2Ugd2UgYXJlIHJlc2l6aW5nXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLng7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMueTtcbiAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZTEgPSB0aGlzLl9mb250U2l6ZTsgLy8gc2F2aW5nIG9sZCBmb250IHNpemVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgdGhpcy5feCA9IHRoaXMueDsgLy8gU2F2aW5nIG9yaWdpbmFsIHggYW5kIHlcbiAgICAgICAgICAgIHRoaXMuX3kgPSB0aGlzLnk7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyB0byBmYWxzZSAobGlrZSBkcmFnZ2luZywgcmVzaXppbmcsIGV0Yykgd2hlbiB0aGUgbW91c2UgaXMgcmVsZWFzZWRcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3ggLSB0aGlzLngpID4gMSB8fCBNYXRoLmFicyh0aGlzLl95IC0gdGhpcy55KSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy90aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dNb3ZlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3NpemUxIC0gdGhpcy5fZm9udFNpemUpID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1Jlc2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJzdHJpbmcgZWZmZWN0IG11bFNlbGVjdGVkOiBcIiArIHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQudmFsKTtcbiAgICAgICAgLy8gaWYodGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC52YWwpe1xuICAgICAgICAvLyAgICAgdGhpcy5sb2dTZWxlY3RlZCgpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmKHRoaXMuaXNNdWx0aXBsZVNlbGVjdGVkKXtcbiAgICAgICAgLy8gICAgIGNvbnRleHQuZXZlbnRMb2cucHVzaChuZXcgU2VsZWN0RXZlbnQoc2VsZWN0ZWRFbGVtcykpO1xuICAgICAgICAvLyAgICAgbWFzdGVyTG9nLnB1c2goY29udGV4dC5ldmVudExvZ1tjb250ZXh0LmV2ZW50TG9nLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgLy8gICAgIC8vY29uc29sZS5sb2coXCJtdWx0aXBsZSBzZWxlY3RlZFwiKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyAvL3RoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ01vdmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKi9cbiAgICBnZXRNb3VzZVBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLl9tb3VzZS54ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueDtcbiAgICAgICAgdGhpcy5fbW91c2UueSA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNDaGFuZ2luZ0RpbXMsIGFuZCBpc1NlbGVjdGVkIHRvIGZhbHNlIGlmIHRoZSBtb3VzZSBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBpc01vdXNlT3V0c2lkZShldmVudCkge1xuICAgICAgICBsZXQgbW91c2VYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgbGV0IG1vdXNlWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5fY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobW91c2VYIDwgcmVjdC5sZWZ0IHx8IG1vdXNlWCA+IHJlY3QucmlnaHQgfHwgbW91c2VZIDwgcmVjdC50b3AgfHwgbW91c2VZID4gcmVjdC5ib3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcGFpbnQgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dQYWludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWludEV2ZW50XzEuUGFpbnRFdmVudCh0aGlzLl9udW0udG9TdHJpbmcoKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVzaXplIGV2ZW50XG4gICAgICovXG4gICAgbG9nUmVzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZUV2ZW50XzEuUmVzaXplRXZlbnQodGhpcy5fbnVtLnRvU3RyaW5nKCkgKyBcIiB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIE1hdGgucm91bmQodGhpcy5fc2l6ZTEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuX2ZvbnRTaXplICogMTAwKSAvIDEwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSBjbGljayBldmVudFxuICAgICAqL1xuICAgIGxvZ0NsaWNrKCkge1xuICAgICAgICByZXR1cm4gbmV3IENsaWNrRXZlbnRfMS5DbGlja0V2ZW50KHRoaXMuX251bS50b1N0cmluZygpICsgXCIgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCBhc3NpZ25zIGFuIElEIHRvIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSBpZCBUaGUgSUQgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBpbml0SUQoaWQpIHtcbiAgICAgICAgdGhpcy5pZE9iaiA9IHsgX2lkOiBpZCwgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2FudmFzXG4gICAgICovXG4gICAgZ2V0IGNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGNhbnZhcyBUaGUgY2FudmFzIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgc2V0IGNhbnZhcyhjYW52YXMpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgIH1cbiAgICBhc3QoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBudW1iZXJcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERpbWVuc2lvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVsbGlwc2UgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgKi9cbiAgICBnZXRKdXN0RHJhZ2dlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1c3REcmFnZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgc2V0SnVzdERyYWdnZWQodmFsKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGlzIGRyYWdnaW5nXG4gICAgICovXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXJcbiAgICAgKi9cbiAgICBnZXQgbnVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbnVtLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb2JqZWN0IElEXG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkT2JqLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBzZWxlY3Rpb24gZXZlbnRzXG4gICAgICovXG4gICAgdG9TZWxTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIiBcIiArIHRoaXMuX251bS50b1N0cmluZygpICsgXCIgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBkcmFnIGV2ZW50c1xuICAgICovXG4gICAgdG9EcmFnU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX251bS50b1N0cmluZygpICsgXCIgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgZnJvbSBcIiArIHRoaXMuX3ggKyBcIiwgXCIgKyB0aGlzLl95ICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gXCIgKyB0aGlzLl9udW0udG9TdHJpbmcoKSArIFwiIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG59XG5leHBvcnRzLk51bWJlckVmZmVjdCA9IE51bWJlckVmZmVjdDtcbi8qKlxuICogR2V0J3MgdGhlIG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZXMgaW4gcmVsYXRpb24gdG8gdGhlIGNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB0aGUgY2FudmFzIG9iamVjdFxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0TW91c2VQb3MoY2FudmFzLCBldmVudCkge1xuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB4MSB4IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB5MSB5IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB4MiB4IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKiBAcGFyYW0geTIgeSBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MiwgMikgKyBNYXRoLnBvdyh5MSAtIHkyLCAyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OdW1iZXJFZmZlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IFBhaW50RXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1BhaW50RXZlbnRcIik7XG5jb25zdCBSZXNpemVFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUmVzaXplRXZlbnRcIik7XG5jb25zdCBDbGlja0V2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9DbGlja0V2ZW50XCIpO1xuY2xhc3MgUmVjdGFuZ2xlRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihyZWN0KSB7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTsgLy8gcHJpdmF0ZSBib29sc1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yYXRpbyA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSAwO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9tb3VzZSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gZXZhbHVhdGluZyBub2RlcyAoU3RyaW5nTm9kZSwgRWxsaXBzZU5vZGUsIGV0YylcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3NpZ25zIGFsbCBwYXJhbXMgdG8gcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIGRyYXdzIHRoZSBpbml0aWFsIG9iamVjdCB0byB0aGUgY2FudmFzXG4gICAgICogYnkgY2FsbGluZyB1cGRhdGUoKVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBwYXJlbnQgU2NvcGUgdGhhdCBjb250YWlucyB0aGUgY2FudmFzIGFtb25nIG90aGVyIHRoaW5nc1xuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBvYmplY3QncyBkaW1lbnNpb25zIGluY2x1ZGluZyB4IGFuZCB5IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGFzdCBVbm5lY2Vzc2FyeSBub3csIHVzZWQgdG8gYmUgdGhlIHBhcmVudCBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBpZiAoY29udGV4dC5jYW52YXMuaXNEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMgPSBkaW1zO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gY29udGV4dC5jYW52YXMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0LmNhbnZhcy5nZXQoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUGFpbnQoKSk7XG4gICAgICAgIGNvbnRleHQuZWZmZWN0cy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBpbiBvcmRlciB0byBkcmF3IGFuZCByZWRyYXcgdGhlIG9iamVjdCB3aGVuIG1hbmlwdWxhdGlvbnMgYXJlIG1hZGVcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy53O1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5oO1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvL3RoaXMuX2N0eC5zdHJva2VTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgLy90aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBcIiNkNWI4ZmZcIjtcbiAgICAgICAgdGhpcy5fY3R4LnNoYWRvd0NvbG9yID0gXCIjNkM2QzZDXCI7XG4gICAgICAgIHRoaXMuX2N0eC5zaGFkb3dCbHVyID0gMTU7XG4gICAgICAgIC8vdGhpcy5fY3R4LnNoYWRvd09mZnNldFggPSAyO1xuICAgICAgICAvL3RoaXMuX2N0eC5zaGFkb3dPZmZzZXRZID0gMjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGwoKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0d1aWRlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0aGlzLl9jb3JuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIG9uZSBmZWxsIHN3b29wXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpOyAvLyBiaW5kIGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBtZWFuaW5nIG9mICd0aGlzJ1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uU2hpZnREb3duLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uU2hpZnRVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaXNNb3VzZU91dHNpZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vbWFrZXMgaXQgc28gdGhhdCBkb3VibGUgY2xpY2tpbmcgZG9lc24ndCBzZWxlY3QgdGV4dCBvbiB0aGUgcGFnZVxuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBmdW5jdGlvbiAoZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IHJldHVybiBmYWxzZTsgfSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBhbm90aGVyIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb2YgdGhlIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSwgZmFsc2UgaWYgb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgaWYgKG14ID4geCAmJiBteCA8IHggKyB3ICYmIG15ID4geSAmJiBteSA8IHkgKyBoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgPiAwIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb25lIG9mIHRoZSBjb3JuZXIvc2lkZSBndWlkZXMsIHJldHVybnMgMCBpZiBub3RcbiAgICAgKiBUaGUgY29ybmVyIGd1aWRlcyBhcmUgbnVtYmVyZWQgMS00IHdpdGggMSBiZWluZyB0aGUgdG9wIGxlZnQsIDIgYmVpbmcgdGhlIHRvcCByaWdodCwgYW5kIHNvIG9uLlxuICAgICAqIFRoZSBtaWRkbGUgZ3VpZGVzIGFyZSBudW1iZXJlZCA1LTgsIHdpdGggNSBiZWluZyB0aGUgdG9wIG1pZGRsZSwgNiBiZWluZyB0aGUgcmlnaHQgbWlkZGxlLCBhbmQgc28gb24uXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGd1aWRlQ29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBsZXQgeGRpZiA9IG14IC0geDtcbiAgICAgICAgbGV0IHlkaWYgPSBteSAtIHk7XG4gICAgICAgIC8qIENvcm5lciBHdWlkZXMgKi9cbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGgpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSB4O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICB9XG4gICAgICAgIC8qIE1pZGRsZSBHdWlkZXMgKi9cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3IC8gMik7XG4gICAgICAgIHlkaWYgPSBteSAtIHk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGggLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3IC8gMik7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSB4O1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGggLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBhbmQgZ3VpZGVzIGZvciB0aGUgb2JqZWN0IHdoZW4gdGhlIG9iamVjdCBpcyBzZWxlY3RlZFxuICAgICAqIElmIG9uZSBvZiB0aGUgZ3VpZGVzIGlzIHNlbGVjdGVkLCBpdCBjb2xvcnMgdGhhdCBndWlkZSBibHVlXG4gICAgICogQHBhcmFtIHggdGhlIHggY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHkgdGhlIHkgY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHcgdGhlIHdpZHRoIG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29ybmVyIHRoZSBudW1iZXIgb2YgdGhlIGNvcm5lciB0byBiZSBjb2xvcmVkIGJsdWUgKGlmIGFueSBhdCBhbGwsIGlmIDAsIGFsbCBhcmUgd2hpdGUpXG4gICAgICovXG4gICAgZHJhd0d1aWRlcyh4LCB5LCB3LCBoLCBjb3JuZXIpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmIChjb3JuZXIgIT09IDAgJiYgY29ybmVyIDw9IDQpIHsgLy8gYSBjb3JuZXIgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29ybmVyICE9PSAwKSB7IC8vIGEgbWlkZGxlIGd1aWRlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgY29ycmVjdCBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvL2lmIG5vIGd1aWRlcyBhcmUgc2VsZWN0ZWQsIGNvbG9ycyBldmVyeXRoaW5nIHdoaXRlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgbWV0aG9kIHRoYXQgZHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geCB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5IHkgY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHcgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIGNvbG9yIG9mIHRoZSByZWN0YW5nbGUncyBmaWxsXG4gICAgICovXG4gICAgZHJhd1NxdWFyZSh4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgd2l0aGluIHRoZSBjYW52YXMuXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24sIGNhbGxzIHRoZSBtb2RpZnkgbWV0aG9kcyBpZiB0aGUgYm9vbGVhbnMgc2F0aXNmeSB0aGVtLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRNb3VzZVBvc2l0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5RHJhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemUodGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0NoYW5naW5nRGltcyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXModGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIGNsaWNrcyBpbnNpZGUgdGhlIGNhbnZhcy5cbiAgICAgKiBNb2RpZmllcyB0aGUgc3RhdGUgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGd1aWRlcyBjb250YWluIHRoZSBtb3VzZSBvciB0aGUgYm91bmRpbmcgcmVjdCBjb250YWlucyB0aGUgbW91c2UuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVN0YXRlKHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSwgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgdW5jbGlja3MuXG4gICAgICogQ2FsbHMgbW9kaWZ5UmVzZXQgdG8gcmVzZXQgZHJhZ2dpbmcgYW5kIHJlc2l6aW5nIGJvb2xlYW5zIGFtb25nIG90aGVycy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNldXAgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlSZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcHJlc3NlZCBkb3duXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcHJlc3NlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdERvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHJlbGVhc2VkXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcmVsZWFzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnRVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogTW9kaWZpY2F0aW9uIGZ1bmN0aW9ucyAqL1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBpbiBvcmRlciB0byBkcmFnIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgbW9kaWZ5RHJhZygpIHtcbiAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueCAtIHRoaXMuX2RyYWdvZmZ4O1xuICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy5fZHJhZ29mZnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHNpemUgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZCAod2hlbiBhIGNvcm5lciBndWlkZSBpcyBjbGlja2VkIGFuZCBkcmFnZ2VkKS5cbiAgICAgKlxuICAgICAqIElmIGFueSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgdG9vIHNtYWxsLCBpdCBzZXRzIHRoZW0gZXF1YWwgdG8gMTAgYW5kIHRoZSBvdGhlciBlcXVhbCB0b1xuICAgICAqIDEwIGRpdmlkZWQgb3IgbXVsdGlwbGllZCBieSB0aGUgcmF0aW8gb2Ygd2lkdGgvaGVpZ2h0IHRvIGtlZXAgaXQgdGhlIHNhbWUuXG4gICAgICpcbiAgICAgKiBUaGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBpcyBkb25lIGJ5IGNhbGxpbmcgdGhlIGhlbHBlciBtZXRob2QgbW9kaWZ5UmVzaXplSGVscGVyLlxuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZSh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBpZiAod2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fcmVjdC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7IC8vIHNldCBmb3IgdGhlIHByb2RpcmVjdCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX3JlY3QuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTAgLyB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fcmVjdC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApOyAvLyBzZXQgZm9yIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgKiB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX3JlY3Qud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyAxLCAyLCBvciA0IGFyZSBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0Rpc3RhbmNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBtb3VzZSBhbmQgdGhlIGxvY2F0aW9uIG9wcG9zaXRlIHRvIGl0XG4gICAgICogKGlmIHRvcCByaWdodCBndWlkZSBpcyBjbGlja2VkLCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGFuZCB0aGUgYm90dG9tIGxlZnQgZ3VpZGUgaXMgbmV3RGlzdGFuY2UpXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgdGhpcy5fcmVjdC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW87XG4gICAgICAgIHRoaXMuX3JlY3QuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQuXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMC5cbiAgICAgKiBDYWxscyBtb2RpZnlDaGFuZ2VEaW1zSGVscGVyIHRvIGFjdHVhbGx5IGRvIHRoZSB3b3JrXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5Q2hhbmdlRGltcyh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBpZiAod2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fcmVjdC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fcmVjdC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyA1IG9yIDggYXJlIHNlbGVjdGVkXG4gICAgICovXG4gICAgbW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oID4gMTApIHsgLy9hcyBsb25nIGFzIHRoZSBoZWlnaHQgaXMgPiAxMFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0LndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53ID4gMTApIHsgLy8gYXMgbG9uZyBhcyB3aWR0aCBpcyA+IDEwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0LndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgZGVwZW5kaW5nIG9uIHRoZSBtb3VzZSBwb3NpdGlvbiB3aGVuIGNhbGxlZCAob25Nb3VzZURvd24pXG4gICAgICogZS5nLiBpZiB0aGUgbW91c2UgaXMgd2l0aGluIHRoZSBib3VuZGluZyByZWN0YW5nbGUgd2hlbiB0aGlzIGlzIGNhbGxlZCwgaXNTZWxlY3RlZCA9IHRydWVcbiAgICAgKiBAcGFyYW0gZ3VpZGVDb250YWluc1xuICAgICAqIEBwYXJhbSBjb250YWluc1xuICAgICAqL1xuICAgIG1vZGlmeVN0YXRlKGd1aWRlQ29udGFpbnMsIGNvbnRhaW5zKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkgeyAvL3ByZXBhcmVzIHRoZSBvYmplY3QgZm9yIGRyYWdnaW5nIHdoZXRoZXIgaXQgaXMgcGVyc29uYWxseSBzZWxlY3RlZCBvciBub3RcbiAgICAgICAgICAgIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kxID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gMCAmJiBndWlkZUNvbnRhaW5zIDw9IDQpIHsgLy9yZXNpemluZ1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gdGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0MSA9IHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoMSA9IHRoaXMudztcbiAgICAgICAgICAgIC8vdGhpcy5fc2l6ZTEgPSBNYXRoLnNxcnQoTWF0aC5wb3codywyKSArIE1hdGgucG93KGgsMikpOyAvLyBzaXplIGlzIGRpYWdvbmFsIGxlbmd0aFxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHsgLy8gc2V0cyB0aGUgb2Zmc2V0cyBkZXBlbmRpbmcgb24gd2hpY2ggY29ybmVyIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgY2FzZSAxOiAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3OyAvLyBvZmZzZXQgaXMgYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoOyAvLyBvZmZzZXQgaXMgYm90dG9tIGxlZnQsIGV0Y1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucyA+IDQpIHsgLy9jaGFuZ2luZyBzaGFwZSBkaW1lbnNpb25zXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IGd1aWRlQ29udGFpbnM7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikgeyAvLyBzZXRzIHRoZSBvZmZzZXRzIGRlcGVuZGluZyBvbiB3aGljaCBtaWRkbGUgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIDU6IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyOyAvLyBvZmZzZXQgaXMgYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6IC8vcmlnaHQgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaCAvIDI7IC8vIG9mZnNldCBpcyBsZWZ0IG1pZGRsZSBldGNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdyAvIDIsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5ICsgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbnMpIHsgLy8gZHJhZ2dpbmdcbiAgICAgICAgICAgIHRoaXMuX3gxID0geDsgLy8gU2F2aW5nIG9yaWdpbmFsIHggYW5kIHlcbiAgICAgICAgICAgIHRoaXMuX3kxID0geTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7IC8vIG5vdCBzZWxlY3RlZFxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgdG8gZmFsc2UgKGxpa2UgZHJhZ2dpbmcsIHJlc2l6aW5nLCBldGMpIHdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkXG4gICAgICovXG4gICAgbW9kaWZ5UmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl94MSAtIHRoaXMueCkgPiAxIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0gdGhpcy55KSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHRoaXMuX2lzUmVzaXppbmcgfHwgdGhpcy5faXNDaGFuZ2luZ0RpbXMpICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBzaXplMiA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLncsIDIpICsgTWF0aC5wb3codGhpcy5oLCAyKSk7XG4gICAgICAgICAgICBpZiAoKE1hdGguYWJzKHRoaXMuX3dpZHRoMSAtIHRoaXMudykgPiAwKSB8fCAoTWF0aC5hYnModGhpcy5faGVpZ2h0MSAtIHRoaXMuaCkgPiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1Jlc2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqL1xuICAgIGdldE1vdXNlUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuX21vdXNlLnggPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS54O1xuICAgICAgICB0aGlzLl9tb3VzZS55ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0NoYW5naW5nRGltcywgYW5kIGlzU2VsZWN0ZWQgdG8gZmFsc2UgaWYgdGhlIG1vdXNlIGNsaWNrcyBvdXRzaWRlIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIGlzTW91c2VPdXRzaWRlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgICAgICBsZXQgbW91c2VZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtb3VzZVggPCByZWN0LmxlZnQgfHwgbW91c2VYID4gcmVjdC5yaWdodCB8fCBtb3VzZVkgPCByZWN0LnRvcCB8fCBtb3VzZVkgPiByZWN0LmJvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlY3RhbmdsZSBwYWludCBldmVudFxuICAgICAqL1xuICAgIGxvZ1BhaW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhaW50RXZlbnRfMS5QYWludEV2ZW50KFwicmVjdGFuZ2xlXCIsIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlY3RhbmdsZSByZXNpemUgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dSZXNpemUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplRXZlbnRfMS5SZXNpemVFdmVudChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIE1hdGgucm91bmQodGhpcy5fd2lkdGgxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLl9oZWlnaHQxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLncgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuaCAqIDEwMCkgLyAxMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIGNsaWNrIGV2ZW50XG4gICAgICovXG4gICAgbG9nQ2xpY2soKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xpY2tFdmVudF8xLkNsaWNrRXZlbnQoXCJyZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCBhc3NpZ25zIGFuIElEIHRvIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSBpZCBUaGUgSUQgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBpbml0SUQoaWQpIHtcbiAgICAgICAgdGhpcy5pZE9iaiA9IHsgX2lkOiBpZCB9O1xuICAgIH1cbiAgICBhc3QoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERpbWVuc2lvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRPYmouX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqL1xuICAgIGdldEp1c3REcmFnZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fanVzdERyYWdnZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBzZXRKdXN0RHJhZ2dlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaXMgZHJhZ2dpbmdcbiAgICAgKi9cbiAgICBnZXQgaXNEcmFnZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRHJhZ2dpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3Igc2VsZWN0aW9uIGV2ZW50c1xuICAgICAqL1xuICAgIHRvU2VsU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCIgcmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgZHJhZyBldmVudHNcbiAgICAqL1xuICAgIHRvRHJhZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBmcm9tIFwiICsgdGhpcy5feDEgKyBcIiwgXCIgKyB0aGlzLl95MSArIFwiIHRvIFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBJRCBhc3NpZ25tZW50IGV2ZW50c1xuICAgICAqL1xuICAgIHRvSURTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pZE9iai5faWQudG9TdHJpbmcoKSArIFwiIHRvIHJlY3RhbmdsZSBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWN0YW5nbGVFZmZlY3QgPSBSZWN0YW5nbGVFZmZlY3Q7XG4vKipcbiAqIEdldHMgdGhlIG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZXMgaW4gcmVsYXRpb24gdG8gdGhlIGNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB0aGUgY2FudmFzIG9iamVjdFxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0TW91c2VQb3MoY2FudmFzLCBldmVudCkge1xuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB4MSB4IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB5MSB5IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB4MiB4IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKiBAcGFyYW0geTIgeSBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MiwgMikgKyBNYXRoLnBvdyh5MSAtIHkyLCAyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWN0YW5nbGVFZmZlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBQYWludEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9QYWludEV2ZW50XCIpO1xuY29uc3QgUmVzaXplRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1Jlc2l6ZUV2ZW50XCIpO1xuY29uc3QgQ2xpY2tFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvQ2xpY2tFdmVudFwiKTtcbmNsYXNzIFN0cmluZ0VmZmVjdCB7XG4gICAgY29uc3RydWN0b3Ioc3RyKSB7XG4gICAgICAgIHRoaXMuX2ZvbnRTaXplID0gMjA7XG4gICAgICAgIC8vcHJpdmF0ZSBfc2l6ZTI6IG51bWJlcjtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBQcml2YXRlIGJvb2xzXG4gICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0xpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlOyAvLyBIYXMgdGhpcyBvYmplY3QganVzdCBiZWVuIGRyYWdnZWQ/XG4gICAgICAgIC8vcHJpdmF0ZSBfbG9nOiBzdHJpbmdbXTtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnggPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IDA7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX21vdXNlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MgPSB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGludGVydmFsOiAwLFxuICAgICAgICAgICAgc3RyOiBcIlwiLFxuICAgICAgICAgICAgaW5pdE1vdXNlUG9zOiAwLFxuICAgICAgICAgICAgY3Vyc29yUG9zOiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3N0ciA9IHN0cjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIGV2YWx1YXRpbmcgbm9kZXMgKFN0cmluZ05vZGUsIEVsbGlwc2VOb2RlLCBldGMpXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyBhbGwgcGFyYW1zIHRvIHByaXZhdGUgdmFyaWFibGVzIGFuZCBkcmF3cyB0aGUgaW5pdGlhbCBvYmplY3QgdG8gdGhlIGNhbnZhc1xuICAgICAqIGJ5IGNhbGxpbmcgdXBkYXRlKClcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgcGFyZW50IFNjb3BlIHRoYXQgY29udGFpbnMgdGhlIGNhbnZhcyBhbW9uZyBvdGhlciB0aGluZ3NcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgb2JqZWN0J3MgZGltZW5zaW9ucyBpbmNsdWRpbmcgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBhc3QgVW5uZWNlc3Nhcnkgbm93LCB1c2VkIHRvIGJlIHRoZSBwYXJlbnQgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY2FudmFzICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBjb250ZXh0LmNhbnZhcy5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMgPSBkaW1zO1xuICAgICAgICAgICAgbGV0IGN0eCA9IGNvbnRleHQuY2FudmFzLmdldCgpLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAvLyBsb2dnaW5nXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dQYWludCgpKTsgLy8gdGhpcy5jb250ZXh0IG9yIGNvbnRleHQ/XG4gICAgICAgICAgICBjb250ZXh0LmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2FudmFzIGlzIE5PVCBkZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBpbiBvcmRlciB0byBkcmF3IGFuZCByZWRyYXcgdGhlIG9iamVjdCB3aGVuIG1hbmlwdWxhdGlvbnMgYXJlIG1hZGVcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCBmb250RGVldHMgPSB0aGlzLl9mb250U2l6ZSArIFwicHggQ291cmllciBOZXdcIjtcbiAgICAgICAgdGhpcy5fY3R4LmZvbnQgPSBmb250RGVldHM7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBcIiM2NzNBQjdcIjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxUZXh0KHRoaXMuX3N0ci52YWwsIHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgbGV0IHRleHREaW1zID0gdGhpcy5fY3R4Lm1lYXN1cmVUZXh0KHRoaXMuX3N0ci52YWwpO1xuICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy53aWR0aCA9IHRleHREaW1zLndpZHRoO1xuICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5oZWlnaHQgPSB0aGlzLl9mb250U2l6ZTtcbiAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3Muc3RyID0gdGhpcy5fc3RyLnZhbDtcbiAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuaW50ZXJ2YWwgPSB0aGlzLl90ZXh0TWV0cmljcy53aWR0aCAvIHRoaXMuX3RleHRNZXRyaWNzLnN0ci5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdUZXh0R3VpZGVzKHRoaXMueCwgdGhpcy55IC0gdGhpcy5fZm9udFNpemUsIHRoaXMuX3RleHRNZXRyaWNzLndpZHRoLCB0aGlzLl90ZXh0TWV0cmljcy5oZWlnaHQsIHRoaXMuX2Nvcm5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lzRWRpdGluZykge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gb25lIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7IC8vIGJpbmQgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIG1lYW5pbmcgb2YgJ3RoaXMnXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25TaGlmdERvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25TaGlmdFVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy9tYWtlcyBpdCBzbyB0aGF0IGRvdWJsZSBjbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0ZXh0IG9uIHRoZSBwYWdlXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uIChlKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGZhbHNlOyB9LCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIGFub3RoZXIgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvZiB0aGUgb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgY29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIHJldHVybiAodGhpcy54IDw9IG14KSAmJiAodGhpcy54ICsgdGhpcy5fdGV4dE1ldHJpY3Mud2lkdGggPj0gbXgpICYmXG4gICAgICAgICAgICAodGhpcy55IC0gdGhpcy5fZm9udFNpemUgPD0gbXkpICYmICh0aGlzLnkgPj0gbXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbnVtYmVyID4gMCBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9uZSBvZiB0aGUgY29ybmVyL3NpZGUgZ3VpZGVzLCByZXR1cm5zIDAgaWYgbm90XG4gICAgICogVGhlIGNvcm5lciBndWlkZXMgYXJlIG51bWJlcmVkIDEtNCB3aXRoIDEgYmVpbmcgdGhlIHRvcCBsZWZ0LCAyIGJlaW5nIHRoZSB0b3AgcmlnaHQsIGFuZCBzbyBvbi5cbiAgICAgKiBUaGUgbWlkZGxlIGd1aWRlcyBhcmUgbnVtYmVyZWQgNS04LCB3aXRoIDUgYmVpbmcgdGhlIHRvcCBtaWRkbGUsIDYgYmVpbmcgdGhlIHJpZ2h0IG1pZGRsZSwgYW5kIHNvIG9uLlxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBndWlkZUNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeGRpZiA9IG14IC0gKHRoaXMueCArIHRoaXMuX3RleHRNZXRyaWNzLndpZHRoKTtcbiAgICAgICAgbGV0IHlkaWYgPSBteSAtICh0aGlzLnkgLSB0aGlzLl9mb250U2l6ZSk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBib3VuZGluZyByZWN0YW5nbGUgYW5kIGd1aWRlcyBmb3IgdGhlIG9iamVjdCB3aGVuIHRoZSBvYmplY3QgaXMgc2VsZWN0ZWRcbiAgICAgKiBJZiBvbmUgb2YgdGhlIGd1aWRlcyBpcyBzZWxlY3RlZCwgaXQgY29sb3JzIHRoYXQgZ3VpZGUgYmx1ZVxuICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB5IHRoZSB5IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB3IHRoZSB3aWR0aCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggdGhlIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvcm5lciB0aGUgbnVtYmVyIG9mIHRoZSBjb3JuZXIgdG8gYmUgY29sb3JlZCBibHVlIChpZiBhbnkgYXQgYWxsLCBpZiAwLCBhbGwgYXJlIHdoaXRlKVxuICAgICAqL1xuICAgIGRyYXdUZXh0R3VpZGVzKHgsIHksIHcsIGgsIGNvcm5lcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKGNvcm5lciAhPT0gMCkge1xuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGd1aWRlIGJsdWUgaWYgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBtZXRob2QgdGhhdCBkcmF3cyBhIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB4IHggY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHkgeSBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gdyB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29sb3IgY29sb3Igb2YgdGhlIHJlY3RhbmdsZSdzIGZpbGxcbiAgICAgKi9cbiAgICBkcmF3U3F1YXJlKHgsIHksIHcsIGgsIGNvbG9yKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgLyogRXZlbnQgbGlzdGVuZXIgZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBtb3ZlcyB3aXRoaW4gdGhlIGNhbnZhcy5cbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiwgY2FsbHMgdGhlIG1vZGlmeSBtZXRob2RzIGlmIHRoZSBib29sZWFucyBzYXRpc2Z5IHRoZW0uXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICB0aGlzLmdldE1vdXNlUG9zaXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQgJiYgdGhpcy5faXNEcmFnZ2luZykge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLl9zdHIudmFsICsgXCIgaXMgYmVpbmcgZHJhZ2dlZC5cIik7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeURyYWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jlc2l6aW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplKHRoaXMuX2ZvbnRTaXplIDwgMTUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSAmJiB0aGlzLl9pc1NlbGVjdGVkICYmIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpIHsgLy90ZXh0IGVkaXRpbmdcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMubW9kaWZ5VGV4dC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2lzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX3N0ci52YWwgKyBcIiBpcyBzZXR0aW5nIGRyYWdnaW5nIHRvIGZhbHNlXCIpO1xuICAgICAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuaW5pdE1vdXNlUG9zID0gdGhpcy5fbW91c2UueDtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kaWZ5U3RhdGUodGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpID4gMCwgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgdW5jbGlja3MuXG4gICAgICogQ2FsbHMgbW9kaWZ5UmVzZXQgdG8gcmVzZXQgZHJhZ2dpbmcgYW5kIHJlc2l6aW5nIGJvb2xlYW5zIGFtb25nIG90aGVycy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNldXAgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlSZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcHJlc3NlZCBkb3duXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcHJlc3NlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdERvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHJlbGVhc2VkXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcmVsZWFzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnRVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogTW9kaWZpY2F0aW9uIGZ1bmN0aW9ucyAqL1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBpbiBvcmRlciB0byBkcmFnIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgbW9kaWZ5RHJhZygpIHtcbiAgICAgICAgLy8oXCJzdHJpbmcgZHJhZ29mZng6IFwiICsgdGhpcy5fZHJhZ29mZngpO1xuICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS54IC0gdGhpcy5fZHJhZ29mZng7XG4gICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLl9kcmFnb2ZmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgbW92ZXMgdGhlIHRleHQgZWRpdCBjdXJzb3IgYmFzZWQgb24gd2hlcmUgdGhlIG1vdXNlIGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBtb2RpZnlUZXh0Q3Vyc29yKCkge1xuICAgICAgICBsZXQgbGVmdFdhbGwgPSB0aGlzLng7IC8vIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBsZWZ0IG1vc3Qgc2lkZSBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICAgIGxldCB4RGlmID0gdGhpcy5fdGV4dE1ldHJpY3MuaW5pdE1vdXNlUG9zIC0gbGVmdFdhbGw7IC8vIGRpZmZlcmVuY2UgYmV0d2VlbiBtb3VzZSB4IGFuZCBsZWZ0IHdhbGxcbiAgICAgICAgbGV0IGludGVydmFsID0gdGhpcy5fdGV4dE1ldHJpY3MuaW50ZXJ2YWw7IC8vIHRoZSB0ZXh0IHdpZHRoIGRpdmlkZWQgYnkgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nXG4gICAgICAgIGxldCBtb3ZlRmFjdG9yID0gMDtcbiAgICAgICAgaWYgKHhEaWYgPj0gaW50ZXJ2YWwgLyAyICYmIHhEaWYgPD0gaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIG1vdmVGYWN0b3IgPSBsZWZ0V2FsbCArIGludGVydmFsO1xuICAgICAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuY3Vyc29yUG9zID0gaW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeERpZiA8PSBpbnRlcnZhbCAvIDIpIHtcbiAgICAgICAgICAgIG1vdmVGYWN0b3IgPSBsZWZ0V2FsbDtcbiAgICAgICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmN1cnNvclBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeERpZiAlIGludGVydmFsID49IGludGVydmFsIC8gMikge1xuICAgICAgICAgICAgbW92ZUZhY3RvciA9IGxlZnRXYWxsICsgaW50ZXJ2YWwgKiBNYXRoLmNlaWwoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmN1cnNvclBvcyA9IGludGVydmFsICogTWF0aC5jZWlsKHhEaWYgLyBpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeERpZiAlIGludGVydmFsIDwgaW50ZXJ2YWwgLyAyKSB7XG4gICAgICAgICAgICBtb3ZlRmFjdG9yID0gbGVmdFdhbGwgKyBpbnRlcnZhbCAqIE1hdGguZmxvb3IoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmN1cnNvclBvcyA9IGludGVydmFsICogTWF0aC5mbG9vcih4RGlmIC8gaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N0eC5tb3ZlVG8obW92ZUZhY3RvciwgdGhpcy55IC0gdGhpcy5fZm9udFNpemUpO1xuICAgICAgICB0aGlzLl9jdHgubGluZVRvKG1vdmVGYWN0b3IsIHRoaXMueSk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9IFwiZ3JleVwiO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZWRpdHMgdGhlIHN0cmluZyB3aGVuIGVkaXRpbmcgdGV4dFxuICAgICAqIEBwYXJhbSBldmVudCBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgbW9kaWZ5VGV4dChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5faXNFZGl0aW5nKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3RIYWxmO1xuICAgICAgICAgICAgbGV0IHNlY29uZEhhbGY7XG4gICAgICAgICAgICBsZXQgYnJlYWtQb2ludCA9IHRoaXMuX3RleHRNZXRyaWNzLmN1cnNvclBvcyAvIHRoaXMuX3RleHRNZXRyaWNzLmludGVydmFsO1xuICAgICAgICAgICAgZmlyc3RIYWxmID0gdGhpcy5fc3RyLnZhbC5zdWJzdHJpbmcoMCwgYnJlYWtQb2ludCk7XG4gICAgICAgICAgICBzZWNvbmRIYWxmID0gdGhpcy5fc3RyLnZhbC5zdWJzdHJpbmcoYnJlYWtQb2ludCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNyAmJiB0aGlzLl90ZXh0TWV0cmljcy5pbml0TW91c2VQb3MgPiB0aGlzLnggKyB0aGlzLl90ZXh0TWV0cmljcy5pbnRlcnZhbCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5pbml0TW91c2VQb3MgLT0gdGhpcy5fdGV4dE1ldHJpY3MuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDM5ICYmIHRoaXMuX3RleHRNZXRyaWNzLmluaXRNb3VzZVBvcyA8IHRoaXMueCArIHRoaXMuX3RleHRNZXRyaWNzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuaW5pdE1vdXNlUG9zICs9IHRoaXMuX3RleHRNZXRyaWNzLmludGVydmFsO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSA4ICYmIHRoaXMuX3N0ci52YWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpcnN0SGFsZiA9IGZpcnN0SGFsZi5zdWJzdHJpbmcoMCwgZmlyc3RIYWxmLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0ci5zdHIgPSBmaXJzdEhhbGYgKyBzZWNvbmRIYWxmO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmluaXRNb3VzZVBvcyAtPSB0aGlzLl90ZXh0TWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBrZXlOYW1lID0gZXZlbnQua2V5O1xuICAgICAgICAgICAgICAgIGlmIChrZXlOYW1lLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0SGFsZiArPSBrZXlOYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHIuc3RyID0gZmlyc3RIYWxmICsgc2Vjb25kSGFsZjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuaW5pdE1vdXNlUG9zICs9IHRoaXMuX3RleHRNZXRyaWNzLmludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9kaWZpZXMgdGhlIGZvbnQgc2l6ZSBvZiB0aGUgdGV4dFxuICAgICAqIElmIHRoZSB0ZXh0IGZvbnQgaXMgc21hbGxlciB0aGFuIDE1cHQsIGl0IHNldCdzIGl0IGVxdWFsIHRvIDE1cHRcbiAgICAgKiBAcGFyYW0gaXNUb29TbWFsbCB0cnVlIGlmIHRoZSBmb250IHNpemUgaXMgPCAxNVxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZShpc1Rvb1NtYWxsKSB7XG4gICAgICAgIGlmIChpc1Rvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9mb250U2l6ZSA9IDE1O1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250U2l6ZSArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMC4yO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAwLjI7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyBkZXBlbmRpbmcgb24gdGhlIG1vdXNlIHBvc2l0aW9uIHdoZW4gY2FsbGVkIChvbk1vdXNlRG93bilcbiAgICAgKiBlLmcuIGlmIHRoZSBtb3VzZSBpcyB3aXRoaW4gdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSB3aGVuIHRoaXMgaXMgY2FsbGVkLCBpc1NlbGVjdGVkID0gdHJ1ZVxuICAgICAqIEBwYXJhbSBndWlkZUNvbnRhaW5zXG4gICAgICogQHBhcmFtIGNvbnRhaW5zXG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGUoZ3VpZGVDb250YWlucywgY29udGFpbnMpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy9wcmVwYXJlcyB0aGUgb2JqZWN0IGZvciBkcmFnZ2luZyB3aGV0aGVyIGl0IGlzIHBlcnNvbmFsbHkgc2VsZWN0ZWQgb3Igbm90XG4gICAgICAgICAgICBpZiAoY29udGFpbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94MSA9IHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl95MSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmKHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQubXVsU2VsKXtcbiAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcInN0cmluZyBlZmZlY3QgbXVsU2VsZWN0ZWQ6IFwiICsgdGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC5tdWxTZWwpO1xuICAgICAgICAgICAgLy8gICAgIC8vaWYodGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC52YWwpe1xuICAgICAgICAgICAgLy8gICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1NlbGVjdGVkKCkpO1xuICAgICAgICAgICAgLy8gICAgIC8vdGhpcy5sb2dTZWxlY3RlZCgpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMpIHsgLy9pZiB0aGUgY29ybmVyIGd1aWRlcyBjb250YWluIHRoZSBtb3VzZSB3ZSBhcmUgcmVzaXppbmdcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gdGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX3N0ci52YWwgKyBcImlzIHNlbGVjdGVkP1wiICsgdGhpcy5fc2VsZWN0ZWQpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInN0YXRlIHNlbGVjdGlvbiBpcyBcIiArIHRoaXMuX3N0ci52YWwpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLng7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMueTtcbiAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZTEgPSB0aGlzLl9mb250U2l6ZTsgLy8gc2F2aW5nIG9sZCBmb250IHNpemVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLng7IC8vIFNhdmluZyBvcmlnaW5hbCB4IGFuZCB5XG4gICAgICAgICAgICB0aGlzLl95MSA9IHRoaXMueTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX3N0ci52YWwgKyBcImlzIHNlbGVjdGVkP1wiICsgdGhpcy5fc2VsZWN0ZWQpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInN0YXRlIHNlbGVjdGlvbiBpcyBcIiArIHRoaXMuX3N0ci52YWwpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX3N0ci52YWwgKyBcIiBpcyBkcmFnZ2luZz8gXCIgKyB0aGlzLl9pc0RyYWdnaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyB0byBmYWxzZSAobGlrZSBkcmFnZ2luZywgcmVzaXppbmcsIGV0Yykgd2hlbiB0aGUgbW91c2UgaXMgcmVsZWFzZWRcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLl9zdHIudmFsICsgXCIgbG9nZ2luZyBkcmFnXCIpO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0gdGhpcy54KSA+IDEgfHwgTWF0aC5hYnModGhpcy5feTEgLSB0aGlzLnkpID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvL3RoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ01vdmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZXNpemluZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX3N0ci52YWwgKyBcIiBsb2dnaW5nIHJlc2l6ZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl9zaXplMSAtIHRoaXMuX2ZvbnRTaXplKSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dSZXNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3RyaW5nIGVmZmVjdCBtdWxTZWxlY3RlZDogXCIgKyB0aGlzLl9jb250ZXh0Lm11bFNlbGVjdGVkLnZhbCk7XG4gICAgICAgIC8vIGlmKHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQudmFsKXtcbiAgICAgICAgLy8gICAgIHRoaXMubG9nU2VsZWN0ZWQoKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZih0aGlzLmlzTXVsdGlwbGVTZWxlY3RlZCl7XG4gICAgICAgIC8vICAgICBjb250ZXh0LmV2ZW50TG9nLnB1c2gobmV3IFNlbGVjdEV2ZW50KHNlbGVjdGVkRWxlbXMpKTtcbiAgICAgICAgLy8gICAgIG1hc3RlckxvZy5wdXNoKGNvbnRleHQuZXZlbnRMb2dbY29udGV4dC5ldmVudExvZy5sZW5ndGggLSAxXSk7XG4gICAgICAgIC8vICAgICAvL2NvbnNvbGUubG9nKFwibXVsdGlwbGUgc2VsZWN0ZWRcIik7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gLy90aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dNb3ZlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICovXG4gICAgZ2V0TW91c2VQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbW91c2UueCA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLng7XG4gICAgICAgIHRoaXMuX21vdXNlLnkgPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzQ2hhbmdpbmdEaW1zLCBhbmQgaXNTZWxlY3RlZCB0byBmYWxzZSBpZiB0aGUgbW91c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgaXNNb3VzZU91dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1vdXNlWCA8IHJlY3QubGVmdCB8fCBtb3VzZVggPiByZWN0LnJpZ2h0IHx8IG1vdXNlWSA8IHJlY3QudG9wIHx8IG1vdXNlWSA+IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHBhaW50IGV2ZW50XG4gICAgICovXG4gICAgbG9nUGFpbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpbnRFdmVudF8xLlBhaW50RXZlbnQodGhpcy5fc3RyLnZhbCwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVzaXplIGV2ZW50XG4gICAgICovXG4gICAgbG9nUmVzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZUV2ZW50XzEuUmVzaXplRXZlbnQodGhpcy5fc3RyLnZhbCArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgTWF0aC5yb3VuZCh0aGlzLl9zaXplMSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5fZm9udFNpemUgKiAxMDApIC8gMTAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIGNsaWNrIGV2ZW50XG4gICAgICovXG4gICAgbG9nQ2xpY2soKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xpY2tFdmVudF8xLkNsaWNrRXZlbnQodGhpcy5fc3RyLnZhbCArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgYXNzaWducyBhbiBJRCB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgaW5pdElEKGlkKSB7XG4gICAgICAgIHRoaXMuaWRPYmogPSB7IF9pZDogaWQsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIGdldCBjYW52YXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBjYW52YXMgVGhlIGNhbnZhcyB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldCBjYW52YXMoY2FudmFzKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgICB9XG4gICAgYXN0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgZWxsaXBzZVxuICAgICAqL1xuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBlbGxpcHNlXG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERpbWVuc2lvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVsbGlwc2UgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgKi9cbiAgICBnZXRKdXN0RHJhZ2dlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1c3REcmFnZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgc2V0SnVzdERyYWdnZWQodmFsKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGlzIGRyYWdnaW5nXG4gICAgICovXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXQgc3RyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RyLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb2JqZWN0IElEXG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkT2JqLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBzZWxlY3Rpb24gZXZlbnRzXG4gICAgICovXG4gICAgdG9TZWxTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIiBcIiArIHRoaXMuX3N0ci52YWwgKyBcIiB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIGRyYWcgZXZlbnRzXG4gICAgKi9cbiAgICB0b0RyYWdTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fc3RyLnZhbCArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94MSArIFwiLCBcIiArIHRoaXMuX3kxICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gXCIgKyB0aGlzLl9zdHIudmFsICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaW5nRWZmZWN0ID0gU3RyaW5nRWZmZWN0O1xuLyoqXG4gKiBHZXQncyB0aGUgbW91c2UgeCBhbmQgeSBjb29yZGluYXRlcyBpbiByZWxhdGlvbiB0byB0aGUgY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHRoZSBjYW52YXMgb2JqZWN0XG4gKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICovXG5mdW5jdGlvbiBnZXRNb3VzZVBvcyhjYW52YXMsIGV2ZW50KSB7XG4gICAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHgxIHggY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHkxIHkgY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHgyIHggY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSB5MiB5IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgyLCAyKSArIE1hdGgucG93KHkxIC0geTIsIDIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmluZ0VmZmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFJldHVybkVycm9yXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9SZXR1cm5FcnJvclwiKTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xuLy8gQXBwbGljYXRpb24gb2YgYSBmdW5jdGlvbi4gQXNzdW1lcyBhcmcgdmFsdWVzIHBhc3NlZCBpbiBzYW1lIG9yZGVyIGFzIEZ1bkRlZiBhcmdzXG5jbGFzcyBGdW5BcHAge1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYSBmdW5jdGlvbiBhcHBsaWNhdGlvblxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBhcmdzIEZ1bmN0aW9uIGFyZ3VtZW50cywgaWYgYXBwbGljYWJsZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiwgaWYgYW55XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgYXJncywgd3MsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX2FyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGZ1bmRlZiA9IGNvbnRleHQubG9va3VwKHRoaXMuX25hbWUsIGNvbnRleHQpOyAvLyBsb29raW5nIHVwIGZ1bmN0aW9uXG4gICAgICAgIC8vbGV0IGNoaWxkID0gbmV3IFNjb3BlKGZ1bmRlZi5zY29wZSk7IC8vIGF2b2lkaW5nIG92ZXJ3cml0ZTsgbmVlZCB0byB0b3NzIGFmdGVyIHJldHVybmluZ1xuICAgICAgICBsZXQgY2hpbGQgPSBmdW5kZWYuc2NvcGUuY29weSgpOyAvLyBDb3B5aW5nIGRlZmluaXRpb24gc2NvcGVcbiAgICAgICAgLy8gQXNzaWducyBhcmcgdmFsdWVzIHRvIGRlZmluaXRpb24gYXJndW1lbnRzXG4gICAgICAgIGlmICh0aGlzLl9hcmdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXJncy5sZW5ndGg7IGkrKykgeyAvL2xvb2t1cHM/XG4gICAgICAgICAgICAgICAgLy9jaGlsZC5kZWNsYXJlKHRoaXMuX2Z1bmN0LmFyZ3NbaV0pOyAvLyByZWRlY2xhcmU/XG4gICAgICAgICAgICAgICAgY2hpbGQuYXNzaWduKGZ1bmRlZi5hcmdzW2ldLCB0aGlzLl9hcmdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaWQgPSBjb250ZXh0Lmdsb2JhbEZ1bklEOyAvLyBBc3NpZ25zIGFuIElEIHRvIHRoZSBmdW5jdGlvblxuICAgICAgICBjb250ZXh0Lmdsb2JhbEZ1bklEKys7XG4gICAgICAgIGNoaWxkLnJldFZhbElEID0gc3BhY2VfbGlmdF8xLlNvbWUoaWQpOyAvLyBuZXcgbWV0aG9kXG4gICAgICAgIC8vIHdlIG9ubHkgcmV0dXJuIGEgdmFsdWUgd2l0aCBmdW5jdGlvbiBhcHBsaWNhdGlvblxuICAgICAgICAvLyBpZiBpdCBpcyBleHBsaWNpdGx5IHJldHVybmVkIHVzaW5nIGEgcmV0dXJuIHN0YXRlbWVudDtcbiAgICAgICAgLy8gd2UgYWJ1c2UgSlMgZXhjZXB0aW9ucyBmb3IgdGhpcyBwdXJwb3NlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGlsZC5oYWRGdW5FdmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIGZ1bmRlZi5ib2R5LmV2YWwoY2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgd2UgY2F0Y2ggb25seSB0aGUgZXJyb3IgaW50ZW5kZWQgZm9yIHVzXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJldHVybkVycm9yXzEuUmV0dXJuRXJyb3IgJiYgcGFyc2VJbnQoZS5JRCkgPT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5yZXRWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlcnJvciB3YXMgbm90IGludGVuZGVkIGZvciB1czsgcmV0aHJvd1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICAvL3JldHVybiBmdW5kZWYuYm9keS5ldmFsKGNoaWxkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZnVuY3Rpb24gYXBwbGljYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGFyZ3NMaXN0ID0gJyc7XG4gICAgICAgIGlmICh0aGlzLl9hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXJncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzTGlzdCArPSB0aGlzLl9hcmdzW2ldLnRvU3RyaW5nKCkgKyBcIiwgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzTGlzdCArPSB0aGlzLl9hcmdzW3RoaXMuX2FyZ3MubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLm5hbWUgKyAnKCcgKyBhcmdzTGlzdCArIFwiKVwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGFwcGxpY2F0aW9ucyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBmdW5jdGlvbiBhcHBsaWNhdGlvblxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gZnVuY3Rpb25zXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXJndW1lbnRzIG9mIHRoZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldCBhcmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXJncztcbiAgICB9XG59XG5leHBvcnRzLkZ1bkFwcCA9IEZ1bkFwcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZ1bkFwcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNsYXNzIEZ1bkRlZiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgYm9keSwgYXJncywgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5fYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLy8gQmluZHMgYXJncyBpbiBjb250ZXh0IG9mIGRlZmluaXRpb247IG5vIHZhbHVlc1xuICAgIC8vIEJpbmRzIG5hbWUgdG8gcGFyZW50IGNvbnRleHQgKGN1ciBjb250ZXh0IGlzIG5ldyBjb250ZXh0KVxuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICB0aGlzLl9mdW5TY29wZSA9IG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpOyAvLyAqKioqKioqKioqKioqIGNvcHk/Pz8/XG4gICAgICAgIHRoaXMuX2Z1blNjb3BlLmNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgICAgICB0aGlzLl9mdW5TY29wZS5ldmVudExvZyA9IGNvbnRleHQuZXZlbnRMb2c7XG4gICAgICAgIHRoaXMuX2Z1blNjb3BlLmVmZmVjdHMgPSBjb250ZXh0LmVmZmVjdHM7XG4gICAgICAgIC8qXG4gICAgICAgIGlmKHRoaXMuX2FyZ3MgIT0gbnVsbCl7XG4gICAgICAgICAgICBmb3IobGV0IGVudHJ5IG9mIHRoaXMuX2FyZ3Mpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1blNjb3BlLmRlY2xhcmUoZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIGNvbnRleHQuZGVjbGFyZSh0aGlzLl9uYW1lKTsgLy8gYXNzaWduIHdpdGggdmFsIGZ1bmN0aW9uXG4gICAgICAgIGNvbnRleHQuYXNzaWduKHRoaXMuX25hbWUsIHRoaXMpOyAvLyBwYXJlbnQgb3IgY3VycmVudD9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGFyZ3NMaXN0ID0gJyc7XG4gICAgICAgIGlmICh0aGlzLl9hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXJncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzTGlzdCArPSB0aGlzLl9hcmdzW2ldICsgXCIsIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnc0xpc3QgKz0gdGhpcy5fYXJnc1t0aGlzLl9hcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwiZnVuIFwiICsgdGhpcy5fbmFtZSArIFwiKFwiICsgYXJnc0xpc3QgKyAnKScgKyAnIHtcXG4gJyArIHRoaXMuX2JvZHkudG9TdHJpbmcoKSArICd9JztcbiAgICB9XG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGZ1bmN0aW9uc1wiKTtcbiAgICB9XG4gICAgLy8gR2V0IG1ldGhvZHNcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIGdldCBib2R5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9keTtcbiAgICB9XG4gICAgZ2V0IGFyZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcmdzO1xuICAgIH1cbiAgICBnZXQgc2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mdW5TY29wZTtcbiAgICB9XG59XG5leHBvcnRzLkZ1bkRlZiA9IEZ1bkRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZ1bkRlZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIExpc3ROb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYW4gYXJyYXktbGlrZSBsaXN0XG4gICAgICogQHBhcmFtIGxpc3QgVGhlIGxpc3QsIHN0b3JlZCBpbiBhIFRTIGFycmF5XG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGlzdCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9saXN0ID0gbGlzdDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyBlYWNoIGVsZW1lbnQgb2YgdGhlIGxpc3QgYW5kIHB1c2hlcyBpdCBvbnRvIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBldmFsTGlzdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBleHByIG9mIHRoaXMuX2xpc3QpIHtcbiAgICAgICAgICAgIGV2YWxMaXN0LnB1c2goZXhwci5ldmFsKGNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpc3ROb2RlKGV2YWxMaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGlzdFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgbGlzdCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2xpc3QubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0ICs9IHRoaXMuX2xpc3RbaV0udG9TdHJpbmcoKSArIFwiLCBcIjtcbiAgICAgICAgfVxuICAgICAgICBsaXN0ICs9IHRoaXMuX2xpc3RbdGhpcy5fbGlzdC5sZW5ndGggLSAxXS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyAnWycgKyBsaXN0ICsgJ10nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGxpc3QgZXF1YWxzIGFub3RoZXIgbGlzdFxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHkgKG11c3QgYmUgYSBMaXN0Tm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgTGlzdE5vZGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcy5saXN0W2ldLmVxdWFsc1ZhbChyaWdodC5saXN0W2ldKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhdyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgbGlzdFxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkcmF3IGEgTGlzdE5vZGVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxpc3RcbiAgICAgKi9cbiAgICBnZXQgbGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0Tm9kZSA9IExpc3ROb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlzdE5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMb2dFdmVudF8xID0gcmVxdWlyZShcIi4vTG9nRXZlbnRcIik7XG5jbGFzcyBDbGVhckV2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBDbGVhciBFdmVudCwgd2hpY2ggbG9ncyB3aGVuIHRoZSBjYW52YXMgaXMgY2xlYXJlZFxuICAgICAqIEBwYXJhbSB0b0xvZyBXaGF0IHRvIGxvZyAoc3BvaWxlcjogbm90aGluZylcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b0xvZykge1xuICAgICAgICBzdXBlcih0b0xvZyk7XG4gICAgICAgIHRoaXMudGFnID0gXCJjbGVhclwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYW5kIHJldHVybnMgbWVzc2FnZSBcIkNvbnNvbGUgY2xlYXJlZFwiIHdpdGggZGF0ZSBhbmQgdGltZSBhdHRhY2hlZFxuICAgICAqL1xuICAgIGFzc2VtYmxlTG9nKCkge1xuICAgICAgICBsZXQgdG9QcmludCA9IFwiQ29uc29sZSBjbGVhcmVkXCI7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0l0ZW0odG9QcmludCk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGVhckV2ZW50ID0gQ2xlYXJFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNsZWFyRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMb2dFdmVudF8xID0gcmVxdWlyZShcIi4vTG9nRXZlbnRcIik7XG5jbGFzcyBDbGlja0V2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgQ2xpY2sgRXZlbnQsIHdoaWNoIGxvZ3Mgd2hlbiBhbiBvYmplY3Qgb24gdGhlIGNhbnZhcyBpcyBjbGlja2VkXG4gICAgICogQHBhcmFtIHRvTG9nIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCB0byBsb2dcbiAgICAgKiBAcGFyYW0geDEgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0IHRvIGxvZ1xuICAgICAqIEBwYXJhbSB5MSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3QgdG8gbG9nXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9Mb2csIHgxLCB5MSkge1xuICAgICAgICBzdXBlcih0b0xvZywgeDEsIHkxKTtcbiAgICAgICAgdGhpcy50YWcgPSBcImNsaWNrXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhbmQgcmV0dXJucyBtZXNzYWdlIG9mIGZvcm0gXCJDbGlja2VkIG9uIG9iaiBhdCB4LCB5XCIgd2l0aCBkYXRlIGFuZCB0aW1lIGF0dGFjaGVkXG4gICAgICovXG4gICAgYXNzZW1ibGVMb2coKSB7XG4gICAgICAgIGxldCB0b1ByaW50ID0gXCJDbGlja2VkIG9uIFwiICsgdGhpcy50b0xvZyArIFwiIGF0IFwiICsgdGhpcy54MS50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy55MS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dJdGVtKHRvUHJpbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpY2tFdmVudCA9IENsaWNrRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DbGlja0V2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0xvZ0V2ZW50XCIpO1xuY2xhc3MgRHJhZ0V2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgRHJhZyBFdmVudCwgd2hpY2ggbG9ncyB3aGVuIGFuIG9iamVjdCBvbiB0aGUgY2FudmFzIGlzIGRyYWdnZWRcbiAgICAgKiBAcGFyYW0gdG9Mb2cgVGhlIGVmZmVjdCB0byBsb2dcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b0xvZykge1xuICAgICAgICBzdXBlcih0b0xvZyk7XG4gICAgICAgIHRoaXMudGFnID0gXCJkcmFnXCI7XG4gICAgICAgIHRoaXMuX3RvUHJpbnQgPSB0aGlzLmFzc2VtYmxlU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIGxvZyBzdHJpbmcgdXNpbmcgdGhlIEVmZmVjdCdzIHRvRHJhZ1N0cmluZygpIG1ldGhvZFxuICAgICAqL1xuICAgIGFzc2VtYmxlU3RyaW5nKCkge1xuICAgICAgICB0aGlzLl90b1ByaW50ID0gdGhpcy50b0xvZy50b0RyYWdTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvUHJpbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhbmQgcmV0dXJucyBmaW5hbCBsb2cgbWVzc2FnZSBvZiBmb3JtIFwiRHJhZ2dlZCBvYmogZnJvbSB4MSwgeTEgdG8geDIsIHkyXCJcbiAgICAgKiB3aXRoIGRhdGUgYW5kIHRpbWUgYXR0YWNoZWRcbiAgICAgKi9cbiAgICBhc3NlbWJsZUxvZygpIHtcbiAgICAgICAgbGV0IHByaW50ID0gXCJEcmFnZ2VkIFwiICsgdGhpcy5fdG9QcmludDtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nSXRlbShwcmludCk7XG4gICAgfVxufVxuZXhwb3J0cy5EcmFnRXZlbnQgPSBEcmFnRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EcmFnRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMb2dFdmVudF8xID0gcmVxdWlyZShcIi4vTG9nRXZlbnRcIik7XG5jbGFzcyBJREV2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQSBjb25zdHJ1Y3RvciBmb3IgYW4gSUQgZXZlbnQsIHVzZWQgd2hlbiBhbiBvYmplY3QgZ2V0cyBhc3NpZ25lZCBhbiBJRFxuICAgICAqIEBwYXJhbSB0b0xvZyBUaGUgZWZmZWN0IHRvIGxvZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRvTG9nKSB7XG4gICAgICAgIHN1cGVyKHRvTG9nKTtcbiAgICAgICAgdGhpcy50YWcgPSBcIklEXCI7XG4gICAgICAgIHRoaXMuX3RvUHJpbnQgPSB0aGlzLmFzc2VtYmxlU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBzdHJpbmcgdXNpbmcgdGhlIGVmZmVjdCdzIHRvSURTdHJpbmcoKSBtZXRob2RcbiAgICAgKi9cbiAgICBhc3NlbWJsZVN0cmluZygpIHtcbiAgICAgICAgdGhpcy5fdG9QcmludCA9IHRoaXMudG9Mb2cudG9JRFN0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9QcmludDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIG1lc3NhZ2Ugb2YgZm9ybSBcIkFzc2lnbmVkIElEICMgdG8gb2JqIGF0IHgsIHlcIiB3aXRoIGRhdGUgYW5kIHRpbWUgYXR0YWNoZWRcbiAgICAgKi9cbiAgICBhc3NlbWJsZUxvZygpIHtcbiAgICAgICAgbGV0IHByaW50ID0gXCJBc3NpZ25lZCBJRCBcIiArIHRoaXMuX3RvUHJpbnQ7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0l0ZW0ocHJpbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuSURFdmVudCA9IElERXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JREV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgTG9nRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IGNsYXNzIGNvbnN0cnVjdG9yIGZvciBhIExvZyBFdmVudC4gUmVnaXN0ZXJzIGV2ZW50IHRpbWUuXG4gICAgICogQHBhcmFtIHRvTG9nIFRoZSBzdHJpbmcsIG9iamVjdCwgb3IgYXJyYXkgb2Ygb2JqZWN0cyB0byBiZSBsb2dnZWRcbiAgICAgKiBAcGFyYW0geDEgSW5pdGlhbCB4IHBvc2l0aW9uLCBpZiBhcHBsaWNhYmxlXG4gICAgICogQHBhcmFtIHkxIEluaXRpYWwgeSBwb3NpdGlvbiwgaWYgYXBwbGljYWJsZVxuICAgICAqIEBwYXJhbSB4MiBGaW5hbCB4IHBvc2l0aW9uLCBpZiBhcHBsaWNhYmxlXG4gICAgICogQHBhcmFtIHkyIEZpbmFsIHkgcG9zaXRpb24sIGlmIGFwcGxpY2FibGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b0xvZywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgbGV0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5fZGF0ZSA9IHRvZGF5LmdldEZ1bGxZZWFyKCkgKyAnLScgKyAodG9kYXkuZ2V0TW9udGgoKSArIDEpICsgJy0nICsgdG9kYXkuZ2V0RGF0ZSgpO1xuICAgICAgICB0aGlzLl90aW1lID0gdG9kYXkuZ2V0SG91cnMoKSArIFwiOlwiICsgdG9kYXkuZ2V0TWludXRlcygpICsgXCI6XCIgKyB0b2RheS5nZXRTZWNvbmRzKCk7XG4gICAgICAgIHRoaXMuX2RhdGVUaW1lID0gdGhpcy5fZGF0ZSArICcgJyArIHRoaXMuX3RpbWU7XG4gICAgICAgIHRoaXMuX3RvTG9nID0gdG9Mb2c7XG4gICAgICAgIC8vdGhpcy5fdG9Mb2dBcnJheSA9IHRvTG9nQXJyYXk7XG4gICAgICAgIHRoaXMuX3gxID0geDE7XG4gICAgICAgIHRoaXMuX3kxID0geTE7XG4gICAgICAgIHRoaXMuX3gyID0geDI7XG4gICAgICAgIHRoaXMuX3kyID0geTI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGRhdGUgYW5kIHRpbWUgdG8gbG9nIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gdG9Mb2cgVGhlIGxvZyBtZXNzYWdlXG4gICAgICovXG4gICAgbG9nSXRlbSh0b0xvZykge1xuICAgICAgICByZXR1cm4gXCIgXCIgKyB0aGlzLl9kYXRlVGltZSArIFwiOiBcIiArIHRvTG9nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRhdGUtdGltZSBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXQgZGF0ZVRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgb3IgZWZmZWN0KHMpIHRvIGJlIGxvZ2dlZFxuICAgICAqL1xuICAgIGdldCB0b0xvZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvTG9nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGV2ZW50IHRhZ1xuICAgICAqL1xuICAgIGdldCB0YWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGFnIHN0cmluZ1xuICAgICAqL1xuICAgIHNldCB0YWcodGFnKSB7XG4gICAgICAgIHRoaXMuX3RhZyA9IHRhZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB4MVxuICAgICAqL1xuICAgIGdldCB4MSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3gxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHkxXG4gICAgICovXG4gICAgZ2V0IHkxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgeDJcbiAgICAgKi9cbiAgICBnZXQgeDIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94MjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB5MlxuICAgICAqL1xuICAgIGdldCB5MigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3kyO1xuICAgIH1cbn1cbmV4cG9ydHMuTG9nRXZlbnQgPSBMb2dFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvZ0V2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0xvZ0V2ZW50XCIpO1xuY2xhc3MgUGFpbnRFdmVudCBleHRlbmRzIExvZ0V2ZW50XzEuTG9nRXZlbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIFBhaW50IEV2ZW50LCB1c2VkIHdoZW4gYW4gb2JqZWN0IGlzIHBhaW50ZWQgb24gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB0b0xvZyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QgdG8gYmUgbG9nZ2VkXG4gICAgICogQHBhcmFtIHgxIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0geTEgVGhlIHkgcG9zaXRpb24gb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRvTG9nLCB4MSwgeTEpIHtcbiAgICAgICAgc3VwZXIodG9Mb2csIHgxLCB5MSk7XG4gICAgICAgIHRoaXMudGFnID0gXCJwYWludFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYW5kIHJldHVybnMgbWVzc2FnZSBvZiBmb3JtIFwiUGFpbnRlZCBvYmogYXQgeCwgeVwiIHdpdGggZGF0ZSBhbmQgdGltZSBhdHRhY2hlZFxuICAgICAqL1xuICAgIGFzc2VtYmxlTG9nKCkge1xuICAgICAgICBsZXQgdG9QcmludCA9IFwiUGFpbnRlZCBcIiArIHRoaXMudG9Mb2cgKyBcIiBhdCBcIiArIHRoaXMueDEudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMueTEudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nSXRlbSh0b1ByaW50KTtcbiAgICB9XG59XG5leHBvcnRzLlBhaW50RXZlbnQgPSBQYWludEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFpbnRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ0V2ZW50XzEgPSByZXF1aXJlKFwiLi9Mb2dFdmVudFwiKTtcbmNsYXNzIFJlc2l6ZUV2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIFJlc2l6ZSBFdmVudCwgdXNlZCB3aGVuIGFuIG9iamVjdCBvbiB0aGUgY2FudmFzIGlzIHJlc2l6ZWRcbiAgICAgKiBAcGFyYW0gdG9Mb2cgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QgdG8gYmUgbG9nZ2VkXG4gICAgICogQHBhcmFtIHgxIEluaXRpYWwgeCBkaW1lbnNpb24gb2YgdGhlIG9iamVjdCwgb3IgaW5pdGlhbCBmb250IHNpemVcbiAgICAgKiBAcGFyYW0geTEgSW5pdGlhbCB5IGRpbWVuc2lvbiBvZiB0aGUgb2JqZWN0LCBvciBmaW5hbCBmb250IHNpemVcbiAgICAgKiBAcGFyYW0geDIgRmluYWwgeCBkaW1lbnNpb24gb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB5MiBGaW5hbCB5IGRpbWVuc2lvbiBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9Mb2csIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHN1cGVyKHRvTG9nLCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgIHRoaXMudGFnID0gXCJyZXNpemVcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGxvZyBtZXNzYWdlIG9mIGZvcm0gXCJSZXNpemVkIG9iaiBmcm9tIHNpemUgeDEsIHkxIHRvIHNpemUgeDEsIHkyXCIgZm9yIHJlY3RzIGFuZCBlbGxpcHNlc1xuICAgICAqIG9yIG9mIGZvcm0gXCJSZXNpemVkIG9iaiBmcm9tIHNpemUgeDEgdG8gc2l6ZSB5MVwiIGZvciBzdHJpbmdzXG4gICAgICogSGFzIGRhdGUgYW5kIHRpbWUgYXR0YWNoZWRcbiAgICAgKi9cbiAgICBhc3NlbWJsZUxvZygpIHtcbiAgICAgICAgaWYgKHRoaXMueDIgIT0gdW5kZWZpbmVkICYmIHRoaXMueTIgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnRvUHJpbnQgPSBcIlJlc2l6ZWQgXCIgKyB0aGlzLnRvTG9nICsgXCIgZnJvbSBzaXplIFwiICsgdGhpcy54MS50b1N0cmluZygpICsgXCIgYnkgXCIgKyB0aGlzLnkxLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICArIFwiIHRvIHNpemUgXCIgKyB0aGlzLngyLnRvU3RyaW5nKCkgKyBcIiBieSBcIiArIHRoaXMueTIudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9QcmludCA9IFwiUmVzaXplZCBcIiArIHRoaXMudG9Mb2cgKyBcIiBmcm9tIHNpemUgXCIgKyB0aGlzLngxLnRvU3RyaW5nKCkgKyBcIiB0byBzaXplIFwiICsgdGhpcy55MS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0l0ZW0odGhpcy50b1ByaW50KTtcbiAgICB9XG59XG5leHBvcnRzLlJlc2l6ZUV2ZW50ID0gUmVzaXplRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNpemVFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ0V2ZW50XzEgPSByZXF1aXJlKFwiLi9Mb2dFdmVudFwiKTtcbmNsYXNzIFNlbGVjdEV2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgU2VsZWN0aW9uIEV2ZW50LCB1c2VkIHdoZW4gbXVsdGlwbGUgb2JqZWN0cyBvbiB0aGUgY2FudmFzIGFyZSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB0b0xvZyBUaGUgYXJyYXkgb2Ygb2JqZWN0cyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRvTG9nKSB7XG4gICAgICAgIHN1cGVyKHRvTG9nKTtcbiAgICAgICAgdGhpcy50YWcgPSBcInNlbGVjdFwiO1xuICAgICAgICB0aGlzLl90b1ByaW50ID0gdGhpcy5hc3NlbWJsZVN0cmluZ3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGFuZCByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFsbCB0aGUgb2JqZWN0cyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGFzc2VtYmxlU3RyaW5ncygpIHtcbiAgICAgICAgbGV0IGxvZ1N0cmluZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWxlbSBvZiB0aGlzLnRvTG9nKSB7XG4gICAgICAgICAgICBsb2dTdHJpbmdzLnB1c2goZWxlbS50b1NlbFN0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJTZWxlY3RlZFwiICsgbG9nU3RyaW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSB3aXRoIGRhdGUgYW5kIHRpbWUgYXR0YWNoZWRcbiAgICAgKi9cbiAgICBhc3NlbWJsZUxvZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nSXRlbSh0aGlzLl90b1ByaW50KTtcbiAgICB9XG59XG5leHBvcnRzLlNlbGVjdEV2ZW50ID0gU2VsZWN0RXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZWxlY3RFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jbGFzcyBBbmQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBsb2dpY2FsICdhbmQnICgmJikgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgc2lkZSBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBvcGVyYXRpb24gYW5kIHJldHVybnMgYSBib29sZWFuIG9mIHRoZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlICYmIHJocyBpbnN0YW5jZW9mIEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMudmFsICYmIHJocy52YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50cyB0byB0aGUgJ2FuZCcgb3BlcmF0b3IgbXVzdCBiZSBib29sZWFucy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArICcgYW5kICcgKyB0aGlzLl9yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIHRoZSAnYW5kJyBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSAnYW5kJyBvcGVyYXRpb24gY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVmdCBzaWRlIG9mIHRoZSBvcFxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgb3BcbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLkFuZCA9IEFuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFuZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jbGFzcyBFcXVhbHMge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBlcXVhbGl0eSAoPT0pIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IHNpZGUgb2YgdGhlIGVxdWFsaXR5XG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIGNvbXBhcmlzb24gYW5kIGV2YWx1YXRlcyB0byBhIEJvb2xlYW5Ob2RlXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMuZXF1YWxzVmFsKHJocykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcXVhbGl0eSBvcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLl9sZWZ0LnRvU3RyaW5nKCkgKyAnIGVxdWFscyAnICsgdGhpcy5fcmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2FuJ3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGFuIGVxdWFsaXR5IG9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIndlbGwgdGhpcyBpcyBtZXRhXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbGl0eSBvcHMgY2FuJ3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLkVxdWFscyA9IEVxdWFscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVxdWFscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIEdyZWF0ZXJUaGFuIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgR3JlYXRlclRoYW4gKD4pIG9wXG4gICAgICogQHBhcmFtIGxlZnQgTGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSByaWdodCBSaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgR3JlYXRlclRoYW4gY29tcGFyaXNvbiBhbmQgcmV0dXJucyBCb29sZWFuTm9kZSByZXByZXNlbnRhdGlvbiBvZiByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSAmJiByaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMudmFsID4gcmhzLnZhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50cyB0byB0aGUgPiBvcGVyYXRvciBtdXN0IGJlIG51bWVyaWMuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLl9sZWZ0LnRvU3RyaW5nKCkgKyBcIiA+IFwiICsgdGhpcy5fcmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBHcmVhdGVyVGhhbiBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyZWF0ZXJUaGFuIG9wIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbn1cbmV4cG9ydHMuR3JlYXRlclRoYW4gPSBHcmVhdGVyVGhhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyZWF0ZXJUaGFuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgR3JlYXRlclRoYW5FcSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIEdyZWF0ZXJUaGFuRXEgKGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0bywgPj0pIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IExlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gcmlnaHQgUmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIEdyZWF0ZXJUaGFuRXEgb3BlcmF0aW9uIGFuZCByZXR1cm5zIEJvb2xlYW5Ob2RlIHdpdGggcmVzdWx0XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSAmJiByaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMudmFsID49IHJocy52YWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudHMgdG8gdGhlID49IG9wZXJhdG9yIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArICcgPj0gJyArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gR3JlYXRlclRoYW5FcSBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyZWF0ZXJUaGFuRXEgb3AgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG4gICAgfVxufVxuZXhwb3J0cy5HcmVhdGVyVGhhbkVxID0gR3JlYXRlclRoYW5FcTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyZWF0ZXJUaGFuRXEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jbGFzcyBMZXNzVGhhbiB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIExlc3NUaGFuICg8KSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBMZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0IFJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgTGVzc1RoYW4gY29tcGFyaXNvbiBhbmQgcmV0dXJucyBCb29sZWFuTm9kZSB3aXRoIHJlc3VsdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KSArIFwiIGlzIGxlc3MgdGhhbiBcIiArIHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCkpO1xuICAgICAgICBsZXQgbGhzID0gdGhpcy5fbGVmdC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBsZXQgcmhzID0gdGhpcy5fcmlnaHQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgaWYgKGxocyBpbnN0YW5jZW9mIE51bWJlck5vZGVfMS5OdW1iZXJOb2RlICYmIHJocyBpbnN0YW5jZW9mIE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiVGhleSdyZSBib3RoIG51bWJlciBub2Rlc1wiKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cobGhzLnZhbCArIFwiPFwiICsgcmhzLnZhbCk7XG4gICAgICAgICAgICAvL2xldCBib29sOiBib29sZWFuID0gbGhzLnZhbCA8IHJocy52YWw7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiYm9vbDogXCIgKyBib29sKTtcbiAgICAgICAgICAgIHJldHVybiAobmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLnZhbCA8IHJocy52YWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50cyB0byBsZXNzIHRoYW4gbXVzdCBwcm9kdWNlIG51bWVyaWMgdmFsdWVzLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArICcgPCAnICsgdGhpcy5fcmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBMZXNzVGhhbiBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlc3NUaGFuIG9wIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc1RoYW4gPSBMZXNzVGhhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NUaGFuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgTGVzc1RoYW5FcSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIExlc3NUaGFuRXEgKGxlc3MgdGhhbiBvciBlcXVhbCB0bywgPD0pIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IHNpZGUgb2YgdGhlIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgTGVzc1RoYW5FcSBjb21wYXJpc29uIGFuZCByZXR1cm5zIEJvb2xlYW5Ob2RlIHdpdGggcmVzdWx0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsaHMgPSB0aGlzLl9sZWZ0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGxldCByaHMgPSB0aGlzLl9yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUgJiYgcmhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLnZhbCA8PSByaHMudmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJndW1lbnRzIHRvIHRoZSA8PSBvcGVyYXRvciBtdXN0IGJlIG51bWVyaWMuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLl9sZWZ0LnRvU3RyaW5nKCkgKyBcIiA8PSBcIiArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gTGVzc1RoYW5FcSBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlc3NUaGFuRXEgb3BzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc1RoYW5FcSA9IExlc3NUaGFuRXE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzVGhhbkVxLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNsYXNzIE5vdCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBsb2dpY2FsIE5vdCAoISkgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGV4cHIgVGhlIGV4cHJlc3Npb24gdG8gYmUgb3BlcmF0ZWQgb24gKG11c3QgYmUgYSBCb29sZWFuTm9kZSlcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihleHByLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2V4cHIgPSBleHByO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIE5vdCBvcGVyYXRpb24gYW5kIHJldHVybnMgQm9vbGVhbk5vZGUgd2l0aCByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGUgPSB0aGlzLl9leHByLmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKCFlLnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJndW1lbnQgdG8gdGhlICEgb3BlcmF0b3IgbXVzdCBiZSBib29sZWFuLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJub3QgXCIgKyB0aGlzLl9leHByLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBOb3Qgb3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3Qgb3BlcmF0aW9ucyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGV4cHJlc3Npb24gdG8gYmUgb3BlcmF0ZWQgb25cbiAgICAgKi9cbiAgICBnZXQgZXhwcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHI7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3QgPSBOb3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jbGFzcyBOb3RFcXVhbCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIE5vdEVxdWFsICghPSkgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgTGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSByaWdodCBSaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgTm90RXF1YWwgb3BlcmF0aW9uIGFuZCByZXR1cm5zIEJvb2xlYW5Ob2RlIHdpdGggcmVzdWx0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsaHMgPSB0aGlzLl9sZWZ0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGxldCByaHMgPSB0aGlzLl9yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUgJiYgcmhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLnZhbCAhPT0gcmhzLnZhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50cyB0byB0aGUgIT0gb3BlcmF0b3IgbXVzdCBiZSBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5fbGVmdC50b1N0cmluZygpICsgXCIgbm90IGVxdWFscyBcIiArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBOb3RFcXVhbCBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdEVxdWFsIG9wcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLk5vdEVxdWFsID0gTm90RXF1YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob3RFcXVhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jbGFzcyBPciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGxvZ2ljYWwgJ29yJyAofHwpIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IExlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gcmlnaHQgUmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIE9yIG9wZXJhdGlvbiBhbmQgcmV0dXJucyBCb29sZWFuTm9kZSB3aXRoIHJlc3VsdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IEN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsaHMgPSB0aGlzLl9sZWZ0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGxldCByaHMgPSB0aGlzLl9yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZSAmJiByaHMgaW5zdGFuY2VvZiBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLnZhbCB8fCByaHMudmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudHMgdG8gdGhlICdvcicgb3BlcmF0b3IgbXVzdCBiZSBib29sZWFucy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArICcgb3IgJyArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gT3Igb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3Igb3BlcmF0aW9ucyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLk9yID0gT3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Pci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jb25zdCBzcGFjZV9saWZ0XzEgPSByZXF1aXJlKFwic3BhY2UtbGlmdFwiKTtcbmNsYXNzIEZvck5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIEZvciBsb29wXG4gICAgICogQHBhcmFtIGluaXQgSW5pdGlhbGl6ZXMgdGhlIHZhcmlhYmxlIHVzZWQgaW4gdGhlIGNvbmRpdGlvblxuICAgICAqIEBwYXJhbSBjb25kIFRoZSBjb25kaXRpb24gKG11c3QgZXZhbHVhdGUgdG8gQm9vbGVhbk5vZGUpXG4gICAgICogQHBhcmFtIHBvc3QgVGhlIHBvc3RldmFsdWF0aW9uIGNvbmRpdGlvblxuICAgICAqIEBwYXJhbSBib2R5IFRoZSBib2R5IG9mIHRoZSBsb29wXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW5pdCwgY29uZCwgcG9zdCwgYm9keSwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2luaXQgPSBpbml0O1xuICAgICAgICB0aGlzLl9jb25kID0gY29uZDtcbiAgICAgICAgdGhpcy5fcG9zdCA9IHBvc3Q7XG4gICAgICAgIHRoaXMuX2JvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBGb3IgbG9vcFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgY2hpbGRDdHggPSBuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0LCBjb250ZXh0LmVmZmVjdHMsIGNvbnRleHQuZXZlbnRMb2cpO1xuICAgICAgICBjaGlsZEN0eC5jYW52YXMgPSBzcGFjZV9saWZ0XzEuU29tZShjb250ZXh0LmNhbnZhcy5nZXQoKSk7XG4gICAgICAgIHRoaXMuX2luaXQuZXZhbChjaGlsZEN0eCk7IC8vIGluaXRpYWxpemUgdmFyXG4gICAgICAgIGxldCByZXMgPSB0aGlzLl9jb25kLmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICBpZiAoIShyZXMgaW5zdGFuY2VvZiBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbmRpdGlvbiBtdXN0IGJlIGEgYm9vbGVhbiBleHByZXNzaW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV0O1xuICAgICAgICB3aGlsZSAocmVzLnZhbCkge1xuICAgICAgICAgICAgcmV0ID0gdGhpcy5fYm9keS5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgICAgIHRoaXMuX3Bvc3QuZXZhbChjaGlsZEN0eCk7XG4gICAgICAgICAgICByZXMgPSB0aGlzLl9jb25kLmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIEZvck5vZGVcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIEZvciBsb29wXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JOb2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHJldHVybiBcIkNhbm5vdCBjYWxsIGRyYXcgb24gRm9yIGxvb3BcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZm9yIGxvb3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgJ2ZvcignICsgdGhpcy5faW5pdC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5fY29uZC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5fcG9zdC50b1N0cmluZygpICsgXCIpIHtcXG4gXCJcbiAgICAgICAgICAgICsgdGhpcy5fYm9keS50b1N0cmluZygpICsgXCJ9XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkZvck5vZGUgPSBGb3JOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Rm9yTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jb25zdCBzcGFjZV9saWZ0XzEgPSByZXF1aXJlKFwic3BhY2UtbGlmdFwiKTtcbmNsYXNzIFdoaWxlTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgV2hpbGUgbG9vcFxuICAgICAqIEBwYXJhbSBjb25kIFRoZSBXaGlsZSBsb29wIGNvbmRpdGlvblxuICAgICAqIEBwYXJhbSBib2R5IFRoZSBib2R5IG9mIHRoZSBsb29wXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZCwgYm9keSwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NvbmQgPSBjb25kO1xuICAgICAgICB0aGlzLl9ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyB0aGUgYm9keSBvZiB0aGUgbG9vcCB3aGlsZSB0aGUgY29uZGl0aW9uIGlzIHRydWVcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgY2hpbGRDdHggPSBuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0LCBjb250ZXh0LmVmZmVjdHMsIGNvbnRleHQuZXZlbnRMb2cpO1xuICAgICAgICBjaGlsZEN0eC5jYW52YXMgPSBzcGFjZV9saWZ0XzEuU29tZShjb250ZXh0LmNhbnZhcy5nZXQoKSk7XG4gICAgICAgIGxldCByZXMgPSB0aGlzLl9jb25kLmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICBpZiAoIShyZXMgaW5zdGFuY2VvZiBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbmRpdGlvbiBtdXN0IGJlIGEgYm9vbGVhbiBleHByZXNzaW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV0O1xuICAgICAgICB3aGlsZSAocmVzLnZhbCkge1xuICAgICAgICAgICAgcmV0ID0gdGhpcy5fYm9keS5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgICAgIHJlcyA9IHRoaXMuX2NvbmQuZXZhbChjaGlsZEN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gV2hpbGVOb2Rlc1xuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gV2hpbGUgbG9vcFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hpbGVOb2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHJldHVybiBcIkNhbm5vdCBjYWxsIGRyYXcgb24gV2hpbGUgbG9vcFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBXaGlsZSBsb29wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwid2hpbGUoXCIgKyB0aGlzLl9jb25kLnRvU3RyaW5nKCkgKyBcIikge1xcbiBcIiArIHRoaXMuX2JvZHkudG9TdHJpbmcoKSArIFwifVwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5XaGlsZU5vZGUgPSBXaGlsZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XaGlsZU5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFbGxpcHNlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9FbGxpcHNlRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uRm91ckNwT25lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDRjMVwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2w0YzInO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFlvdSd2ZSBtYWRlIGl0IHRvIHRoZSBGSU5BTCBDSEFMTEVOR0VTISBDb21wbGV0ZSB0aGVzZSBjaGFsbGVuZ2VzIHRvIGVhcm4gRVRFUk5BTCBHTE9SWSEgPC9wPlxuICAgIDxwPiBUaHJvdWdob3V0IHRoaXMgSG91ciBvZiBDb2RlLCB5b3UgaGF2ZSBsZWFybmVkOiA8L3A+XG4gICAgPHA+IC0gSG93IHRvIHByaW50IGEgd29yZCwgY2lyY2xlLCByZWN0YW5nbGUsIGFuZCBjdXJ2ZS4gPC9wPlxuICAgIDxwPiAtIEhvdyB0byBzdG9yZSBhbnkgb2YgdGhlIHZhbHVlIGFib3ZlIGluIGEgdmFyaWFibGUuIDwvcD5cbiAgICA8cD4gLSBIb3cgdG8gdXNlIGlmL2Vsc2Ugc3RhdGVtZW50IHRvIGNoZWNrIGEgY29uZGl0aW9uIGFib3V0IGEgdmFyaWFibGUuIDwvcD5cbiAgICA8cD4gRWFjaCBvZiB0aGUgZm9sbG93aW5nIGNoYWxsZW5nZXMgd2lsbCB0ZXN0IHRoZXNlIGNvbmNlcHRzLiBMZXQncyBkaXZlIHJpZ2h0IGluISA8L3A+XG4gICAgPHA+IFByaW50IGEgY2lyY2xlIGFuZCBwdXQgaXRzIGhlaWdodCBhbmQgd2lkdGggaW4gb25lIG9mIHRoZSBib3hlcyB0byB0aGUgc2lkZS4gVGhlbiBwcmludCBhIHJlY3RhbmdsZSBhbmQgcHV0IGl0cyBoZWlnaHQgYW5kIHdpZHRoIGluIHRoZSBib3guIDwvcD5cbiAgICA8cD4gQ0hBTExFTkdFOiBQcmludCBhIGNpcmNsZSBhbmQgcmVjdGFuZ2xlLiBQdXQgdGhlaXIgcmVzcGVjdGl2ZSB3aWR0aCBhbmQgaGVpZ2h0IGluIHRoZSBib3hlcyBwcm92aWRlZC4gPC9wPmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIGxlYWRpbmcgaW50byBjb25kaXRpb25hbHNcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRcIikudmFsdWU7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZWdleCA9IC9wcmludFxccypcXChcXHMqZWxsaXBzZVxccypcXChcXHMqWzEtOV1bMC05XSpcXHMqLFxccypbMS05XVswLTldKlxccypcXClcXHMqLFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKTsvO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gY29kZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgbGV0IGNhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvbkZvdXJDcE9uZSA9IExlc3NvbkZvdXJDcE9uZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvbkZvdXJDcE9uZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25Gb3VyQ3BUd28ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsNGMyXCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDRjMic7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gWWVzISBZb3UgZ290IHRoaXMhIDwvcD5cbiAgICA8cD4gTm93IGxldCdzIHB1dCB0aG9zZSBza2lsbHMgaW4gaWYvZWxzZSBzdGF0ZW1lbnRzIHRvIHdvcmshIDwvcD5cbiAgICA8cD4gQ3JlYXRlIGEgcGFpciBvZiBpZi9lbHNlIHN0YXRlbWVudHMgdG8gcHJpbnQgb3V0IHRvIHRoZSBDQU5WQVMgYSBjbGFpbSBvZiB3aGV0aGVyIHRoZSBjaXJjbGUgaXMgcG9zaXRpb25lZCBBQk9WRSBvciBCRUxPVyB0aGUgcmVjdGFuZ2xlLiA8L3A+XG4gICAgPHA+IENIQUxMRU5HRTogUHJpbnQgYSBjbGFpbSB0aGF0IHN0YXRlcyB3aGV0aGVyIGNpcmNsZSBpcyBBQk9WRSBvciBCRUxPVyB0aGUgcmVjdGFuZ2xlLiA8L3A+XG4gICAgPHA+IEhJTlQ6IFJlbWVtYmVyIHRoYXQgdGhlIG51bWJlcnMgaW4gdGhlIHByaW50KCkgc3RhdGVtZW50cyBkZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIHRoZSBzaGFwZXMgYmVpbmcgcHJpbnRlZC4gPC9wPmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIGxlYWRpbmcgaW50byBjb25kaXRpb25hbHNcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRcIikudmFsdWU7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZWdleCA9IC9wcmludFxccypcXChcXHMqZWxsaXBzZVxccypcXChcXHMqWzEtOV1bMC05XSpcXHMqLFxccypbMS05XVswLTldKlxccypcXClcXHMqLFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKTsvO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gY29kZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgbGV0IGNhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvbkZvdXJDcFR3byA9IExlc3NvbkZvdXJDcFR3bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvbkZvdXJDcFR3by5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uT25lQ3BGb3VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDFjNFwiO1xuICAgICAgICB0aGlzLl9wcmV2TW9kdWxlID0gJ2wxYzInO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wyYzEnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ2NhbnZhcyc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gTm90ZSB0aGF0IGNoYW5naW5nIHRoZSBmaXJzdCBudW1iZXIgaW4gdGhlIHByaW50IHN0YXRlbWVudCBtb3ZlcyB0aGUgd29yZHMgbGVmdCBvciByaWdodCwgd2hpbGUgY2hhbmdpbmcgdGhlIHNlY29uZCBudW1iZXIgbW92ZSB0aGVtIHVwIG9yIGRvd24uIDwvcD5cbiAgICA8cD4gTm93IHRpbWUgZm9yIGEgY2hhbGxlbmdlISBQcmludCB0aGUgd29yZCBcIm1vb1wiIG9uIHRoZSBDQU5WQVMsIGFuZCBwdXQgaXQgcmlnaHQgaW4gdGhlIGNlbnRlciBvZiB0aGUgZW50aXJlIENBTlZBUy4gPC9wPlxuICAgIDxwPiBDSEFMTEVOR0U6IFByaW50IHRoZSB3b3JkIFwibW9vXCIgaW4gdGhlIGNlbnRlciBvZiB0aGUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IEhJTlQ6IFdyaXRlIHByaW50KFwibW9vXCIsIDUwLCA1MCkgaW4gdGhlIENPREUgYXJlYSBmaXJzdCwgdGhlbiBjaGFuZ2UgdGhlIG51bWJlcnMgaW5zaWRlIHRoYXQgcHJpbnQgc3RhdGVtZW50LiA8L3A+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciA9PT0gXCJtb29cIikge1xuICAgICAgICAgICAgICAgIGlmICgoZWZmZWN0LnggPiAyMDAgJiYgZWZmZWN0LnggPCAzMDApICYmIChlZmZlY3QueSA+IDIwMCAmJiBlZmZlY3QueSA8IDMwMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uT25lQ3BGb3VyID0gTGVzc29uT25lQ3BGb3VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uT25lQ3BGb3VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3RyaW5nRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9TdHJpbmdFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25PbmVDcE9uZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwxYzFcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsMWMyJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBUbyBiZWdpbiwgbGV04oCZcyB0ZWxsIHRoZSBjb21wdXRlciB0byB3cml0ZSBzb21ldGhpbmcgb24gdGhlIENBTlZBUy4gPC9wPlxuICAgIDxwPiBHT0FMOiB3cml0ZSBvbiB0aGUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IEhJTlQ6IHR5cGUgaW4gdGhlIENPREUgYm94OiBwcmludChcIkhlbGxvLCB3b3JsZCFcIiksIHRoZW4gaGl0IHRoZSBSVU4gYnV0dG9uLiA8L3A+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2Fsczogd3JpdGUgYW55IHN0cmluZyBvbiBDQU5WQVNcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LnN0ciAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25PbmVDcE9uZSA9IExlc3Nvbk9uZUNwT25lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uT25lQ3BPbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3Nvbk9uZUNwVGhyZWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMWMzXCI7XG4gICAgICAgIHRoaXMuX3ByZXZNb2R1bGUgPSAnbDFjMic7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDFjNCc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnY2FudmFzJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBZZXAhIE1vdmluZyB0aGUgd29yZHMgYWN0dWFsbHkgY2hhbmdlIHRoZSBudW1iZXJzIGluIHlvdXIgQ09ERS4gPC9wPlxuICAgIDxwPiBOb3cgdGhlIENBTlZBUyBoYXMgYmVlbiBmcm96ZW4hIFRyeSBjaGFuZ2luZyB5b3VyIENPREUgdG8gc2VlIGlmIHlvdSBjYW4gbW92ZSB0aGUgd29yZHMgdG8gdGhlIGJvdHRvbSByaWdodCBjb3JuZXIuIDwvcD5cbiAgICA8cD4gR09BTDogTW92ZSB0aGUgd29yZHMgdG8gdGhlIGJvdHRvbSByaWdodCBvZiB0aGUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IEhJTlQ6IENoYW5nZSBvbmUgb2YgdGhlIDIgbnVtYmVycyBhdCBhIHRpbWUsIHRoZW4gY2xpY2sgUlVOIHRvIHNlZSBob3cgdGhhdCBjaGFuZ2VzIHRoZSBDQU5WQVMuYDtcbiAgICAgICAgdGhpcy54ID0gMTA7XG4gICAgICAgIHRoaXMueSA9IDQzMDtcbiAgICB9XG4gICAgZHJhd0d1aWRlcyhjdHgpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucmVjdCh0aGlzLngsIHRoaXMueSwgMTAwLCAxMDApO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmZvbnQgPSAyMCArIFwicHggQ291cmllciBOZXdcIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgY3R4LmZpbGxUZXh0KFwiUHV0IHRleHRcIiwgdGhpcy54LCAzOTApO1xuICAgICAgICBjdHguZmlsbFRleHQoXCJpbiBoZXJlXCIsIHRoaXMueCwgNDEwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QueCA+IHRoaXMueCAmJiBlZmZlY3QueCA8IHRoaXMueCArIDEwMCAmJiBlZmZlY3QueSA+IHRoaXMueSAmJiBlZmZlY3QueSA8IHRoaXMueSArIDEwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25PbmVDcFRocmVlID0gTGVzc29uT25lQ3BUaHJlZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3Nvbk9uZUNwVGhyZWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3Nvbk9uZUNwVHdvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDFjMlwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wxYzMnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ2NvZGUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFlvdSBqdXN0IHRvbGQgdGhlIGNvbXB1dGVyIHRvIHdyaXRlIHdvcmRzIG9uIHRoZSBDQU5WQVMhIDwvcD5cbiAgICA8cD4gTm93IGxldCdzIGRvIHNvbWV0aGluZyBtb3JlIGludGVyZXN0aW5nOiBjbGljayBvbiB0aGUgd29yZHMgb24gdGhlIENBTlZBUywgdGhlbiBkcmFnIGl0IGluc2lkZSB0aGUgYm94IGF0IHRoZSB0b3AtcmlnaHQgY29ybmVyLiBPYnNlcnZlIHdoYXQgaGFwcGVucyB0byB5b3VyIGNvZGUuIDwvcD5cbiAgICA8cD4gR09BTDogTW92ZSB0aGUgd29yZHMgeW91IGp1c3QgY3JlYXRlZCBpbnNpZGUgdGhlIHRvcC1yaWdodCBib3guIDwvcD5gO1xuICAgICAgICB0aGlzLnggPSAzOTA7XG4gICAgICAgIHRoaXMueSA9IDEwO1xuICAgIH1cbiAgICBkcmF3R3VpZGVzKGN0eCkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5yZWN0KHRoaXMueCwgdGhpcy55LCAxMDAsIDEwMCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguZm9udCA9IDIwICsgXCJweCBDb3VyaWVyIE5ld1wiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICBjdHguZmlsbFRleHQoXCJQdXQgdGV4dFwiLCAzOTAsIDEzMCk7XG4gICAgICAgIGN0eC5maWxsVGV4dChcImluIGhlcmVcIiwgMzkwLCAxNTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC54ID4gdGhpcy54ICYmIGVmZmVjdC54IDwgdGhpcy54ICsgMTAwICYmIGVmZmVjdC55ID4gdGhpcy55ICYmIGVmZmVjdC55IDwgdGhpcy55ICsgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3Nvbk9uZUNwVHdvID0gTGVzc29uT25lQ3BUd287XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25PbmVDcFR3by5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVGhyZWVDcEZpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsM2M1XCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDNjNic7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gU28gd2UgcHJpbnQgYSBtZXNzYWdlIHRvIHRoZSBDQU5WQVMgYW55dGltZSBjIGlzIGV4YWN0bHkgZXF1YWwgdG8gOC4gPC9wPlxuICAgIDxwPiBXaGF0IGlmIHdlIHdhbnQgdG8gcHJpbnQgYW5vdGhlciBtZXNzYWdlLCBcImMgaXMgbm90IGVxdWFsIHRvIDhcIiBhbnkgdGltZSBjIGlzIG5vdCBlcXVhbCB0byA4PyA8L3A+XG4gICAgPHA+IFdlIGRvIHNvIGJ5IHVzaW5nIGFuIGVsc2Ugc3RhdGVtZW50LiBPYnNlcnZlIHRoZSBDT0RFIGFib3ZlLiA8L3A+XG4gICAgPHA+IFdoZW4gdGhlIGNvbmRpdGlvbiBpbnNpZGUgdGhlIGlmKCkgc3RhdGVtZW50IGlzIHNhdGlzZmllZCwgdGhlIGNvZGUgYmxvY2sgaW5zaWRlIHRoZSB7fSByaWdodCBhZnRlciBpdCB3b3VsZCBydW4uIDwvcD5cbiAgICA8cD4gV2hlbiB0aGF0IGNvbmRpdGlvbiBpcyBub3Qgc2F0aXNmaWVkLCB0aGUgY29kZSBibG9jayBpbnNpZGUgdGhlIHt9IGFmdGVyIHRoZSBlbHNlIHN0YXRlbWVudCB3b3VsZCBydW4uIDwvcD5cbiAgICA8cD4gR09BTDogQ2hhbmdlIHRoZSB2YWx1ZSBvZiBjIHNvIHRoYXQgdGhlIGxpbmUgXCJjIGlzIE5PVCBlcXVhbCB0byA4LlwiIGlzIHByaW50ZWQgb24gdGhlIENBTlZBUy4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYGMgPSA4O1xuaWYoYyA9PSA4KSB7XG4gIHByaW50KFwiYyBpcyBlcXVhbCB0byA4LlwiLCAxMDMsIDE0Myk7XG59IGVsc2Uge1xuICBwcmludChcImMgaXMgTk9UIGVxdWFsIHRvIDguXCIsIDEwMywgMTQzKTtcbn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiBsZWFkaW5nIGludG8gY29uZGl0aW9uYWxzXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvY1xccyo9XFxzKlteOF1cXHMqLztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciA9PT0gXCJjIGlzIE5PVCBlcXVhbCB0byA4LlwiKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblRocmVlQ3BGaXZlID0gTGVzc29uVGhyZWVDcEZpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25UaHJlZUNwRml2ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVGhyZWVDcEZvdXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsM2M0XCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDNjNSc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gWW91IGNhbiBwdXQgYW4gaW5lcXVhbGl0eSBjb25kaXRpb24gaW4gdGhlIGlmKCkgY2xhdXNlLCBzdWNoIGFzIFwiYSA8IDVcIiBvciBcImIgPiAyMFwiLiA8L3A+XG4gICAgPHA+IFlvdSBjYW4gYWxzbyB1c2UgYW4gZXF1YWxpdHkgY29uZGl0aW9uLiBPYnNlcnZlIHRoZSBDT0RFIGFib3ZlIHdpdGggXCJjID09IDhcIi4gVGhlIDIgZXF1YWwgc2lnbnMgbWVhbiB0aGF0IHlvdSBhcmUgY2hlY2tpbmcgd2hldGhlciBjIGlzIGV4YWN0bHkgZXF1YWwgdG8gOCBvciBub3QuIDwvcD5cbiAgICA8cD4gQ2hhbmdlIHRoZSB2YWx1ZSBvZiBjIHNvIHRoYXQgdGhlIGxpbmUgXCJjIGlzIGVxdWFsIHRvIDguXCIgaXMgcHJpbnRlZCBvbiB0aGUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IEdPQUw6IENoYW5nZSB0aGUgdmFsdWUgb2YgYyBzbyB0aGF0IHRoZSBsaW5lIFwiYyBpcyBlcXVhbCB0byA4LlwiIGlzIHByaW50ZWQgb24gdGhlIENBTlZBUy4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYGMgPSAxMDA7XG5pZihjID09IDgpIHtcbiAgcHJpbnQoXCJjIGlzIGVxdWFsIHRvIDguXCIsIDEwMywgMTQzKTtcbn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiBsZWFkaW5nIGludG8gY29uZGl0aW9uYWxzXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvY1xccyo9XFxzKjhcXHMqLztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciA9PT0gXCJjIGlzIGVxdWFsIHRvIDguXCIpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVGhyZWVDcEZvdXIgPSBMZXNzb25UaHJlZUNwRm91cjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblRocmVlQ3BGb3VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3RyaW5nRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9TdHJpbmdFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25UaHJlZUNwT25lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDNjMVwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wzYzInO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFdlIGxlYXJuZWQgdG8gdGVsbCB0aGUgY29tcHV0ZXIgdG8gcHJpbnQgYSBsb3Qgb2YgdGhpbmdzLiBVbmZvcnR1bmF0ZWx5LCB0aGUgY29tcHV0ZXIgaXMga2luZGEgYmFkIGF0IG1hdGguIDwvcD5cbiAgICA8cD4gTG9vayBhdCB0aGUgQ09ERSBhYm92ZS4gV2UgbGV0IGEgPSA1LCB0aGVuIHdlIHByaW50IHRoZSB2YWx1ZSBvZiBhIHRvIHRoZSBDQU5WQVMuIFRoZW4gd2UgcHJpbnQgdGhlIGxpbmUgXCJhIGlzIGxlc3MgdGhhbiAxMFwiLiA8L3A+XG4gICAgPHA+IFNpbmNlIGEgPSA1LCBhbmQgNSA8IDEwLCB3ZSBrbm93IHRoYXQgYSBpcyBsZXNzIHRoYW4gMTAuIEJ1dCB3aGF0IHdvdWxkIGhhcHBlbiBpZiB3ZSBjaGFuZ2UgdGhlIHZhbHVlIG9mIGEgdG8sIHNheSwgMTI/IDwvcD5cbiAgICA8cD4gR09BTDogY2hhbmdlIHRoZSB2YWx1ZSBvZiBhIHRvIDEyLiA8L3A+XG4gICAgPHA+IEhJTlQ6IFlvdSBjYW4gZG8gdGhpcyBieSBjaGFuZ2luZyB0aGUgbGluZSBhID0gNSBpbiB0aGUgQ09ERSBhcmVhLCBvciB5b3UgY2FuIGNsaWNrIG9uIHRoZSBudW1iZXIgNSBvbiB0aGUgQ0FOVkFTLiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgYSA9IDU7XG5wcmludChhLCAxMTgsIDYzKTtcbnByaW50KFwiYSBpcyBsZXNzIHRoYW4gMTBcIiwgMTAzLCAxNDMpO2A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIGxlYWRpbmcgaW50byBjb25kaXRpb25hbHNcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRcIikudmFsdWU7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZWdleCA9IC9hXFxzKj1cXHMqMTJcXHMqLztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyID09PSBcImEgaXMgbGVzcyB0aGFuIDEwXCIpIHtcbiAgICAgICAgICAgICAgICAvL2NhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy9icmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblRocmVlQ3BPbmUgPSBMZXNzb25UaHJlZUNwT25lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVGhyZWVDcE9uZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25UaHJlZUNwU2l4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDNjNlwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2w0YzEnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IE5vdyB0aGF0IHlvdSBrbm93IGhvdyB0byB1c2UgaWYvZWxzZSBzdGF0ZW1lbnRzLCBsZXQncyBwdXQgdGhlbSBhbGwgdG9nZXRoZXIhIDwvcD5cbiAgICA8cD4gQWJvdmUgd2UgaGF2ZSB0aGUgQ09ERSB0byBkcmF3IDIgY2lyY2xlczogY2lyY2xlIEEgaGFzIGhlaWdodCBhbmQgd2lkdGggYSwgYW5kIGNpcmNsZSBCIGhhcyBoZWlnaHQgYW5kIHdpZHRoIGIuIDwvcD5cbiAgICA8cD4gSG93ZXZlciwgY3VycmVudGx5IHRoZSBjbGFpbSB0aGF0IFwiQ2lyY2xlIEEgaXMgc21hbGxlciB0aGFuIGNpcmNsZSBCLlwiIHJlZ2FyZGxlc3Mgb2YgdGhlIGNpcmNsZXMnIGFjdHVhbCBzaXplcy4gPC9wPlxuICAgIDxwPiBDcmVhdGUgYW4gaWYvZWxzZSBzdGF0ZW1lbnQgdG8gcHJpbnQgXCJDaXJjbGUgQSBpcyBzbWFsbGVyIHRoYW4gY2lyY2xlIEIuXCIgd2hlbiBpdCBpcyBhY3R1YWxseSBzbywgYW5kIHByaW50IFwiQ2lyY2xlIEEgaXMgYmlnZ2VyIHRoYW4gY2lyY2xlIEJcIiBvdGhlcndpc2UuIDwvcD5cbiAgICA8cD4gQ0hBTExFTkdFOiBDcmVhdGUgYW4gaWYvZWxzZSBzdGF0ZW1lbnQgdG8gcHJpbnQgdGhlIGNvcnJlY3QgY2xhaW0gYWJvdXQgdGhlIHNpemVzIG9mIHRoZSAyIGNpcmNsZXMuIDwvcD5gO1xuICAgICAgICB0aGlzLl9zdGFydGVyQ29kZSA9IGBhID0gMjAwO1xucHJpbnQoYSwgMTExLCAxMDMpO1xucHJpbnQoZWxsaXBzZShhLCBhKSwgMTMyLCAyODcpO1xuYiA9IDEwMDtcbnByaW50KGIsIDMzNywgMTA0KTtcbnByaW50KGVsbGlwc2UoYiwgYiksIDM3MSwgMjQ4KTtcbnByaW50KFwiQ2lyY2xlIEEgaXMgc21hbGxlciB0aGFuIGNpcmNsZSBCLlwiLCA0NSwgNDUzKTtcbmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIGxlYWRpbmcgaW50byBjb25kaXRpb25hbHNcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRcIikudmFsdWU7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZWdleCA9IC9wcmludFxccypcXChcXHMqZWxsaXBzZVxccypcXChcXHMqWzEtOV1bMC05XSpcXHMqLFxccypbMS05XVswLTldKlxccypcXClcXHMqLFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKTsvO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gY29kZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgbGV0IGNhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblRocmVlQ3BTaXggPSBMZXNzb25UaHJlZUNwU2l4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVGhyZWVDcFNpeC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVGhyZWVDcFRocmVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDNjM1wiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wzYzQnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IGlmIHN0YXRlbWVudHMgYWxsb3cgeW91IHRvIHJ1biBhIGJsb2NrIG9mIGNvZGUgaW5zaWRlIHRoZSBjdXJseSBicmFjZXMge30gT05MWSB3aGVuIHRoZSBjb25kaXRpb24gaW5zaWRlIHRoZSBpZigpIGNsYXVzZSBpcyB0cnVlLiA8L3A+XG4gICAgPHA+IExldCdzIGhhdmUgYSBxdWljayBjaGFsbGVuZ2U6IG9ic2VydmUgdGhlIENPREUgYWJvdmUuIE1ha2UgaXQgc28gdGhhdCB0aGUgbGluZSBcImIgaXMgZ3JlYXRlciB0aGFuIDIwXCIgaXMgb25seSBwcmludGVkIG9uIHRoZSBDQU5WQVMgd2hlbiBiIGlzIGFjdHVhbGx5IGdyZWF0ZXIgdGhhbiAyMC4gPC9wPlxuICAgIDxwPiBHT0FMOiBNYWtlIHRoZSBsaW5lIFwiYiBpcyBncmVhdGVyIHRoYW4gMjBcIiBvbmx5IGJlIHByaW50ZWQgb24gdGhlIENBTlZBUyB3aGVuIGIgaXMgYWN0dWFsbHkgZ3JlYXRlciB0aGFuIDIwLiBDaGFuZ2UgYiB0byBhIG51bWJlciBncmVhdGVyIHRoYW4gMjAgdG8gdGVzdC4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYGIgPSA4O1xuaWYoYiA8IDEwKSB7XG4gIHByaW50KFwiYiBpcyBncmVhdGVyIHRoYW4gMjAuXCIsIDEwMywgMTQzKTtcbn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiBsZWFkaW5nIGludG8gY29uZGl0aW9uYWxzXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvaWZcXHMqXFwoXFxzKmJcXHMqPlxccyoyMFxccypcXCkvO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gY29kZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgbGV0IGNhbnZhc0lzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyID09PSBcImIgaXMgZ3JlYXRlciB0aGFuIDIwLlwiKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblRocmVlQ3BUaHJlZSA9IExlc3NvblRocmVlQ3BUaHJlZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblRocmVlQ3BUaHJlZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVGhyZWVDcFR3byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwzYzJcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsM2MzJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBEaWQgeW91IG5vdGljZSB0aGUgY2xhaW0gdGhhdCBcImEgaXMgbGVzcyB0aGFuIDEwXCIgZGlkIG5vdCBjaGFuZ2U/IGEgaXMgbm93IDEyIGFuZCBjbGVhcmx5IGdyZWF0ZXIgdGhhbiAxMCEgPC9wPlxuICAgIDxwPiBXaGF0IHdlIHdhbnQgaXMgZm9yIHRoZSBjb21wdXRlciB0byBvbmx5IHByaW50IFwiYSBpcyBsZXNzIHRoYW4gMTBcIiBPTkxZIHdoZW4gdGhlIHZhbHVlIG9mIGEgaXMgdHJ1bHkgbGVzcyB0aGFuIDEwLiA8L3A+XG4gICAgPHA+IFRvIGRvIHNvLCB3ZSB1c2UgYW4gaWYgc3RhdGVtZW50LiBPYnNlcnZlIHRoZSBDT0RFIGFib3ZlLiBBbGwgd2UgY2hhbmdlZCB3YXMgdG8gcHV0IGluIGFuIGlmIHN0YXRlbWVudCB0aGF0IGNoZWNrcyB3aGV0aGVyIGEgPCAxMC4gSWYgYSBpcywgdGhlIGNvZGUgaW5zaWRlIHRoZSBjdXJseSBicmFjZXMge30gYXJlIGV4ZWN1dGVkLiA8L3A+XG4gICAgPHA+IENoYW5nZSB0aGUgdmFsdWUgb2YgYSB0byAxMiwgMTAsIDggYW5kIG9ic2VydmUgd2hhdCBoYXBwZW5zLiA8L3A+XG4gICAgPHA+IEdPQUw6IFJVTiB0aGUgQ09ERSB3aXRoIGEgPSAxMiBvciAxMCBvciA4LiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgYSA9IDEyO1xucHJpbnQoYSwgMTE4LCA2Myk7XG5pZihhIDwgMTApIHtcbiAgcHJpbnQoXCJhIGlzIGxlc3MgdGhhbiAxMFwiLCAxMDMsIDE0Myk7XG59YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gbGVhZGluZyBpbnRvIGNvbmRpdGlvbmFsc1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dFwiKS52YWx1ZTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gL2FcXHMqPVxccyo4XFxzKi87XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBjb2RlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSBtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICBsZXQgY2FudmFzSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0ICYmIGVmZmVjdC5zdHIgPT09IFwiYSBpcyBsZXNzIHRoYW4gMTBcIikge1xuICAgICAgICAgICAgICAgIGNhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25UaHJlZUNwVHdvID0gTGVzc29uVGhyZWVDcFR3bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblRocmVlQ3BUd28uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFbGxpcHNlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9FbGxpcHNlRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVHdvQ3BGaXZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDJjNVwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wyYzYnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IERpZCB5b3Ugc2VlIHRoZSBDQU5WQVMgY2hhbmdlZD8gPC9wPlxuICAgIDxwPiBJbiBvdXIgY29kZSwgd2UgbWFrZSB2YXJpYWJsZSBhIHJlZmVyIHRvIHRoZSB3b3JkcyBcIm1vbyBtb29cIiwgYW5kIHZhcmlhYmxlIGIgcmVmZXIgdG8gYW4gZWxsaXBzZSgxMDAsIDEwMCkuIDwvcD5cbiAgICA8cD4gQXMgYSByZXN1bHQsIHdoZW4gd2UgdGVsbCB0aGUgY29tcHV0ZXIgdG8gcHJpbnQgYSwgaXQgd2lsbCBwcmludCBcIm1vbyBtb29cIiwgYW5kIHdoZW4gd2UgdGVsbCB0aGUgY29tcHV0ZXIgdG8gcHJpbnQgYiwgaXQgd2lsbCBwcmludCBhIGNpcmNsZS4gPC9wPlxuICAgIDxwPiBMZXQncyB0YWtlIHRoaXMgb25lIHN0ZXAgZnVydGhlcjogQ3JlYXRlIGEgbmV3IHZhcmlhYmxlIGMsIGFuZCBtYWtlIGl0IHJlZmVyIHRvIGFuIGVsbGlwc2UoMTAwLCAxMDApLiBUaGVuIHdyaXRlIDIgc3RhdGVtZW50cyB0byBwcmludCBjLiBXaGF0IGRvIHlvdSB0aGluayB3b3VsZCBoYXBwZW4/IDwvcD5cbiAgICA8cD4gR09BTDogQ3JlYXRlIGEgdmFyaWFibGUgYyByZWZlcnJpbmcgdG8gYW4gZWxsaXBzZSgxMDAsIDEwMCksIHRoZW4gd3JpdGUgMiBwcmludCBzdGF0ZW1lbnRzIHRvIHByaW50IGMuIDwvcD5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dFwiKS52YWx1ZTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGFzc2lnbm1lbnQgPSAvY1xccyo9XFxzKmVsbGlwc2VcXHMqXFwoXFxzKlsxLTldWzAtOV0qXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqXFwpXFxzKjsvZztcbiAgICAgICAgICAgIGxldCBtYXRjaEFzc2lnbiA9IGNvZGUubWF0Y2goYXNzaWdubWVudCk7XG4gICAgICAgICAgICBsZXQgcHJpbnQgPSAvcHJpbnRcXHMqXFwoXFxzKmNcXHMqLFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKTsvZztcbiAgICAgICAgICAgIGxldCBtYXRjaFByaW50ID0gY29kZS5tYXRjaChwcmludCk7XG4gICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2hBc3NpZ24gIT0gbnVsbCAmJiBtYXRjaEFzc2lnbi5sZW5ndGggPiAwICYmIG1hdGNoUHJpbnQgIT0gbnVsbCAmJiBtYXRjaFByaW50Lmxlbmd0aCA+PSAyO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgbGV0IGNpcmNsZUNvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBFbGxpcHNlRWZmZWN0XzEuRWxsaXBzZUVmZmVjdCkge1xuICAgICAgICAgICAgICAgIGNpcmNsZUNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVJc0NvcnJlY3QgJiYgY2lyY2xlQ291bnQgPj0gMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVHdvQ3BGaXZlID0gTGVzc29uVHdvQ3BGaXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVHdvQ3BGaXZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwRm91ciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwyYzRcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsMmM1JztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBUaGVyZSdzIG5vIGxpbWl0IHRvIGhvdyBtYW55IHByaW50IHN0YXRlbWVudHMgdGhlIGNvbXB1dGVyIGNhbiB1bmRlcnN0YW5kLCBzbyB5b3UgY2FuIHdyaXRlIDEwMDAgcHJpbnQgc3RhdGVtZW50cywgYW5kIHRoZSBjb21wdXRlciB3aWxsIGRyYXcgMTAwMCB0aGluZ3Mgb24gdGhlIENBTlZBUyBmb3IgeW91ISA8L3A+XG4gICAgPHA+IFRpbWUgdG8gdGFrZSB5b3VyIGNvZGluZyB0byB0aGUgbmV4dCBsZXZlbC4gTGV0J3MgbGVhcm4gYWJvdXQgdmFyaWFibGVzLiA8L3A+XG4gICAgPHA+IFZhcmlhYmxlcyBhcmUgc2ltcGx5IG5hbWVzIHlvdSBnaXZlIHRvIHRoZSB0aGluZ3MgdGhhdCB5b3UgZHJhdy4gPC9wPlxuICAgIDxwPiBGb3IgZXhhbXBsZSwgdGFrZSBhIGxvb2sgYXQgdGhlIGNvZGUgYWJvdmUuIENoYW5nZSB0aGUgYSBpbiB0aGUgcHJpbnQgc3RhdGVtZW50IHRvIGIsIGFuZCBvYnNlcnZlIHdoYXQgaGFwcGVuZWQgb24gdGhlIENBTlZBUy4gPC9wPlxuICAgIDxwPiBHT0FMOiBDaGFuZ2UgYSB0byBiIGluIHRoZSBwcmludCBzdGF0ZW1lbnQuIDwvcD5gO1xuICAgICAgICB0aGlzLl9zdGFydGVyQ29kZSA9IGBhID0gXCJtb28gbW9vXCI7XFxuYiA9IGVsbGlwc2UoMTAwLCAxMDApO1xcbnByaW50KGEsIDUwLCA3MCk7YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRcIikudmFsdWU7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZWdleCA9IC9wcmludFxccypcXChcXHMqYlxccyosXFxzKlsxLTldWzAtOV0qXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqXFwpOy87XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBjb2RlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSBtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICBsZXQgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmICghY2FudmFzSXNDb3JyZWN0ICYmIGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblR3b0NwRm91ciA9IExlc3NvblR3b0NwRm91cjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblR3b0NwRm91ci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25Ud29DcE9uZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwyYzFcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsMmMyJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBQcmludGluZyBvbmx5IHdvcmRzIGlzIGtpbmRhIGJvcmluZywgc28gbGV0J3MgbGVhcm4gdG8gcHJpbnQgc29tZSBzaGFwZXMgb24gdGhlIENBTlZBUyEgPC9wPlxuICAgIDxwPiBJbiB0aGUgcHJpbnQgc3RhdGVtZW50LCByZXBsYWNlIFwibW9vXCIgd2l0aCBlbGxpcHNlKDEwMCwxMDApLiBIaXQgdGhlIFJVTiBidXR0b24gdG8gc2VlIHdoYXQgaGFwcGVucy4gPC9wPlxuICAgIDxwPiBHT0FMOiByZXBsYWNlIFwibW9vXCIgd2l0aCBlbGxpcHNlKDEwMCwxMDApIGluIHRoZSBwcmludCBzdGF0ZW1lbnQgYWJvdmUuIDwvcD5cbiAgICA8cD4gSElOVDogSGlnaGxpZ2h0IFwibW9vXCIgLSBpbmNsdWRpbmcgdGhlIGRvdWJsZSBxdW90ZXMgXCIsIGFuZCByZXBsYWNlIHRoYXQgd2l0aCBlbGxpcHNlKDEwMCwgMTAwKS4gS0VFUCBFVkVSWVRISU5HIEVMU0UgVEhFIFNBTUUuIDwvcD5gO1xuICAgICAgICB0aGlzLl9zdGFydGVyQ29kZSA9IGBcbiAgICBwcmludChcIm1vb1wiLCA1MCwgNzApYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRcIikudmFsdWU7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZWdleCA9IC9wcmludFxccypcXChcXHMqZWxsaXBzZVxccypcXChcXHMqWzEtOV1bMC05XSpcXHMqLFxccypbMS05XVswLTldKlxccypcXClcXHMqLFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKTsvO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gY29kZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgbGV0IGNhbnZhc0lzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblR3b0NwT25lID0gTGVzc29uVHdvQ3BPbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Ud29DcE9uZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlckVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvTnVtYmVyRWZmZWN0XCIpO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwU2V2ZW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMmM3XCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDNjMSc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gQ2hhbmdpbmcgb25lIGNpcmNsZSBjaGFuZ2VzIGMsIHdoaWNoIHdpbGwgdGhlbiBpbiB0dXJuIGNoYW5nZSB0aGUgb3RoZXIgY2lyY2xlISA8L3A+XG4gICAgPHA+IE5vdyBsZXQncyBwdXQgYWxsIHdlIGhhdmUgbGVhcm5lZCB0byBwcmFjdGljZS4gPC9wPlxuICAgIDxwPiBDcmVhdGUgYSBjaXJjbGUsIGFuZCBwcmludCBvdXQgdGhlIHNpemUgb2YgdGhhdCBjaXJjbGUgaW4gdGhlIGdpdmVuIGJveC4gPC9wPlxuICAgIDxwPiBJRiB3ZSBldmVyIGNoYW5nZSB0aGUgY2lyY2xlLCB3ZSB3YW50IHRoZSBudW1iZXIgaW4gdGhlIGJveCB0byBjaGFuZ2UsIHRvbyEgPC9wPlxuICAgIDxwPiBDSEFMTEVOR0U6IENyZWF0ZSBhIGNpcmNsZSBhbmQgcHJpbnQgaXRzIHNpemUgaW4gdGhlIGdpdmVuIGJveC4gPC9wPmA7XG4gICAgICAgIHRoaXMueCA9IDEwO1xuICAgICAgICB0aGlzLnkgPSA0MzA7XG4gICAgfVxuICAgIGRyYXdHdWlkZXMoY3R4KSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3QodGhpcy54LCB0aGlzLnksIDEwMCwgMTAwKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5mb250ID0gMjAgKyBcInB4IENvdXJpZXIgTmV3XCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgIGN0eC5maWxsVGV4dChcIlB1dCBjaXJjbGUncyBzaXplXCIsIHRoaXMueCwgMzkwKTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KFwiaW4gaGVyZVwiLCB0aGlzLngsIDQxMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIE51bWJlckVmZmVjdF8xLk51bWJlckVmZmVjdCAmJiBlZmZlY3QubnVtICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LnggPiB0aGlzLnggJiYgZWZmZWN0LnggPCB0aGlzLnggKyAxMDAgJiYgZWZmZWN0LnkgPiB0aGlzLnkgJiYgZWZmZWN0LnkgPCB0aGlzLnkgKyAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IGVmZmVjdC5udW07XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdDIgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVmZmVjdDIgaW5zdGFuY2VvZiBFbGxpcHNlRWZmZWN0XzEuRWxsaXBzZUVmZmVjdCAmJiAodmFsID09IGVmZmVjdDIudyB8fCB2YWwgPT0gZWZmZWN0Mi5oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVHdvQ3BTZXZlbiA9IExlc3NvblR3b0NwU2V2ZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Ud29DcFNldmVuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwU2l4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDJjNlwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wyYzcnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ2NvZGUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IE5vdyB0aGF0IHlvdSBoYXZlIGRyYXduIDIgY2lyY2xlcyBib3RoIGFyZSBjYWxsZWQgYywgbGV0J3Mgc2VlIHdoYXQgaGFwcGVucyB3aGVuIHlvdSB0cnkgdG8gbW9kaWZ5IG9uZSBvZiB0aGVtLiA8L3A+XG4gICAgPHA+IENsaWNrIG9uIG9uZSBvZiB0aGUgY2lyY2xlcyBvbiB0aGUgQ0FOVkFTLCBhbmQgdHJ5IG1ha2UgaXQgYmlnZ2VyLiBPYnNlcnZlIHdoYXQgaGFwcGVucyB0byB5b3VyIGRlY2xhcmF0aW9uIG9mIGMuIDwvcD5cbiAgICA8cD4gR09BTDogRW5sYXJnZSBvbmUgb2YgdGhlIGNpcmNsZXMgcmVmZXJyZWQgdG8gYnkgYyBvbiB0aGUgQ0FOVkFTLiA8L3A+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LncgPiAyNTAgJiYgZWZmZWN0LmggPiAyNTApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVHdvQ3BTaXggPSBMZXNzb25Ud29DcFNpeDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblR3b0NwU2l4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVHdvQ3BUaHJlZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwyYzNcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsMmM0JztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBTbyB3ZSBjYW4gZHJhdyBhIGNpcmNsZSBhbmQgY2hhbmdlIGl0LiBCdXQgd2hhdCBpZiB3ZSB3YW50IHRvIGRyYXcgYm90aCBjaXJjbGVzIGFuZCB3b3Jkcz8gPC9wPlxuICAgIDxwPiBXZWxsLCBzaW1wbGUhIEp1c3Qgd3JpdGUgbW9yZSBwcmludCBzdGF0ZW1lbnRzIGluIHRoZSBDT0RFIGFyZWEhIDwvcD5cbiAgICA8cD4gR09BTDogRHJhdyAyIGNpcmNsZXMgYW5kIGEgd29yZCBvbiB0aGUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IEhJTlQ6IFJlbWVtYmVyIHRoYXQgdGhlIG51bWJlcnMgcmlnaHQgaW5zaWRlIHRoZSBlbGxpcHNlKF8sXykgc3RhdGVtZW50IGNoYW5nZSB0aGUgY2lyY2xlJ3Mgc2l6ZXMuYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIGxldCBzdHJpbmdFeGlzdHMgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNpcmNsZUNvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmICghc3RyaW5nRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nRXhpc3RzID0gZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0ICYmIGVmZmVjdC5zdHIgIT09IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBjaXJjbGVDb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdFeGlzdHMgJiYgY2lyY2xlQ291bnQgPj0gMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVHdvQ3BUaHJlZSA9IExlc3NvblR3b0NwVGhyZWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Ud29DcFRocmVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwVHdvIHtcbiAgICAvKlxuICAgIGA8cD4gU28gd2UgY2FuIGRyYXcgYSBjaXJjbGUgYW5kIGNoYW5nZSBpdC4gQnV0IHdoYXQgaWYgd2Ugd2FudCB0byBkcmF3IGJvdGggYSBjaXJjbGUgYW5kIGEgd29yZD8gPC9wPlxuICAgIDxwPiBXZWxsLCBzaW1wbGUhIEp1c3Qgd3JpdGUgYW5vdGhlciBwcmludCBzdGF0ZW1lbnQgaW4gdGhlIENPREUgYXJlYSEgPC9wPlxuICAgIDxwPiBHT0FMOiBEcmF3IDIgY2lyY2xlcyBhbmQgYSB3b3JkIG9uIHRoZSBDQU5WQVMuIDwvcD5cbiAgICA8cD4gSElOVDogUmVtZW1iZXIgdGhhdCB0aGUgbnVtYmVycyByaWdodCBpbnNpZGUgdGhlIGVsbGlwc2UoXyxfKSBzdGF0ZW1lbnQgY2hhbmdlIHRoZSBjaXJjbGUncyBzaXplcy5gO1xuKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDJjMlwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wyYzMnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ2NvZGUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFdlIGNhbiB3cml0ZSBlbGxpcHNlKDEwMCwgMTAwKSBpbiB0aGUgcHJpbnQgc3RhdGVtZW50IHRvIGRyYXcgYSBjaXJjbGUgb24gdGhlIENBTlZBUy4gPC9wPlxuICAgIDxwPiBXaGF0IGFyZSB0aGUgbnVtYmVycyAoMTAwLCAxMDApIGZvcj8gSSdtIGdsYWQgeW91IGFza2VkLi4uIDwvcD5cbiAgICA8cD4gQmVjYXVzZSB0aGUgQ09ERSBhcmVhIGlzIGZyb3plbiBhZ2FpbiEgRHJhZyBvbmUgb2YgdGhlIDkgd2hpdGUgdGlwcyBhcm91bmQgdGhlIGNpcmNsZSBvbiB0aGUgQ0FOVkFTIHRvIHNlZSBob3cgdGhlIG51bWJlciBjaGFuZ2VzISA8L3A+XG4gICAgPHA+IEdPQUw6IE1ha2UgdGhlIGNpcmNsZSB3aWRlciBidXQgc2hvcnRlci4gPC9wPmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudCBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LncgPiAyMDAgJiYgZWZmZWN0LmggPCA4MCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Ud29DcFR3byA9IExlc3NvblR3b0NwVHdvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVHdvQ3BUd28uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwYW50c18xID0gcmVxdWlyZShcInBhbnRzXCIpO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi8uLi9pbmRleFwiKTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xudmFyIFBhcnNlcjtcbihmdW5jdGlvbiAoUGFyc2VyKSB7XG4gICAgLyoqXG4gICAgICogdG8gYmUgbW92ZWQgdG8gUGFudHNcbiAgICAgKiBudW1iZXIgcGFyc2VzIG51bWJlcnMgYnkgcmVwZWF0ZWRseSBhcHBseWluZyB0aGUgZGlnaXQgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG8gPSBwYW50c18xLlByaW1pdGl2ZXMubWFueTEocGFudHNfMS5QcmltaXRpdmVzLmRpZ2l0KCkpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIGxldCBzID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZGlnaXQgb2Ygby5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gZGlnaXQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHBhbnRzXzEuUHJpbWl0aXZlcy5TdWNjZXNzKG8uaW5wdXRzdHJlYW0sIHBhcnNlRmxvYXQocykpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQYXJzZXIubnVtYmVyID0gbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIHRvIGJlIG1vdmVkIHRvIFBhbnRzXG4gICAgICogc3RyaW5nIGlzIGFuIGFyYml0cmFyeSBzdHJpbmcgcGFyc2VyIHRoYXQgcmVwZWF0ZWRseSBhcHBsaWVzIHRoZSBsZXR0ZXIgcHJpbWl0aXZlXG4gICAgICogcmV0dXJucyBhIENoYXJTdHJlYW0gcmVwcmVzZW50aW5nIHRoZSBlbnRpcmUgcGFyc2VkIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmluZygpIHtcbiAgICAgICAgbGV0IHAgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55MShwYW50c18xLlByaW1pdGl2ZXMubGV0dGVyKCkpKTtcbiAgICAgICAgbGV0IGYgPSAoeHMpID0+IHBhbnRzXzEuQ2hhclV0aWwuQ2hhclN0cmVhbS5jb25jYXQoeHMpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwKShmKTtcbiAgICB9XG4gICAgUGFyc2VyLnN0cmluZyA9IHN0cmluZztcbiAgICAvKipcbiAgICAgKiB0byBiZSBtb3ZlZCB0byBQYW50c1xuICAgICAqIHB1bmN0dWF0aW9uIHBhcnNlcyBhbGwgcG9zc2libGUgcHVuY3R1YXRpb24gY2hhcmFjdGVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bmN0dWF0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNhdCh4ID0+IHggPT0gXCIhXCJcbiAgICAgICAgICAgIHx8IHggPT0gXCIuXCJcbiAgICAgICAgICAgIHx8IHggPT0gJywnXG4gICAgICAgICAgICB8fCB4ID09IFwiO1wiXG4gICAgICAgICAgICB8fCB4ID09ICc/J1xuICAgICAgICAgICAgfHwgeCA9PSBcIi1cIlxuICAgICAgICAgICAgfHwgeCA9PSBcIiZcIlxuICAgICAgICAgICAgfHwgeCA9PSAnJCdcbiAgICAgICAgICAgIHx8IHggPT0gJzonXG4gICAgICAgICAgICB8fCB4ID09ICcvJ1xuICAgICAgICAgICAgfHwgeCA9PSAnfCdcbiAgICAgICAgICAgIHx8IHggPT0gJyUnXG4gICAgICAgICAgICB8fCB4ID09ICcjJ1xuICAgICAgICAgICAgfHwgeCA9PSBcIkBcIlxuICAgICAgICAgICAgfHwgeCA9PSBcIn5cIlxuICAgICAgICAgICAgfHwgeCA9PSAnYCdcbiAgICAgICAgICAgIHx8IHggPT0gJyonXG4gICAgICAgICAgICB8fCB4ID09ICdeJ1xuICAgICAgICAgICAgfHwgeCA9PSAneydcbiAgICAgICAgICAgIHx8IHggPT0gJ30nXG4gICAgICAgICAgICB8fCB4ID09IFwiW1wiXG4gICAgICAgICAgICB8fCB4ID09ICddJ1xuICAgICAgICAgICAgfHwgeCA9PSAnKCdcbiAgICAgICAgICAgIHx8IHggPT0gXCIpXCJcbiAgICAgICAgICAgIHx8IHggPT0gXCInXCJcbiAgICAgICAgICAgIHx8IHggPT0gXCJfXCIpO1xuICAgIH1cbiAgICBQYXJzZXIucHVuY3R1YXRpb24gPSBwdW5jdHVhdGlvbjtcbiAgICBsZXQgaWQgPSAoeCkgPT4geDtcbiAgICAvKipcbiAgICAgKiBwYXJzZSBpcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgdGhlIGlucHV0IHRleHQgaW4gYSBDaGFyU3RyZWFtXG4gICAgICogYW5kIHBhc3NlcyBpdCB0byB0aGUgdXBwZXItbGV2ZWwgcGFyc2UgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gcHJvZ3JhbSBhIHN0cmluZyByZXByZXNlbnRpbmcgcHJvZ3JhbSB0ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2UocHJvZ3JhbSkge1xuICAgICAgICBwcm9ncmFtICs9IFwiXFxuXCI7XG4gICAgICAgIGxldCBvID0gUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIobmV3IHBhbnRzXzEuQ2hhclV0aWwuQ2hhclN0cmVhbShwcm9ncmFtKSk7XG4gICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYWNlX2xpZnRfMS5Tb21lKG8ucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYWNlX2xpZnRfMS5Ob25lO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBhcnNlci5wYXJzZSA9IHBhcnNlO1xuICAgIC8qKlxuICAgICAqIEV4cHJlc3Npb24gcGFyc2VyIGZpcnN0IHNlYXJjaGVzIGZvciB0aGUgZmlyc3QgZXhwcmVzc2lvbiBvZiBhIHNlcXVlbmNlIGFuZCBlaXRoZXJcbiAgICAgKiBhbm90aGVyIGV4cHJlc3Npb24gb3IgdGhlIGVuZCBvZiB0aGUgcHJvZ3JhbSAoTk9QKSBhbmQgcmV0dXJucyBhIHNlcXVlbmNlIG5vZGVcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIGJ1ZyBvZiBlYWdlciBwYXJzaW5nXG4gICAgICovXG4gICAgUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIgPSBpID0+IHtcbiAgICAgICAgbGV0IGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuU2VxdWVuY2VOb2RlKHR1cFswXSwgdHVwWzFdKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHAgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9TZXEpKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCc7JykpKHBhbnRzXzEuUHJpbWl0aXZlcy5ubCgpKSkocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyKSkocGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoXyA9PiBuZXcgaW5kZXhfMS5OT1AoKSkpKSkoZik7XG4gICAgICAgIHJldHVybiBwKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhyb3VnaCBhbGwgcG9zc2libGUgZXhwcmVzc2lvbnMgZXhjZXB0IGZvciBzZXF1ZW5jZXNcbiAgICAgKiB1c2VkIHRvIGF2b2lkIGluZmluaXRlIGxvb3BpbmcgaW4gdXBwZXIgbGV2ZWwgcGFyc2VcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIGJ1ZyBvZiBlYWdlciBwYXJzaW5nXG4gICAgICovXG4gICAgUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSA9IGkgPT4ge1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKGxOdW1iZXIoKSkobHN0cmluZzIoKSk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UodmFyTmFtZVBhcnNlKCkpKHAxKTtcbiAgICAgICAgbGV0IHAzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShCb29sUGFyc2UoKSkocDIpO1xuICAgICAgICBsZXQgcDQgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHZhckRlY1BhcnNlKCkpKHAzKTtcbiAgICAgICAgbGV0IHA1ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIudW5PcHNFeHByKShwNCk7XG4gICAgICAgIGxldCBwNiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoRGVjbGFyZSgpKShwNSk7XG4gICAgICAgIGxldCBwNyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmJpbk9wRXhwcikocDYpO1xuICAgICAgICBsZXQgcDggPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKExvZ2ljRXhwcigpKShwNyk7XG4gICAgICAgIGxldCBwOSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLkxpc3RIZWFkKShwOCk7XG4gICAgICAgIGxldCBwMTAgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5mdW5BcHApKHA5KTtcbiAgICAgICAgbGV0IHAxMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLnJldHVyblBhcnNlcikocDEwKTtcbiAgICAgICAgbGV0IHAxMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmNvbmRQYXJzZSkocDExKTtcbiAgICAgICAgbGV0IHAxMyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLldoaWxlTG9vcCkocDEyKTtcbiAgICAgICAgbGV0IHAxNCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLkZvckxvb3ApKHAxMyk7XG4gICAgICAgIGxldCBwMTUgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5mdW5EZWYpKHAxNCk7XG4gICAgICAgIHJldHVybiBwMTUoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aHJvdWdoIGFsbCBwb3NzaWJsZSBleHByZXNzaW9ucyBleGNlcHQgZm9yIGJpbk9wIGV4cHJlc3Npb25zXG4gICAgICogdXNlZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIGluIHRoZSBiaW5hcnkgZXhwcmVzc2lvbiBwYXJzZXJcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIGJ1ZyBvZiBlYWdlciBwYXJzaW5nXG4gICAgICovXG4gICAgUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb0Jpbk9wID0gaSA9PiB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UobE51bWJlcigpKShsc3RyaW5nMigpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZSh2YXJOYW1lUGFyc2UoKSkocDEpO1xuICAgICAgICBsZXQgcDMgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKEJvb2xQYXJzZSgpKShwMik7XG4gICAgICAgIGxldCBwNCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UodmFyRGVjUGFyc2UoKSkocDMpO1xuICAgICAgICBsZXQgcDUgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci51bk9wc0V4cHIpKHA0KTtcbiAgICAgICAgbGV0IHA2ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShEZWNsYXJlKCkpKHA1KTtcbiAgICAgICAgbGV0IHA3ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuTGlzdEhlYWQpKHA2KTtcbiAgICAgICAgbGV0IHA4ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuZnVuQXBwKShwNyk7XG4gICAgICAgIGxldCBwOSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLnJldHVyblBhcnNlcikocDgpO1xuICAgICAgICBsZXQgcDEwID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuY29uZFBhcnNlKShwOSk7XG4gICAgICAgIGxldCBwMTEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5XaGlsZUxvb3ApKHAxMCk7XG4gICAgICAgIGxldCBwMTIgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5Gb3JMb29wKShwMTEpO1xuICAgICAgICBsZXQgcDEzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuZnVuRGVmKShwMTIpO1xuICAgICAgICByZXR1cm4gcDEzKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhyb3VnaCBhbGwgcG9zc2libGUgZXhwcmVzc2lvbnMgZXhjZXB0IGZvciBsb2dpY2FsIGV4cHJlc3Npb25zXG4gICAgICogdXNlZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIGluIHRoZSBsb2dpY2FsIGV4cHJlc3Npb24gcGFyc2VyXG4gICAgICogQHBhcmFtIGkgYSBub25zZW5zZSBwYXJhbWV0ZXIgdXNlZCB0byBhdm9pZCBidWcgb2YgZWFnZXIgcGFyc2luZ1xuICAgICAqL1xuICAgIFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9Mb2dpYyA9IGkgPT4ge1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKGxOdW1iZXIoKSkobHN0cmluZzIoKSk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UodmFyTmFtZVBhcnNlKCkpKHAxKTtcbiAgICAgICAgbGV0IHAzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShCb29sUGFyc2UoKSkocDIpO1xuICAgICAgICBsZXQgcDQgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHZhckRlY1BhcnNlKCkpKHAzKTtcbiAgICAgICAgbGV0IHA1ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIudW5PcHNFeHByKShwNCk7XG4gICAgICAgIGxldCBwNiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoRGVjbGFyZSgpKShwNSk7XG4gICAgICAgIGxldCBwNyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmJpbk9wRXhwcikocDYpO1xuICAgICAgICBsZXQgcDggPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5MaXN0SGVhZCkocDcpO1xuICAgICAgICBsZXQgcDkgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5mdW5BcHApKHA4KTtcbiAgICAgICAgbGV0IHAxMCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLnJldHVyblBhcnNlcikocDkpO1xuICAgICAgICBsZXQgcDExID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuY29uZFBhcnNlKShwMTApO1xuICAgICAgICBsZXQgcDEyID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuV2hpbGVMb29wKShwMTEpO1xuICAgICAgICBsZXQgcDEzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuRm9yTG9vcCkocDEyKTtcbiAgICAgICAgbGV0IHAxNCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmZ1bkRlZikocDEzKTtcbiAgICAgICAgcmV0dXJuIHAxNChpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGxOdW1iZXIgaXMgdXNlZCB0byB3cmFwIHBhcnNlZCBudW1iZXJzIGluIE51bWJlck5vZGVzIGZvciB0aGUgQVNUXG4gICAgICovXG4gICAgZnVuY3Rpb24gbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgbyA9IG51bWJlcigpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGFudHNfMS5QcmltaXRpdmVzLlN1Y2Nlc3Moby5pbnB1dHN0cmVhbSwgbmV3IGluZGV4XzEuTnVtYmVyTm9kZShvLnJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQYXJzZXIubE51bWJlciA9IGxOdW1iZXI7XG4gICAgLyoqXG4gICAgICogYmluT3BzQ2hhciBwYXJzZXMgYWxsIHBvc3NpYmxlIGJpbmFyeSBvcGVyYXRvcnMsIHN1Y2ggYXMgKyBvciAtXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluT3BzQ2hhcigpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuc2F0KHggPT4geCA9PSBcIitcIlxuICAgICAgICAgICAgICAgIHx8IHggPT0gXCItXCJcbiAgICAgICAgICAgICAgICB8fCB4ID09IFwiL1wiXG4gICAgICAgICAgICAgICAgfHwgeCA9PSBcIj1cIlxuICAgICAgICAgICAgICAgIHx8IHggPT0gXCIqXCIpKShpc3RyZWFtKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUGFyc2VyLmJpbk9wc0NoYXIgPSBiaW5PcHNDaGFyO1xuICAgIC8qKlxuICAgICAqIGJpbk9wc1Nob3J0IHJldHVybnMgYSB0dXBsZSB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgYmluYXJ5IG9wZXJhdG9yIChDaGFyU3RyZWFtKVxuICAgICAqIGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgdGhlIGV4cHJlc3Npb24gdG8gdGhlIHJpZ2h0IG9mIHRoZSBvcGVyYXRvciAoRXhwcmVzc2lvbjx7fT4pXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluT3BTaG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEoYmluT3BzQ2hhcigpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKSgoeCkgPT4geCk7XG4gICAgfVxuICAgIFBhcnNlci5iaW5PcFNob3J0ID0gYmluT3BTaG9ydDtcbiAgICAvKipcbiAgICAgKiBiaW5PcEV4cHIgcGFyc2VzIGFsbCBwb3NzaWJsZSBiaW5hcnkgb3BlcmF0aW9uIGV4cHJlc3Npb25zIGFuZCByZXR1cm5zIHRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgQVNUIG5vZGUgY29uc3RydWN0IChhbHNvIHBhcnNlcyBwb3N0Zml4IGluY3JlbWVudHMvZGVjcmVtZW50cyBsaWtlIGkrKylcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIHRoZSBidWcgd2l0aCBlYWdlciBldmFsdWF0aW9uXG4gICAgICovXG4gICAgUGFyc2VyLmJpbk9wRXhwciA9IGkgPT4ge1xuICAgICAgICB2YXIgZiA9ICh0dXApID0+IHtcbiAgICAgICAgICAgIGxldCBsaHMgPSB0dXBbMF07XG4gICAgICAgICAgICBsZXQgb3AgPSB0dXBbMV1bMF07XG4gICAgICAgICAgICBsZXQgcmhzID0gdHVwWzFdWzFdO1xuICAgICAgICAgICAgc3dpdGNoIChvcC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLlBsdXNPcChsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5NaW51c09wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkRpdk9wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLk11bE9wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkFzc2lnbk9wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmluYXJ5IE9wZXJhdGlvbiBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9CaW5PcCkodmFyRGVjUGFyc2UoKSk7XG4gICAgICAgIGxldCBwMiA9IGJpbk9wU2hvcnQoKTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwb3N0UGx1cyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vQmluT3ApKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCcrKycpKSh0dXAgPT4geyByZXR1cm4gbmV3IGluZGV4XzEuSW5jcmVtZW50KHR1cFswXSwgd3MpOyB9KTtcbiAgICAgICAgbGV0IHBvc3RNaW51cyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vQmluT3ApKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCctLScpKSh0dXAgPT4geyByZXR1cm4gbmV3IGluZGV4XzEuRGVjcmVtZW50KHR1cFswXSwgd3MpOyB9KTtcbiAgICAgICAgbGV0IGJpbk9wID0gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHAxKSkocDIpKGYpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShiaW5PcCkocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwb3N0UGx1cykocG9zdE1pbnVzKSkoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB1bk9wc0NoYXIgcGFyc2VzIGFsbCBwb3NzaWJsZSB1bmFyeSBvcGVyYXRvcnNcbiAgICAgKiBPbmx5IG5lZ2F0aW9ucyBhcmUgc3VwcG9ydGVkLCBidXQgbW9yZSBjYW4gYmUgYWRkZWQgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIGkgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIudW5PcHNDaGFyID0gaSA9PiB7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKFwiLVwiKSkoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB1bk9wc0V4cHIgd3JhcHMgYSB1bmFyeSBvcGVyYXRpb24gZXhwcmVzc2lvbiBpbiB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIEFTVCBub2RlIGFuZCByZXR1cm5zIGl0XG4gICAgICogQHBhcmFtIGkgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIudW5PcHNFeHByID0gaSA9PiB7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLk5lZ09wKHR1cFsxXSwgd3MpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgd3MgPSBcIlwiO1xuICAgICAgICBsZXQgcHJlY2VkaW5nV1MgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKSh4ID0+IHdzID0geC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShQYXJzZXIudW5PcHNDaGFyKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSkoZikoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBsc3RyaW5nIHBhcnNlcyB2YWxpZCBzdHJpbmdzIGluIHRoZSBTV0VMTCBsYW5ndWFnZVxuICAgICAqIGEgdmFsaWQgc3RyaW5nIGlzIHN1cnJvdW5kZWQgYnkgcXVvdGF0aW9ucyBhbmQgY29uc2lzdHMgb2YgbGV0dGVycywgbnVtYmVycywgcHVuY3R1YXRpb24sIGFuZC9vciB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbHN0cmluZygpIHtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHBhbnRzXzEuUHJpbWl0aXZlcy5sZXR0ZXIoKSkocGFudHNfMS5QcmltaXRpdmVzLndzMSgpKSkocGFudHNfMS5QcmltaXRpdmVzLmRpZ2l0KCkpO1xuICAgICAgICAvL2xldCBwMSA9IFByaW1pdGl2ZXMuY2hvaWNlKFByaW1pdGl2ZXMubGV0dGVyKCkpKFByaW1pdGl2ZXMud3MxKCkpO1xuICAgICAgICBsZXQgcCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoXCJcXFwiXCIpKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKFwiXFxcIlwiKSkocGFudHNfMS5QcmltaXRpdmVzLm1hbnkocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMSkocHVuY3R1YXRpb24oKSkpKTtcbiAgICAgICAgbGV0IGYgPSAoeHMpID0+IHBhbnRzXzEuQ2hhclV0aWwuQ2hhclN0cmVhbS5jb25jYXQoeHMpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwKShmKTtcbiAgICB9XG4gICAgUGFyc2VyLmxzdHJpbmcgPSBsc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIGxzdHJpbmcyIHdyYXBzIHN0cmluZ3MgcGFyc2VkIGJ5IGxzdHJpbmcgaW4gU3RyaW5Ob2RlIG9iamVjdHMgYW5kIHJldHVybnMgdGhlbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxzdHJpbmcyKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgICAgICBsZXQgcHJlY2VkaW5nV1MgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKSh4ID0+IHdzID0geC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGxldCBvID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShsc3RyaW5nKCkpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGFudHNfMS5QcmltaXRpdmVzLlN1Y2Nlc3Moby5pbnB1dHN0cmVhbSwgbmV3IGluZGV4XzEuU3RyaW5nTm9kZShvLnJlc3VsdC50b1N0cmluZygpLCB3cykpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQYXJzZXIubHN0cmluZzIgPSBsc3RyaW5nMjtcbiAgICAvKipcbiAgICAgKiB2YXJOYW1lUGFyc2UgcGFyc2VzIHZhbGlkIHZhcmlhYmxlIG5hbWVzXG4gICAgICogdmFyaWFibGUgbmFtZXMgaW4gU1dFTEwgYmVnaW4gd2l0aCBhIGxvd2VyY2FzZSBjaGFyIGFuZCBhcmUgZm9sbG93ZWRcbiAgICAgKiBieSBsZXR0ZXJzIG9yIGRpZ2l0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhck5hbWVQYXJzZSgpIHtcbiAgICAgICAgdmFyIGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuVmFyaWFibGVOb2RlKHR1cFswXS50b1N0cmluZygpICsgcGFudHNfMS5DaGFyVXRpbC5DaGFyU3RyZWFtLmNvbmNhdCh0dXBbMV0pLnRvU3RyaW5nKCksIHdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBmaXJzdENoYXIgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5sb3dlcigpKTtcbiAgICAgICAgbGV0IG5leHRDaGFycyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55KHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UocGFudHNfMS5QcmltaXRpdmVzLmRpZ2l0KCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5sZXR0ZXIoKSkpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShmaXJzdENoYXIpKG5leHRDaGFycykoZik7XG4gICAgfVxuICAgIFBhcnNlci52YXJOYW1lUGFyc2UgPSB2YXJOYW1lUGFyc2U7XG4gICAgLyoqXG4gICAgICogdmFyRGVjUGFyc2UgcGFyc2VzIHZhbGlkIHZhcmlhYmxlIGRlY2xhcmF0aW9ucyBpbiB0aGUgZm9ybSBcInZhciB4XCJcbiAgICAgKiB0aGUgcGFyc2VyIHRoZW4gd3JhcHMgdGhlIHBhcnNlZCB2YWx1ZSBpbiBhIHZhcmlhYmxlIG5vZGUgZm9yIHRoZSBBU1RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YXJEZWNQYXJzZSgpIHtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cihcInZhclwiKSk7XG4gICAgICAgIGxldCB2YXJOYW1lID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzMSgpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkodmFyTmFtZVBhcnNlKCkpO1xuICAgICAgICBsZXQgcCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocDEpKHZhck5hbWUpKHR1cCA9PiB0dXBbMV0pO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgUGFyc2VyLnZhckRlY1BhcnNlID0gdmFyRGVjUGFyc2U7XG4gICAgLyoqXG4gICAgICogRGVjbGFyZSBwYXJzZXMgdmFyaWFibGUgZGVjbGFyYXRpb25zIGluIHRoZSBmb3JtIFwidmFyIHggPSAyXCJcbiAgICAgKiBhbmQgcmV0dXJucyBhIERlY2xhcmVPcCBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjbGFyZSgpIHtcbiAgICAgICAgbGV0IGVxID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignPScpKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmxlZnQodmFyRGVjUGFyc2UoKSkoZXEpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwMSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSkodHVwID0+IHsgcmV0dXJuIG5ldyBpbmRleF8xLkRlY2xhcmVPcCh0dXBbMF0sIHR1cFsxXSk7IH0pO1xuICAgIH1cbiAgICBQYXJzZXIuRGVjbGFyZSA9IERlY2xhcmU7XG4gICAgLyoqXG4gICAgICogTGlzdEhlYWQgcGFyc2VzIGFsbCBsaXN0cyBpbiB0aGUgU1dFTEwgbGFuZ3VhZ2UsIGluY2x1ZGluZyBlbXB0eSBsaXN0c1xuICAgICAqIExpc3RzIGFyZSBzdXJyb3VuZGVkIGJ5IHNxdWFyZSBicmFja2V0cyBhbmQgZWFjaCBlbGVtZW50IGlzIHNlcGFyYXRlZCBieSBhIGNvbW1hXG4gICAgICogcmV0dXJucyBhIGxpc3ROb2RlIG9iamVjdFxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIuTGlzdEhlYWQgPSBpID0+IHtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwMCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCdbJykpKShwMCk7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgbGV0IGhkID0gdHVwWzBdO1xuICAgICAgICAgICAgbGV0IHJlcyA9IFtoZF07XG4gICAgICAgICAgICBsZXQgdGFpbCA9IHR1cFsxXTtcbiAgICAgICAgICAgIGZvciAobGV0IGVsZW0gb2YgdGFpbCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkxpc3ROb2RlKHJlcywgd3MpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHAxKShMaXN0VGFpbCgpKShmKTtcbiAgICAgICAgbGV0IHAzID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ1tdJykpKShfID0+IG5ldyBpbmRleF8xLkxpc3ROb2RlKFtdLCB3cykpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMykocDIpKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTGlzdCBUYWlsIHBhcnNlcyBzZWNvbmQgdGhyb3VnaCBsYXN0IGVsZW1lbnRzIG9mIGEgbGlzdCwgZWFjaCBzZXBhcmF0ZWQgYnkgYSBjb21tYVxuICAgICAqIHJldHVybnMgYW4gYXJyYXkgb2YgRXhwcmVzc2lvbnMgdGhhdCB3aWxsIGJlIGFjY2Vzc2VkIGJ5IExpc3RIZWFkXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGlzdFRhaWwoKSB7XG4gICAgICAgIGxldCBwMCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMuY2hhcignLCcpKShwMCk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5sZWZ0KHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55KHAxKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ10nKSk7XG4gICAgICAgIHJldHVybiBwMjtcbiAgICB9XG4gICAgUGFyc2VyLkxpc3RUYWlsID0gTGlzdFRhaWw7XG4gICAgLyoqXG4gICAgICogZnVuRGVmQXJnTGlzdCBwYXJzZXMgYXJndW1lbnQgbGlzdHMgZm9yIGZ1bmN0aW9uIGRlZmluaXRpb25zLFxuICAgICAqIHN1cnJvdW5kZWQgYnkgcGFyZW5zIGFuZCBzZXBhcmF0ZWQgYnkgY29tbWFzXG4gICAgICogcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bkRlZkFyZ0xpc3QoKSB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKCcpKShzdHJpbmcoKSk7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgbGV0IGhkID0gdHVwWzBdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgcmVzID0gW2hkXTtcbiAgICAgICAgICAgIGxldCB0YWlsID0gdHVwWzFdO1xuICAgICAgICAgICAgZm9yIChsZXQgZWxlbSBvZiB0YWlsKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goZWxlbS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocDEpKGZ1bkRlZkFyZ0xpc3RUYWlsKCkpKGYpO1xuICAgICAgICBsZXQgcDMgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJygpJykpKF8gPT4gW10pO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMykocDIpO1xuICAgIH1cbiAgICBQYXJzZXIuZnVuRGVmQXJnTGlzdCA9IGZ1bkRlZkFyZ0xpc3Q7XG4gICAgLyoqXG4gICAgICogZnVuRGVmQXJnTGlzdFRhaWwgcGFyc2VzIHRoZSBzZWNvbmQgdGhyb3VnaCBsYXN0IGVsZW1lbnRzIG9mIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBwYXJhbWV0ZXIgbGlzdFxuICAgICAqIHBhcmFtZXRlcnMgYXJlIHNlcGFyYXRlZCBieSBjb21tYXMgYW5kIGVuZCB3aXRoIGEgY2xvc2luZyBwYXJlbnNcbiAgICAgKiByZXR1cm5zIGFuIGFycmF5IG9mIHBhcmFtZXRlcnMsIHdoaWNoIGlzIGFjY2Vzc2VkIGJ5IGZ1bkRlZkFyZ0xpc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5EZWZBcmdMaXN0VGFpbCgpIHtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcsJykpKHN0cmluZygpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmxlZnQocGFudHNfMS5QcmltaXRpdmVzLm1hbnkocDEpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKScpKTtcbiAgICAgICAgcmV0dXJuIHAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmdW5BcHBBcmdMaXN0IHBhcnNlcyBhcmd1bWVudCBsaXN0cyBmb3IgZnVuY3Rpb24gYXBwbGljYXRpb25zLCBpbmNsdWRpbmcgZW1wdHkgYXJncyBsaXN0c1xuICAgICAqIHRoZSBwYXJzZXIgcmV0dXJucyBhbiBhcnJheSBvZiBFeHByZXNzaW9uIG9iamVjdHMgdGhhdCByZXByZXNlbnQgdGhlIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bkFwcEFyZ0xpc3QoKSB7XG4gICAgICAgIGxldCBleHByID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcoJykpKGV4cHIpO1xuICAgICAgICB2YXIgZiA9ICh0dXApID0+IHtcbiAgICAgICAgICAgIGxldCBoZCA9IHR1cFswXTtcbiAgICAgICAgICAgIGxldCByZXMgPSBbaGRdO1xuICAgICAgICAgICAgbGV0IHRhaWwgPSB0dXBbMV07XG4gICAgICAgICAgICBmb3IgKGxldCBlbGVtIG9mIHRhaWwpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocDEpKGZ1bkFwcEFyZ0xpc3RUYWlsKCkpKGYpO1xuICAgICAgICBsZXQgcDMgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJygpJykpKF8gPT4gW10pO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMykocDIpO1xuICAgIH1cbiAgICBQYXJzZXIuZnVuQXBwQXJnTGlzdCA9IGZ1bkFwcEFyZ0xpc3Q7XG4gICAgLyoqXG4gICAgICogZnVuQXBwQXJnTGlzdFRhaWwgcGFyc2VzIHRoZSBzZWNvbmQgdGhyb3VnaCBsYXN0IGVsZW1lbnRzIG9mIGFuIGFyZ3VtZW50IGxpc3RcbiAgICAgKiBlYWNoIGVsZW1lbnQgaXMgc2VwYXJhdGVkIGJ5IGEgY29tbWFcbiAgICAgKiByZXR1cm5zIGFuIGFycmF5IG9mIEV4cHJlc3Npb24gb2JqZWN0cywgbGF0ZXIgYWNjZXNzZWQgYnkgZnVuQXBwQXJnc0xpc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5BcHBBcmdMaXN0VGFpbCgpIHtcbiAgICAgICAgbGV0IGNvbW1hID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignLCcpKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KGNvbW1hKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmxlZnQocGFudHNfMS5QcmltaXRpdmVzLm1hbnkocDEpKShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcpJykpKTtcbiAgICAgICAgcmV0dXJuIHAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXR1cm5QYXJzZXIgcGFyc2VzIHZhbGlkIHJldHVybiBzdGF0ZW1lbnRzIGluIHRoZSBmb3JtIFwicmV0dXJuIHhcIlxuICAgICAqIHdyYXBzIHRoZSBwYXJzZWQgdmFsdWUgaW4gYSBSZXR1cm4gbm9kZSBmb3IgdGhlIEFTVFxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIucmV0dXJuUGFyc2VyID0gaSA9PiB7XG4gICAgICAgIGxldCBleHByID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cigncmV0dXJuJykpKShleHByKTtcbiAgICAgICAgdmFyIGYgPSAoZSkgPT4geyByZXR1cm4gbmV3IGluZGV4XzEuUmV0dXJuKGUsIHdzKTsgfTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocCkoZikoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBmdW5EZWYgcGFyc2VzIHZhbGlkIGZ1bmN0aW9uIGRlZmluaXRpb25zIGluIHRoZSBmb3JtIFwiZnVuIGZ1bmN0aW9uTmFtZShhcmdMaXN0KXsgYm9keTt9XCJcbiAgICAgKiB0aGUgcGFyc2VyIHJldHVybnMgYSBmdW5EZWYgbm9kZSBmb3IgdGhlIEFTVFxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIuZnVuRGVmID0gaSA9PiB7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cignZnVuJykpKShwYW50c18xLlByaW1pdGl2ZXMuc2VxKFxuICAgICAgICAvKiBmdW5jdGlvbiBuYW1lICovXG4gICAgICAgIHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4oc3RyaW5nKCkpKGNzID0+IGNzLnRvU3RyaW5nKCkpKShwYW50c18xLlByaW1pdGl2ZXMuc2VxKFxuICAgICAgICAvKiBmdW5jdGlvbiBhcmd1bWVudHMgKi9cbiAgICAgICAgZnVuRGVmQXJnTGlzdCgpKShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQoXG4gICAgICAgIC8qIGZ1bmN0aW9uIGJvZHkgKi9cbiAgICAgICAgcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcigneycpKSkocGFudHNfMS5QcmltaXRpdmVzLmxlZnQocGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlcikpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCd9JykpKSkoaWQpKShcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBBU1Qgbm9kZVxuICAgICAgICAodHVwKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm5hbWUgPSB0dXBbMF07XG4gICAgICAgICAgICBsZXQgYXJncyA9IHR1cFsxXVswXTtcbiAgICAgICAgICAgIGxldCBib2R5ID0gdHVwWzFdWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkZ1bkRlZihmbmFtZSwgYm9keSwgYXJncywgd3MpO1xuICAgICAgICB9KSkoaSk7XG4gICAgfTtcbiAgICBsZXQgcHJpbnRPZmZzZXQgPSAtMTtcbiAgICAvKipcbiAgICAgKiBmdW5BcHAgcGFyc2VzIHZhbGlkIGZ1bmN0aW9uIGFwcGxpY2F0aW9ucyBpbiB0aGUgZm9ybSBcImZ1bmN0aW9uTmFtZShhcmdzTGlzdClcIiBhbmQgcmV0dXJucyBhIGZ1bkFwcCBub2RlXG4gICAgICogcGFyc2VyIGNoZWNrcyBmb3IgYnVpbHQtaW4gZnVuY3Rpb25zLCBsaWtlIHByaW50LCBlbGxpcHNlLCBhbmQgcmVjdDsgYW5kIHJldHVybnMgdGhlIHZhbGlkIEFTVCBub2RlXG4gICAgICogQHBhcmFtIGkgYSBub25zZW5zZSBwYXJhbWV0ZXIgdXNlZCB0byBhdm9pZCB0aGUgYnVnIHdpdGggZWFnZXIgZXZhbHVhdGlvblxuICAgICAqL1xuICAgIFBhcnNlci5mdW5BcHAgPSBpID0+IHtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykoc3RyaW5nKCkpKShmdW5BcHBBcmdMaXN0KCkpKHR1cCA9PiB7XG4gICAgICAgICAgICBsZXQgZm5hbWUgPSB0dXBbMF0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicHJpbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1cFsxXS5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLlByaW50Tm9kZSh0dXBbMV1bMF0sIG5ldyBpbmRleF8xLkRpbWVuc2lvbnModHVwWzFdWzFdLCB0dXBbMV1bMl0sIG5ldyBpbmRleF8xLk51bWJlck5vZGUoMSkpLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJpbnRPZmZzZXQgPSAocHJpbnRPZmZzZXQgKyAxKSAlIDEyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuUHJpbnROb2RlKHR1cFsxXVswXSwgbmV3IGluZGV4XzEuRGltZW5zaW9ucyhuZXcgaW5kZXhfMS5OdW1iZXJOb2RlKDEwMCArIDEwMCAqIChwcmludE9mZnNldCAlIDMpKSwgbmV3IGluZGV4XzEuTnVtYmVyTm9kZSgxMDAgKyAxMDAgKiAocHJpbnRPZmZzZXQgLyA0KSksIG5ldyBpbmRleF8xLk51bWJlck5vZGUoMSkpLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVsbGlwc2VcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1cFsxXS5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkVsbGlwc2VOb2RlKHR1cFsxXVswXSwgdHVwWzFdWzFdLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwicmVjdFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHVwWzFdLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuUmVjdGFuZ2xlTm9kZSh0dXBbMV1bMF0sIHR1cFsxXVsxXSwgd3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1cFsxXS5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkxpbmVOb2RlKHR1cFsxXVswXSwgdHVwWzFdWzFdLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiY3VydmVcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1cFsxXS5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkN1cnZlTm9kZSh0dXBbMV1bMF0sIHR1cFsxXVsxXSwgdHVwWzFdWzJdLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZXBoXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0dXBbMV0ubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5FcGhOb2RlKHR1cFsxXVswXSwgdHVwWzFdWzFdLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhcmdzID0gdHVwWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkZ1bkFwcChmbmFtZSwgYXJncywgd3MpO1xuICAgICAgICB9KShpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJvb2xQYXJzZSBwYXJzZXMgdmFsaWQgYm9vbGVhbnMsIHRydWUgYW5kIGZhbHNlLCBhbmQgcmV0dXJucyBhIEJvb2xlYW5Ob2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gQm9vbFBhcnNlKCkge1xuICAgICAgICBsZXQgd3MgPSBcIlwiO1xuICAgICAgICBsZXQgcHJlY2VkaW5nV1MgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKSh4ID0+IHdzID0geC50b1N0cmluZygpKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ3RydWUnKSkpKF8gPT4gbmV3IGluZGV4XzEuQm9vbGVhbk5vZGUodHJ1ZSwgd3MpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ2ZhbHNlJykpKShfID0+IG5ldyBpbmRleF8xLkJvb2xlYW5Ob2RlKGZhbHNlLCB3cykpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMSkocDIpO1xuICAgIH1cbiAgICBQYXJzZXIuQm9vbFBhcnNlID0gQm9vbFBhcnNlO1xuICAgIC8qKlxuICAgICAqIGxvZ2ljQ2hhciBwYXJzZXMgYWxsIGxvZ2ljYWwgb3BlcmF0b3JzIGluIHRoZSBTV0VMTCBsYW5ndWFnZSBhbmQgcmV0dXJucyB0aGUgY29uc3VtZWQgb3BlcmF0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2dpY0NoYXIoKSB7XG4gICAgICAgIHZhciBsb2dpY0NoYXIgPSBbXCJlcXVhbHNcIiwgJz09JywgJ2FuZCcsICc+JywgJzwnLCAnbm90IGVxdWFscycsICdvciddO1xuICAgICAgICB2YXIgbG9naWNDaGFyMiA9IFsnPj0nLCAnPD0nXTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuc3RyU2F0KGxvZ2ljQ2hhcikpO1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHJTYXQobG9naWNDaGFyMikpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMikocDEpO1xuICAgIH1cbiAgICBQYXJzZXIubG9naWNDaGFyID0gbG9naWNDaGFyO1xuICAgIC8qKlxuICAgICAqIGxvZ2ljU2hvcnQgcmV0dXJucyBhIHR1cGxlLCB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCByZXByZXNlbnRzIHRoZSBsb2dpY2FsIG9wZXJhdG9yIGFuZFxuICAgICAqIHRoZSBzZWNvbmQgZWxlbWVudCBpcyB0aGUgZXhwcmVzc2lvbiB0byB0aGUgcmlnaHQgb2YgdGhlIG9wZXJhdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9naWNTaG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEobG9naWNDaGFyKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9TZXEpKCh4KSA9PiB4KTtcbiAgICB9XG4gICAgUGFyc2VyLmxvZ2ljU2hvcnQgPSBsb2dpY1Nob3J0O1xuICAgIC8qKlxuICAgICAqIGxvZ2ljRXhwciBwYXJzZXMgbG9naWNhbCBleHByZXNzaW9ucyBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBBU1Qgbm9kZVxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2dpY0V4cHIoKSB7XG4gICAgICAgIC8vIFRPRE86IERhbiAoMjAxOC0xMS0xOSksIHNob3VsZG4ndCBwYXJhbWV0ZXJpemVkIHR5cGUgYmUgQm9vbGVhbk5vZGU/XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxocyA9IHR1cFswXTtcbiAgICAgICAgICAgIGxldCBvcCA9IHR1cFsxXVswXTtcbiAgICAgICAgICAgIGxldCByaHMgPSB0dXBbMV1bMV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXF1YWxzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5FcXVhbHMobGhzLCByaHMsIHdzKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiPT1cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkVxdWFscyhsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkFuZChsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5HcmVhdGVyVGhhbihsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5MZXNzVGhhbihsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuR3JlYXRlclRoYW5FcShsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuTGVzc1RoYW5FcShsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvclwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuT3IobGhzLCByaHMsIHdzKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwibm90IGVxdWFsc1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuTm90RXF1YWwobGhzLCByaHMsIHdzKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2dpY2FsIGV4cHJlc3Npb24gbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBub3QgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ25vdCcpKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KG5vdCkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBub3RFeHByID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwMSkoeCA9PiBuZXcgaW5kZXhfMS5Ob3QoeCwgd3MpKTtcbiAgICAgICAgbGV0IGxvZ2ljRXhwciA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vTG9naWMpKShsb2dpY1Nob3J0KCkpKGYpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShub3RFeHByKShsb2dpY0V4cHIpO1xuICAgIH1cbiAgICBQYXJzZXIuTG9naWNFeHByID0gTG9naWNFeHByO1xuICAgIC8qKlxuICAgICAqIElmUGFyc2UgcGFyc2VzIHZhbGlkIGlmIHN0YXRlbWVudHMgaW4gdGhlIGZvcm0gXCJpZihjb25kaXRpb24peyBib2R5OyB9XCJcbiAgICAgKiByZXR1cm5zIGFuIGFycmF5IHdoZXJlIHRoZSBmaXJzdCBlbGVtIGlzIHRoZSBjb25kaXRpb24gYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGJvZHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJZlBhcnNlKCkge1xuICAgICAgICBsZXQgZXhwciA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBib2R5UGFyc2UgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCdpZicpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKCcpKSh4ID0+IHgpO1xuICAgICAgICBsZXQgY29uZCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHAxKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKScpKShleHByKTtcbiAgICAgICAgbGV0IGN1cmx5ID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcigneycpKTtcbiAgICAgICAgbGV0IGJvZHkgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihjdXJseSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ30nKSkoYm9keVBhcnNlKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEoY29uZCkoYm9keSkoeCA9PiB4KTtcbiAgICB9XG4gICAgUGFyc2VyLklmUGFyc2UgPSBJZlBhcnNlO1xuICAgIC8qKlxuICAgICAgKiBJZkVsc2VQYXJzZSBwYXJzZXMgdmFsaWQgaWYgZWxzZSBzdGF0ZW1lbnRzIGluIHRoZSBmb3JtIFwiaWYoY29uZGl0aW9uKXsgYm9keTsgfSBlbHNleyBib2R5Mjt9XCJcbiAgICAgICogcmV0dXJucyBhbiBhcnJheSB3aGVyZSB0aGUgZmlyc3QgZWxlbSBpcyB0aGUgY29uZGl0aW9uIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSBmaXJzdCBib2R5IGFuZCB0aGUgdGhpcmQgaXMgYm9keTJcbiAgICAgICovXG4gICAgZnVuY3Rpb24gSWZFbHNlUGFyc2UoKSB7XG4gICAgICAgIGxldCBlID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCdlbHNlJykpO1xuICAgICAgICBsZXQgYm9keSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIpO1xuICAgICAgICBsZXQgYm9keTIgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMuc3RyKCd7JykpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ30nKSkoYm9keSk7XG4gICAgICAgIGxldCBlbHNlUGFyc2UgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQoZSkoYm9keTIpO1xuICAgICAgICB2YXIgZiA9ICh0dXApID0+IHtcbiAgICAgICAgICAgIHR1cFswXS5wdXNoKHR1cFsxXSk7XG4gICAgICAgICAgICByZXR1cm4gdHVwWzBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShJZlBhcnNlKCkpKGVsc2VQYXJzZSkoZik7XG4gICAgfVxuICAgIFBhcnNlci5JZkVsc2VQYXJzZSA9IElmRWxzZVBhcnNlO1xuICAgIC8qKlxuICAgICAqIGNvbmRQYXJzZSBwYXJzZXMgcG9zc2libGUgY29uZGl0aW9uYWwgc3RhdGVtZW50cywgaW5jbHVkaW5nIGlmIGFuZCBpZi9lbHNlIHN0YXRlbWVudHNcbiAgICAgKiByZXR1cm5zIGEgQ29uZGl0aW9uYWwgbm9kZVxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIuY29uZFBhcnNlID0gaSA9PiB7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR1cC5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5Db25kaXRpb25hbCh0dXBbMF0sIHR1cFsxXSwgdHVwWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5Db25kaXRpb25hbCh0dXBbMF0sIHR1cFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoSWZFbHNlUGFyc2UoKSkoSWZQYXJzZSgpKSkoZikoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGlsZUxvb3AgcGFyc2VzIHZhbGlkIHdoaWxlIGxvb3BzIGluIHRoZSBmb3JtIFwid2hpbGUoY29uZGl0aW9uKSB7IGJvZHk7fVwiXG4gICAgICogcmV0dXJucyBhIFdoaWxlTm9kZSBmb3IgdGhlIEFTVFxuICAgICAqL1xuICAgIFBhcnNlci5XaGlsZUxvb3AgPSBpID0+IHtcbiAgICAgICAgbGV0IGV4cHIgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9TZXEpO1xuICAgICAgICBsZXQgYm9keVBhcnNlID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlcik7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cihcIndoaWxlXCIpKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJygnKSkoeCA9PiB4KTtcbiAgICAgICAgbGV0IGNvbmQgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwMSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJyknKSkoZXhwcik7XG4gICAgICAgIGxldCBjdXJseSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ3snKSk7XG4gICAgICAgIGxldCBib2R5ID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4oY3VybHkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCd9JykpKGJvZHlQYXJzZSk7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4geyByZXR1cm4gbmV3IGluZGV4XzEuV2hpbGVOb2RlKHR1cFswXSwgdHVwWzFdLCB3cyk7IH07XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuc2VxKGNvbmQpKGJvZHkpKGYpKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9yTG9vcCBwYXJzZXMgdmFsaWQgZm9yIGxvb3BzIGluIHRoZSBmb3JtIFwiZm9yKGluaXRpYWwsIGNvbmRpdGlvbiwgcG9zdCkgeyBib2R5O31cIiBhbmQgcmV0dXJucyBhIEZvck5vZGVcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIHRoZSBidWcgd2l0aCBlYWdlciBldmFsdWF0aW9uXG4gICAgICovXG4gICAgUGFyc2VyLkZvckxvb3AgPSBpID0+IHtcbiAgICAgICAgbGV0IGFyZ3MgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKGZ1bkFwcEFyZ0xpc3QoKSk7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCdmb3InKSkpKGFyZ3MpO1xuICAgICAgICBsZXQgY3VybHkgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCd7JykpO1xuICAgICAgICBsZXQgZXhwciA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5ubCgpKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyKTtcbiAgICAgICAgbGV0IGJvZHkgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihjdXJseSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ30nKSkoZXhwcik7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgbGV0IGluaXQgPSB0dXBbMF1bMF07XG4gICAgICAgICAgICBsZXQgY29uZCA9IHR1cFswXVsxXTtcbiAgICAgICAgICAgIGxldCBwb3N0ID0gdHVwWzBdWzJdO1xuICAgICAgICAgICAgbGV0IGJvZHkgPSB0dXBbMV07XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuRm9yTm9kZShpbml0LCBjb25kLCBwb3N0LCBib2R5LCB3cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHAxKShib2R5KShmKShpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHNpbmdsZUNvbW1lbnQoKSB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55MShwYW50c18xLlByaW1pdGl2ZXMuaXRlbSgpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwMSkoeHMgPT4gcGFudHNfMS5DaGFyVXRpbC5DaGFyU3RyZWFtLmNvbmNhdCh4cykpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLnN0cignLy8nKSkocGFudHNfMS5QcmltaXRpdmVzLm5sKCkpKHAyKTtcbiAgICAgICAgLy9yZXR1cm4gUHJpbWl0aXZlcy5zZXE8Q2hhclV0aWwuQ2hhclN0cmVhbSwgQ2hhclV0aWwuQ2hhclN0cmVhbSwgQ2hhclV0aWwuQ2hhclN0cmVhbVtdPihQcmltaXRpdmVzLnN0cignLy8nKSkoUHJpbWl0aXZlcy5ubCgpKSh4PT54KTtcbiAgICB9XG4gICAgUGFyc2VyLnNpbmdsZUNvbW1lbnQgPSBzaW5nbGVDb21tZW50O1xuICAgIGZ1bmN0aW9uIG11bHRpTGluZUNvbW1lbnQoKSB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55MShwYW50c18xLlByaW1pdGl2ZXMuaXRlbSgpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwMSkoeHMgPT4gcGFudHNfMS5DaGFyVXRpbC5DaGFyU3RyZWFtLmNvbmNhdCh4cykpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLnN0cignXFwvKionKSkocGFudHNfMS5QcmltaXRpdmVzLnN0cignKlxcLycpKShwMik7XG4gICAgfVxuICAgIFBhcnNlci5tdWx0aUxpbmVDb21tZW50ID0gbXVsdGlMaW5lQ29tbWVudDtcbn0pKFBhcnNlciA9IGV4cG9ydHMuUGFyc2VyIHx8IChleHBvcnRzLlBhcnNlciA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBCb29sZWFuTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIEJvb2xlYW5Ob2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgYm9vbGVhblxuICAgICAqIEBwYXJhbSB2YWwgVGhlIGJvb2xlYW4gdmFsdWUgb2YgdGhlIEJvb2xlYW5Ob2RlXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZSBzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl92YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQm9vbGVhbk5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJvb2xlYW5Ob2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgQm9vbGVhbk5vZGUgZXF1YWxzIGFub3RoZXJcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIEJvb2xlYW5Ob2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWwgPT09IHJpZ2h0LnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEJvb2xlYW5Ob2RlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX3ZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYm9vbGVhbiB2YWx1ZVxuICAgICAqL1xuICAgIGdldCB2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvb2xlYW4gdmFsdWVcbiAgICAgKi9cbiAgICBzZXQgdmFsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5Cb29sZWFuTm9kZSA9IEJvb2xlYW5Ob2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm9vbGVhbk5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBOT1Age1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKiBBIE5PUCBpcyBhIHBsYWNlaG9sZGVyIG9wZXJhdGlvbiB0aGF0IGV2YWx1YXRlcyB0byBub3RoaW5nICovXG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBOT1BcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTk9QcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5PUHMgY2Fubm90IGJlIGRyYXduLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgTk9QXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBOT1AgZXF1YWxzIGFub3RoZXIgKHNwb2lsZXI6IGl0IGRvZXNuJ3QpXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuTk9QID0gTk9QO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tk9QLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9OdW1iZXJFZmZlY3RcIik7XG4vLyBOb2RlcyByZXByZXNlbnRpbmcgbnVtYmVyc1xuLy8gU2hvdWxkIGFic3RyYWN0IE5vZGUgY2xhc3MgaW1wbGVtZW50IEV4cHJlc3Npb24/XG5jbGFzcyBOdW1iZXJOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBOdW1iZXJOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgbnVtYmVyXG4gICAgICogQHBhcmFtIHZhbCBUaGUgbnVtYmVyIHZhbHVlXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFsLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTnVtYmVyTm9kZXMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBsZXQgZSA9IG5ldyBOdW1iZXJFZmZlY3RfMS5OdW1iZXJFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBOdW1iZXJOb2RlIGVxdWFscyBhbm90aGVyIE51bWJlck5vZGVcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5IChtdXN0IGJlIGEgTnVtYmVyTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgTnVtYmVyTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsID09PSByaWdodC52YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBOdW1iZXJOb2RlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX3ZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIHN0b3JlZCBpbiB0aGUgbm9kZVxuICAgICAqL1xuICAgIGdldCB2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBudW1iZXIgc3RvcmVkIGluIHRoZSBub2RlXG4gICAgICovXG4gICAgc2V0IHZhbCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWwgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuTnVtYmVyTm9kZSA9IE51bWJlck5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OdW1iZXJOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3RyaW5nRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9TdHJpbmdFZmZlY3RcIik7XG5jbGFzcyBTdHJpbmdOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBTdHJpbmdOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHN0b3JlZCBpbiB0aGUgbm9kZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0ciwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdHIgPSBzdHI7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgU3RyaW5nTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIFN0cmluZyB1c2luZyBTdHJpbmdFZmZlY3RcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgc3RyaW5nIHRvIGJlIGRyYXduXG4gICAgICogQHBhcmFtIGFzdCBUaGUgcHJvZ3JhbSBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBsZXQgZSA9IG5ldyBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBTdHJpbmdOb2RlIGVxdWFscyBhbm90aGVyIFN0cmluZ05vZGVcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5LCBtdXN0IGJlIGEgU3RyaW5nTm9kZVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBTdHJpbmdOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWwgPT09IHJpZ2h0LnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFN0cmluZ05vZGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgJ1xcXCInICsgdGhpcy5fc3RyICsgJ1xcXCInO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJpbmcgc3RvcmVkIGluIHRoZSBub2RlXG4gICAgICovXG4gICAgc2V0IHN0cih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zdHIgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nIHN0b3JlZCBpbiB0aGUgbm9kZVxuICAgICAqL1xuICAgIGdldCB2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLlN0cmluZ05vZGUgPSBTdHJpbmdOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RyaW5nTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIENvbG9yTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgQ29sb3JOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGFuIFJHQiBjb2xvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZWQgPSByZWQ7XG4gICAgICAgIHRoaXMuX2dyZWVuID0gZ3JlZW47XG4gICAgICAgIHRoaXMuX2JsdWUgPSBibHVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIGludG8gYSBzdHJpbmcgUkdCIHZhbHVlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWQgKyBcIiBcIiArIHRoaXMuX2dyZWVuICsgXCIgXCIgKyB0aGlzLl9ibHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb2xvck5vZGVzIGNhbm5vdCBjdXJyZW50bHkgYmUgZHJhd25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgQ29sb3JOb2RlIGVxdWFscyBhbm90aGVyIENvbG9yTm9kZVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHkgKG11c3QgYmUgYSBCb29sZWFuTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgQ29sb3JOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucmVkID09PSByaWdodC5yZWQgJiYgdGhpcy5ncmVlbiA9PT0gcmlnaHQuZ3JlZW4gJiYgdGhpcy5ibHVlID09PSByaWdodC5ibHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIENvbG9yTm9kZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVkIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IHJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmVkIHZhbHVlXG4gICAgICovXG4gICAgc2V0IHJlZChyZWQpIHtcbiAgICAgICAgdGhpcy5fcmVkID0gcmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBncmVlbiB2YWx1ZVxuICAgICAqL1xuICAgIGdldCBncmVlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyZWVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBncmVlbiB2YWx1ZVxuICAgICAqL1xuICAgIHNldCBncmVlbihncmVlbikge1xuICAgICAgICB0aGlzLl9ncmVlbiA9IGdyZWVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBibHVlIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IGJsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBibHVlIHZhbHVlXG4gICAgICovXG4gICAgc2V0IGJsdWUoYmx1ZSkge1xuICAgICAgICB0aGlzLl9ibHVlID0gYmx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29sb3JOb2RlID0gQ29sb3JOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sb3JOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBDdXJ2ZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvQ3VydmVFZmZlY3RcIik7XG5jbGFzcyBDdXJ2ZU5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIEN1cnZlTm9kZSwgYSBub2RlIHJlcHJlc2VudGluZyBhIGN1cnZlXG4gICAgICogQHBhcmFtIGR4IHRoZSBydW4gb2YgdGhlIGN1cnZlXG4gICAgICogQHBhcmFtIGR5IHRoZSByaXNlIG9mIHRoZSBjdXJ2ZVxuICAgICAqIEBwYXJhbSBjdXJ2YXR1cmUgaG93IG11Y2ggdGhlIGN1cnZlLCB1bW0sIGN1cnZlc1xuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGR4LCBkeSwgY3VydmF0dXJlLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2R4ID0gZHg7XG4gICAgICAgIHRoaXMuX2R5ID0gZHk7XG4gICAgICAgIHRoaXMuX2N1cnZhdHVyZSA9IGN1cnZhdHVyZTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBDdXJ2ZU5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBjdXJ2ZSB1c2luZyBDdXJ2ZUVmZmVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBsaW5lIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGRpbXMud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5fZHguZXZhbChjb250ZXh0KS52YWwsIFwiXCIpO1xuICAgICAgICBkaW1zLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl9keS5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGRpbXMuY3VydmF0dXJlID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMuX2N1cnZhdHVyZS5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGxldCBlID0gbmV3IEN1cnZlRWZmZWN0XzEuQ3VydmVFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBDdXJ2ZU5vZGUgZXF1YWxzIGFub3RoZXIgKGlmIHRoZWlyIGR4LCBkeSwgYW5kIGN1cnZhdHVyZSBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhIEN1cnZlTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgQ3VydmVOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZHguZXF1YWxzVmFsKHJpZ2h0LmR4KSAmJiB0aGlzLmR5LmVxdWFsc1ZhbChyaWdodC5keSkgJiYgdGhpcy5jdXJ2YXR1cmUuZXF1YWxzVmFsKHJpZ2h0LmN1cnZhdHVyZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW92ZSgpIHsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnZlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwiY3VydmUoXCIgKyB0aGlzLl9keC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5fZHkudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuX2N1cnZhdHVyZS50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJ1biBvZiB0aGUgY3VydmVcbiAgICAgKi9cbiAgICBnZXQgZHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9keDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcnVuIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIHNldCBkeChkeCkge1xuICAgICAgICB0aGlzLl9keCA9IGR4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByaXNlIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIGdldCBkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByaXNlIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIHNldCBkeShkeSkge1xuICAgICAgICB0aGlzLl9keSA9IGR5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJ2YXR1cmUgb2YgdGhlIGN1cnZlXG4gICAgICovXG4gICAgZ2V0IGN1cnZhdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnZhdHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VydmF0dXJlIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIHNldCBjdXJ2YXR1cmUoY3VydmF0dXJlKSB7XG4gICAgICAgIHRoaXMuX2N1cnZhdHVyZSA9IGN1cnZhdHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuQ3VydmVOb2RlID0gQ3VydmVOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3VydmVOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIEVsbGlwc2VOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYW4gRWxsaXBzZU5vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYW4gZWxsaXBzZVxuICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIGVsbGlwc2VcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGVsbGlwc2VcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBFbGxpcHNlTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGVsbGlwc2Ugb24gdGhlIGNhbnZhcyB1c2luZyBFbGxpcHNlRWZmZWN0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXMgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGVsbGlwc2VcbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGRpbXMud2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgZGltcy5oZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIGxldCBlID0gbmV3IEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KHRoaXMpO1xuICAgICAgICBlLmRyYXcoY29udGV4dCwgZGltcywgYXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgRWxsaXBzZU5vZGUgZXF1YWxzIGFub3RoZXIgRWxsaXBzZU5vZGUgKGlmIHRoZWlyIHdpZHRocyBhbmQgaGVpZ2h0cyBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhbiBFbGxpcHNlTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgRWxsaXBzZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy53aWR0aC5lcXVhbHNWYWwocmlnaHQud2lkdGgpICYmIHRoaXMuaGVpZ2h0LmVxdWFsc1ZhbChyaWdodC5oZWlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVsbGlwc2VcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJlbGxpcHNlKFwiICsgdGhpcy5fd2lkdGgudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuX2hlaWdodC50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIG1vdmUoKSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGxpcHNlIHdpZHRoXG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGVsbGlwc2Ugd2lkdGhcbiAgICAgKi9cbiAgICBzZXQgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBlbGxpcHNlIGhlaWdodFxuICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZWxsaXBzZSBoZWlnaHRcbiAgICAgKi9cbiAgICBzZXQgaGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkVsbGlwc2VOb2RlID0gRWxsaXBzZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbGxpcHNlTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgRXBoRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9FcGhFZmZlY3RcIik7XG5jbGFzcyBFcGhOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYW4gRXBoTm9kZSwgYSBub2RlIHJlcHJlc2VudGluZyBzb21ldGhpbmcgdmVyeSBzcGVjaWFsXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgRXBoTm9kZVxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgRXBoTm9kZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgLy90aGlzLl9pbWFnZSA9IGltYWdlO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgRXBoTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIHJlY3RhbmdsZSB1c2luZyBFcGhFZmZlY3RcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgcmVjdGFuZ2xlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGRpbXMud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5fd2lkdGguZXZhbChjb250ZXh0KS52YWwsIFwiXCIpO1xuICAgICAgICBkaW1zLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl9oZWlnaHQuZXZhbChjb250ZXh0KS52YWwsIFwiXCIpO1xuICAgICAgICBsZXQgZSA9IG5ldyBFcGhFZmZlY3RfMS5FcGhFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBFcGhOb2RlIGVxdWFscyBhbm90aGVyIChpZiB0aGVpciB3aWR0aHMgYW5kIGhlaWdodHMgYXJlIGVxdWFsKVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHkgKG11c3QgYmUgYW4gRXBoTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgRXBoTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoLmVxdWFsc1ZhbChyaWdodC53aWR0aCkgJiYgdGhpcy5oZWlnaHQuZXF1YWxzVmFsKHJpZ2h0LmhlaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW92ZSgpIHsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEVwaE5vZGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJlcGgoXCIgKyB0aGlzLl93aWR0aC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5faGVpZ2h0LnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIEVwaE5vZGVcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd2lkdGggb2YgdGhlIEVwaE5vZGVcbiAgICAgKi9cbiAgICBzZXQgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBFcGhOb2RlXG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBFcGhOb2RlXG4gICAgICovXG4gICAgc2V0IGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5FcGhOb2RlID0gRXBoTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVwaE5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IExpbmVFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0xpbmVFZmZlY3RcIik7XG5jbGFzcyBMaW5lTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgTGluZU5vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYSBsaW5lXG4gICAgICogQHBhcmFtIGR4IHRoZSBydW4gb2YgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0gZHkgdGhlIHJpc2Ugb2YgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkeCwgZHksIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZHggPSBkeDtcbiAgICAgICAgdGhpcy5fZHkgPSBkeTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMaW5lTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGxpbmUgdXNpbmcgTGluZUVmZmVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBsaW5lIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGRpbXMud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5fZHguZXZhbChjb250ZXh0KS52YWwsIFwiXCIpO1xuICAgICAgICBkaW1zLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl9keS5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGxldCBlID0gbmV3IExpbmVFZmZlY3RfMS5MaW5lRWZmZWN0KHRoaXMpO1xuICAgICAgICBlLmRyYXcoY29udGV4dCwgZGltcywgYXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgTGluZU5vZGUgZXF1YWxzIGFub3RoZXIgKGlmIHRoZWlyIGR4IGFuZCBkeSBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhIExpbmVOb2RlKVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBMaW5lTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmR4LmVxdWFsc1ZhbChyaWdodC5keCkgJiYgdGhpcy5keS5lcXVhbHNWYWwocmlnaHQuZHkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vdmUoKSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsaW5lXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwibGluZShcIiArIHRoaXMuX2R4LnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLl9keS50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJ1biBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIGdldCBkeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBydW4gb2YgdGhlIGxpbmVcbiAgICAgKi9cbiAgICBzZXQgZHgoZHgpIHtcbiAgICAgICAgdGhpcy5fZHggPSBkeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmlzZSBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIGdldCBkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByaXNlIG9mIHRoZSBsaW5lXG4gICAgICovXG4gICAgc2V0IGR5KGR5KSB7XG4gICAgICAgIHRoaXMuX2R5ID0gZHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkxpbmVOb2RlID0gTGluZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgUmVjdGFuZ2xlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9SZWN0YW5nbGVFZmZlY3RcIik7XG5jbGFzcyBSZWN0YW5nbGVOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBSZWN0YW5nbGVOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBSZWN0YW5nbGVOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgcmVjdGFuZ2xlIHVzaW5nIFJlY3RhbmdsZUVmZmVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSByZWN0YW5nbGUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSBhc3QgVGhlIHByb2dyYW0gQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgZGltcy53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl93aWR0aC5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGRpbXMuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMuX2hlaWdodC5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGxldCBlID0gbmV3IFJlY3RhbmdsZUVmZmVjdF8xLlJlY3RhbmdsZUVmZmVjdCh0aGlzKTtcbiAgICAgICAgZS5kcmF3KGNvbnRleHQsIGRpbXMsIGFzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIFJlY3RhbmdsZU5vZGUgZXF1YWxzIGFub3RoZXIgKGlmIHRoZWlyIHdpZHRocyBhbmQgaGVpZ2h0cyBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhIFJlY3RhbmdsZU5vZGUpXG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIFJlY3RhbmdsZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy53aWR0aC5lcXVhbHNWYWwocmlnaHQud2lkdGgpICYmIHRoaXMuaGVpZ2h0LmVxdWFsc1ZhbChyaWdodC5oZWlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vdmUoKSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJyZWN0KFwiICsgdGhpcy5fd2lkdGgudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuX2hlaWdodC50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIHNldCB3aWR0aCh3aWR0aCkge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICovXG4gICAgc2V0IGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5SZWN0YW5nbGVOb2RlID0gUmVjdGFuZ2xlTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlY3RhbmdsZU5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIERpbWVuc2lvbnMge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBEaW1lbnNpb25zLCB3aGljaCBzdG9yZXMgb2JqZWN0IGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0geCBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0geSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gc2NhbGUgVGhlIHNjYWxlIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gcmFkaXVzIFRoZSByYWRpdXMgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHNjYWxlLCByYWRpdXMpIHtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICB0aGlzLl9zY2FsZSA9IHNjYWxlO1xuICAgICAgICB0aGlzLl9yYWRpdXMgPSByYWRpdXMgfHwgbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDMwLCBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGltZW5zaW9uc1xuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy54LnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLnkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgc2V0IHgodmFsKSB7XG4gICAgICAgIHRoaXMuX3ggPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIHNldCB5KHZhbCkge1xuICAgICAgICB0aGlzLl95ID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByYWRpdXMgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGdldCByYWRpdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJhZGl1cyBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgc2V0IHJhZGl1cyh2YWwpIHtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzY2FsZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IHNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjYWxlIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgc2NhbGUodmFsKSB7XG4gICAgICAgIHRoaXMuX3NjYWxlID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHdpZHRoIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgd2lkdGgodmFsKSB7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgc2V0IGhlaWdodCh2YWwpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJ2YXR1cmUgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBjdXJ2YXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJ2YXR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnZhdHVyZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgc2V0IGN1cnZhdHVyZSh2YWwpIHtcbiAgICAgICAgdGhpcy5fY3VydmF0dXJlID0gdmFsO1xuICAgIH1cbn1cbmV4cG9ydHMuRGltZW5zaW9ucyA9IERpbWVuc2lvbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaW1lbnNpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgUHJpbnROb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBQcmludE5vZGUsIHJlcHJlc2VudGluZyBhbiBvYmplY3QgdG8gYmUgcHJpbnRlZFxuICAgICAqIEBwYXJhbSB0b1ByaW50IFRoZSBvYmplY3QgdG8gYmUgcHJpbnRlZFxuICAgICAqIEBwYXJhbSBkaW1lbnNpb25zIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3QgdG8gYmUgcHJpbnRlZFxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRvUHJpbnQsIGRpbWVuc2lvbnMsIHdzKSB7XG4gICAgICAgIHRoaXMuX3NjYWxlID0gMTtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90b1ByaW50ID0gdG9QcmludDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RpbXMgPSBkaW1lbnNpb25zIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCB0byBiZSBwcmludGVkXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwicHJpbnQoXCIgKyB0aGlzLnRvUHJpbnQudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuZGltcy50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgUHJpbnROb2RlXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBQcmludE5vZGVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW50Tm9kZXMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3KCkgb24gcHJpbnRPcFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBvYmplY3QgdG8gYmUgcHJpbnRlZCBhbmQgZHJhd3MgaXRcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5fdG9QcmludC5ldmFsKGNvbnRleHQpO1xuICAgICAgICByZXMuZHJhdyhjb250ZXh0LCB0aGlzLl9kaW1zLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb2JqZWN0IHRvIGJlIHByaW50ZWRcbiAgICAgKi9cbiAgICBnZXQgdG9QcmludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvUHJpbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9iamVjdCB0byBiZSBwcmludGVkXG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5QcmludE5vZGUgPSBQcmludE5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QcmludE5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBSZXR1cm5FcnJvcl8xID0gcmVxdWlyZShcIi4vUmV0dXJuRXJyb3JcIik7XG5jbGFzcyBSZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIFJldHVybiBvYmplY3QsIHJlcHJlc2VudGluZyBzb21ldGhpbmcgdG8gYmUgcmV0dXJuZWQgaW4gYSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBleHByIFRoZSBleHByZXNzaW9uIHRvIGJlIHJldHVybmVkXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZXhwciwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9leHByID0gZXhwcjtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyB0aGUgZXhwcmVzc2lvbiB0byBiZSByZXR1cm5lZCBhbmQgcmV0dXJucyB2aWEgYSBSZXR1cm5FcnJvXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIC8vIElmIHJldHVybiB2YWwgaXMgYSB2YXIsIHJldHVybnMgdGhhdCB2YXIncyB2YWx1ZVxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fZXhwci5ldmFsKGNvbnRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgUmV0dXJuRXJyb3JfMS5SZXR1cm5FcnJvcihyZXN1bHQsIGNvbnRleHQucmV0SURMb29rdXAoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIFJldHVybiBub2Rlc1xuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gUmV0dXJuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBSZXR1cm4gbm9kZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyBcInJldHVybiBcIiArIHRoaXMuX2V4cHIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbm9kZXMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIFJldHVyblwiKTtcbiAgICB9XG59XG5leHBvcnRzLlJldHVybiA9IFJldHVybjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJldHVybi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFJldHVybkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBSZXR1cm5FcnJvciwgYSBjdXN0b20gZXJyb3IgY2xhc3MgdGhhdCB3ZSBhYnVzZSB0byByZXR1cm4gdmFsdWVzXG4gICAgICogQHBhcmFtIHJldFZhbCBUaGUgdmFsdWUgdG8gYmUgcmV0dXJuZWRcbiAgICAgKiBAcGFyYW0gSUQgVGhlIElEIG9mIHRoZSB2YWx1ZSB0byBiZSByZXR1cm5lZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJldFZhbCwgSUQpIHtcbiAgICAgICAgc3VwZXIoSUQpO1xuICAgICAgICB0aGlzLnJldFZhbCA9IHJldFZhbDtcbiAgICAgICAgdGhpcy5JRCA9IElEO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUmV0dXJuRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLlJldHVybkVycm9yID0gUmV0dXJuRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXR1cm5FcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xuY2xhc3MgU2NvcGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBTY29wZSwgYW4gb2JqZWN0IGtlZXBpbmcgdHJhY2sgb2Ygb2JqZWN0cyB3aXRoaW4gYSBwYXJ0aWN1bGFyIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gcGFyZW50IFRoZSBwYXJlbnQgU2NvcGVcbiAgICAgKiBAcGFyYW0gZWZmZWN0cyBFZmZlY3RzIHdpdGhpbiB0aGlzIFNjb3BlXG4gICAgICogQHBhcmFtIG15U3RhdGUgVGhlIHNjb3BlIHN0YXRlXG4gICAgICogQHBhcmFtIGV2ZW50TG9nIFRoZSBsb2cgb2YgZXZlbnRzIHRoYXQgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGVmZmVjdHMsIGV2ZW50TG9nKSB7XG4gICAgICAgIHRoaXMuX3JldFZhbElEID0gc3BhY2VfbGlmdF8xLk5vbmU7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IHNwYWNlX2xpZnRfMS5Ob25lO1xuICAgICAgICB0aGlzLl9ldmVudExvZyA9IFtdOyAvLyBUaGUgZXZlbnQgbG9nXG4gICAgICAgIHRoaXMuX2hhZEZ1bkV2YWwgPSBmYWxzZTsgLy8gV2FzIHRoaXMgY3JlYXRlZCBpbiBhIGZ1bmN0aW9uP1xuICAgICAgICAvL3B1YmxpYyBnbG9iYWxGdW5JRCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHRoaXMuZ2xvYmFsRnVuSUQgPSAxMDAwMDAwMDsgLy8gVGhlIGdsb2JhbCBJRCBmb3IgZnVuY3Rpb25zIGluIHRoaXMgY29udGV4dFxuICAgICAgICB0aGlzLl92YXJCaW5kaW5ncyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLl9lZmZlY3RzID0gZWZmZWN0cyB8fCBudWxsO1xuICAgICAgICB0aGlzLl9ldmVudExvZyA9IGV2ZW50TG9nO1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50ICE9IG51bGwgJiYgdGhpcy5fcGFyZW50Ll9oYWRGdW5FdmFsKVxuICAgICAgICAgICAgdGhpcy5faGFkRnVuRXZhbCA9IHRydWU7IC8vIGNvcHkgZnVuY3Rpb24gZXZhbCBmbGFnIGZyb20gcGFyZW50XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyBpbmZvcm1hdGlvbiBmcm9tIHRoaXMgU2NvcGUgaW50byBhbm90aGVyIFNjb3BlIGFuZCByZXR1cm5zIHRoZSBuZXcgU2NvcGVcbiAgICAgKi9cbiAgICBjb3B5KCkge1xuICAgICAgICBsZXQgcyA9IG5ldyBTY29wZSh0aGlzLl9wYXJlbnQsIHRoaXMuX2VmZmVjdHMsIHRoaXMuX2V2ZW50TG9nKTtcbiAgICAgICAgcy52YXJCaW5kaW5ncyA9IG5ldyBNYXAodGhpcy5fdmFyQmluZGluZ3MpO1xuICAgICAgICBzLmNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgICBzLmV2ZW50TG9nID0gdGhpcy5ldmVudExvZztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY2xhcmVzIGEgbmV3IHZhcmlhYmxlXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGJlIGRlY2xhcmVkXG4gICAgICovXG4gICAgZGVjbGFyZShuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl92YXJCaW5kaW5ncy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjb3BlIGFscmVhZHkgaGFzIHZhciB3aXRoIG5hbWUgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92YXJCaW5kaW5ncy5zZXQobmFtZSwgc3BhY2VfbGlmdF8xLk5vbmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIGEgdmFsdWUgdG8gYSB2YXJpYWJsZSBpbiB0aGlzIENvbnRleHRcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGVcbiAgICAgKi9cbiAgICBhc3NpZ24obmFtZSwgdmFsKSB7XG4gICAgICAgIHRoaXMuX3ZhckJpbmRpbmdzLnNldChuYW1lLCBzcGFjZV9saWZ0XzEuU29tZSh2YWwpKTsgLy9Tb21lKHZhbCk/XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIGEgdmFsdWUgd2l0aGluIHRoZSBTY29wZSBhbmQgYWxsIGl0cyBhbmNlc3RvciBTY29wZXNcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB0byBzZWFyY2ggd2l0aGluXG4gICAgICovXG4gICAgbG9va3VwKG5hbWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQudmFyQmluZGluZ3MuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC52YXJCaW5kaW5ncy5nZXQobmFtZSkuaXNEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNvbnRleHQudmFyQmluZGluZ3MuZ2V0KG5hbWUpLmdldCgpKTsgLy9leHRyYSBnZXQgdG8gbWFuYWdlIFNvbWUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghKGNvbnRleHQucGFyZW50ID09IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb29rdXAobmFtZSwgY29udGV4dC5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhcmlhYmxlIGNvdWxkIG5vdCBiZSBmb3VuZC5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIGFuZCByZXR1cm5zIHRoZSByZXR1cm4gSUQgdmFsdWVcbiAgICAgKi9cbiAgICByZXRJRExvb2t1cCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JldFZhbElELmlzRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0VmFsSUQuZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudC5yZXRJRExvb2t1cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjYWxsZXIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE1hcCBvZiB2YXJpYWJsZSBiaW5kaW5nc1xuICAgICAqL1xuICAgIGdldCB2YXJCaW5kaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhckJpbmRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBNYXAgb2YgdmFyaWFibGUgYmluZGluZ3NcbiAgICAgKi9cbiAgICBzZXQgdmFyQmluZGluZ3MobSkge1xuICAgICAgICB0aGlzLl92YXJCaW5kaW5ncyA9IG07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhcmVudCBTY29wZVxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJldHVybiB2YWx1ZSBJRFxuICAgICAqL1xuICAgIGdldCByZXRWYWxJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldFZhbElEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByZXR1cm4gdmFsdWUgSURcbiAgICAgKi9cbiAgICBzZXQgcmV0VmFsSUQodmFsKSB7XG4gICAgICAgIHRoaXMuX3JldFZhbElEID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBIVE1MIGNhbnZhc1xuICAgICAqL1xuICAgIGdldCBjYW52YXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIEhUTUwgY2FudmFzXG4gICAgICovXG4gICAgc2V0IGNhbnZhcyh2YWwpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlZmZlY3RzIGFycmF5XG4gICAgICovXG4gICAgZ2V0IGVmZmVjdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lZmZlY3RzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBlZmZlY3RzIGFycmF5XG4gICAgICovXG4gICAgc2V0IGVmZmVjdHMoYXJyKSB7XG4gICAgICAgIHRoaXMuX2VmZmVjdHMgPSBhcnI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV2ZW50IGxvZ1xuICAgICAqL1xuICAgIGdldCBldmVudExvZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50TG9nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBldmVudCBsb2dcbiAgICAgKi9cbiAgICBzZXQgZXZlbnRMb2codXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50TG9nID0gdXBkYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBlZmZlY3RzXG4gICAgICovXG4gICAgZ2V0IG11bFNlbEFycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbXVsU2VsQXJyYXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFycmF5IG9mIGVmZmVjdHNcbiAgICAgKi9cbiAgICBzZXQgbXVsU2VsQXJyYXkodXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX211bFNlbEFycmF5ID0gdXBkYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBTY29wZSB3YXMgY3JlYXRlZCBpbiBhIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZ2V0IGhhZEZ1bkV2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYWRGdW5FdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhpcyBTY29wZSB3YXMgY3JlYXRlZCBpbiBhIGZ1bmN0aW9uXG4gICAgICovXG4gICAgc2V0IGhhZEZ1bkV2YWwodmFsKSB7XG4gICAgICAgIHRoaXMuX2hhZEZ1bkV2YWwgPSB2YWw7XG4gICAgfVxufVxuZXhwb3J0cy5TY29wZSA9IFNjb3BlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2NvcGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTY29wZV8xID0gcmVxdWlyZShcIi4vU2NvcGVcIik7XG5jb25zdCBzcGFjZV9saWZ0XzEgPSByZXF1aXJlKFwic3BhY2UtbGlmdFwiKTtcbmNsYXNzIFNlcXVlbmNlTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgU2VxdWVuY2VOb2RlLCB0aGUgYnVpbGRpbmcgYmxvY2sgb2YgdGhlIEFTVFxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IHNpZGUgb2YgdGhlIFNlcXVlbmNlXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBTZXF1ZW5jZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBjaGlsZHJlbiBpbiBwb3N0b3JkZXIgKGxlZnQsIHJpZ2h0LCBwYXJlbnQpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsZWZ0U2NvcGUgPSBuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0LCBjb250ZXh0LmVmZmVjdHMsIGNvbnRleHQuZXZlbnRMb2cpO1xuICAgICAgICBsZWZ0U2NvcGUuY2FudmFzID0gc3BhY2VfbGlmdF8xLlNvbWUoY29udGV4dC5jYW52YXMuZ2V0KCkpO1xuICAgICAgICAvL3Rocm93aW5nIGF3YXkgYWZ0ZXIgZXZhbGluZ1xuICAgICAgICB0aGlzLl9sZWZ0VmFsID0gdGhpcy5fbGVmdC5ldmFsKGxlZnRTY29wZSk7XG4gICAgICAgIHRoaXMuX3JpZ2h0VmFsID0gdGhpcy5fcmlnaHQuZXZhbChsZWZ0U2NvcGUpOyAvLyBsZWZ0U2NvcGUgbWF5IGJlIG1vZGlmaWVkIG5vd1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXF1ZW5jZU5vZGVzIGNhbm5vdCBiZSBkaXJlY3RseSBkcmF3blxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdygpIG9uIFNlcXVlbmNlTm9kZXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgZGlyZWN0bHkgY2FsbGVkIG9uIFNlcXVlbmNlTm9kZXNcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIFNlcXVlbmNlTm9kZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQVNUXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9sZWZ0LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLl9sZWZ0Lm5ld0xpbmUoKSA9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCI7XFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JpZ2h0Lm5ld0xpbmUoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCkgKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLl9yaWdodC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxlZnQgY2hpbGRcbiAgICAgKi9cbiAgICBzZXQgbGVmdChsZWZ0KSB7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsZWZ0IGNoaWxkXG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByaWdodCBjaGlsZFxuICAgICAqL1xuICAgIHNldCByaWdodChyaWdodCkge1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByaWdodCBjaGlsZFxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbGVmdCBjaGlsZVxuICAgICAqL1xuICAgIGdldCBsZWZ0VmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdFZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHJpZ2h0IGNoaWxlXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0VmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHRWYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLlNlcXVlbmNlTm9kZSA9IFNlcXVlbmNlTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlcXVlbmNlTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi4vLi4vaW5kZXhcIik7XG5jb25zdCBpbmRleF8yID0gcmVxdWlyZShcIi4uLy4uL2luZGV4XCIpO1xuY29uc3QgaW5kZXhfMyA9IHJlcXVpcmUoXCIuLi8uLi9pbmRleFwiKTtcbmNvbnN0IGluZGV4XzQgPSByZXF1aXJlKFwiLi4vLi4vaW5kZXhcIik7XG5jb25zdCBpbmRleF81ID0gcmVxdWlyZShcIi4uLy4uL2luZGV4XCIpO1xuY29uc3QgaW5kZXhfNiA9IHJlcXVpcmUoXCIuLi8uLi9pbmRleFwiKTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xubGV0IGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xubGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5sZXQgaW5wdXRCb3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5wdXQnKTtcbmxldCBsYXN0V29ya2luZ0lucHV0VGV4dCA9IFwiXCI7XG4vL3RoZSBlZmZlY3RzIGFycmF5IHRoYXQgaG9sZHMgYWxsIHRoZSB0ZXh0LCBlbGxpcHNlcywgYW5kIHJlY3RhbmdsZXNcbmxldCBlZmZlY3RzID0gW107XG5sZXQgYXN0O1xubGV0IGNvbnRleHQ7XG5sZXQgc2hvd0RlYnVnID0gdHJ1ZTsgLy8gZmxhZyB0byBzaG93IG9yIGhpZGUgZGVidWcgYnV0dG9uXG5sZXQgbWFzdGVyTG9nID0gW107XG5sZXQgc2VsZWN0ZWRFbGVtcyA9IFtdO1xubGV0IHRleHRCb3hTZWxlY3RlZDsgLy9zZWVzIGlmIHRoZSB0ZXh0IGJveCBpcyBzZWxlY3RlZFxubGV0IGlzUGFpbnRpbmc7IC8vdGVzdHMgdG8gc2VlIGlmIHlvdSdyZSBwYWludGluZyB0byB0aGUgY2FudmFzXG5sZXQgY2hlY2twb2ludElzQWN0aXZlID0gZmFsc2U7XG5sZXQgY2hlY2twb2ludCA9IG51bGw7XG5sZXQgY2FudmFzSXNEaXNhYmxlZCA9IGZhbHNlO1xubGV0IHNlbGVjdGVkID0gMDsgLy90aGUgbnVtYmVyIG9mIHNlbGVjdGVkIGVmZmVjdHMgaWYgbXVsdGlwbHkgc2VsZWN0aW5nXG5sZXQgYWxyZWFkeUxvZ2dlZCA9IGZhbHNlO1xubGV0IG51bUxvZ2dlZCA9IDA7XG5sZXQgZ2xvYmFsSUQgPSAxO1xubGV0IGVwaDtcbi8qXG5sZXQgYnVnQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlYnVnJyk7XG5pZighc2hvd0RlYnVnKXtcbiAgICBidWdCdXR0b24uc3R5bGUudmlzaWJpbGl0eT0naGlkZGVuJztcbn1cblxuYnVnQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbigpe1xuICAgIHByaW50TG9nKCk7XG59XG4qL1xuLyoqXG4gKiA8ZGl2IGNsYXNzPVwiY29sLWl0ZW1cIj5cbiAqICA8YnV0dG9uIGlkPSdwYWludCcgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiNERkI1MzRcIj4gUnVuIDwvYnV0dG9uPlxuICogPC9kaXY+XG4gKlxuICogUHV0IHRoaXMgaW4gaHRtbCBmaWxlIGZvciBSdW4gYnV0dG9uJ3Mgc3R5bGluZ1xuICovXG4vL2xldCBwYWludEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYWludCcpO1xuLyoqXG4gKiBtYWtlcyB0aGUgcGFpbnQgYnV0dG9uIHBhaW50IHRleHQgZnJvbSB0aGUgdGV4dGFyZWEgdG8gdGhlIGNhbnZhcyFcbiAqL1xuLypcbnBhaW50QnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWZmZWN0cy5sZW5ndGggPSAwOyAvLyBzbGlnaHRseSBza2V0Y2ggY2xlYXJpbmcgbWV0aG9kIHRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBhcnJheVxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgIGlzUGFpbnRpbmcgPSB0cnVlO1xuICAgIGxldCBpbnB1dFRleHQgPSBpbnB1dEJveC52YWx1ZTtcblxuICAgIGxldCBhc3RPcHQgPSBQYXJzZXIucGFyc2UoaW5wdXRUZXh0KTtcbiAgICBpZihhc3RPcHQuaXNEZWZpbmVkKCkpe1xuICAgICAgICBhc3QgPSBhc3RPcHQuZ2V0KCk7XG4gICAgICAgIGNvbnRleHQgPSBuZXcgU2NvcGUobnVsbCwgZWZmZWN0cywgbWFzdGVyTG9nKTtcbiAgICAgICAgY29udGV4dC5jYW52YXMgPSBTb21lKGNhbnZhcyk7XG4gICAgICAgIGFzdC5ldmFsKGNvbnRleHQpOyAvL3RoaXMgaXMgd2hlcmUgd2UgZHJhdyB0aGUgb2JqZWN0cyB0byB0aGUgc2NyZWVuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGVycm9yID0gXCJlcnJvciB0ZXh0XCI7XG4gICAgICAgIGFsZXJ0KFwiUXVhbjogc28gc29tZXRoaW5nIHdpdGggdGhpcyBzeW50YXggZXJyb3I6IFwiICsgZXJyb3IpO1xuICAgIH1cblxuICAgIC8vbGV0IHBhaW50RXZ0ID0gbmV3IFBhaW50RXZlbnQoaW5wdXRUZXh0KTsgLy8gd2lsbCBuZWVkIHRvIGdldCBmcm9tIGFzdCB3aGVuIHRoYXQncyBpbXBsZW1lbnRlZFxuXG4gICAgLy8gQWRkaW5nIGNvbnRleHQgbG9nIHRvIG1hc3RlciBsb2dcbiAgICAvL2xvZ0V2ZW50LnB1c2gocGFpbnRFdnQuYXNzZW1ibGVMb2coKSk7XG4gICAgcHJpbnRMb2coKTtcbiAgICAvL2V2ZW50MS5sb2dJdGVtKCk7XG4gICAgLy8gfVxufTtcbiovXG4vL2NsZWFycyB0aGUgY2FudmFzIVxubGV0IHJlc2V0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlc2V0Jyk7XG5yZXNldEJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjaGVja3BvaW50Ll9zdGFydGVyQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHRleHRCb3hTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlucHV0Qm94LnZhbHVlID0gY2hlY2twb2ludC5fc3RhcnRlckNvZGU7XG4gICAgfVxuICAgIGNvbnRleHQuZXZlbnRMb2cucHVzaChuZXcgaW5kZXhfMi5DbGVhckV2ZW50KCkpO1xuICAgIG1hc3RlckxvZy5wdXNoKGNvbnRleHQuZXZlbnRMb2dbY29udGV4dC5ldmVudExvZy5sZW5ndGggLSAxXSk7IC8vIERvZXMgdGhpcyBhY3R1YWxseSB3b3JrP1xuICAgIHByaW50TG9nKCk7XG4gICAgLy9sZXQgY2xlYXJFdnQgPSBuZXcgQ2xlYXJFdmVudCgpO1xuICAgIC8vbG9nRXZlbnQucHVzaChjbGVhckV2dC5hc3NlbWJsZUxvZygpKTtcbiAgICAvL2NvbnNvbGUubG9nKFwiTG9nOiBcIiArIGxvZ0V2ZW50KTtcbn07XG5sZXQgdGltZXIgPSBudWxsO1xuaW5wdXRCb3gub25rZXlkb3duID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aW1lciAhPSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgfVxuICAgIHRpbWVyID0gc2V0VGltZW91dChwYXJzZSwgMjAwKTtcbn07XG5mdW5jdGlvbiBwYXJzZSgpIHtcbiAgICBlZmZlY3RzLmxlbmd0aCA9IDA7IC8vIHNsaWdodGx5IHNrZXRjaCBjbGVhcmluZyBtZXRob2QgdG8gbWFpbnRhaW4gcmVmZXJlbmNlIHRvIG9yaWdpbmFsIGFycmF5XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGxldCBpbnB1dFRleHQgPSBpbnB1dEJveC52YWx1ZTtcbiAgICBsZXQgYXN0T3B0ID0gaW5kZXhfMS5QYXJzZXIucGFyc2UoaW5wdXRUZXh0KTtcbiAgICBpZiAoYXN0T3B0LmlzRGVmaW5lZCgpKSB7XG4gICAgICAgIGFzdCA9IGFzdE9wdC5nZXQoKTtcbiAgICAgICAgY29udGV4dCA9IG5ldyBpbmRleF8yLlNjb3BlKG51bGwsIGVmZmVjdHMsIG1hc3RlckxvZyk7XG4gICAgICAgIGNvbnRleHQuY2FudmFzID0gc3BhY2VfbGlmdF8xLlNvbWUoY2FudmFzKTtcbiAgICAgICAgYXN0LmV2YWwoY29udGV4dCk7IC8vdGhpcyBpcyB3aGVyZSB3ZSBkcmF3IHRoZSBvYmplY3RzIHRvIHRoZSBzY3JlZW5cbiAgICAgICAgbGFzdFdvcmtpbmdJbnB1dFRleHQgPSBpbnB1dFRleHQ7XG4gICAgfVxuICAgIC8vbGV0IHBhaW50RXZ0ID0gbmV3IFBhaW50RXZlbnQoaW5wdXRUZXh0KTsgLy8gd2lsbCBuZWVkIHRvIGdldCBmcm9tIGFzdCB3aGVuIHRoYXQncyBpbXBsZW1lbnRlZFxuICAgIC8vIEFkZGluZyBjb250ZXh0IGxvZyB0byBtYXN0ZXIgbG9nXG4gICAgLy9sb2dFdmVudC5wdXNoKHBhaW50RXZ0LmFzc2VtYmxlTG9nKCkpO1xuICAgIHByaW50TG9nKCk7XG4gICAgLy9ldmVudDEubG9nSXRlbSgpO1xuICAgIC8vIH1cbn1cbi8qKlxuICogVGhlIGFuaW1hdGlvbiBmdW5jdGlvbiB0aGF0IGJhc2ljYWxseSByZWN1cnNpdmVseSBjYWxscyBpdHNlbGYsIGNsZWFyaW5nIGFuZFxuICogcmVkcmF3aW5nIHRvIHRoZSBjYW52YXMgYXQgNjBmcHMuXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsgLy9jbGVhcnMgY2FudmFzXG4gICAgc2VsZWN0ZWQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWZmZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlZmZlY3RzW2ldLnVwZGF0ZSgpO1xuICAgICAgICBpZiAoZWZmZWN0c1tpXS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRFbGVtcy5wdXNoKGVmZmVjdHNbaV0pO1xuICAgICAgICAgICAgc2VsZWN0ZWQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0c1tpXS5nZXRKdXN0RHJhZ2dlZCgpKSB7IC8vIExvZ3MgZHJhZyBldmVudFxuICAgICAgICAgICAgY29udGV4dC5ldmVudExvZy5wdXNoKG5ldyBpbmRleF8yLkRyYWdFdmVudChlZmZlY3RzW2ldKSk7XG4gICAgICAgICAgICBtYXN0ZXJMb2cucHVzaChjb250ZXh0LmV2ZW50TG9nW2NvbnRleHQuZXZlbnRMb2cubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgZWZmZWN0c1tpXS5zZXRKdXN0RHJhZ2dlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdHNbaV0uaWRPYmogPT0gdW5kZWZpbmVkKSB7IC8vIEdpdmVzIG9iamVjdCBhbiBJRCBpZiBpdCBkb2Vzbid0IGhhdmUgb25lXG4gICAgICAgICAgICBlZmZlY3RzW2ldLmluaXRJRChnbG9iYWxJRCk7XG4gICAgICAgICAgICBjb250ZXh0LmV2ZW50TG9nLnB1c2gobmV3IGluZGV4XzIuSURFdmVudChlZmZlY3RzW2ldKSk7IC8vIExvZ3MgSURcbiAgICAgICAgICAgIGdsb2JhbElEKys7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVmZmVjdHNbaV0uZ2V0SUQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYoKChlZmZlY3RzW2ldIGFzIEVsbGlwc2VFZmZlY3QpLmp1c3REcmFnZ2VkKSl7XG4gICAgICAgIC8vICAgICAvL2NvbnRleHQuZXZlbnRMb2cucHVzaChuZXcgRHJhZ0V2ZW50KGVmZmVjdHNbaV0pKTtcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBoYXZlIGl0ZXJhdGVkIHRocm91Z2ggYWxsIGVmZmVjdHMgYW5kIGhhdmUgY29tcGxldGUgbGlzdCB0byBsb2dcbiAgICBpZiAoc2VsZWN0ZWQgIT0gbnVtTG9nZ2VkKSB7IC8vIGlmIHNlbGVjdGlvbnMgaGF2ZSBjaGFuZ2VkLCBzaG91bGQgbG9nIGFnYWluXG4gICAgICAgIGFscmVhZHlMb2dnZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFhbHJlYWR5TG9nZ2VkICYmIHNlbGVjdGVkID49IDIpIHsgLy8gbG9ncyBpZiBoYXNuJ3QgYWxyZWFkeVxuICAgICAgICBudW1Mb2dnZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgY29udGV4dC5ldmVudExvZy5wdXNoKG5ldyBpbmRleF8yLlNlbGVjdEV2ZW50KHNlbGVjdGVkRWxlbXMpKTtcbiAgICAgICAgbWFzdGVyTG9nLnB1c2goY29udGV4dC5ldmVudExvZ1tjb250ZXh0LmV2ZW50TG9nLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgYWxyZWFkeUxvZ2dlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vVGhpcyBkb2VzIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uLCBwYXNzaW5nIHRoZSBuZXcgc3RyaW5ncyB0byB0aGUgdGV4dCBib3hcbiAgICBsZXQgaW5wdXRUZXh0ID0gaW5wdXRCb3gudmFsdWU7XG4gICAgaWYgKHRleHRCb3hTZWxlY3RlZCAmJiBpbnB1dFRleHQgIT09IGxhc3RXb3JraW5nSW5wdXRUZXh0KSB7XG4gICAgICAgIC8qICAgICAgZWZmZWN0cy5sZW5ndGggPSAwOyAvLyBzbGlnaHRseSBza2V0Y2ggY2xlYXJpbmcgbWV0aG9kIHRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBhcnJheVxuICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAvL2lzUGFpbnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAvL2xldCBpbnB1dFRleHQgPSBpbnB1dEJveC52YWx1ZTtcbiAgICAgICAgXG4gICAgICAgICAgICAgIGxldCBhc3RPcHQgPSBQYXJzZXIucGFyc2UoaW5wdXRUZXh0KTtcbiAgICAgICAgICAgICAgaWYoYXN0T3B0LmlzRGVmaW5lZCgpKXtcbiAgICAgICAgICAgICAgICAgIGFzdCA9IGFzdE9wdC5nZXQoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBuZXcgU2NvcGUobnVsbCwgZWZmZWN0cywgbWFzdGVyTG9nKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2FudmFzID0gU29tZShjYW52YXMpO1xuICAgICAgICAgICAgICAgICAgYXN0LmV2YWwoY29udGV4dCk7IC8vdGhpcyBpcyB3aGVyZSB3ZSBkcmF3IHRoZSBvYmplY3RzIHRvIHRoZSBzY3JlZW5cbiAgICAgICAgICAgICAgICAgIGxhc3RXb3JraW5nSW5wdXRUZXh0ID0gaW5wdXRUZXh0O1xuICAgICAgICAgICAgICB9IC8qZWxzZSB7XG4gICAgICAgICAgICAgICAgICBsZXQgZXJyb3IgPSBcImVycm9yIHRleHRcIjtcbiAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiUXVhbjogc28gc29tZXRoaW5nIHdpdGggdGhpcyBzeW50YXggZXJyb3I6IFwiICsgZXJyb3IpO1xuICAgICAgICAgICAgICB9Ki9cbiAgICAgICAgLy9sZXQgcGFpbnRFdnQgPSBuZXcgUGFpbnRFdmVudChpbnB1dFRleHQpOyAvLyB3aWxsIG5lZWQgdG8gZ2V0IGZyb20gYXN0IHdoZW4gdGhhdCdzIGltcGxlbWVudGVkXG4gICAgICAgIC8vIEFkZGluZyBjb250ZXh0IGxvZyB0byBtYXN0ZXIgbG9nXG4gICAgICAgIC8vbG9nRXZlbnQucHVzaChwYWludEV2dC5hc3NlbWJsZUxvZygpKTtcbiAgICAgICAgcHJpbnRMb2coKTtcbiAgICAgICAgLy9ldmVudDEubG9nSXRlbSgpO1xuICAgICAgICAvLyB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdCAhPSB1bmRlZmluZWQgJiYgIXRleHRCb3hTZWxlY3RlZCAvKiAmJiAhaXNQYWludGluZyAqLykge1xuICAgICAgICBsZXQgbmV3SW5wdXQgPSBhc3QudG9TdHJpbmcoKTtcbiAgICAgICAgaW5wdXRCb3gudmFsdWUgPSBuZXdJbnB1dDtcbiAgICB9XG4gICAgaWYgKGNoZWNrcG9pbnRJc0FjdGl2ZSkge1xuICAgICAgICBjaGVja3BvaW50Q2hlY2tzR29hbCgpO1xuICAgIH1cbiAgICBpZiAoY2hlY2twb2ludCAhPSBudWxsICYmIGNoZWNrcG9pbnQuZHJhd0d1aWRlcyAhPSBudWxsKSB7XG4gICAgICAgIGNoZWNrcG9pbnQuZHJhd0d1aWRlcyhjdHgpO1xuICAgICAgICAvKlxuICAgICAgICAgICAgICBpZiAoY2hlY2twb2ludC5fbmFtZSA9PSBcImwxYzNcIikge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVjdCgxMCwgNDMwLCAxMDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSAyMCArIFwicHggQ291cmllciBOZXdcIjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChcIlB1dCB0ZXh0XCIsIDEwLCAzOTApO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChcImluIGhlcmVcIiwgMTAsIDQxMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgKi9cbiAgICB9XG4gICAgc2VsZWN0ZWRFbGVtcyA9IFtdO1xufVxuLy9jaGVja3MgdG8gc2VlIHdoZXRoZXIgdGhlIHRleHQgYm94IGlzIHNlbGVjdGVkXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaXNJbnB1dEJveFNlbGVjdGVkKTtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBtYW5hZ2VzIHRoZSBzdGF0ZSBvZiB0aGUgVUkgd2hlbiB0aGUgdGV4dCBib3ggaXMgc2VsZWN0ZWQgYW5kIHdoZW4gaXQgaXNuJ3QuXG4gKiBJZiBpdCBpcyBpbnNpZGUgdGhlIHRleHQgYm94LCBpc1BhaW50aW5nIGlzIGZhbHNlIGFuZCB0ZXh0Qm94U2VsZWN0ZWQgaXMgdHJ1ZS5cbiAqIElmIGl0J3Mgbm90LCBpZiBpdCdzIGluc2lkZSB0aGUgcGFpbnQgYnV0dG9uLCB0aGVuIGlzUGFpbnRpbmcgPSB0cnVlLlxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZSBkb3duIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGlzSW5wdXRCb3hTZWxlY3RlZChldmVudCkge1xuICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgIGxldCByZWN0ID0gaW5wdXRCb3guZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKG1vdXNlWCA+IHJlY3QubGVmdCAmJiBtb3VzZVggPCByZWN0LnJpZ2h0ICYmIG1vdXNlWSA+IHJlY3QudG9wICYmIG1vdXNlWSA8IHJlY3QuYm90dG9tKSB7XG4gICAgICAgIC8vaXNQYWludGluZyA9IGZhbHNlO1xuICAgICAgICB0ZXh0Qm94U2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLypcbiAgICAgICAgICBsZXQgcGFpbnRCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFpbnQnKTtcbiAgICAgICAgICByZWN0ID0gcGFpbnRCdXR0b24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgaWYobW91c2VYID4gcmVjdC5sZWZ0ICYmIG1vdXNlWCA8IHJlY3QucmlnaHQgJiYgbW91c2VZID4gcmVjdC50b3AgJiYgbW91c2VZIDwgcmVjdC5ib3R0b20pIHtcbiAgICAgICAgICAgICAgaXNQYWludGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpc1BhaW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgICovXG4gICAgICAgIHRleHRCb3hTZWxlY3RlZCA9IGZhbHNlO1xuICAgIH1cbn1cbi8vY2hlY2tzIHRvIHNlZSB3aGV0aGVyIHRoZSB0ZXh0IGJveCBpcyBzZWxlY3RlZFxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGRpc2FibGVkQ2FudmFzSXNTZWxlY3RlZCk7XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyB0aGUgY2FzZSB3aGVuIGEgZGlzYWJsZWQgY2FudmFzIGlzIHNlbGVjdGVkLlxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZSBkb3duIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVkQ2FudmFzSXNTZWxlY3RlZChldmVudCkge1xuICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBwb3BVcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwb3B1cCcpO1xuICAgIGlmIChjYW52YXNJc0Rpc2FibGVkICYmIG1vdXNlWCA+IHJlY3QubGVmdCAmJiBtb3VzZVggPCByZWN0LnJpZ2h0ICYmIG1vdXNlWSA+IHJlY3QudG9wICYmIG1vdXNlWSA8IHJlY3QuYm90dG9tKSB7XG4gICAgICAgIHBvcFVwLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9wVXAuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG59XG5mdW5jdGlvbiBwcmludExvZygpIHtcbiAgICBjb25zb2xlLmxvZyhcIkxvZzogXCIpO1xuICAgIGZvciAobGV0IGVsZW0gb2YgbWFzdGVyTG9nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVsZW0uYXNzZW1ibGVMb2coKSk7XG4gICAgfVxufVxubGV0IHBhbGV0dGVCdXR0b25zID0gW1xuICAgIFwiZWxsaXBzZVwiLCBcInJlY3RcIiwgXCJzdHJpbmdcIiwgXCJudW1iZXJcIixcbiAgICBcImxpbmVcIiwgXCJjdXJ2ZVwiXG5dO1xuZm9yIChsZXQgYnV0dG9uTmFtZSBvZiBwYWxldHRlQnV0dG9ucykge1xuICAgIGxldCBwYWxldHRlQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYnV0dG9uTmFtZSk7XG4gICAgcGFsZXR0ZUJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0ZXh0Qm94U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBwcmludE5ld05vZGUoYnV0dG9uTmFtZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHByaW50TmV3Tm9kZShidXR0b25OYW1lKSB7XG4gICAgbGV0IHByaW50TGluZSA9IFwiXCI7XG4gICAgc3dpdGNoIChidXR0b25OYW1lKSB7XG4gICAgICAgIGNhc2UgXCJlbGxpcHNlXCI6XG4gICAgICAgICAgICBwcmludExpbmUgPSBcInByaW50KGVsbGlwc2UoMTAwLDEwMCkpO1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWN0XCI6XG4gICAgICAgICAgICBwcmludExpbmUgPSBcInByaW50KHJlY3QoMTAwLDEwMCkpO1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHByaW50TGluZSA9ICdwcmludChcIm5ld1dvcmRcIik7JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBwcmludExpbmUgPSBcInByaW50KDEwKTtcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICAgICAgcHJpbnRMaW5lID0gXCJwcmludChsaW5lKDEwMCwxMDApKTtcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY3VydmVcIjpcbiAgICAgICAgICAgIHByaW50TGluZSA9IFwicHJpbnQoY3VydmUoMTAwLDEwMCwxMDApKTtcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQcm9ibGVtIHdpdGggXCIgKyBidXR0b25OYW1lKTtcbiAgICB9XG4gICAgaW5wdXRCb3gudmFsdWUgKz0gcHJpbnRMaW5lO1xuICAgIHBhcnNlKCk7XG59XG5sZXQgaW5zdHJ1Y3Rpb25zID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luc3RydWN0aW9ucycpO1xubGV0IGdvYWxCb3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ29hbC1jb250YWluZXInKTtcbmxldCBpbnN0ckxhYmVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luc3RyLWxhYmVsJyk7XG4vL01hcCBtYWludGFpbmluZyBjb2RlIGxhc3QgdXNlZCBhdCBhIGNoZWNrcG9pbnRcbmxldCBjcENvZGUgPSBuZXcgTWFwKFtcbiAgICBbJ2wxYzEnLCBcIlwiXSxcbiAgICBbJ2wxYzInLCBcIlwiXSxcbiAgICBbJ2wxYzMnLCBcIlwiXSxcbiAgICBbJ2wxYzQnLCBcIlwiXSxcbiAgICBbJ2wyYzEnLCBcIlwiXSxcbiAgICBbJ2wyYzInLCBcIlwiXSxcbiAgICBbJ2wyYzMnLCBcIlwiXSxcbiAgICBbJ2wyYzQnLCBcIlwiXSxcbiAgICBbJ2wyYzUnLCBcIlwiXSxcbiAgICBbJ2wyYzYnLCBcIlwiXSxcbiAgICBbJ2wyYzcnLCBcIlwiXSxcbiAgICBbJ2wzYzEnLCBcIlwiXSxcbiAgICBbJ2wzYzInLCBcIlwiXSxcbiAgICBbJ2wzYzMnLCBcIlwiXSxcbiAgICBbJ2wzYzQnLCBcIlwiXSxcbiAgICBbJ2wzYzUnLCBcIlwiXSxcbiAgICBbJ2wzYzYnLCBcIlwiXSxcbiAgICBbJ2w0YzEnLCBcIlwiXSxcbiAgICBbJ2w0YzInLCBcIlwiXVxuXSk7XG4vL01hcCBtYWludGFpbmluZyB3aGV0aGVyIGEgY2hlY2twb2ludCBoYXMgYmVlbiBjb21wbGV0ZWRcbmxldCBjcENvbXBsZXRpb24gPSBuZXcgTWFwKFtcbiAgICBbJ2wxYzEnLCBmYWxzZV0sXG4gICAgWydsMWMyJywgZmFsc2VdLFxuICAgIFsnbDFjMycsIGZhbHNlXSxcbiAgICBbJ2wxYzQnLCBmYWxzZV0sXG4gICAgWydsMmMxJywgZmFsc2VdLFxuICAgIFsnbDJjMicsIGZhbHNlXSxcbiAgICBbJ2wyYzMnLCBmYWxzZV0sXG4gICAgWydsMmM0JywgZmFsc2VdLFxuICAgIFsnbDJjNScsIGZhbHNlXSxcbiAgICBbJ2wyYzYnLCBmYWxzZV0sXG4gICAgWydsMmM3JywgZmFsc2VdLFxuICAgIFsnbDNjMScsIGZhbHNlXSxcbiAgICBbJ2wzYzInLCBmYWxzZV0sXG4gICAgWydsM2MzJywgZmFsc2VdLFxuICAgIFsnbDNjNCcsIGZhbHNlXSxcbiAgICBbJ2wzYzUnLCBmYWxzZV0sXG4gICAgWydsM2M2JywgZmFsc2VdLFxuICAgIFsnbDRjMScsIGZhbHNlXSxcbiAgICBbJ2w0YzInLCBmYWxzZV1cbl0pO1xubGV0IGNoZWNrcG9pbnRzID0gbmV3IE1hcChbXG4gICAgWydsMWMxJywgKCkgPT4gbmV3IGluZGV4XzMuTGVzc29uT25lQ3BPbmUoKV0sXG4gICAgWydsMWMyJywgKCkgPT4gbmV3IGluZGV4XzMuTGVzc29uT25lQ3BUd28oKV0sXG4gICAgWydsMWMzJywgKCkgPT4gbmV3IGluZGV4XzMuTGVzc29uT25lQ3BUaHJlZSgpXSxcbiAgICBbJ2wxYzQnLCAoKSA9PiBuZXcgaW5kZXhfMy5MZXNzb25PbmVDcEZvdXIoKV0sXG4gICAgWydsMmMxJywgKCkgPT4gbmV3IGluZGV4XzQuTGVzc29uVHdvQ3BPbmUoKV0sXG4gICAgWydsMmMyJywgKCkgPT4gbmV3IGluZGV4XzQuTGVzc29uVHdvQ3BUd28oKV0sXG4gICAgWydsMmMzJywgKCkgPT4gbmV3IGluZGV4XzQuTGVzc29uVHdvQ3BUaHJlZSgpXSxcbiAgICBbJ2wyYzQnLCAoKSA9PiBuZXcgaW5kZXhfNC5MZXNzb25Ud29DcEZvdXIoKV0sXG4gICAgWydsMmM1JywgKCkgPT4gbmV3IGluZGV4XzQuTGVzc29uVHdvQ3BGaXZlKCldLFxuICAgIFsnbDJjNicsICgpID0+IG5ldyBpbmRleF80Lkxlc3NvblR3b0NwU2l4KCldLFxuICAgIFsnbDJjNycsICgpID0+IG5ldyBpbmRleF80Lkxlc3NvblR3b0NwU2V2ZW4oKV0sXG4gICAgWydsM2MxJywgKCkgPT4gbmV3IGluZGV4XzUuTGVzc29uVGhyZWVDcE9uZSgpXSxcbiAgICBbJ2wzYzInLCAoKSA9PiBuZXcgaW5kZXhfNS5MZXNzb25UaHJlZUNwVHdvKCldLFxuICAgIFsnbDNjMycsICgpID0+IG5ldyBpbmRleF81Lkxlc3NvblRocmVlQ3BUaHJlZSgpXSxcbiAgICBbJ2wzYzQnLCAoKSA9PiBuZXcgaW5kZXhfNS5MZXNzb25UaHJlZUNwRm91cigpXSxcbiAgICBbJ2wzYzUnLCAoKSA9PiBuZXcgaW5kZXhfNS5MZXNzb25UaHJlZUNwRml2ZSgpXSxcbiAgICBbJ2wzYzYnLCAoKSA9PiBuZXcgaW5kZXhfNS5MZXNzb25UaHJlZUNwU2l4KCldLFxuICAgIFsnbDRjMScsICgpID0+IG5ldyBpbmRleF82Lkxlc3NvbkZvdXJDcE9uZSgpXSxcbiAgICBbJ2w0YzInLCAoKSA9PiBuZXcgaW5kZXhfNi5MZXNzb25Gb3VyQ3BUd28oKV1cbl0pO1xuZm9yIChsZXQgY3Agb2YgY2hlY2twb2ludHMua2V5cygpKSB7XG4gICAgbGV0IGNwQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY3ApO1xuICAgIGNwQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluaXRDaGVja3BvaW50KGNwKTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbW9kdWxlIGNvcnJlc3BvbmRpbmcgdG8gYSBjaGVja3BvaW50IHBhc3NlZCBpbi5cbiAqIFNldHMgdXAgdGhlIGluc3RydWN0aW9uLCBDT0RFIGFyZWEsIGFuZCBnb2FsIGJveCBhY2NvcmRpbmdseS5cbiAqIEBwYXJhbSBjcDogdGhlIG5hbWUgb2YgdGhlIGNoZWNrcG9pbnRcbiAqL1xuZnVuY3Rpb24gaW5pdENoZWNrcG9pbnQoY3ApIHtcbiAgICBpZiAoY2hlY2twb2ludHMuaGFzKGNwKSkge1xuICAgICAgICBpZiAoY2hlY2twb2ludCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjcENvZGUuc2V0KGNoZWNrcG9pbnQuX25hbWUsIGlucHV0Qm94LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhcIkluaXRpYXRpbmcgY2hlY2twb2ludCBcIiArIGNwKTtcbiAgICAgICAgY2hlY2twb2ludCA9IGNoZWNrcG9pbnRzLmdldChjcCkoKTtcbiAgICAgICAgaW5zdHJMYWJlbC5pbm5lckhUTUwgPSBjcCArIFwiIC0gSU5TVFJVQ1RJT05TXCI7XG4gICAgICAgIGluc3RydWN0aW9ucy5pbm5lckhUTUwgPSBjaGVja3BvaW50Ll9pbnN0cnVjdGlvbnM7XG4gICAgICAgIC8vc2V0IHVwIHRoZSBDT0RFIGFuZCBDQU5WQVMgYXJlYXNcbiAgICAgICAgaWYgKGNoZWNrcG9pbnQuX2NvbnN0cmFpbnQgPT0gJ2NvZGUnKSB7XG4gICAgICAgICAgICBpbnB1dEJveC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICBpbnB1dEJveC5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSAnI0VCRUJFQic7XG4gICAgICAgICAgICBjYW52YXNJc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hlY2twb2ludC5fY29uc3RyYWludCA9PSAnY2FudmFzJykge1xuICAgICAgICAgICAgaW5wdXRCb3gucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgaW5wdXRCb3guc3R5bGUub3BhY2l0eSA9ICcxLjAnO1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kID0gJyNDMEMwQzAnO1xuICAgICAgICAgICAgY2FudmFzSXNEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnB1dEJveC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICBpbnB1dEJveC5zdHlsZS5vcGFjaXR5ID0gJzEuMCc7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSAnI0VCRUJFQic7XG4gICAgICAgICAgICBjYW52YXNJc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBvcFVwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BvcHVwJyk7XG4gICAgICAgIHBvcFVwLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGlmIChjcENvZGUuZ2V0KGNoZWNrcG9pbnQuX25hbWUpICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB0ZXh0Qm94U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaW5wdXRCb3gudmFsdWUgPSBjcENvZGUuZ2V0KGNoZWNrcG9pbnQuX25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vc2V0IHVwIHRoZSBpbnN0cnVjdGlvbiBhbmQgZ29hbCBib3hlc1xuICAgICAgICBpZiAoY3BDb21wbGV0aW9uLmdldChjcCkpIHtcbiAgICAgICAgICAgIHVwZGF0ZUdvYWxCb3goKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjaGVja3BvaW50Ll9zdGFydGVyQ29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGV4dEJveFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpbnB1dEJveC52YWx1ZSA9IGNoZWNrcG9pbnQuX3N0YXJ0ZXJDb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ29hbEJveC5zdHlsZS5iYWNrZ3JvdW5kID0gJyNDMEMwQzAnO1xuICAgICAgICAgICAgbGV0IGdvYWxUZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dvYWwtdGV4dCcpO1xuICAgICAgICAgICAgZ29hbFRleHQuc3R5bGUuY29sb3IgPSAnYmxhY2snO1xuICAgICAgICAgICAgZ29hbFRleHQuaW5uZXJIVE1MID0gJ0NvbXBsZXRlIGdvYWwgdG8gZWFybiBhIHN0YXIhJztcbiAgICAgICAgICAgIGxldCBnb2FsSW1nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dvYWwtaW1hZ2UnKTtcbiAgICAgICAgICAgIGdvYWxJbWcuc3JjID0gJ3BpY3MvZ3JleXN0YXIuc3ZnJztcbiAgICAgICAgICAgIGdvYWxJbWcuYWx0ID0gJ2Egc3RhciB0byBiZSBlYXJuZWQnO1xuICAgICAgICAgICAgbGV0IG5leHRCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmV4dCcpO1xuICAgICAgICAgICAgbmV4dEJ0bi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICBjaGVja3BvaW50SXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2twb2ludENoZWNrc0dvYWwoKSB7XG4gICAgaWYgKGNoZWNrcG9pbnQuY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSkge1xuICAgICAgICB1cGRhdGVHb2FsQm94KCk7XG4gICAgICAgIGNwQ29tcGxldGlvbi5zZXQoY2hlY2twb2ludC5fbmFtZSwgdHJ1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlR29hbEJveCgpIHtcbiAgICBnb2FsQm94LnN0eWxlLmJhY2tncm91bmQgPSAnIzY3M0FCNyc7XG4gICAgY29uc29sZS5sb2coZG9jdW1lbnQpO1xuICAgIGxldCBnb2FsVGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnb2FsLXRleHQnKTtcbiAgICBnb2FsVGV4dC5zdHlsZS5jb2xvciA9ICcjRDhEOEQ4JztcbiAgICBnb2FsVGV4dC5pbm5lckhUTUwgPSAnR29hbCBtZXQhJztcbiAgICBsZXQgZ29hbEltZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnb2FsLWltYWdlJyk7XG4gICAgZ29hbEltZy5zcmMgPSAncGljcy9zdGFyLnN2Zyc7XG4gICAgZ29hbEltZy5hbHQgPSAnc3RhciBlYXJuZWQnO1xuICAgIGxldCBuZXh0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25leHQnKTtcbiAgICBuZXh0QnRuLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGluc3RydWN0aW9ucy5pbm5lckhUTUwgKz0gXCJcXG5Ib29yYXkhIEdvYWwgbWV0ISBDbGljayAnTmV4dCcgdG8gcHJvY2VlZCB0byBuZXh0IGNoZWNrcG9pbnQhXCI7XG4gICAgaW5zdHJ1Y3Rpb25zLnNjcm9sbFRvcCA9IGluc3RydWN0aW9ucy5zY3JvbGxIZWlnaHQ7XG4gICAgY2hlY2twb2ludElzQWN0aXZlID0gZmFsc2U7XG59XG5sZXQgbmV4dEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZXh0Jyk7XG5uZXh0QnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IG5leHRNb2R1bGUgPSBjaGVja3BvaW50Ll9uZXh0TW9kdWxlO1xuICAgIGlmIChuZXh0TW9kdWxlICE9ICcnKSB7XG4gICAgICAgIGluaXRDaGVja3BvaW50KG5leHRNb2R1bGUpO1xuICAgIH1cbn07XG5sZXQgcHJldkJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcmV2Jyk7XG5wcmV2QnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHByZXZNb2R1bGUgPSBjaGVja3BvaW50Ll9wcmV2TW9kdWxlO1xuICAgIGlmIChwcmV2TW9kdWxlICE9ICcnKSB7XG4gICAgICAgIGluaXRDaGVja3BvaW50KHByZXZNb2R1bGUpO1xuICAgIH1cbn07XG4vL2NhbGwgdG8gYW5pbWF0ZVxuYW5pbWF0ZSgpO1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyogdGVzdCBsaW5lcyBvZiBTLlcuRS5MLkwuIGNvZGVcblxucHJpbnQoXCJoZWxsbyB3b3JsZFwiLCAxODAsIDQyMSk7XG5wcmludChlbGxpcHNlKDc1LCA1MCksIDEwMCwgMTAwKTtcbnByaW50KHJlY3QoNjAsIDcwKSwgMjUwLCAyNTApO1xuXG5wcmludChcImhlbGxvXCIpO1xucHJpbnQoXCJ3b3JsZFwiKTtcblxuT3VyIHNhbXBsZSBwcm9ncmFtXG5wcmludChcImhlbGxvIHdvcmxkXCIpO1xucHJpbnQoZWxsaXBzZSgxMzAsIDEwMCkpO1xuKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgVW5hcnlPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL1VuYXJ5T3BlcmF0aW9uXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jbGFzcyBOZWdPcCBleHRlbmRzIFVuYXJ5T3BlcmF0aW9uXzEuVW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIE5lZ2F0aW9uT3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gYmUgbmVnYXRlZCAobXVzdCBiZSBhIE51bWJlck5vZGUpXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFsLCB3cykge1xuICAgICAgICBzdXBlcih2YWwpO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSB2YWx1ZSBpbnRvIHRoZSBuZWdhdGl2ZSB2ZXJzaW9uXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCB2ID0gdGhpcy52YWwuZXZhbChjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgtdi52YWwsIFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOZWdPcHMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZWdhdGlvbiBvcHMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhIE5lZ09wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBOZWdPcFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgTmVnT3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCItXCIgKyB0aGlzLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLk5lZ09wID0gTmVnT3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OZWdPcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFVuYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBBYnN0cmFjdCBjbGFzcyBjb25zdHJ1Y3RvciBmb3IgVW5hcnkgT3BlcmF0aW9uc1xuICAgICAqIEBwYXJhbSBfdmFsIFRoZSBvYmplY3QgdG8gYmUgb3BlcmF0ZWQgb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfdmFsKSB7XG4gICAgICAgIHRoaXMuX3ZhbCA9IF92YWw7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IGRyYXcgbWV0aG9kIGZvciB1bmRyYXdhYmxlIFVuYXJ5T3BzXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFyeSBPcGVyYXRpb25zIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gVW5hcnlPcHNcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIFVuYXJ5T3BcIik7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFVuYXJ5T3AgdmFsdWVcbiAgICAgKi9cbiAgICBnZXQgdmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBVbmFyeU9wIHZhbHVlXG4gICAgICovXG4gICAgc2V0IHZhbCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWwgPSB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLlVuYXJ5T3BlcmF0aW9uID0gVW5hcnlPcGVyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VbmFyeU9wZXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFZhcmlhYmxlTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgVmFyaWFibGVOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgdmFyaWFibGUgbmFtZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyB1cCB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlIGluIHRoZSBjb250ZXh0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0Lmxvb2t1cCh0aGlzLl9uYW1lLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFyaWFibGVOb2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gdmFyaWFibGUgbm9kZXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIFZhcmlhYmxlTm9kZXNcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRpcmVjdGx5IGNvbXBhcmUgdmFycywgZXZhbCBmaXJzdFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFyaWFibGVOb2RlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5WYXJpYWJsZU5vZGUgPSBWYXJpYWJsZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WYXJpYWJsZU5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgU2hhbGxvdyB1cGRhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4vKiogUGVyZm9ybXMgYSBzaGFsbG93IHVwZGF0ZSBvZiBhbiBvYmplY3QgdXNpbmcgYSBwYXJ0aWFsIG9iamVjdCBvZiB0aGUgc2FtZSBzaGFwZS4gQSBuZXcgb2JqZWN0IGlzIHJldHVybmVkLiAqL1xuZnVuY3Rpb24gdXBkYXRlKGhvc3QsIHNwZWMpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2xvbmUoaG9zdCk7XG4gICAgZm9yICh2YXIga2V5IGluIHNwZWMpIHtcbiAgICAgICAgdmFyIHNwZWNWYWx1ZSA9IHNwZWNba2V5XTtcbiAgICAgICAgaWYgKHNwZWNWYWx1ZSA9PT0gZXhwb3J0cy5ERUxFVEUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gc3BlY1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnVwZGF0ZSA9IHVwZGF0ZTtcbi8vIFdlIGxpZSBhYm91dCB0aGUgcHVibGljIHR5cGUgc28gdGhhdCBvbmx5IGEgcHJvcGVydHkgdGhhdCBpcyBvcHRpb25hbCBvciB0aGF0IGNhbiBiZSBhc3NpZ25lZCB0byB1bmRlZmluZWQgY2FuIGJlIERFTEVURSdkXG4vKiogTWFya2VyIHVzZWQgdG8gZGVsZXRlIGEga2V5ICovXG5leHBvcnRzLkRFTEVURSA9IHt9O1xudmFyIF9VcGRhdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9VcGRhdGVyKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGtleU9ySW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfVXBkYXRlcih7IHR5cGU6ICdhdCcsIHBhcmVudDogdGhpcywgZmllbGQ6IGtleU9ySW5kZXggfSk7XG4gICAgfTtcbiAgICBfVXBkYXRlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkb1NldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5jbG9uZUZvclVwZGF0ZSh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5uYW1lID09PSAnYWJvcnRlZCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIHZhciBjbG9uZWRUYXJnZXQgPSByZXN1bHQuY2xvbmVkVGFyZ2V0LCBsZWFmSG9zdCA9IHJlc3VsdC5sZWFmSG9zdCwgZmllbGQgPSByZXN1bHQuZmllbGQ7XG4gICAgICAgICAgICB2YWx1ZSA9PT0gZXhwb3J0cy5ERUxFVEUgPyBkZWxldGUgbGVhZkhvc3RbZmllbGRdIDogbGVhZkhvc3RbZmllbGRdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkVGFyZ2V0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYm91bmRUYXJnZXQgPSB0aGlzLmZpbmRCb3VuZFRhcmdldCgpO1xuICAgICAgICByZXR1cm4gYm91bmRUYXJnZXRcbiAgICAgICAgICAgID8gZG9TZXQoYm91bmRUYXJnZXQpXG4gICAgICAgICAgICA6IGRvU2V0O1xuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLm1vZGlmeSA9IGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZG9Nb2RpZnkgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMuY2xvbmVGb3JVcGRhdGUodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubmFtZSA9PT0gJ2Fib3J0ZWQnKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB2YXIgY2xvbmVkVGFyZ2V0ID0gcmVzdWx0LmNsb25lZFRhcmdldCwgbGVhZkhvc3QgPSByZXN1bHQubGVhZkhvc3QsIGZpZWxkID0gcmVzdWx0LmZpZWxkO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbW9kaWZpZXIobGVhZkhvc3RbZmllbGRdKTtcbiAgICAgICAgICAgIHZhbHVlID09PSBleHBvcnRzLkRFTEVURSA/IGRlbGV0ZSBsZWFmSG9zdFtmaWVsZF0gOiBsZWFmSG9zdFtmaWVsZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZWRUYXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBib3VuZFRhcmdldCA9IHRoaXMuZmluZEJvdW5kVGFyZ2V0KCk7XG4gICAgICAgIHJldHVybiBib3VuZFRhcmdldFxuICAgICAgICAgICAgPyBkb01vZGlmeShib3VuZFRhcmdldClcbiAgICAgICAgICAgIDogZG9Nb2RpZnk7XG4gICAgfTtcbiAgICBfVXBkYXRlci5wcm90b3R5cGUud2l0aERlZmF1bHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfVXBkYXRlcih7IHR5cGU6ICd3aXRoRGVmYXVsdCcsIHBhcmVudDogdGhpcywgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KTtcbiAgICB9O1xuICAgIF9VcGRhdGVyLnByb3RvdHlwZS5hYm9ydElmVW5kZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1VwZGF0ZXIoeyB0eXBlOiAnYWJvcnRJZlVuZGVmJywgcGFyZW50OiB0aGlzIH0pO1xuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLmZpbmRCb3VuZFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuZGF0YS50eXBlID09PSAncm9vdCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZGF0YS5ib3VuZFRhcmdldDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmRhdGEucGFyZW50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVXBkYXRlci5wcm90b3R5cGUucGFyZW50VXBkYXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1cGRhdGVycyA9IFt0aGlzXTtcbiAgICAgICAgdmFyIHBhcmVudFVwZGF0ZXIgPSB0aGlzLmRhdGEucGFyZW50O1xuICAgICAgICAvLyBJZ25vcmUgdGhlIHJvb3QgdXBkYXRlclxuICAgICAgICB3aGlsZSAocGFyZW50VXBkYXRlciAmJiBwYXJlbnRVcGRhdGVyLmRhdGEucGFyZW50KSB7XG4gICAgICAgICAgICB1cGRhdGVycy51bnNoaWZ0KHBhcmVudFVwZGF0ZXIpO1xuICAgICAgICAgICAgcGFyZW50VXBkYXRlciA9IHBhcmVudFVwZGF0ZXIuZGF0YS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVwZGF0ZXJzO1xuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLmdldE5leHRWYWx1ZSA9IGZ1bmN0aW9uIChwcmV2aW91c0hvc3QsIGhvc3QsIGZpZWxkLCBpc0xhc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS50eXBlID09PSAnYXQnKSB7XG4gICAgICAgICAgICB2YXIgbmV3RmllbGQgPSB0aGlzLmRhdGEuZmllbGQ7XG4gICAgICAgICAgICB2YXIgdmFsdWVfMSA9IGhvc3RbbmV3RmllbGRdO1xuICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IGlzT2JqZWN0T3JBcnJheSh2YWx1ZV8xKSA/IGNsb25lKHZhbHVlXzEpIDogdmFsdWVfMTtcbiAgICAgICAgICAgIHZhciBuZXdIb3N0XzEgPSBpc0xhc3QgPyBob3N0IDogbmV4dFZhbHVlO1xuICAgICAgICAgICAgaG9zdFt0aGlzLmRhdGEuZmllbGRdID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgaG9zdDogbmV3SG9zdF8xLCBmaWVsZDogbmV3RmllbGQgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBwcmV2aW91c0hvc3RbZmllbGRdO1xuICAgICAgICBpZiAodGhpcy5kYXRhLnR5cGUgPT09ICdhYm9ydElmVW5kZWYnICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGhvc3Q6IGhvc3QsIGZpZWxkOiBmaWVsZCwgYWJvcnRlZDogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhdGEudHlwZSA9PT0gJ3dpdGhEZWZhdWx0JyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gdGhpcy5kYXRhLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIHZhciBuZXdIb3N0XzIgPSBpc0xhc3QgPyBwcmV2aW91c0hvc3QgOiBuZXh0VmFsdWU7XG4gICAgICAgICAgICBwcmV2aW91c0hvc3RbZmllbGRdID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgaG9zdDogbmV3SG9zdF8yLCBmaWVsZDogZmllbGQgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3SG9zdCA9IGlzTGFzdCA/IHByZXZpb3VzSG9zdCA6IGhvc3Q7XG4gICAgICAgIHJldHVybiB7IGhvc3Q6IG5ld0hvc3QsIGZpZWxkOiBmaWVsZCB9O1xuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLmNsb25lRm9yVXBkYXRlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB2YXIgdXBkYXRlcnMgPSB0aGlzLnBhcmVudFVwZGF0ZXJzKCk7XG4gICAgICAgIHZhciBvYmogPSBjbG9uZSh0YXJnZXQpO1xuICAgICAgICB2YXIgcHJldmlvdXNIb3N0ID0gb2JqO1xuICAgICAgICB2YXIgaG9zdCA9IG9iajtcbiAgICAgICAgdmFyIGZpZWxkID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB1cGRhdGVyc1tpXS5nZXROZXh0VmFsdWUocHJldmlvdXNIb3N0LCBob3N0LCBmaWVsZCwgaSA9PT0gdXBkYXRlcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogJ2Fib3J0ZWQnIH07XG4gICAgICAgICAgICBwcmV2aW91c0hvc3QgPSBob3N0O1xuICAgICAgICAgICAgaG9zdCA9IHJlc3VsdC5ob3N0O1xuICAgICAgICAgICAgZmllbGQgPSByZXN1bHQuZmllbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdyZXN1bHQnLFxuICAgICAgICAgICAgY2xvbmVkVGFyZ2V0OiBvYmosXG4gICAgICAgICAgICBsZWFmSG9zdDogaG9zdCxcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIF9VcGRhdGVyO1xufSgpKTtcbmZ1bmN0aW9uIGlzT2JqZWN0T3JBcnJheShvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufVxuZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSlcbiAgICAgICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICAgIHZhciBjbG9uZWQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBjbG9uZWRba2V5XSA9IG9ialtrZXldOyB9KTtcbiAgICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gZGVlcFVwZGF0ZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gbmV3IF9VcGRhdGVyKHsgdHlwZTogJ3Jvb3QnLCBib3VuZFRhcmdldDogdGFyZ2V0IH0pO1xufVxuZXhwb3J0cy5kZWVwVXBkYXRlID0gZGVlcFVwZGF0ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENoYXJVdGlsO1xuKGZ1bmN0aW9uIChDaGFyVXRpbCkge1xuICAgIGNsYXNzIENoYXJTdHJlYW0ge1xuICAgICAgICBjb25zdHJ1Y3RvcihzLCBzdGFydHBvcywgZW5kcG9zLCBoYXNFT0YpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzRU9GID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBzO1xuICAgICAgICAgICAgaWYgKGhhc0VPRiAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0VPRiA9IGhhc0VPRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydHBvcyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0cG9zID0gMDsgLy8gbm90IHNwZWNpZmllZDsgc2V0IGRlZmF1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0cG9zID4gcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0cG9zID0gcy5sZW5ndGg7IC8vIHNlZWsgdG9vIGZhcjsgc2V0IEVPRlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydHBvcyA9IHN0YXJ0cG9zOyAvLyBzcGVjaWZpZWQgYW5kIGluIGJvdW5kc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZHBvcyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvcyA9IHMubGVuZ3RoOyAvLyBub3Qgc3BlY2lmaWVkOyBzZXQgZGVmYXVsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kcG9zID4gcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvcyA9IHMubGVuZ3RoOyAvLyBzZWVrIHRvbyBmYXI7IHNldCBFT0ZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9zID0gZW5kcG9zOyAvLyBzcGVjaWZpZWQgYW5kIGluIGJvdW5kc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRwb3MgPiB0aGlzLmVuZHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRwb3MgPSB0aGlzLmVuZHBvczsgLy8gaWYgdGhlIHVzZXIgZmxpcHBlZCBwb3NpdGlvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIG9mIHRoZSBlbmQgb2YgdGhlIGlucHV0IGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpc0VPRigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0VPRiAmJiB0aGlzLnN0YXJ0cG9zID09IHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgSmF2c2NyaXB0IHByaW1pdGl2ZSBzdHJpbmcgb2YgdGhlIHNsaWNlIG9mIGlucHV0XG4gICAgICAgICAqIHJlcHJlc2VudGVkIGJ5IHRoaXMgQ2hhclN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQuc3Vic3RyaW5nKHRoaXMuc3RhcnRwb3MsIHRoaXMuZW5kcG9zKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBDaGFyU3RyZWFtIHJlcHJlc2VudGluZyB0aGUgaW5wdXQgZnJvbSB0aGVcbiAgICAgICAgICogY3VycmVudCBzdGFydCBwb3NpdGlvbiB0byBhbiBlbmQgcG9zaXRpb24gbnVtIGNoYXJzIGZyb21cbiAgICAgICAgICogdGhlIGN1cnJlbnQgc3RhcnQgcG9zaXRpb24uICBJZiBzdGFydHBvcyArIG51bSA+IGVuZHBvcyxcbiAgICAgICAgICogdGhlIGN1cnJlbnQgQ2hhclN0cmVhbSBpcyByZXR1cm5lZC5cbiAgICAgICAgICogQHBhcmFtIG51bVxuICAgICAgICAgKi9cbiAgICAgICAgcGVlayhudW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0cG9zICsgbnVtID4gdGhpcy5lbmRwb3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXdIYXNFT0YgPSB0aGlzLnN0YXJ0cG9zICsgbnVtID09IHRoaXMuZW5kcG9zICYmIHRoaXMuaGFzRU9GO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbSh0aGlzLmlucHV0LCB0aGlzLnN0YXJ0cG9zLCB0aGlzLnN0YXJ0cG9zICsgbnVtLCBuZXdIYXNFT0YpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IENoYXJTdHJlYW0gcmVwcmVzZW50aW5nIHRoZSBzdHJpbmcgYWZ0ZXJcbiAgICAgICAgICogc2Vla2luZyBudW0gY2hhcmFjdGVycyBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gbnVtXG4gICAgICAgICAqL1xuICAgICAgICBzZWVrKG51bSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRwb3MgKyBudW0gPiB0aGlzLmVuZHBvcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbSh0aGlzLmlucHV0LCB0aGlzLmVuZHBvcywgdGhpcy5lbmRwb3MsIHRoaXMuaGFzRU9GKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbSh0aGlzLmlucHV0LCB0aGlzLnN0YXJ0cG9zICsgbnVtLCB0aGlzLmVuZHBvcywgdGhpcy5oYXNFT0YpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IENoYXJTdHJlYW0gcmVwcmVzZW50aW5nIHRoZSBoZWFkIG9mIHRoZSBpbnB1dCBhdFxuICAgICAgICAgKiB0aGUgY3VycmVudCBwb3NpdGlvbi4gIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIENoYXJTdHJlYW0gaXNcbiAgICAgICAgICogZW1wdHkuXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hhc0VPRiA9IHRoaXMuc3RhcnRwb3MgKyAxID09IHRoaXMuZW5kcG9zICYmIHRoaXMuaGFzRU9GO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbSh0aGlzLmlucHV0LCB0aGlzLnN0YXJ0cG9zLCB0aGlzLnN0YXJ0cG9zICsgMSwgbmV3SGFzRU9GKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGhlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBDaGFyU3RyZWFtIHJlcHJlc2VudGluZyB0aGUgdGFpbCBvZiB0aGUgaW5wdXQgYXRcbiAgICAgICAgICogdGhlIGN1cnJlbnQgcG9zaXRpb24uICBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBDaGFyU3RyZWFtIGlzXG4gICAgICAgICAqIGVtcHR5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGFpbCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENoYXJTdHJlYW0odGhpcy5pbnB1dCwgdGhpcy5zdGFydHBvcyArIDEsIHRoaXMuZW5kcG9zLCB0aGlzLmhhc0VPRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSB0YWlsIG9mIGFuIGVtcHR5IHN0cmluZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gaXMgZW1wdHkuIE5vdGVcbiAgICAgICAgICogdGhhdCBhIENoYXJTdHJlYW0gYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgY29udGFpbnMgYW4gZW1wdHlcbiAgICAgICAgICogc3RyaW5nIGJ1dCB0aGF0IGFuIGVtcHR5IHN0cmluZyBtYXkgbm90IGJlIHRoZSBlbmQtb2YtZmlsZSAoaS5lLixcbiAgICAgICAgICogaXNFT0YgaXMgZmFsc2UpLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNFbXB0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0cG9zID09IHRoaXMuZW5kcG9zO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyByZW1haW5pbmcgYXRcbiAgICAgICAgICogdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBsZW5ndGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmRwb3MgLSB0aGlzLnN0YXJ0cG9zO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzdWJzdHJpbmcgYmV0d2VlbiBzdGFydCBhbmQgZW5kIGF0IHRoZVxuICAgICAgICAgKiBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gc3RhcnQgdGhlIHN0YXJ0IGluZGV4IG9mIHRoZSBzdWJzdHJpbmcsIGluY2x1c2l2ZVxuICAgICAgICAgKiBAcGFyYW0gZW5kIHRoZSBlbmQgaW5kZXggb2YgdGhlIHN1YnN0cmluZywgZXhjbHVzaXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdWJzdHJpbmcoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQyID0gdGhpcy5zdGFydHBvcyArIHN0YXJ0O1xuICAgICAgICAgICAgY29uc3QgZW5kMiA9IHRoaXMuc3RhcnRwb3MgKyBlbmQ7XG4gICAgICAgICAgICBjb25zdCBuZXdIYXNFT0YgPSB0aGlzLmVuZHBvcyA9PSBlbmQyICYmIHRoaXMuaGFzRU9GO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFyU3RyZWFtKHRoaXMuaW5wdXQsIHN0YXJ0MiwgZW5kMiwgbmV3SGFzRU9GKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgY3VycmVudCBDaGFyU3RyZWFtIHdpdGhcbiAgICAgICAgICogdGhlIGdpdmVuIENoYXJTdHJlYW0uIE5vdGU6IHJldHVybmVkIG9iamVjdCBkb2VzIG5vdFxuICAgICAgICAgKiByZXVzZSBvcmlnaW5hbCBpbnB1dCBzdHJpbmcsIGFuZCBzdGFydHBvcyBhbmQgZW5kcG9zXG4gICAgICAgICAqIGFyZSByZXNldC4gSWYgdGhlIGdpdmVuIENoYXJTdHJlYW0gY29udGFpbnMgRU9GLCB0aGVcbiAgICAgICAgICogY29uY2F0ZW5hdGVkIENoYXJTdHJlYW0gd2lsbCBhbHNvIGNvbnRhaW4gRU9GLlxuICAgICAgICAgKiBAcGFyYW0gY3MgdGhlIENoYXJTdHJlYW0gdG8gY29uY2F0IHRvIHRoaXMgQ2hhclN0cmVhbVxuICAgICAgICAgKi9cbiAgICAgICAgY29uY2F0KGNzKSB7XG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy50b1N0cmluZygpICsgY3MudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbShzLCAwLCBzLmxlbmd0aCwgY3MuaGFzRU9GKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uY2F0ZW5hdGUgYW4gYXJyYXkgb2YgQ2hhclN0cmVhbSBvYmplY3RzIGludG8gYSBzaW5nbGVcbiAgICAgICAgICogQ2hhclN0cmVhbSBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSBjc3MgYSBDaGFyU3RyZWFtW11cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjb25jYXQoY3NzKSB7XG4gICAgICAgICAgICBpZiAoY3NzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFyU3RyZWFtKFwiXCIsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjcyA9IGNzc1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjcyA9IGNzLmNvbmNhdChjc3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2hhclV0aWwuQ2hhclN0cmVhbSA9IENoYXJTdHJlYW07XG59KShDaGFyVXRpbCA9IGV4cG9ydHMuQ2hhclV0aWwgfHwgKGV4cG9ydHMuQ2hhclV0aWwgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhcnN0cmVhbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcmltaXRpdmVzXzEgPSByZXF1aXJlKFwiLi9wcmltaXRpdmVzXCIpO1xuZXhwb3J0cy5QcmltaXRpdmVzID0gcHJpbWl0aXZlc18xLlByaW1pdGl2ZXM7XG52YXIgY2hhcnN0cmVhbV8xID0gcmVxdWlyZShcIi4vY2hhcnN0cmVhbVwiKTtcbmV4cG9ydHMuQ2hhclV0aWwgPSBjaGFyc3RyZWFtXzEuQ2hhclV0aWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNoYXJzdHJlYW1fMSA9IHJlcXVpcmUoXCIuL2NoYXJzdHJlYW1cIik7XG52YXIgUHJpbWl0aXZlcztcbihmdW5jdGlvbiAoUHJpbWl0aXZlcykge1xuICAgIGNsYXNzIEVPRk1hcmsge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgICAgICBzdGF0aWMgZ2V0IEluc3RhbmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlIHx8ICh0aGlzLl9pbnN0YW5jZSA9IG5ldyB0aGlzKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuRU9GTWFyayA9IEVPRk1hcms7XG4gICAgUHJpbWl0aXZlcy5FT0YgPSBFT0ZNYXJrLkluc3RhbmNlO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdWNjZXNzZnVsIHBhcnNlLlxuICAgICAqL1xuICAgIGNsYXNzIFN1Y2Nlc3Mge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgc3VjY2Vzc2Z1bCBwYXJzZS5cbiAgICAgICAgICogQHBhcmFtIGlzdHJlYW0gVGhlIHJlbWFpbmluZyBzdHJpbmcuXG4gICAgICAgICAqIEBwYXJhbSByZXMgVGhlIHJlc3VsdCBvZiB0aGUgcGFyc2VcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKGlzdHJlYW0sIHJlcykge1xuICAgICAgICAgICAgdGhpcy50YWcgPSBcInN1Y2Nlc3NcIjtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzdHJlYW0gPSBpc3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSByZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUHJpbWl0aXZlcy5TdWNjZXNzID0gU3VjY2VzcztcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgZmFpbGVkIHBhcnNlLlxuICAgICAqL1xuICAgIGNsYXNzIEZhaWx1cmUge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZmFpbGVkIHBhcnNlLlxuICAgICAgICAgKiBAcGFyYW0gaXN0cmVhbSBUaGUgc3RyaW5nLCB1bm1vZGlmaWVkLCB0aGF0IHdhcyBnaXZlbiB0byB0aGUgcGFyc2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoaXN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy50YWcgPSBcImZhaWx1cmVcIjtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzdHJlYW0gPSBpc3RyZWFtO1xuICAgICAgICB9XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuRmFpbHVyZSA9IEZhaWx1cmU7XG4gICAgLyoqXG4gICAgICogcmVzdWx0IHN1Y2NlZWRzIHdpdGhvdXQgY29uc3VtaW5nIGFueSBpbnB1dCwgYW5kIHJldHVybnMgdi5cbiAgICAgKiBAcGFyYW0gdiBUaGUgcmVzdWx0IG9mIHRoZSBwYXJzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQodikge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IG5ldyBTdWNjZXNzKGlzdHJlYW0sIHYpO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAvKipcbiAgICAgKiB6ZXJvIGZhaWxzIHdpdGhvdXQgY29uc3VtaW5nIGFueSBpbnB1dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6ZXJvKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnplcm8gPSB6ZXJvO1xuICAgIC8qKlxuICAgICAqIGl0ZW0gc3VjY2Vzc2Z1bGx5IGNvbnN1bWVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaWYgdGhlIGlucHV0XG4gICAgICogc3RyaW5nIGlzIG5vbi1lbXB0eSwgb3RoZXJ3aXNlIGl0IGZhaWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl0ZW0oKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzdHJlYW0uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKGlzdHJlYW0udGFpbCgpLCBpc3RyZWFtLmhlYWQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuaXRlbSA9IGl0ZW07XG4gICAgLyoqXG4gICAgICogYmluZCBpcyBhIGN1cnJpZWQgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHBhcnNlciBwIGFuZCByZXR1cm5zXG4gICAgICogYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgcGFyc2VyIGYgd2hpY2ggcmV0dXJucyB0aGUgY29tcG9zaXRpb25cbiAgICAgKiBvZiBwIGFuZCBmLiAgSWYgX2FueV8gb2YgdGhlIHBhcnNlcnMgZmFpbCwgdGhlIG9yaWdpbmFsIGlucHV0c3RyZWFtXG4gICAgICogaXMgcmV0dXJuZWQgaW4gdGhlIEZhaWx1cmUgb2JqZWN0IChpLmUuLCBiaW5kIGJhY2t0cmFja3MpLlxuICAgICAqIEBwYXJhbSBwIEEgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZChwKSB7XG4gICAgICAgIHJldHVybiAoZikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHIgPSBwKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoci50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvID0gZihyLnJlc3VsdCkoci5pbnB1dHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG8udGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjogcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90ZTogYmFja3RyYWNrcywgcmV0dXJuaW5nIG9yaWdpbmFsIGlzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOiByZXR1cm4gbmV3IEZhaWx1cmUoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5iaW5kID0gYmluZDtcbiAgICBmdW5jdGlvbiBkZWxheShwKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBwO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmRlbGF5ID0gZGVsYXk7XG4gICAgLyoqXG4gICAgICogc2VxIGlzIGEgY3VycmllZCBmdW5jdGlvbiB0aGF0IHRha2VzIGEgcGFyc2VyIHAsIGEgcGFyc2VyIHEsXG4gICAgICogYW5kIGEgZnVuY3Rpb24gZi4gSXQgYXBwbGllcyBwIHRvIHRoZSBpbnB1dCwgcGFzc2luZyB0aGVcbiAgICAgKiByZW1haW5pbmcgaW5wdXQgc3RyZWFtIHRvIHE7IHEgaXMgdGhlbiBhcHBsaWVkLiAgVGhlIGZ1bmN0aW9uXG4gICAgICogZiB0YWtlcyB0aGUgcmVzdWx0IG9mIHAgYW5kIHEsIGFzIGEgdHVwbGUsIGFuZCByZXR1cm5zXG4gICAgICogYSBzaW5nbGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwIEEgcGFyc2VyXG4gICAgICovXG4gICAgLy8gZXhwb3J0IGxldCBzZXEgPSBmdW5jdGlvbjxULFUsVj4ocDogSVBhcnNlcjxUPikge1xuICAgIC8vICAgICByZXR1cm4gKHE6IElQYXJzZXI8VT4pID0+IHtcbiAgICAvLyAgICAgICAgIHJldHVybiAoZjogKGU6IFtULFVdKSA9PiBWKSA9PiB7XG4gICAgLy8gICAgICAgICAgICAgcmV0dXJuIGJpbmQ8VCxWPihwKSgoeCkgPT4ge1xuICAgIC8vICAgICAgICAgICAgICAgICByZXR1cm4gYmluZDxVLFY+KHEpKCh5KSA9PiB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBsZXQgdHVwIDogW1QsVV0gPSBbeCx5XTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ8Vj4oZih0dXApKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgfSk7XG4gICAgLy8gICAgICAgICAgICAgfSk7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH07XG4gICAgLy8gfVxuICAgIGZ1bmN0aW9uIHNlcShwKSB7XG4gICAgICAgIHJldHVybiAocSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChmKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQocCkoKHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQocSkoKHkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0dXAgPSBbeCwgeV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0KGYodHVwKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5zZXEgPSBzZXE7XG4gICAgLyoqXG4gICAgICogc2F0IHRha2VzIGEgcHJlZGljYXRlIGFuZCB5aWVsZHMgYSBwYXJzZXIgdGhhdCBjb25zdW1lcyBhXG4gICAgICogc2luZ2xlIGNoYXJhY3RlciBpZiB0aGUgY2hhcmFjdGVyIHNhdGlzZmllcyB0aGUgcHJlZGljYXRlLFxuICAgICAqIG90aGVyd2lzZSBpdCBmYWlscy5cbiAgICAgKiBAcGFyYW0gcHJlZCBhIGNoYXJhY3RlciBwcmVkaWNhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYXQocHJlZCkge1xuICAgICAgICBsZXQgcHJlZDIgPSAoY3MpID0+IHByZWQoY3MudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBhID0gaXRlbSgpO1xuICAgICAgICBsZXQgYiA9ICh4KSA9PiB7XG4gICAgICAgICAgICBpZiAocHJlZDIoeCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0KHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGJpbmQoYSkoYik7XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuc2F0ID0gc2F0O1xuICAgIC8qKlxuICAgICAqIGNoYXIgdGFrZXMgYSBjaGFyYWN0ZXIgYW5kIHlpZWxkcyBhIHBhcnNlciB0aGF0IGNvbnN1bWVcbiAgICAgKiB0aGF0IGNoYXJhY3Rlci4gVGhlIHJldHVybmVkIHBhcnNlciBzdWNjZWVkcyBpZiB0aGUgbmV4dFxuICAgICAqIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQgc3RyZWFtIGlzIGMsIG90aGVyd2lzZSBpdCBmYWlscy5cbiAgICAgKiBAcGFyYW0gY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYXIoYykge1xuICAgICAgICBpZiAoYy5sZW5ndGggIT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hhciBwYXJzZXIgdGFrZXMgYSBzdHJpbmcgb2YgbGVuZ3RoIDEgKGkuZS4sIGEgY2hhcilcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNhdCh4ID0+IHggPT0gYyk7XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuY2hhciA9IGNoYXI7XG4gICAgLyoqXG4gICAgICogbGV0dGVyIHJldHVybnMgYSBwYXJzZXIgdGhhdCBjb25zdW1lcyBhIHNpbmdsZSBhbHBoYWJldGljXG4gICAgICogY2hhcmFjdGVyLCBmcm9tIGEteiwgcmVnYXJkbGVzcyBvZiBjYXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxldHRlcigpIHtcbiAgICAgICAgbGV0IGNvbnRhaW5zX2xldHRlciA9ICh4KSA9PiB7XG4gICAgICAgICAgICBsZXQgYV9sZXR0ZXIgPSAvW0EtWmEtel0vO1xuICAgICAgICAgICAgcmV0dXJuIHgubWF0Y2goYV9sZXR0ZXIpICE9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNhdChjb250YWluc19sZXR0ZXIpO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmxldHRlciA9IGxldHRlcjtcbiAgICAvKipcbiAgICAgKiBkaWdpdCByZXR1cm5zIGEgcGFyc2VyIHRoYXQgY29uc3VtZXMgYSBzaW5nbGUgbnVtZXJpY1xuICAgICAqIGNoYXJhY3RlciwgZnJvbSAwLTkuICBOb3RlIHRoYXQgdGhlIHR5cGUgb2YgdGhlIHJlc3VsdFxuICAgICAqIGlzIGEgc3RyaW5nLCBub3QgYSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlnaXQoKSB7XG4gICAgICAgIHJldHVybiBzYXQoeCA9PiB4ID09IFwiMFwiXG4gICAgICAgICAgICB8fCB4ID09IFwiMVwiXG4gICAgICAgICAgICB8fCB4ID09IFwiMlwiXG4gICAgICAgICAgICB8fCB4ID09IFwiM1wiXG4gICAgICAgICAgICB8fCB4ID09IFwiNFwiXG4gICAgICAgICAgICB8fCB4ID09IFwiNVwiXG4gICAgICAgICAgICB8fCB4ID09IFwiNlwiXG4gICAgICAgICAgICB8fCB4ID09IFwiN1wiXG4gICAgICAgICAgICB8fCB4ID09IFwiOFwiXG4gICAgICAgICAgICB8fCB4ID09IFwiOVwiKTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5kaWdpdCA9IGRpZ2l0O1xuICAgIC8qKlxuICAgICAqIHVwcGVyIHJldHVybnMgYSBwYXJzZXIgdGhhdCBjb25zdW1lcyBhIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICAgKiBpZiB0aGF0IGNoYXJhY3RlciBpcyB1cHBlcmNhc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBwZXIoKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgbGV0IG8xID0gbGV0dGVyKCkoaXN0cmVhbSk7XG4gICAgICAgICAgICBzd2l0Y2ggKG8xLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIGxldCBvMiA9IHNhdCh4ID0+IHggPT0geC50b1VwcGVyQ2FzZSgpKShvMS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG8yLnRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFpbHVyZShpc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZXZlciBoYXBwZW5zXCIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnVwcGVyID0gdXBwZXI7XG4gICAgLyoqXG4gICAgICogbG93ZXIgcmV0dXJucyBhIHBhcnNlciB0aGF0IGNvbnN1bWVzIGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAqIGlmIHRoYXQgY2hhcmFjdGVyIGlzIGxvd2VyY2FzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb3dlcigpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgbzEgPSBsZXR0ZXIoKShpc3RyZWFtKTtcbiAgICAgICAgICAgIHN3aXRjaCAobzEudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgbGV0IG8yID0gc2F0KHggPT4geCA9PSB4LnRvTG93ZXJDYXNlKCkpKG8xLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobzIudGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5ldmVyIGhhcHBlbnNcIik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMubG93ZXIgPSBsb3dlcjtcbiAgICAvKipcbiAgICAgKiBjaG9pY2Ugc3BlY2lmaWVzIGFuIG9yZGVyZWQgY2hvaWNlIGJldHdlZW4gdHdvIHBhcnNlcnMsXG4gICAgICogcDEgYW5kIHAyLiBUaGUgcmV0dXJuZWQgcGFyc2VyIHdpbGwgZmlyc3QgYXBwbHlcbiAgICAgKiBwYXJzZXIgcDEuICBJZiBwMSBzdWNjZWVkcywgcDEncyBPdXRjb21lIGlzIHJldHVybmVkLlxuICAgICAqIElmIHAxIGZhaWxzLCBwMiBpcyBhcHBsaWVkIGFuZCB0aGUgT3V0Y29tZSBvZiBwMiBpcyByZXR1cm5lZC5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBnaXZlbiB0byBwMSBhbmQgcDIgaXMgZXhhY3RseVxuICAgICAqIHRoZSBzYW1lIGlucHV0IHN0cmVhbS5cbiAgICAgKiBAcGFyYW0gcDEgQSBwYXJzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hvaWNlKHAxKSB7XG4gICAgICAgIHJldHVybiAocDIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBvID0gcDEoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDIoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5jaG9pY2UgPSBjaG9pY2U7XG4gICAgLyoqXG4gICAgICogYXBwZnVuIGFsbG93cyB0aGUgdXNlciB0byBhcHBseSBhIGZ1bmN0aW9uIGYgdG9cbiAgICAgKiB0aGUgcmVzdWx0IG9mIGEgcGFyc2VyIHAsIGFzc3VtaW5nIHRoYXQgcCBpcyBzdWNjZXNzZnVsLlxuICAgICAqIEBwYXJhbSBwIEEgcGFyc2VyLiAgVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgfD4+XG4gICAgICogZnVuY3Rpb24gZnJvbSBGUGFyc2VjLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFwcGZ1bihwKSB7XG4gICAgICAgIHJldHVybiAoZikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG8gPSBwKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2VzcyhvLmlucHV0c3RyZWFtLCBmKG8ucmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmFwcGZ1biA9IGFwcGZ1bjtcbiAgICAvKipcbiAgICAgKiBtYW55IHJlcGVhdGVkbHkgYXBwbGllcyB0aGUgcGFyc2VyIHAgdW50aWwgcCBmYWlscy4gbWFueSBhbHdheXNcbiAgICAgKiBzdWNjZWVkcywgZXZlbiBpZiBpdCBtYXRjaGVzIG5vdGhpbmcuICBtYW55IHRyaWVzIHRvIGd1YXJkXG4gICAgICogYWdhaW5zdCBhbiBpbmZpbml0ZSBsb29wIGJ5IHJhaXNpbmcgYW4gZXhjZXB0aW9uIGlmIHAgc3VjY2VlZHNcbiAgICAgKiB3aXRob3V0IGNoYW5naW5nIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICogQHBhcmFtIHBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYW55KHApIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgaXN0cmVhbTIgPSBpc3RyZWFtO1xuICAgICAgICAgICAgbGV0IG91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBzdWNjZWVkcyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoIWlzdHJlYW0yLmlzRW1wdHkoKSAmJiBzdWNjZWVkcykge1xuICAgICAgICAgICAgICAgIGxldCBvID0gcChpc3RyZWFtMik7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzdHJlYW0yID09IG8uaW5wdXRzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZXIgbG9vcHMgaW5maW5pdGVseS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3RyZWFtMiA9IG8uaW5wdXRzdHJlYW07XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2goby5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZWVkcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKGlzdHJlYW0yLCBvdXRwdXRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5tYW55ID0gbWFueTtcbiAgICAvKipcbiAgICAgKiBtYW55MSByZXBlYXRlZGx5IGFwcGxpZXMgdGhlIHBhcnNlciBwIHVudGlsIHAgZmFpbHMuIG1hbnkxIG11c3RcbiAgICAgKiBzdWNjZWVkIGF0IGxlYXN0IG9uY2UuICBtYW55MSB0cmllcyB0byBndWFyZCBhZ2FpbnN0IGFuIGluZmluaXRlXG4gICAgICogbG9vcCBieSByYWlzaW5nIGFuIGV4Y2VwdGlvbiBpZiBwIHN1Y2NlZWRzIHdpdGhvdXQgY2hhbmdpbmcgdGhlXG4gICAgICogcGFyc2VyIHN0YXRlLlxuICAgICAqIEBwYXJhbSBwXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFueTEocCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzZXEocCkobWFueShwKSkodHVwID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaGQgPSB0dXBbXCIwXCJdO1xuICAgICAgICAgICAgICAgIGxldCB0bCA9IHR1cFtcIjFcIl07XG4gICAgICAgICAgICAgICAgdGwudW5zaGlmdChoZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRsO1xuICAgICAgICAgICAgfSkoaXN0cmVhbSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMubWFueTEgPSBtYW55MTtcbiAgICAvKipcbiAgICAgKiBzdHIgeWllbGRzIGEgcGFyc2VyIGZvciB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICAqIEBwYXJhbSBzIEEgc3RyaW5nXG4gICAgICovXG4gICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYWN0dWFsbHkgYmUgYSBzZXF1ZW5jZSBvZiBwYXJzZXJzIGNvbnN0cnVjdGVkXG4gICAgLy8gZnJvbSB0aGUgc3RyaW5nIHNcbiAgICBmdW5jdGlvbiBzdHIocykge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIC8vIGVzY2FwZSByZWdleCBtZXRhY2hhcmFjdGVyc1xuICAgICAgICAgICAgLy8gKHRoaXMgbGlrZWx5IG5lZWRzIHdvcmspXG4gICAgICAgICAgICBsZXQgczIgPSBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4gICAgICAgICAgICBsZXQgcmUgPSBuZXcgUmVnRXhwKFwiXlwiICsgczIpO1xuICAgICAgICAgICAgaWYgKGlzdHJlYW0udG9TdHJpbmcoKS5tYXRjaChyZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW0gPSBpc3RyZWFtLnN1YnN0cmluZyhzLmxlbmd0aCwgaXN0cmVhbS5sZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gaXN0cmVhbS5zdWJzdHJpbmcoMCwgcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2VzcyhyZW0sIHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhaWx1cmUoaXN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuc3RyID0gc3RyO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwYXJzZXIgdGhhdCBzdWNjZWVkcyBvbmx5IGlmIHRoZSBlbmQgb2YgdGhlXG4gICAgICogaW5wdXQgaGFzIGJlZW4gcmVhY2hlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlb2YoKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzdHJlYW0uaXNFT0YoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2Vzcyhpc3RyZWFtLCBQcmltaXRpdmVzLkVPRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhaWx1cmUoaXN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuZW9mID0gZW9mO1xuICAgIC8qKlxuICAgICAqIGZyZXN1bHQgcmV0dXJucyBhIHBhcnNlciB0aGF0IGFwcGxpZXMgdGhlIHBhcnNlciBwLFxuICAgICAqIGFuZCBpZiBwIHN1Y2NlZWRzLCByZXR1cm5zIHRoZSB2YWx1ZSB4LlxuICAgICAqIEBwYXJhbSBwIGEgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJlc3VsdChwKSB7XG4gICAgICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQocCkoKHQpID0+IHJlc3VsdCh4KSkoaXN0cmVhbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmZyZXN1bHQgPSBmcmVzdWx0O1xuICAgIC8qKlxuICAgICAqIGxlZnQgcmV0dXJucyBhIHBhcnNlciB0aGF0IGFwcGxpZXMgdGhlIHBhcnNlciBwLFxuICAgICAqIHRoZW4gdGhlIHBhcnNlciBxLCBhbmQgaWYgYm90aCBhcmUgc3VjY2Vzc2Z1bCxcbiAgICAgKiByZXR1cm5zIHRoZSByZXN1bHQgb2YgcC5cbiAgICAgKiBAcGFyYW0gcCBhIHBhcnNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlZnQocCkge1xuICAgICAgICByZXR1cm4gKHEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiaW5kKHApKCh0KSA9PiBmcmVzdWx0KHEpKHQpKShpc3RyZWFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMubGVmdCA9IGxlZnQ7XG4gICAgLyoqXG4gICAgICogcmlnaHQgcmV0dXJucyBhIHBhcnNlciB0aGF0IGFwcGxpZXMgdGhlIHBhcnNlciBwLFxuICAgICAqIHRoZW4gdGhlIHBhcnNlciBxLCBhbmQgaWYgYm90aCBhcmUgc3VjY2Vzc2Z1bCxcbiAgICAgKiByZXR1cm5zIHRoZSByZXN1bHQgb2YgcS5cbiAgICAgKiBAcGFyYW0gcCBhIHBhcnNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJpZ2h0KHApIHtcbiAgICAgICAgcmV0dXJuIChxKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluZChwKShfID0+IHEpKGlzdHJlYW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5yaWdodCA9IHJpZ2h0O1xuICAgIC8qKlxuICAgICAqIGJldHdlZW4gcmV0dXJucyBhIHBhcnNlciB0aGF0IGFwcGxpZXMgdGhlIHBhcnNlclxuICAgICAqIHBvcGVuLCBwLCBhbmQgcGNsb3NlIGluIHNlcXVlbmNlLCBhbmQgaWYgYWxsIGFyZVxuICAgICAqIHN1Y2Nlc3NmdWwsIHJldHVybnMgdGhlIHJlc3VsdCBvZiBwLlxuICAgICAqIEBwYXJhbSBwb3BlbiB0aGUgZmlyc3QgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmV0d2Vlbihwb3Blbikge1xuICAgICAgICByZXR1cm4gKHBjbG9zZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChwKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGwgPSBsZWZ0KHApKHBjbG9zZSk7XG4gICAgICAgICAgICAgICAgbGV0IHIgPSByaWdodChwb3BlbikobCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmJldHdlZW4gPSBiZXR3ZWVuO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWJ1ZyBwYXJzZXIgdGFrZXMgYSBwYXJzZXIgcCBhbmQgYSBkZWJ1ZyBzdHJpbmcsXG4gICAgICogcHJpbnRpbmcgdGhlIGRlYnVnIHN0cmluZyBhcyBhIHNpZGUtZWZmZWN0IGJlZm9yZVxuICAgICAqIGFwcGx5aW5nIHAgdG8gdGhlIGlucHV0LlxuICAgICAqIEBwYXJhbSBwIGEgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVidWcocCkge1xuICAgICAgICByZXR1cm4gKGxhYmVsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImFwcGx5OiBcIiArIGxhYmVsKTtcbiAgICAgICAgICAgICAgICBsZXQgbyA9IHAoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzdWNjZXNzOiBcIiArIGxhYmVsICsgXCIsIHN0YXJ0cG9zOiBcIiArIGlzdHJlYW0uc3RhcnRwb3MgKyBcIiwgZW5kcG9zOiBcIiArIGlzdHJlYW0uZW5kcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJmYWlsdXJlOiBcIiArIGxhYmVsICsgXCIsIHN0YXJ0cG9zOiBcIiArIGlzdHJlYW0uc3RhcnRwb3MgKyBcIiwgZW5kcG9zOiBcIiArIGlzdHJlYW0uZW5kcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuZGVidWcgPSBkZWJ1ZztcbiAgICBsZXQgd3NjaGFycyA9IGNob2ljZShzYXQoYyA9PiBjID09ICcgJyB8fCBjID09ICdcXHQnKSkobmwoKSk7XG4gICAgLyoqXG4gICAgICogd3MgbWF0Y2hlcyB6ZXJvIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnM6XG4gICAgICogJyAnLCAnXFx0JywgJ1xcbicsIG9yICdcXHJcXG4nXG4gICAgICogd3MgcmV0dXJucyBtYXRjaGVkIHdoaXRlc3BhY2UgaW4gYSBzaW5nbGUgQ2hhclN0cmVhbSByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3MoKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgbGV0IG8gPSBtYW55KHdzY2hhcnMpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2VzcyhvLmlucHV0c3RyZWFtLCBjaGFyc3RyZWFtXzEuQ2hhclV0aWwuQ2hhclN0cmVhbS5jb25jYXQoby5yZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAvLyB3cyBuZXZlciBmYWlsc1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLndzID0gd3M7XG4gICAgLyoqXG4gICAgICogd3MxIG1hdGNoZXMgb25lIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnM6XG4gICAgICogJyAnLCAnXFx0JywgJ1xcbicsIG9yICdcXHJcXG4nXG4gICAgICogd3MxIHJldHVybnMgbWF0Y2hlZCB3aGl0ZXNwYWNlIGluIGEgc2luZ2xlIENoYXJTdHJlYW0gcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdzMSgpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgbyA9IG1hbnkxKHdzY2hhcnMpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2VzcyhvLmlucHV0c3RyZWFtLCBjaGFyc3RyZWFtXzEuQ2hhclV0aWwuQ2hhclN0cmVhbS5jb25jYXQoby5yZXN1bHQpKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy53czEgPSB3czE7XG4gICAgLyoqXG4gICAgICogbmwgbWF0Y2hlcyBhbmQgcmV0dXJucyBhIG5ld2xpbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmwoKSB7XG4gICAgICAgIHJldHVybiBQcmltaXRpdmVzLmNob2ljZShQcmltaXRpdmVzLnN0cihcIlxcblwiKSkoUHJpbWl0aXZlcy5zdHIoXCJcXHJcXG5cIikpO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLm5sID0gbmw7XG4gICAgZnVuY3Rpb24gZ3JvdXBCeShsaXN0LCBrZXlHZXR0ZXIpIHtcbiAgICAgICAgbGV0IG0gPSBuZXcgTWFwKCk7XG4gICAgICAgIGxpc3QuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5R2V0dGVyKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKCFtLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbS5zZXQoa2V5LCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY29sbGVjdGlvbiA9IG0uZ2V0KGtleSk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2goaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyU2F0KHN0cnMpIHtcbiAgICAgICAgLy8gc29ydCBzdHJpbmdzIGZpcnN0IGJ5IGxlbmd0aCwgYW5kIHRoZW4gbGV4aWNvZ3JhcGljYWxseTtcbiAgICAgICAgLy8gc2xpY2UoKSBjYWxsZWQgaGVyZSBzbyBhcyBub3QgdG8gbW9kaWZ5IG9yaWdpbmFsIGFycmF5XG4gICAgICAgIGxldCBzbWFwID0gZ3JvdXBCeShzdHJzLCBzID0+IHMubGVuZ3RoKTtcbiAgICAgICAgbGV0IHNpemVzID0gW107XG4gICAgICAgIC8vIGZpbmQgc2l6ZSBjbGFzc2VzO1xuICAgICAgICAvLyBhbHNvIHNvcnQgZWFjaCBzZXQgb2YgZXF1aXZhbGVudC1sZW5ndGggdmFsdWVzXG4gICAgICAgIHNtYXAuZm9yRWFjaCgodmFscywga2V5LCBtKSA9PiB7XG4gICAgICAgICAgICBzaXplcy5wdXNoKGtleSk7XG4gICAgICAgICAgICB2YWxzLnNvcnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNpemVzLnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAvLyBzdGFydCB3aXRoIHRoZSBzbWFsbGVzdCBzaXplIGNsYXNzICAgICAgIFxuICAgICAgICAgICAgZm9yIChsZXQgcGVla0luZGV4ID0gMDsgcGVla0luZGV4IDwgc2l6ZXMubGVuZ3RoOyBwZWVrSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIHNpemUgY2xhc3MsIHRyeSBtYXRjaGluZyBhbGwgb2ZcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3RyaW5nczsgaWYgb25lIGlzIGZvdW5kLCByZXR1cm4gdGhlXG4gICAgICAgICAgICAgICAgLy8gYXBwcm9wcmlhdGUgQ2hhclN0cmVhbTsgaWYgbm90LCBmYWlsLlxuICAgICAgICAgICAgICAgIGxldCBwZWVrID0gaXN0cmVhbS5wZWVrKHNpemVzW3BlZWtJbmRleF0pO1xuICAgICAgICAgICAgICAgIGxldCB0YWlsID0gaXN0cmVhbS5zZWVrKHNpemVzW3BlZWtJbmRleF0pO1xuICAgICAgICAgICAgICAgIGxldCBjYW5kaWRhdGVzID0gc21hcC5nZXQoc2l6ZXNbcGVla0luZGV4XSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY0luZGV4ID0gMDsgY0luZGV4IDwgY2FuZGlkYXRlcy5sZW5ndGg7IGNJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGVzW2NJbmRleF0gPT09IHBlZWsudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKHRhaWwsIHBlZWspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnN0clNhdCA9IHN0clNhdDtcbn0pKFByaW1pdGl2ZXMgPSBleHBvcnRzLlByaW1pdGl2ZXMgfHwgKGV4cG9ydHMuUHJpbWl0aXZlcyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmltaXRpdmVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0XzEgPSByZXF1aXJlKFwiLi4vbGlmdFwiKTtcbi8qKlxuICogQ29udmVydHMgYW4gQXJyYXktbGlrZSBvYmplY3QgKHN1Y2ggYXMgYW4gYXJndW1lbnRzIG9yIE5vZGVMaXN0IGluc3RhbmNlKSB0byBhIHJlZ3VsYXIgQXJyYXlcbiAqL1xuZnVuY3Rpb24gZnJvbUFycmF5TGlrZShhcnJheUxpa2UpIHtcbiAgICByZXR1cm4gbmV3IGxpZnRfMS5BcnJheU9wcyhbXS5zbGljZS5jYWxsKGFycmF5TGlrZSkpO1xufVxuZXhwb3J0cy5mcm9tQXJyYXlMaWtlID0gZnJvbUFycmF5TGlrZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0XzEgPSByZXF1aXJlKFwiLi4vbGlmdFwiKTtcbi8qXG4qIFJldHVybnMgYSBudW1iZXJbXSB3cmFwcGVyIHdpdGggYWxsIG51bWJlcnMgZnJvbSBzdGFydCB0byBzdG9wIChpbmNsdXNpdmUpLFxuKiBpbmNyZW1lbnRlZCBvciBkZWNyZW1lbnRlZCBieSBzdGVwLlxuKi9cbmZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RvcCA9IGFyZ3VtZW50c1swXSAtIDE7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGluY3JlYXNpbmcgPSBzdGVwID4gMDtcbiAgICB2YXIgbmV4dCA9IHN0YXJ0O1xuICAgIHdoaWxlICgoaW5jcmVhc2luZyAmJiBuZXh0IDw9IHN0b3ApIHx8ICghaW5jcmVhc2luZyAmJiBuZXh0ID49IHN0b3ApKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5leHQpO1xuICAgICAgICBuZXh0ID0gbmV4dCArIHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgbGlmdF8xLkFycmF5T3BzKHJlc3VsdCk7XG59XG5leHBvcnRzLnJhbmdlID0gcmFuZ2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5mdW5jdGlvbiB0dXBsZShhcnIpIHtcbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0cy50dXBsZSA9IHR1cGxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGlzXzEgPSByZXF1aXJlKFwiLi4vb2JqZWN0L2lzXCIpO1xudmFyIGN1cnJlbnRNZW1vSWQgPSAwO1xuLyoqXG4gKiBNZW1vaXplcyBhIGZ1bmN0aW9uIG9mIGFyYml0cmFyeSBhcml0eS5cbiAqIFRoaXMgaGFzIHR3byBtYWluIHVzZXM6XG4gKiAgIDEpIFJlZHVjaW5nIHRoZSBDUFUgdGltZSB0YWtlbiBieSBleHBlbnNpdmUgY2FsY3VsYXRpb25zIGF0IHRoZSBjb3N0IG9mIHNvbWUgbWVtb3J5IG92ZXJoZWFkXG4gKiAgIDIpIFByb2R1Y2luZyBzdGFibGUgcmVmZXJlbmNlcyBmb3IgYSBnaXZlbiBzZXQgb2YgYXJndW1lbnRzLiBVc2VmdWwgd2hlbiByZWx5aW5nIG9uIHJlZmVyZW5jZSBlcXVhbGl0eS5cbiAqXG4gKiBNZW1vaXplZCBmdW5jdGlvbnMga2VlcCBpbnRlcm5hbCBzdGF0ZS4gSWYgeW91IHdpc2ggdG8gY2xlYXIgdGhhdCBzdGF0ZSBlbnRpcmVseSwgeW91IGNhbiByZWNyZWF0ZSB0aGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuLCBvcHRpb25zKSB7XG4gICAgLy8gVGhlIHVuaXF1ZSBwcm9wZXJ0eSBuYW1lIHVzZWQgYnkgdGhpcyBtZW1vaXplIGZ1bmN0aW9uIGluc3RhbmNlLlxuICAgIC8vIFRoaXMgaXMgdXNlZCB0byBzdG9yZSB0aGUgaWQvcmVmZXJlbmNlIG9mIG9iamVjdCBhcmd1bWVudHMsIGFzIFdlYWsgbWFwcy9zZXRzIGFyZSB2ZXJ5IGxpbWl0ZWQuXG4gICAgdmFyIG1lbW9LZXkgPSBcIl9fbWVtb19fXCIgKyBjdXJyZW50TWVtb0lkKys7XG4gICAgdmFyIGxhc3RBcmdLZXlzID0gW107XG4gICAgdmFyIGNhY2hlU2l6ZSA9IChvcHRpb25zICYmIG9wdGlvbnMuY2FjaGVTaXplKSB8fCAzMDtcbiAgICB2YXIga2V5RnVuY3Rpb24gPSBvcHRpb25zICYmIG9wdGlvbnMua2V5O1xuICAgIC8vIFRoZSB1bmlxdWUgaWRzL3JlZmVyZW5jZXMgb2Ygb2JqZWN0cyBpbnNpZGUgdGhlIGFyaXR5TkNhY2hlIGNhY2hlXG4gICAgdmFyIG9iaklkID0gMDtcbiAgICB2YXIgYXJpdHkwQ2FjaGU7XG4gICAgdmFyIGFyaXR5TkNhY2hlO1xuICAgIHZhciBrZXlDYWNoZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIDAgYXJndW1lbnRzIGVkZ2UtY2FzZVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICghYXJpdHkwQ2FjaGUpXG4gICAgICAgICAgICAgICAgYXJpdHkwQ2FjaGUgPSBmdW4oKTtcbiAgICAgICAgICAgIHJldHVybiBhcml0eTBDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjdXN0b20ga2V5IGZ1bmN0aW9uXG4gICAgICAgIGVsc2UgaWYgKGtleUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBrZXlDYWNoZSA9IGtleUNhY2hlIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleUZ1bmN0aW9uLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGtleUNhY2hlW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGxhc3RBcmdLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICBsaW1pdENhY2hlU2l6ZShrZXlDYWNoZSwgbGFzdEFyZ0tleXMsIGNhY2hlU2l6ZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ga2V5Q2FjaGVba2V5XSA9IGZ1bi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTiBhcmd1bWVudHNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhcml0eU5DYWNoZSA9IGFyaXR5TkNhY2hlIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGtleSA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgICAgICAgdmFyIGFyZ0tleSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoaXNfMS5vYmplY3QoYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdLZXkgPSBhcmdbbWVtb0tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXJnS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb24gZW51bWVyYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFyZywgbWVtb0tleSwgeyB2YWx1ZTogXCJvYmpcIiArIG9iaklkKysgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdLZXkgPSBhcmdbbWVtb0tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ0tleSA9IGFyZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5ICs9IChhcmdLZXkgKyAnXycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGFyaXR5TkNhY2hlW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGxhc3RBcmdLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICBsaW1pdENhY2hlU2l6ZShhcml0eU5DYWNoZSwgbGFzdEFyZ0tleXMsIGNhY2hlU2l6ZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXJpdHlOQ2FjaGVba2V5XSA9IGZ1bi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5tZW1vaXplID0gbWVtb2l6ZTtcbmZ1bmN0aW9uIGxpbWl0Q2FjaGVTaXplKGNhY2hlLCBsYXN0QXJnS2V5cywgc2l6ZSkge1xuICAgIGlmIChsYXN0QXJnS2V5cy5sZW5ndGggPT09IHNpemUgKyAxKSB7XG4gICAgICAgIHZhciBrZXkgPSBsYXN0QXJnS2V5cy5zaGlmdCgpO1xuICAgICAgICBkZWxldGUgY2FjaGVba2V5XTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbGlmdF8xID0gcmVxdWlyZShcIi4vbGlmdFwiKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbGlmdF8xW1wiZGVmYXVsdFwiXTtcbnZhciBsaWZ0XzIgPSByZXF1aXJlKFwiLi9saWZ0XCIpO1xuZXhwb3J0cy5BcnJheU9wcyA9IGxpZnRfMi5BcnJheU9wcztcbmV4cG9ydHMuT2JqZWN0T3BzID0gbGlmdF8yLk9iamVjdE9wcztcbmV4cG9ydHMuTnVtYmVyT3BzID0gbGlmdF8yLk51bWJlck9wcztcbmV4cG9ydHMuU3RyaW5nT3BzID0gbGlmdF8yLlN0cmluZ09wcztcbmV4cG9ydHMuRGF0ZU9wcyA9IGxpZnRfMi5EYXRlT3BzO1xuZXhwb3J0cy5nZXRWYWx1ZSA9IGxpZnRfMi5nZXRWYWx1ZTtcbnZhciBpbW11cGRhdGVfMSA9IHJlcXVpcmUoXCJpbW11cGRhdGVcIik7XG5leHBvcnRzLnVwZGF0ZSA9IGltbXVwZGF0ZV8xLnVwZGF0ZTtcbmV4cG9ydHMuZGVlcFVwZGF0ZSA9IGltbXVwZGF0ZV8xLmRlZXBVcGRhdGU7XG5leHBvcnRzLkRFTEVURSA9IGltbXVwZGF0ZV8xLkRFTEVURTtcbnZhciBvcHRpb25fMSA9IHJlcXVpcmUoXCIuL29wdGlvblwiKTtcbmV4cG9ydHMuT3B0aW9uID0gb3B0aW9uXzEuT3B0aW9uO1xuZXhwb3J0cy5Ob25lID0gb3B0aW9uXzEuTm9uZTtcbmV4cG9ydHMuU29tZSA9IG9wdGlvbl8xLlNvbWU7XG52YXIgcmVzdWx0XzEgPSByZXF1aXJlKFwiLi9yZXN1bHRcIik7XG5leHBvcnRzLlJlc3VsdCA9IHJlc3VsdF8xLlJlc3VsdDtcbmV4cG9ydHMuT2sgPSByZXN1bHRfMS5PaztcbmV4cG9ydHMuRXJyID0gcmVzdWx0XzEuRXJyO1xudmFyIHJhbmdlXzEgPSByZXF1aXJlKFwiLi9hcnJheS9yYW5nZVwiKTtcbmV4cG9ydHMucmFuZ2UgPSByYW5nZV8xLnJhbmdlO1xudmFyIGZyb21BcnJheUxpa2VfMSA9IHJlcXVpcmUoXCIuL2FycmF5L2Zyb21BcnJheUxpa2VcIik7XG5leHBvcnRzLmZyb21BcnJheUxpa2UgPSBmcm9tQXJyYXlMaWtlXzEuZnJvbUFycmF5TGlrZTtcbnZhciB0dXBsZV8xID0gcmVxdWlyZShcIi4vYXJyYXkvdHVwbGVcIik7XG5leHBvcnRzLnR1cGxlID0gdHVwbGVfMS50dXBsZTtcbnZhciBzZXRfMSA9IHJlcXVpcmUoXCIuL29iamVjdC9zZXRcIik7XG5leHBvcnRzLlNldCA9IHNldF8xLlNldDtcbnZhciBtZW1vaXplXzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbi9tZW1vaXplXCIpO1xuZXhwb3J0cy5tZW1vaXplID0gbWVtb2l6ZV8xLm1lbW9pemU7XG52YXIgaXNUeXBlID0gcmVxdWlyZShcIi4vb2JqZWN0L2lzXCIpO1xuZXhwb3J0cy5pcyA9IGlzVHlwZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLkFycmF5T3BzKG9iaik7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgIHJldHVybiBuZXcgZXhwb3J0cy5EYXRlT3BzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuU3RyaW5nT3BzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuTnVtYmVyT3BzKG9iaik7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLk9iamVjdE9wcyhvYmopO1xufTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbGlmdDtcbmZ1bmN0aW9uIGdldFZhbHVlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ICYmIGlucHV0WydfaXNMaWZ0V3JhcHBlciddXG4gICAgICAgID8gaW5wdXQudmFsdWUoKVxuICAgICAgICA6IGlucHV0O1xufVxuZXhwb3J0cy5nZXRWYWx1ZSA9IGdldFZhbHVlO1xuZnVuY3Rpb24gbWFrZU9wcygpIHtcbiAgICB2YXIgT3BzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBPcHMoX3ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzTGlmdFdyYXBwZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIE9wcy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfTtcbiAgICAgICAgcmV0dXJuIE9wcztcbiAgICB9KCkpO1xuICAgIHJldHVybiBPcHM7XG59XG5leHBvcnRzLkFycmF5T3BzID0gbWFrZU9wcygpO1xuZXhwb3J0cy5PYmplY3RPcHMgPSBtYWtlT3BzKCk7XG5leHBvcnRzLk51bWJlck9wcyA9IG1ha2VPcHMoKTtcbmV4cG9ydHMuU3RyaW5nT3BzID0gbWFrZU9wcygpO1xuZXhwb3J0cy5EYXRlT3BzID0gbWFrZU9wcygpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuLyoqIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaXMgYW4gQXJyYXkgKi9cbmV4cG9ydHMuYXJyYXkgPSBBcnJheS5pc0FycmF5O1xuLyoqIFJldHVybnMgd2hldGhlciB0aGlzIG9iamVjdCBpcyBhIGZ1bmN0aW9uICovXG5mdW5jdGlvbiBmdW5jKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5leHBvcnRzLmZ1bmMgPSBmdW5jO1xuLyoqIFJldHVybnMgd2hldGhlciB0aGlzIG9iamVjdCBpcyBhIHN0cmluZyAqL1xuZnVuY3Rpb24gc3RyaW5nKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpO1xufVxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG4vKiogUmV0dXJucyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIGEgbnVtYmVyICovXG5mdW5jdGlvbiBudW1iZXIob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyk7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbi8qKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvYmplY3QgaXMgYSBib29sZWFuICovXG5mdW5jdGlvbiBib29sZWFuKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nKTtcbn1cbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XG4vKiogUmV0dXJucyB3aGV0aGVyIHRoaXMgdmFsdWUgaXMgYW4gb2JqZWN0IChlLmcgbm90IGEgcHJpbWl0aXZlOiBkYXRlcywgYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKSkgKi9cbmZ1bmN0aW9uIG9iamVjdChvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5leHBvcnRzLm9iamVjdCA9IG9iamVjdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0XzEgPSByZXF1aXJlKFwiLi4vbGlmdFwiKTtcbi8qKlxuICogQ3JlYXRlcyBhIFNldC1saWtlIG9iamVjdCAoc3RyaW5nIGtleXMsIHRydWUgdmFsdWVzKSBmcm9tIGEgbGlzdCBvZiBrZXlzXG4gKi9cbmZ1bmN0aW9uIFNldCgpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGtleXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiByZXN1bHRba2V5XSA9IHRydWU7IH0pO1xuICAgIHJldHVybiBuZXcgbGlmdF8xLk9iamVjdE9wcyhyZXN1bHQpO1xufVxuZXhwb3J0cy5TZXQgPSBTZXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbGlmdF8xID0gcmVxdWlyZShcIi4uL2xpZnRcIik7XG4vLyBUaGUgT3B0aW9uIGZhY3RvcnkgLyBzdGF0aWMgb2JqZWN0XG52YXIgT3B0aW9uT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzRGVmKHZhbHVlKSA/IFNvbWUodmFsdWUpIDogZXhwb3J0cy5Ob25lO1xufTtcbk9wdGlvbk9iamVjdC5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgaWYgKGV4cG9ydHMuT3B0aW9uLmlzT3B0aW9uKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZ2V0KCk7XG4gICAgICAgIGlmICghaXNEZWYodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTm9uZTtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gU29tZSh2YWx1ZXMpO1xufTtcbk9wdGlvbk9iamVjdC5pc09wdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICh2YWx1ZS50eXBlID09PSAnc29tZScgfHwgdmFsdWUudHlwZSA9PT0gJ25vbmUnKTtcbn07XG5mdW5jdGlvbiBtYWtlTm9uZSgpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuICAgIGZ1bmN0aW9uIHJldHVybk5vbmUoKSB7IHJldHVybiBleHBvcnRzLk5vbmU7IH1cbiAgICBzZWxmLnR5cGUgPSAnbm9uZSc7XG4gICAgc2VsZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH07XG4gICAgc2VsZi5pc0RlZmluZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICBzZWxmLmZvckVhY2ggPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgc2VsZi5tYXAgPSByZXR1cm5Ob25lO1xuICAgIHNlbGYuZmxhdE1hcCA9IHJldHVybk5vbmU7XG4gICAgc2VsZi5maWx0ZXIgPSByZXR1cm5Ob25lO1xuICAgIHNlbGYuZm9sZCA9IGZ1bmN0aW9uIChpZkVtcHR5KSB7IHJldHVybiBpZkVtcHR5KCk7IH07XG4gICAgc2VsZi5vckVsc2UgPSBmdW5jdGlvbiAoYWx0KSB7IHJldHVybiBhbHQoKTsgfTtcbiAgICBzZWxmLmdldE9yRWxzZSA9IGZ1bmN0aW9uIChhbHQpIHsgcmV0dXJuIGFsdDsgfTtcbiAgICBzZWxmLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWZ0XzFbXCJkZWZhdWx0XCJdKFtdKTsgfTtcbiAgICBzZWxmLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ05vbmUnOyB9O1xuICAgIHNlbGYudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9Tb21lKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuX1NvbWUucHJvdG90eXBlID0ge1xuICAgIHR5cGU6ICdzb21lJyxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfSxcbiAgICBpc0RlZmluZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgZm4odGhpcy52YWx1ZSk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcHRpb24obGlmdF8xLmdldFZhbHVlKGZuKHRoaXMudmFsdWUpKSk7XG4gICAgfSxcbiAgICBmbGF0TWFwOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKHRoaXMudmFsdWUpO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKHRoaXMudmFsdWUpID8gdGhpcyA6IGV4cG9ydHMuTm9uZTtcbiAgICB9LFxuICAgIGZvbGQ6IGZ1bmN0aW9uIChpZkVtcHR5LCBpZkRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGlmRGVmaW5lZCh0aGlzLnZhbHVlKTtcbiAgICB9LFxuICAgIG9yRWxzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldE9yRWxzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9LFxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxpZnRfMVtcImRlZmF1bHRcIl0oW3RoaXMudmFsdWVdKTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNvbWUoXCIgKyB0aGlzLnZhbHVlICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGlzRGVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLk9wdGlvbiA9IE9wdGlvbk9iamVjdDtcbi8qKiBDcmVhdGVzIGEgbmV3IFNvbWUgaW5zdGFuY2UgdXNpbmcgYSBub24gbnVsbGFibGUgdmFsdWUgKi9cbi8vIGV4dGVuZHMge30gdG8gcHJldmVudCBudWxsIGFuZCB1bmRlZmluZWQgYmVpbmcgcGFzc2VkXG5mdW5jdGlvbiBTb21lKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfU29tZSh2YWx1ZSk7XG59XG5leHBvcnRzLlNvbWUgPSBTb21lO1xuZXhwb3J0cy5Ob25lID0gbWFrZU5vbmUoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0XzEgPSByZXF1aXJlKFwiLi4vbGlmdFwiKTtcbnZhciBSZXN1bHRPYmplY3QgPSB7fTtcblJlc3VsdE9iamVjdC5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIG9rVmFsdWVzID0gW107XG4gICAgdmFyIGN1cnJlbnRSZXN1bHQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRSZXN1bHRfMSA9IGFycltpXTtcbiAgICAgICAgaWYgKCFjdXJyZW50UmVzdWx0XzEuaXNPaygpKVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRfMTtcbiAgICAgICAgb2tWYWx1ZXMucHVzaChjdXJyZW50UmVzdWx0XzEuZ2V0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gT2sob2tWYWx1ZXMpO1xufTtcblJlc3VsdE9iamVjdC5pc1Jlc3VsdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICh2YWx1ZS50eXBlID09PSAnb2snIHx8IHZhbHVlLnR5cGUgPT09ICdlcnInKTtcbn07XG5mdW5jdGlvbiBfT2sodmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xufVxuX09rLnByb3RvdHlwZSA9IHtcbiAgICB0eXBlOiAnb2snLFxuICAgIGlzT2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gT2sobGlmdF8xLmdldFZhbHVlKGZuKHRoaXMuX3ZhbHVlKSkpO1xuICAgIH0sXG4gICAgbWFwRXJyb3I6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZsYXRNYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4odGhpcy5fdmFsdWUpO1xuICAgIH0sXG4gICAgZm9sZDogZnVuY3Rpb24gKGlmRXJyLCBpZk9rKSB7XG4gICAgICAgIHJldHVybiBpZk9rKHRoaXMuX3ZhbHVlKTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIk9rKFwiICsgdGhpcy5fdmFsdWUgKyBcIilcIjtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxufTtcbmZ1bmN0aW9uIF9FcnIoZXJyb3IpIHtcbiAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xufVxuX0Vyci5wcm90b3R5cGUgPSB7XG4gICAgdHlwZTogJ2VycicsXG4gICAgaXNPazogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG1hcEVycm9yOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIEVycihmbih0aGlzLl9lcnJvcikpO1xuICAgIH0sXG4gICAgZmxhdE1hcDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZm9sZDogZnVuY3Rpb24gKGlmRXJyLCBpZk9rKSB7XG4gICAgICAgIHJldHVybiBpZkVycih0aGlzLl9lcnJvcik7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJFcnIoXCIgKyB0aGlzLl9lcnJvciArIFwiKVwiO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICB9XG59O1xuZXhwb3J0cy5SZXN1bHQgPSBSZXN1bHRPYmplY3Q7XG5mdW5jdGlvbiBPayh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX09rKHZhbHVlKTtcbn1cbmV4cG9ydHMuT2sgPSBPaztcbmZ1bmN0aW9uIEVycihlcnJvcikge1xuICAgIHJldHVybiBuZXcgX0VycihlcnJvcik7XG59XG5leHBvcnRzLkVyciA9IEVycjtcbiJdfQ==
