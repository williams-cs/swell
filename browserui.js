(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Scope_1 = require("./lib/structural/Scope");
exports.Scope = Scope_1.Scope;
/* BINARY OPS */
var AssignOp_1 = require("./lib/binops/AssignOp");
exports.AssignOp = AssignOp_1.AssignOp;
var BinaryOperation_1 = require("./lib/binops/BinaryOperation");
exports.BinaryOperation = BinaryOperation_1.BinaryOperation;
var DivOp_1 = require("./lib/binops/DivOp");
exports.DivOp = DivOp_1.DivOp;
var MinusOp_1 = require("./lib/binops/MinusOp");
exports.MinusOp = MinusOp_1.MinusOp;
var MulOp_1 = require("./lib/binops/MulOp");
exports.MulOp = MulOp_1.MulOp;
var PlusOp_1 = require("./lib/binops/PlusOp");
exports.PlusOp = PlusOp_1.PlusOp;
var GreaterThan_1 = require("./lib/logic/GreaterThan");
exports.GreaterThan = GreaterThan_1.GreaterThan;
var GreaterThanEq_1 = require("./lib/logic/GreaterThanEq");
exports.GreaterThanEq = GreaterThanEq_1.GreaterThanEq;
var LessThan_1 = require("./lib/logic/LessThan");
exports.LessThan = LessThan_1.LessThan;
var LessThanEq_1 = require("./lib/logic/LessThanEq");
exports.LessThanEq = LessThanEq_1.LessThanEq;
var DeclareOp_1 = require("./lib/binops/DeclareOp");
exports.DeclareOp = DeclareOp_1.DeclareOp;
var And_1 = require("./lib/logic/And");
exports.And = And_1.And;
var Or_1 = require("./lib/logic/Or");
exports.Or = Or_1.Or;
var Equals_1 = require("./lib/logic/Equals");
exports.Equals = Equals_1.Equals;
var NotEqual_1 = require("./lib/logic/NotEqual");
exports.NotEqual = NotEqual_1.NotEqual;
var Increment_1 = require("./lib/binops/Increment");
exports.Increment = Increment_1.Increment;
var Decrement_1 = require("./lib/binops/Decrement");
exports.Decrement = Decrement_1.Decrement;
/* UNARY OPS */
var UnaryOperation_1 = require("./lib/unops/UnaryOperation");
exports.UnaryOperation = UnaryOperation_1.UnaryOperation;
var NegOp_1 = require("./lib/unops/NegOp");
exports.NegOp = NegOp_1.NegOp;
var Not_1 = require("./lib/logic/Not");
exports.Not = Not_1.Not;
/* DATA TYPES */
var ListNode_1 = require("./lib/lists/ListNode");
exports.ListNode = ListNode_1.ListNode;
var NumberNode_1 = require("./lib/prims/NumberNode");
exports.NumberNode = NumberNode_1.NumberNode;
var StringNode_1 = require("./lib/prims/StringNode");
exports.StringNode = StringNode_1.StringNode;
var BooleanNode_1 = require("./lib/prims/BooleanNode");
exports.BooleanNode = BooleanNode_1.BooleanNode;
var NOP_1 = require("./lib/prims/NOP");
exports.NOP = NOP_1.NOP;
/* VARIABLES */
var VariableNode_1 = require("./lib/vars/VariableNode");
exports.VariableNode = VariableNode_1.VariableNode;
/* CONTROL CONSTRUCTS */
var Conditional_1 = require("./lib/conditionals/Conditional");
exports.Conditional = Conditional_1.Conditional;
var FunApp_1 = require("./lib/funhouse/FunApp");
exports.FunApp = FunApp_1.FunApp;
var FunDef_1 = require("./lib/funhouse/FunDef");
exports.FunDef = FunDef_1.FunDef;
var SequenceNode_1 = require("./lib/structural/SequenceNode");
exports.SequenceNode = SequenceNode_1.SequenceNode;
var WhileNode_1 = require("./lib/loops/WhileNode");
exports.WhileNode = WhileNode_1.WhileNode;
var ForNode_1 = require("./lib/loops/ForNode");
exports.ForNode = ForNode_1.ForNode;
/* BUILTIN FUNCTIONS */
var ColorNode_1 = require("./lib/shapes/ColorNode");
exports.ColorNode = ColorNode_1.ColorNode;
var EllipseNode_1 = require("./lib/shapes/EllipseNode");
exports.EllipseNode = EllipseNode_1.EllipseNode;
var RectangleNode_1 = require("./lib/shapes/RectangleNode");
exports.RectangleNode = RectangleNode_1.RectangleNode;
var LineNode_1 = require("./lib/shapes/LineNode");
exports.LineNode = LineNode_1.LineNode;
var CurveNode_1 = require("./lib/shapes/CurveNode");
exports.CurveNode = CurveNode_1.CurveNode;
var EphNode_1 = require("./lib/shapes/EphNode");
exports.EphNode = EphNode_1.EphNode;
var PrintNode_1 = require("./lib/structural/PrintNode");
exports.PrintNode = PrintNode_1.PrintNode;
var Return_1 = require("./lib/structural/Return");
exports.Return = Return_1.Return;
var ReturnError_1 = require("./lib/structural/ReturnError");
exports.ReturnError = ReturnError_1.ReturnError;
var EllipseEffect_1 = require("./lib/effects/EllipseEffect");
exports.EllipseEffect = EllipseEffect_1.EllipseEffect;
var NumberEffect_1 = require("./lib/effects/NumberEffect");
exports.NumberEffect = NumberEffect_1.NumberEffect;
var StringEffect_1 = require("./lib/effects/StringEffect");
exports.StringEffect = StringEffect_1.StringEffect;
var Dimensions_1 = require("./lib/structural/Dimensions");
exports.Dimensions = Dimensions_1.Dimensions;
var RectangleEffect_1 = require("./lib/effects/RectangleEffect");
exports.RectangleEffect = RectangleEffect_1.RectangleEffect;
var LineEffect_1 = require("./lib/effects/LineEffect");
exports.LineEffect = LineEffect_1.LineEffect;
var CurveEffect_1 = require("./lib/effects/CurveEffect");
exports.CurveEffect = CurveEffect_1.CurveEffect;
var EphEffect_1 = require("./lib/effects/EphEffect");
exports.EphEffect = EphEffect_1.EphEffect;
/* EVENTS */
var LogEvent_1 = require("./lib/logging/LogEvent");
exports.LogEvent = LogEvent_1.LogEvent;
var ClearEvent_1 = require("./lib/logging/ClearEvent");
exports.ClearEvent = ClearEvent_1.ClearEvent;
var DragEvent_1 = require("./lib/logging/DragEvent");
exports.DragEvent = DragEvent_1.DragEvent;
var PaintEvent_1 = require("./lib/logging/PaintEvent");
exports.PaintEvent = PaintEvent_1.PaintEvent;
var ResizeEvent_1 = require("./lib/logging/ResizeEvent");
exports.ResizeEvent = ResizeEvent_1.ResizeEvent;
var SelectEvent_1 = require("./lib/logging/SelectEvent");
exports.SelectEvent = SelectEvent_1.SelectEvent;
var IDEvent_1 = require("./lib/logging/IDEvent");
exports.IDEvent = IDEvent_1.IDEvent;
var LessonOneCpOne_1 = require("./lib/modules/LessonOneCpOne");
exports.LessonOneCpOne = LessonOneCpOne_1.LessonOneCpOne;
var LessonOneCpTwo_1 = require("./lib/modules/LessonOneCpTwo");
exports.LessonOneCpTwo = LessonOneCpTwo_1.LessonOneCpTwo;
var LessonOneCpThree_1 = require("./lib/modules/LessonOneCpThree");
exports.LessonOneCpThree = LessonOneCpThree_1.LessonOneCpThree;
var LessonOneCpFour_1 = require("./lib/modules/LessonOneCpFour");
exports.LessonOneCpFour = LessonOneCpFour_1.LessonOneCpFour;
var LessonTwoCpOne_1 = require("./lib/modules/LessonTwoCpOne");
exports.LessonTwoCpOne = LessonTwoCpOne_1.LessonTwoCpOne;
var LessonTwoCpTwo_1 = require("./lib/modules/LessonTwoCpTwo");
exports.LessonTwoCpTwo = LessonTwoCpTwo_1.LessonTwoCpTwo;
var LessonTwoCpThree_1 = require("./lib/modules/LessonTwoCpThree");
exports.LessonTwoCpThree = LessonTwoCpThree_1.LessonTwoCpThree;
var LessonTwoCpFour_1 = require("./lib/modules/LessonTwoCpFour");
exports.LessonTwoCpFour = LessonTwoCpFour_1.LessonTwoCpFour;
var LessonTwoCpFive_1 = require("./lib/modules/LessonTwoCpFive");
exports.LessonTwoCpFive = LessonTwoCpFive_1.LessonTwoCpFive;
var LessonTwoCpSix_1 = require("./lib/modules/LessonTwoCpSix");
exports.LessonTwoCpSix = LessonTwoCpSix_1.LessonTwoCpSix;
var LessonTwoCpSeven_1 = require("./lib/modules/LessonTwoCpSeven");
exports.LessonTwoCpSeven = LessonTwoCpSeven_1.LessonTwoCpSeven;
var LessonThreeCpOne_1 = require("./lib/modules/LessonThreeCpOne");
exports.LessonThreeCpOne = LessonThreeCpOne_1.LessonThreeCpOne;
var LessonThreeCpTwo_1 = require("./lib/modules/LessonThreeCpTwo");
exports.LessonThreeCpTwo = LessonThreeCpTwo_1.LessonThreeCpTwo;
var LessonThreeCpThree_1 = require("./lib/modules/LessonThreeCpThree");
exports.LessonThreeCpThree = LessonThreeCpThree_1.LessonThreeCpThree;
var LessonThreeCpFour_1 = require("./lib/modules/LessonThreeCpFour");
exports.LessonThreeCpFour = LessonThreeCpFour_1.LessonThreeCpFour;
var LessonThreeCpFive_1 = require("./lib/modules/LessonThreeCpFive");
exports.LessonThreeCpFive = LessonThreeCpFive_1.LessonThreeCpFive;
var LessonThreeCpSix_1 = require("./lib/modules/LessonThreeCpSix");
exports.LessonThreeCpSix = LessonThreeCpSix_1.LessonThreeCpSix;
var LessonFourCpOne_1 = require("./lib/modules/LessonFourCpOne");
exports.LessonFourCpOne = LessonFourCpOne_1.LessonFourCpOne;
var LessonFourCpTwo_1 = require("./lib/modules/LessonFourCpTwo");
exports.LessonFourCpTwo = LessonFourCpTwo_1.LessonFourCpTwo;
/* PARSER */
var parser_1 = require("./lib/parser/parser");
exports.Parser = parser_1.Parser;

},{"./lib/binops/AssignOp":2,"./lib/binops/BinaryOperation":3,"./lib/binops/DeclareOp":4,"./lib/binops/Decrement":5,"./lib/binops/DivOp":6,"./lib/binops/Increment":7,"./lib/binops/MinusOp":8,"./lib/binops/MulOp":9,"./lib/binops/PlusOp":10,"./lib/conditionals/Conditional":11,"./lib/effects/CurveEffect":12,"./lib/effects/EllipseEffect":13,"./lib/effects/EphEffect":14,"./lib/effects/LineEffect":15,"./lib/effects/NumberEffect":16,"./lib/effects/RectangleEffect":17,"./lib/effects/StringEffect":18,"./lib/funhouse/FunApp":19,"./lib/funhouse/FunDef":20,"./lib/lists/ListNode":21,"./lib/logging/ClearEvent":22,"./lib/logging/DragEvent":24,"./lib/logging/IDEvent":25,"./lib/logging/LogEvent":26,"./lib/logging/PaintEvent":27,"./lib/logging/ResizeEvent":28,"./lib/logging/SelectEvent":29,"./lib/logic/And":30,"./lib/logic/Equals":31,"./lib/logic/GreaterThan":32,"./lib/logic/GreaterThanEq":33,"./lib/logic/LessThan":34,"./lib/logic/LessThanEq":35,"./lib/logic/Not":36,"./lib/logic/NotEqual":37,"./lib/logic/Or":38,"./lib/loops/ForNode":39,"./lib/loops/WhileNode":40,"./lib/modules/LessonFourCpOne":42,"./lib/modules/LessonFourCpTwo":43,"./lib/modules/LessonOneCpFour":44,"./lib/modules/LessonOneCpOne":45,"./lib/modules/LessonOneCpThree":46,"./lib/modules/LessonOneCpTwo":47,"./lib/modules/LessonThreeCpFive":48,"./lib/modules/LessonThreeCpFour":49,"./lib/modules/LessonThreeCpOne":50,"./lib/modules/LessonThreeCpSix":51,"./lib/modules/LessonThreeCpThree":52,"./lib/modules/LessonThreeCpTwo":53,"./lib/modules/LessonTwoCpFive":54,"./lib/modules/LessonTwoCpFour":55,"./lib/modules/LessonTwoCpOne":56,"./lib/modules/LessonTwoCpSeven":57,"./lib/modules/LessonTwoCpSix":58,"./lib/modules/LessonTwoCpThree":59,"./lib/modules/LessonTwoCpTwo":60,"./lib/parser/parser":61,"./lib/prims/BooleanNode":62,"./lib/prims/NOP":63,"./lib/prims/NumberNode":64,"./lib/prims/StringNode":65,"./lib/shapes/ColorNode":66,"./lib/shapes/CurveNode":67,"./lib/shapes/EllipseNode":68,"./lib/shapes/EphNode":69,"./lib/shapes/LineNode":70,"./lib/shapes/RectangleNode":71,"./lib/structural/Dimensions":72,"./lib/structural/PrintNode":73,"./lib/structural/Return":74,"./lib/structural/ReturnError":75,"./lib/structural/Scope":76,"./lib/structural/SequenceNode":77,"./lib/unops/NegOp":79,"./lib/unops/UnaryOperation":80,"./lib/vars/VariableNode":81}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const VariableNode_1 = require("../vars/VariableNode");
// left side is variable, right side is val
// Reassign new value to var
class AssignOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for an assignment operation
     * @param left The left side of the assignment (the var)
     * @param right The right side of the assignment (the value)
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        if (!(left instanceof VariableNode_1.VariableNode)) {
            throw new Error("The left hand side of the assignment must be a variable.");
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates assign op by assigning value to var
     * @param context The current context
     */
    eval(context) {
        if (this.left instanceof VariableNode_1.VariableNode) {
            let r = this.right.eval(context);
            context.assign(this.left.name, r);
            return r;
        }
        throw new Error("HALP (in AssignOp)");
    }
    /**
     * Returns a string representation of the AssignOp
     */
    toString() {
        return this._ws + this.left.toString() + ' = ' + this.right.toString();
    }
    /**
     * AssignOps can't be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on AssignOp
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.AssignOp = AssignOp;

},{"../vars/VariableNode":81,"./BinaryOperation":3}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BinaryOperation {
    /**
     * Constructor for the BinOp abstract class
     * @param _left The left side of the binary operation
     * @param _right The right side of the binary operation
     */
    constructor(_left, _right) {
        this._left = _left;
        this._right = _right;
        this._newLine = false;
    }
    ;
    /**
     * Draws the binary operation, if applicable
     * @param context The current program context
     * @param dims The dimensions
     * @param ast The AST
     */
    draw(context, dims, ast) { }
    /**
     * Checks if equal to another expression
     * @param right The right side of the equality
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on BinOp");
    }
    /**
     * Returns a string representation of the binary operation
     */
    toString() { return ""; }
    ;
    /**
     * Gets left side of the binary operation
     */
    get left() {
        return this._left;
    }
    /**
     * Sets left side of the binary operation
     */
    set left(left) {
        this._left = left;
    }
    /**
     * Gets right side of the binary operation
     */
    get right() {
        return this._right;
    }
    /**
     * Sets right side of the binary operation
     */
    set right(right) {
        this._right = right;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.BinaryOperation = BinaryOperation;

},{}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const VariableNode_1 = require("../vars/VariableNode");
// left side is variable, right side is val
// Declares new val
class DeclareOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the declare operation, which declares a variable for the first time
     * @param left The left side of the declare op (the variable)
     * @param right The right side of the op (the value)
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        if (!(left instanceof VariableNode_1.VariableNode)) {
            throw new Error("The left hand side of the assignment must be a variable.");
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the declaration by declaring the variable in the context and assigning the value
     * @param context The current program context
     */
    eval(context) {
        if (this.left instanceof VariableNode_1.VariableNode) {
            context.declare(this.left.name);
            let r = this.right.eval(context);
            context.assign(this.left.name, r);
            return r;
        }
        throw new Error("HALP (in DeclareOp)");
    }
    /**
     * Returns a string representation of the declare op
     */
    toString() {
        return this._ws + "var " + this.left.toString() + ' = ' + this.right.toString();
    }
    /**
     * DeclareOps cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called direcly on a DeclareOp
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.DeclareOp = DeclareOp;

},{"../vars/VariableNode":81,"./BinaryOperation":3}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const MinusOp_1 = require("./MinusOp");
const AssignOp_1 = require("./AssignOp");
const VariableNode_1 = require("../vars/VariableNode");
class Decrement {
    /**
     * Constructor for the decrement operation
     * @param variable The expression to be decremented
     * @param ws Preceding whitespace
     */
    constructor(variable, ws) {
        this.expr = variable;
        if (variable instanceof VariableNode_1.VariableNode) {
            this.innerRep = new AssignOp_1.AssignOp(variable, new MinusOp_1.MinusOp(variable, new NumberNode_1.NumberNode(1)));
        }
        else {
            this.innerRep = new MinusOp_1.MinusOp(variable, new NumberNode_1.NumberNode(1));
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the decrement op to a NumberNode
     * @param context The current program context
     */
    eval(context) {
        return this.innerRep.eval(context);
    }
    /**
     * Returns a string representation of the decrement op
     */
    toString() {
        return this._ws + this.expr.toString() + "--";
    }
    /**
     * Decrement ops can't be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on decrement
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.Decrement = Decrement;

},{"../prims/NumberNode":64,"../vars/VariableNode":81,"./AssignOp":2,"./MinusOp":8}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
class DivOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the division operation
     * @param left The dividend
     * @param right The divisor
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the division and evaluates into a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val / this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Division ops can't be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on a division op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the division
     */
    toString() {
        return this._ws + this.left.toString() + ' / ' + this.right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.DivOp = DivOp;

},{"../prims/NumberNode":64,"../structural/Scope":76,"./BinaryOperation":3}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PlusOp_1 = require("./PlusOp");
const AssignOp_1 = require("./AssignOp");
const VariableNode_1 = require("../vars/VariableNode");
class Increment {
    /**
     * Constructor for Increment
     * @param variable The expression to increment
     * @param ws Tracks preceding whitespace
     */
    constructor(variable, ws) {
        this.expr = variable;
        if (variable instanceof VariableNode_1.VariableNode) {
            this.innerRep = new AssignOp_1.AssignOp(variable, new PlusOp_1.PlusOp(variable, new NumberNode_1.NumberNode(1)));
        }
        else {
            this.innerRep = new PlusOp_1.PlusOp(variable, new NumberNode_1.NumberNode(1, ""));
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates increment into a number node
     * @param context The function scope
     */
    eval(context) {
        return this.innerRep.eval(context);
    }
    /**
     * Increments cannot be drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Cannot call equals directly on binops
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the increment expression
     */
    toString() {
        return this._ws + this.expr.toString() + "++";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.Increment = Increment;

},{"../prims/NumberNode":64,"../vars/VariableNode":81,"./AssignOp":2,"./PlusOp":10}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
class MinusOp extends BinaryOperation_1.BinaryOperation {
    /**
     * The constructor for the subtraction operation
     * @param left The minuend
     * @param right The subrahend
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the subtraction and evaluates to a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val - this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Subtraction ops can't be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on subtraction
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the subtraction op
     */
    toString() {
        return this._ws + this.left.toString() + ' - ' + this.right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.MinusOp = MinusOp;

},{"../prims/NumberNode":64,"../structural/Scope":76,"./BinaryOperation":3}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
class MulOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the multiplication operation
     * @param left The multiplicand
     * @param right The multiplier
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the multiplication and returns a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val * this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Returns a string representation of the multiplication op
     */
    toString() {
        return this._ws + this.left.toString() + ' * ' + this.right.toString();
    }
    /**
     * Multiplication ops cannot be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a multiplicaiton operation
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.MulOp = MulOp;

},{"../prims/NumberNode":64,"../structural/Scope":76,"./BinaryOperation":3}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
// left and right are both expressions
class PlusOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the addition operation
     * @param left The first addend
     * @param right The second addend
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the addition and returns a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val + this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Addition ops cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on an addition op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the addition op
     */
    toString() {
        return this._ws + this.left.toString() + ' + ' + this.right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.PlusOp = PlusOp;

},{"../prims/NumberNode":64,"../structural/Scope":76,"./BinaryOperation":3}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const BooleanNode_1 = require("../prims/BooleanNode");
const space_lift_1 = require("space-lift");
class Conditional {
    /**
     * The constructor for conditionals (if, else if, and else statements)
     * @param test The condition of the statement
     * @param trueBranch The branch to follow if the condition evaluates to true
     * @param falseBranch The branch to follow if the condition evaluates to false
     */
    constructor(test, trueBranch, falseBranch) {
        this._newLine = true;
        this._test = test;
        this._trueBranch = trueBranch;
        this._falseBranch = falseBranch;
    }
    /**
     * Checks the test result and returns the result of the true or false branch, depending on the test
     * @param context The current program context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        let res = this._test.eval(childCtx);
        if (!(res instanceof BooleanNode_1.BooleanNode)) {
            throw new Error("The condition must be a boolean expression.");
        }
        if (res.val) {
            return this._trueBranch.eval(childCtx);
        }
        else if (this._falseBranch != null) { // check if else/else if is null or undefined
            return this._falseBranch.eval(childCtx); // possibly a bad idea
        }
    }
    /**
     * Returns a string representation of the conditional statement
     */
    toString() {
        let res = 'if(' + this._test.toString() + ") {\n " + this._trueBranch.toString() + "}";
        if (this._falseBranch !== undefined) {
            res += '\nelse {\n ' + this._falseBranch.toString() + '}';
        }
        return res;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the true branch of the conditional
     */
    get trueBranch() {
        return this._trueBranch;
    }
    /**
     * Returns the false branch of the conditional
     */
    get falseBranch() {
        return this._falseBranch;
    }
    /**
     * Conditionals cannot be drawn directly
     */
    draw() {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a conditional
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on conditionals");
    }
}
exports.Conditional = Conditional;

},{"../prims/BooleanNode":62,"../structural/Scope":76,"space-lift":90}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class CurveEffect {
    constructor(curve) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._curve = curve;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        let curvature = this.curvature;
        this._ctx.beginPath();
        this._ctx.moveTo(x, y);
        let v = this.perpendicularVector(width, height);
        this._ctx.quadraticCurveTo((x + width / 2) + curvature * v[0], (y + height / 2) + curvature * v[1], x + width, y + height);
        this._ctx.strokeStyle = "#673AB7";
        this._ctx.stroke();
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    //a * w + b * h = 0
    perpendicularVector(w, h) {
        if (w == 0 && h == 0) {
            return [0, 0];
        }
        else if (w == 0) {
            return [1, 0];
        }
        else if (h == 0) {
            return [0, 1];
        }
        return [1, (-w) / h];
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) { // a corner guide is selected
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) { // a middle guide is selected
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else { //if no guides are selected, colors everything white
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._curve.dx = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._curve.dy = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._curve.dy = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._curve.dx = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._curve.dx = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._curve.dy = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._curve.dx = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._curve.dy = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.h > 10) { //as long as the height is > 10
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10) { // as long as width is > 10
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) { // sets the offsets depending on which corner is selected
                case 1: // top left
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w; // offset is bottom right
                    this._dragoffy = y + h;
                    break;
                case 2: // top right
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h; // offset is bottom left, etc
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) { // sets the offsets depending on which middle guide is selected
                case 5: // top middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2; // offset is bottom middle
                    this._dragoffy = y + h;
                    break;
                case 6: //right middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2; // offset is left middle etc
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) { // dragging
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) { // not selected
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isChangingDims = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a rectangle paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("rectangle", this.x, this.y);
    }
    /**
     * Logs a rectangle resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("rectangle with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs a rectangle click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("rectangle with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the rect
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the rect
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the rect
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the rect
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the curvature of the curve
     */
    get curvature() {
        return this._dims.curvature.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the rect is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the rect
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the rect has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the rect has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the rect is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " rectangle with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("rectangle with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to rectangle at " + this.x + ", " + this.y);
    }
}
exports.CurveEffect = CurveEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":64}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const NumberNode_1 = require("../prims/NumberNode");
const ClickEvent_1 = require("../logging/ClickEvent");
class EllipseEffect {
    constructor(circle) {
        this._corner = 0;
        this._isSelected = false; // Private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false; // Has this object just been dragged?
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._circle = circle;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        // logging
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        this._ctx.beginPath();
        this._ctx.ellipse(x, y, w / 2, h / 2, 0, 0, Math.PI * 2, false);
        //this._ctx.strokeStyle = "black";
        //this._ctx.stroke();
        this._ctx.fillStyle = "#D5B8FF";
        this._ctx.shadowColor = "#6C6C6C";
        this._ctx.shadowBlur = 15;
        //this._ctx.shadowOffsetX = 2;
        //this._ctx.shadowOffsetY = 2;
        this._ctx.fill();
        if (this._isSelected) {
            this.drawGuides(x - w / 2, y - h / 2, w, h, this._corner);
        }
    }
    /*
        private mouseMove = this.onMouseMove.bind(this);
        private mouseDown = this.onMouseDown.bind(this);
        private mouseUp = this.onMouseUp.bind(this);
        private shiftDown = this.onShiftDown.bind(this);
        private shiftUp = this.onShiftUp.bind(this);
        private mouseOutside = this.isMouseOutside.bind(this);
        private selectStart = function(e:any) { e.preventDefault(); return false; };
    */
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    removeEventListeners() {
        /*
        console.log("removing EventListners");
          this._canvas.removeEventListener('mousemove', this.mouseMove); // bind in order to maintain the meaning of 'this'
          this._canvas.removeEventListener('mousedown', this.mouseDown);
          this._canvas.removeEventListener('mouseup', this.mouseUp);
          window.removeEventListener('keydown', this.shiftDown);
          window.removeEventListener('keyup', this.shiftUp);
          window.removeEventListener('mousedown', this.mouseOutside);
          //makes it so that double clicking doesn't select text on the page
          this._canvas.removeEventListener('selectstart', this.selectStart, false);
          */
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        return Math.pow(mx - x, 2) / Math.pow(w / 2, 2) + Math.pow(my - y, 2) / Math.pow(h / 2, 2) <= 1;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - (x - w / 2);
        let ydif = my - (y - h / 2);
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - (x - w / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - x;
        ydif = my - (y - h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - (x - w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) {
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0 && corner > 4) {
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else {
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 14, this.h < 14);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 14, this.h < 14);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        //console.log("I'm an ellipse!");
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //console.log("ellipse dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 14 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     * @param widthTooSmall true if the width dimension is < 14
     * @param heightTooSmall true if the height dimension is < 14
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 14;
            this._circle.width = new NumberNode_1.NumberNode(14); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 14 / this._ratio;
            this._circle.height = new NumberNode_1.NumberNode(Math.round(14 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._initDistance = newDistance;
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 14;
            this._circle.height = new NumberNode_1.NumberNode(14); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 14 * this._ratio;
            this._circle.width = new NumberNode_1.NumberNode(Math.round(14 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._initDistance = newDistance;
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
            this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
            this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
            this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
            this._initDistance = newDistance;
        }
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (this._corner == 5 || this._corner == 7) { // if modifying height
            if (!heightTooSmall) {
                this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._initDistance = newDistance;
                this._ratio = this.w / this.h; // setting width/height ratio = to the new ratio
            }
            else {
                this._dims.height.eval(this._context).val = 14;
                this._circle.height = new NumberNode_1.NumberNode(14);
                this._ratio = this.w / this.h;
                if (newDistance - this._initDistance > 0) {
                    this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                    this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                    this._initDistance = newDistance;
                    this._ratio = this.w / this.h;
                }
            }
        }
        else { // modifying width
            if (!widthTooSmall) {
                this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._initDistance = newDistance;
                this._ratio = this.w / this.h;
            }
            else {
                this._dims.width.eval(this._context).val = 14;
                this._circle.width = new NumberNode_1.NumberNode(14);
                this._ratio = this.w / this.h;
                if (newDistance - this._initDistance > 0) {
                    this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                    this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                    this._initDistance = newDistance;
                    this._ratio = this.w / this.h;
                }
            }
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
            else {
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = guideContains;
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
            this._width1 = this.w;
            this._height1 = this.h;
            //this._size1 = Math.sqrt(Math.pow(this.w,2) + Math.pow(this.h,2)); // saving old size
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
        }
        else if (contains) { //simply selecting the shape or dragging
            this._x1 = this.x; // Saving original x and y
            this._y1 = this.y;
            this._isSelected = true;
            this._isDragging = true;
            this._context.eventLog.push(this.logClick());
            this._dragoffx = this._mouse.x - this.x;
            this._dragoffy = this._mouse.y - this.y;
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) { // probs only need dragging but oh well | isSel || selMul?
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
                //this._context.eventLog.push(this.logMove());
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            //console.log("resizing ellipse");
            this._isResizing = false;
            //let size2 = Math.sqrt(Math.pow(this.w,2) + Math.pow(this.h,2));
            //console.log("Size diff: " + Math.abs(this._size1 - size2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        // if(this._isSelectingMultiple){
        //     if(Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
        //         this._context.eventLog.push(this.logMove());
        //     }
        // }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("ellipse", this.x, this.y);
    }
    /**
     * Logs a resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("ellipse with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
        //Math.round(this._size1*100)/100, Math.round((Math.sqrt(Math.pow(this.w,2) + Math.pow(this.h,2))*100))/100);
    }
    /**
     * Logs a click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("ellipse with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the ellipse
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the ellipse
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the ellipse
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the ellipse
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the ellipse is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the ellipse
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the ellipse has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the ellipse has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the ellipse is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return (" ellipse with ID " + this.getID().toString() + " at " + this.x + ", " + this.y);
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("ellipse with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to ellipse at " + this.x + ", " + this.y);
    }
}
exports.EllipseEffect = EllipseEffect;
/**
 * Get's the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":64}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class EphEffect {
    constructor(eph) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._eph = eph;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ephImg = new Image();
            this._ephImg.src = './pics/demoncow.png';
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        //var imgObj = new Image();
        //let ctx = this._canvas.getContext('2d');
        // this._ephImg = new Image();
        // this._ephImg.src = './pics/demoncow.png';
        //imgObj.onload = function(){
        //this._ephImg.onload = function(){
        this._ctx.drawImage(this._ephImg, this.x, this.y, width, height);
        //this._ephImg.onload = function(){
        // this._ephImg.width = width;
        // this._ephImg.height = height;
        //}
        //}
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) {
            switch (corner) { //colors the coreph guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) {
            switch (corner) { //colors the coreph guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else {
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * @param event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //console.log("ephangle dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._eph.width = new NumberNode_1.NumberNode(10);
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._eph.height = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._eph.height = new NumberNode_1.NumberNode(10);
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._eph.width = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._eph.width = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._eph.height = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._eph.width = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._eph.height = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.w > 10 && this.h > 10) {
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._eph.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._eph.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._eph.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10 && this.h > 10) {
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._eph.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) {
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) {
                case 1:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h;
                    break;
                case 2:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h;
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
            //this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h / 2);
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) {
                case 5:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y + h;
                    break;
                case 6:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2;
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) {
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let eph = this._canvas.getBoundingClientRect();
        if (mouseX < eph.left || mouseX > eph.right || mouseY < eph.top || mouseY > eph.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs an eph paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("eph", this.x, this.y);
    }
    /**
     * Logs an eph resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("eph with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs an eph click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("eph with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Not implemented");
    }
    updateAST() {
        throw new Error("Not implemented");
    }
    /**
     * Returns the x position of the eph
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the eph
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the eph
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the eph
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the eph is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the image
     */
    get image() {
        return this._ephImg;
    }
    /**
     * Returns the ID of the eph
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the eph has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the eph has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the eph is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " eph with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("eph with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to eph at " + this.x + ", " + this.y);
    }
}
exports.EphEffect = EphEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let eph = canvas.getBoundingClientRect();
    return {
        x: event.clientX - eph.left,
        y: event.clientY - eph.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":64}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class LineEffect {
    constructor(line) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._line = line;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        this._ctx.moveTo(x, y);
        this._ctx.lineTo(x + width, y + height);
        this._ctx.strokeStyle = "#673AB7";
        this._ctx.stroke();
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) { // a corner guide is selected
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) { // a middle guide is selected
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else { //if no guides are selected, colors everything white
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._line.dx = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._line.dy = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._line.dy = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._line.dx = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._line.dx = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._line.dy = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._line.dx = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._line.dy = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.h > 10) { //as long as the height is > 10
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._line.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._line.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._line.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10) { // as long as width is > 10
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._line.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) { // sets the offsets depending on which corner is selected
                case 1: // top left
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w; // offset is bottom right
                    this._dragoffy = y + h;
                    break;
                case 2: // top right
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h; // offset is bottom left, etc
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) { // sets the offsets depending on which middle guide is selected
                case 5: // top middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2; // offset is bottom middle
                    this._dragoffy = y + h;
                    break;
                case 6: //right middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2; // offset is left middle etc
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) { // dragging
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) { // not selected
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isChangingDims = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a rectangle paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("rectangle", this.x, this.y);
    }
    /**
     * Logs a rectangle resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("rectangle with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs a rectangle click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("rectangle with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the rect
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the rect
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the rect
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the rect
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the rect is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the rect
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the rect has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the rect has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the rect is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " rectangle with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("rectangle with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to rectangle at " + this.x + ", " + this.y);
    }
}
exports.LineEffect = LineEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":64}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class NumberEffect {
    constructor(num) {
        this._fontSize = 20;
        this._corner = 0;
        this._isEditing = false;
        this._isListening = false;
        this._isDragging = false;
        this._isResizing = false;
        this._isSelectingMultiple = false;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._numberMetrics = {
            width: 0,
            height: 0,
            interval: 0,
            str: "",
            initMousePos: 0,
            cursorPos: 0
        };
        this._num = num;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas != undefined) {
            this._context = context;
            this._canvas = context.canvas.get();
            this._dims = dims;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this.update();
            // logging
            this._context.eventLog.push(this.logPaint()); // this.context or context?
            context.effects.push(this);
            this.addEventListeners();
        }
        else {
            console.log("canvas is NOT defined");
        }
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let fontDeets = this._fontSize + "px Courier New";
        this._ctx.font = fontDeets;
        this._ctx.fillStyle = "#673AB7";
        let str = this._num.toString();
        this._ctx.fillText(str, this.x, this.y);
        let numberDims = this._ctx.measureText(str);
        this._numberMetrics.width = numberDims.width;
        this._numberMetrics.height = this._fontSize;
        this._numberMetrics.str = str;
        this._numberMetrics.interval = this._numberMetrics.width / this._numberMetrics.str.length;
        if (this._isSelected) {
            this.drawTextGuides(this.x, this.y - this._fontSize, this._numberMetrics.width, this._numberMetrics.height, this._corner);
        }
        if (this._isEditing) {
            this.modifyTextCursor();
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        return (this.x <= mx) && (this.x + this._numberMetrics.width >= mx) &&
            (this.y - this._fontSize <= my) && (this.y >= my);
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let xdif = mx - (this.x + this._numberMetrics.width);
        let ydif = my - (this.y - this._fontSize);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) {
            this._isEditing = false;
            return 2;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawTextGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0) {
            switch (corner) { //colors the guide blue if selected
                case 2:
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue');
                    break;
            }
        }
        else {
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white');
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /* Event listener functions */
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isSelected && this._isDragging) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this._fontSize < 15);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        if (!this._isSelectingMultiple && this._isSelected && this.contains(this._mouse.x, this._mouse.y)) { //text editing
            if (!this._isListening) {
                window.addEventListener('keydown', this.modifyText.bind(this));
            }
            this._isListening = true;
            this._isEditing = true;
            this._isDragging = false;
            this._numberMetrics.initMousePos = this._mouse.x;
            this.modifyTextCursor();
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isEditing = false;
        }
        else {
            this._isEditing = false;
        }
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y) > 0, this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //("string dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Creates and moves the text edit cursor based on where the mouse is clicked
     */
    modifyTextCursor() {
        let leftWall = this.x; // the x position of the left most side of the bounding rectangle
        let xDif = this._numberMetrics.initMousePos - leftWall; // difference between mouse x and left wall
        let interval = this._numberMetrics.interval; // the text width divided by the length of the string
        let moveFactor = 0;
        if (xDif >= interval / 2 && xDif <= interval) {
            moveFactor = leftWall + interval;
            this._numberMetrics.cursorPos = interval;
        }
        else if (xDif <= interval / 2) {
            moveFactor = leftWall;
            this._numberMetrics.cursorPos = 0;
        }
        else if (xDif % interval >= interval / 2) {
            moveFactor = leftWall + interval * Math.ceil(xDif / interval);
            this._numberMetrics.cursorPos = interval * Math.ceil(xDif / interval);
        }
        else if (xDif % interval < interval / 2) {
            moveFactor = leftWall + interval * Math.floor(xDif / interval);
            this._numberMetrics.cursorPos = interval * Math.floor(xDif / interval);
        }
        this._ctx.moveTo(moveFactor, this.y - this._fontSize);
        this._ctx.lineTo(moveFactor, this.y);
        this._ctx.strokeStyle = "grey";
        this._ctx.stroke();
    }
    /**
     * This edits the string when editing text
     * @param event keydown event
     */
    modifyText(event) {
        if (this._isEditing) {
            let firstHalf;
            let secondHalf;
            let str = this._num.toString();
            let breakPoint = this._numberMetrics.cursorPos / this._numberMetrics.interval;
            firstHalf = str.substring(0, breakPoint);
            secondHalf = str.substring(breakPoint);
            if (event.keyCode == 37 && this._numberMetrics.initMousePos > this.x + this._numberMetrics.interval / 2) {
                this._numberMetrics.initMousePos -= this._numberMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 39 && this._numberMetrics.initMousePos < this.x + this._numberMetrics.width) {
                this._numberMetrics.initMousePos += this._numberMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 8 && str.length > 0) {
                firstHalf = firstHalf.substring(0, firstHalf.length - 1);
                str = firstHalf + secondHalf;
                this._num.val = Number(str);
                this._numberMetrics.initMousePos -= this._numberMetrics.interval;
                this.modifyTextCursor();
            }
            else {
                let keyName = event.key;
                if (keyName.length == 1) {
                    firstHalf += keyName;
                    str = firstHalf + secondHalf;
                    this._num.val = Number(str);
                    this._numberMetrics.initMousePos += this._numberMetrics.interval;
                    this.modifyTextCursor();
                }
            }
        }
    }
    /**
     * Modifies the font size of the text
     * If the text font is smaller than 15pt, it set's it equal to 15pt
     * @param isTooSmall true if the font size is < 15
     */
    modifyResize(isTooSmall) {
        if (isTooSmall) {
            this._fontSize = 15;
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._fontSize += (newDistance - this._initDistance) * 0.2;
                this._initDistance = newDistance;
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this._fontSize += (newDistance - this._initDistance) * 0.2;
            this._initDistance = newDistance;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x = this.x;
                this._y = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
            else {
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
                this._isDragging = true;
            }
            // if(this._context.mulSelected.mulSel){
            //     console.log("string effect mulSelected: " + this._context.mulSelected.mulSel);
            //     //if(this._context.mulSelected.val){
            //     this._context.eventLog.push(this.logSelected());
            //     //this.logSelected();
            // }
        }
        else if (guideContains) { //if the corner guides contain the mouse we are resizing
            this._isSelected = true;
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._context.eventLog.push(this.logClick());
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
            this._isResizing = true;
            this._size1 = this._fontSize; // saving old font size
        }
        else if (contains) {
            this._x = this.x; // Saving original x and y
            this._y = this.y;
            this._isSelected = true;
            this._context.eventLog.push(this.logClick());
            this._dragoffx = this._mouse.x - this.x;
            this._dragoffy = this._mouse.y - this.y;
            if (!this._isEditing) {
                this._isDragging = true;
            }
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
            this._isEditing = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x - this.x) > 1 || Math.abs(this._y - this.y) > 1) {
                this._justDragged = true;
                //this._context.eventLog.push(this.logMove());
            }
        }
        else if (this._isResizing && this._isSelected) {
            this._isResizing = false;
            if (Math.abs(this._size1 - this._fontSize) > 0) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._corner = 0;
        // console.log("string effect mulSelected: " + this._context.mulSelected.val);
        // if(this._context.mulSelected.val){
        //     this.logSelected();
        // }
        // if(this.isMultipleSelected){
        //     context.eventLog.push(new SelectEvent(selectedElems));
        //     masterLog.push(context.eventLog[context.eventLog.length - 1]);
        //     //console.log("multiple selected");
        // }
        // //this._context.eventLog.push(this.logMove());
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._isEditing = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent(this._num.toString(), this.x, this.y);
    }
    /**
     * Logs a resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent(this._num.toString() + " with ID " + this.getID().toString(), Math.round(this._size1 * 100) / 100, Math.round(this._fontSize * 100) / 100);
    }
    /**
     * Logs a click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent(this._num.toString() + " with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id, };
    }
    /**
     * Returns the canvas
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Sets the canvas
     * @param canvas The canvas to be assigned
     */
    set canvas(canvas) {
        this._canvas = canvas;
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the number
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the number
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
    * Returns whether or not the ellipse has just been dragged
    */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the ellipse has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the ellipse is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Returns whether or not this is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the number
     */
    get num() {
        return this._num.val;
    }
    /**
     * Returns the object ID
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " " + this._num.toString() + " with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return (this._num.toString() + " with ID " + this.getID().toString() + " from " + this._x + ", " + this._y + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to " + this._num.toString() + " at " + this.x + ", " + this.y);
    }
}
exports.NumberEffect = NumberEffect;
/**
 * Get's the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class RectangleEffect {
    constructor(rect) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._rect = rect;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        this._ctx.rect(x, y, width, height);
        //this._ctx.strokeStyle = "black";
        //this._ctx.stroke();
        this._ctx.fillStyle = "#d5b8ff";
        this._ctx.shadowColor = "#6C6C6C";
        this._ctx.shadowBlur = 15;
        //this._ctx.shadowOffsetX = 2;
        //this._ctx.shadowOffsetY = 2;
        this._ctx.fill();
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) { // a corner guide is selected
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) { // a middle guide is selected
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else { //if no guides are selected, colors everything white
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._rect.width = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._rect.height = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._rect.height = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._rect.width = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._rect.width = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._rect.height = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._rect.width = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._rect.height = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.h > 10) { //as long as the height is > 10
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._rect.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._rect.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._rect.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10) { // as long as width is > 10
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._rect.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) { // sets the offsets depending on which corner is selected
                case 1: // top left
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w; // offset is bottom right
                    this._dragoffy = y + h;
                    break;
                case 2: // top right
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h; // offset is bottom left, etc
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) { // sets the offsets depending on which middle guide is selected
                case 5: // top middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2; // offset is bottom middle
                    this._dragoffy = y + h;
                    break;
                case 6: //right middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2; // offset is left middle etc
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) { // dragging
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) { // not selected
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isChangingDims = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a rectangle paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("rectangle", this.x, this.y);
    }
    /**
     * Logs a rectangle resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("rectangle with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs a rectangle click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("rectangle with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the rect
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the rect
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the rect
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the rect
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the rect is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the rect
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the rect has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the rect has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the rect is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " rectangle with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("rectangle with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to rectangle at " + this.x + ", " + this.y);
    }
}
exports.RectangleEffect = RectangleEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":64}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class StringEffect {
    constructor(str) {
        this._fontSize = 20;
        //private _size2: number;
        this._corner = 0;
        this._isSelected = false; // Private bools
        this._isEditing = false;
        this._isListening = false;
        this._isDragging = false;
        this._isResizing = false;
        this._isSelectingMultiple = false;
        this._justDragged = false; // Has this object just been dragged?
        //private _log: string[];
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._textMetrics = {
            width: 0,
            height: 0,
            interval: 0,
            str: "",
            initMousePos: 0,
            cursorPos: 0
        };
        this._str = str;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas != undefined) {
            this._context = context;
            this._canvas = context.canvas.get();
            this._dims = dims;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this.update();
            // logging
            this._context.eventLog.push(this.logPaint()); // this.context or context?
            context.effects.push(this);
            this.addEventListeners();
        }
        else {
            console.log("canvas is NOT defined");
        }
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let fontDeets = this._fontSize + "px Courier New";
        this._ctx.font = fontDeets;
        this._ctx.fillStyle = "#673AB7";
        this._ctx.fillText(this._str.val, this.x, this.y);
        let textDims = this._ctx.measureText(this._str.val);
        this._textMetrics.width = textDims.width;
        this._textMetrics.height = this._fontSize;
        this._textMetrics.str = this._str.val;
        this._textMetrics.interval = this._textMetrics.width / this._textMetrics.str.length;
        if (this._isSelected) {
            this.drawTextGuides(this.x, this.y - this._fontSize, this._textMetrics.width, this._textMetrics.height, this._corner);
        }
        if (this._isEditing) {
            this.modifyTextCursor();
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        return (this.x <= mx) && (this.x + this._textMetrics.width >= mx) &&
            (this.y - this._fontSize <= my) && (this.y >= my);
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let xdif = mx - (this.x + this._textMetrics.width);
        let ydif = my - (this.y - this._fontSize);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) {
            this._isEditing = false;
            return 2;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawTextGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0) {
            switch (corner) { //colors the guide blue if selected
                case 2:
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue');
                    break;
            }
        }
        else {
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white');
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /* Event listener functions */
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isSelected && this._isDragging) {
            //console.log(this._str.val + " is being dragged.");
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this._fontSize < 15);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        if (!this._isSelectingMultiple && this._isSelected && this.contains(this._mouse.x, this._mouse.y)) { //text editing
            if (!this._isListening) {
                window.addEventListener('keydown', this.modifyText.bind(this));
            }
            this._isListening = true;
            this._isEditing = true;
            this._isDragging = false;
            //console.log(this._str.val + " is setting dragging to false");
            this._textMetrics.initMousePos = this._mouse.x;
            this.modifyTextCursor();
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isEditing = false;
        }
        else {
            this._isEditing = false;
        }
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y) > 0, this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //("string dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Creates and moves the text edit cursor based on where the mouse is clicked
     */
    modifyTextCursor() {
        let leftWall = this.x; // the x position of the left most side of the bounding rectangle
        let xDif = this._textMetrics.initMousePos - leftWall; // difference between mouse x and left wall
        let interval = this._textMetrics.interval; // the text width divided by the length of the string
        let moveFactor = 0;
        if (xDif >= interval / 2 && xDif <= interval) {
            moveFactor = leftWall + interval;
            this._textMetrics.cursorPos = interval;
        }
        else if (xDif <= interval / 2) {
            moveFactor = leftWall;
            this._textMetrics.cursorPos = 0;
        }
        else if (xDif % interval >= interval / 2) {
            moveFactor = leftWall + interval * Math.ceil(xDif / interval);
            this._textMetrics.cursorPos = interval * Math.ceil(xDif / interval);
        }
        else if (xDif % interval < interval / 2) {
            moveFactor = leftWall + interval * Math.floor(xDif / interval);
            this._textMetrics.cursorPos = interval * Math.floor(xDif / interval);
        }
        this._ctx.moveTo(moveFactor, this.y - this._fontSize);
        this._ctx.lineTo(moveFactor, this.y);
        this._ctx.strokeStyle = "grey";
        this._ctx.stroke();
    }
    /**
     * This edits the string when editing text
     * @param event keydown event
     */
    modifyText(event) {
        if (this._isEditing) {
            let firstHalf;
            let secondHalf;
            let breakPoint = this._textMetrics.cursorPos / this._textMetrics.interval;
            firstHalf = this._str.val.substring(0, breakPoint);
            secondHalf = this._str.val.substring(breakPoint);
            if (event.keyCode == 37 && this._textMetrics.initMousePos > this.x + this._textMetrics.interval / 2) {
                this._textMetrics.initMousePos -= this._textMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 39 && this._textMetrics.initMousePos < this.x + this._textMetrics.width) {
                this._textMetrics.initMousePos += this._textMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 8 && this._str.val.length > 0) {
                firstHalf = firstHalf.substring(0, firstHalf.length - 1);
                this._str.str = firstHalf + secondHalf;
                this._textMetrics.initMousePos -= this._textMetrics.interval;
                this.modifyTextCursor();
            }
            else {
                let keyName = event.key;
                if (keyName.length == 1) {
                    firstHalf += keyName;
                    this._str.str = firstHalf + secondHalf;
                    this._textMetrics.initMousePos += this._textMetrics.interval;
                    this.modifyTextCursor();
                }
            }
        }
    }
    /**
     * Modifies the font size of the text
     * If the text font is smaller than 15pt, it set's it equal to 15pt
     * @param isTooSmall true if the font size is < 15
     */
    modifyResize(isTooSmall) {
        if (isTooSmall) {
            this._fontSize = 15;
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._fontSize += (newDistance - this._initDistance) * 0.2;
                this._initDistance = newDistance;
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this._fontSize += (newDistance - this._initDistance) * 0.2;
            this._initDistance = newDistance;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
            else {
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
                this._isDragging = true;
            }
            // if(this._context.mulSelected.mulSel){
            //     console.log("string effect mulSelected: " + this._context.mulSelected.mulSel);
            //     //if(this._context.mulSelected.val){
            //     this._context.eventLog.push(this.logSelected());
            //     //this.logSelected();
            // }
        }
        else if (guideContains) { //if the corner guides contain the mouse we are resizing
            this._isSelected = true;
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._context.eventLog.push(this.logClick());
            //console.log(this._str.val + "is selected?" + this._selected);
            //console.log("state selection is " + this._str.val);
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
            this._isResizing = true;
            this._size1 = this._fontSize; // saving old font size
        }
        else if (contains) {
            this._x1 = this.x; // Saving original x and y
            this._y1 = this.y;
            this._isSelected = true;
            this._context.eventLog.push(this.logClick());
            //console.log(this._str.val + "is selected?" + this._selected);
            //console.log("state selection is " + this._str.val);
            this._dragoffx = this._mouse.x - this.x;
            this._dragoffy = this._mouse.y - this.y;
            if (!this._isEditing) {
                this._isDragging = true;
                //console.log(this._str.val + " is dragging? " + this._isDragging);
            }
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
            this._isEditing = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            //console.log(this._str.val + " logging drag");
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
                //this._context.eventLog.push(this.logMove());
            }
        }
        else if (this._isResizing && this._isSelected) {
            //console.log(this._str.val + " logging resize");
            this._isResizing = false;
            if (Math.abs(this._size1 - this._fontSize) > 0) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._corner = 0;
        // console.log("string effect mulSelected: " + this._context.mulSelected.val);
        // if(this._context.mulSelected.val){
        //     this.logSelected();
        // }
        // if(this.isMultipleSelected){
        //     context.eventLog.push(new SelectEvent(selectedElems));
        //     masterLog.push(context.eventLog[context.eventLog.length - 1]);
        //     //console.log("multiple selected");
        // }
        // //this._context.eventLog.push(this.logMove());
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._isEditing = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent(this._str.val, this.x, this.y);
    }
    /**
     * Logs a resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent(this._str.val + " with ID " + this.getID().toString(), Math.round(this._size1 * 100) / 100, Math.round(this._fontSize * 100) / 100);
    }
    /**
     * Logs a click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent(this._str.val + " with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id, };
    }
    /**
     * Returns the canvas
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Sets the canvas
     * @param canvas The canvas to be assigned
     */
    set canvas(canvas) {
        this._canvas = canvas;
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the ellipse
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the ellipse
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
    * Returns whether or not the ellipse has just been dragged
    */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the ellipse has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the ellipse is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Returns whether or not this is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the string
     */
    get str() {
        return this._str.val;
    }
    /**
     * Returns the object ID
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " " + this._str.val + " with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return (this._str.val + " with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to " + this._str.val + " at " + this.x + ", " + this.y);
    }
}
exports.StringEffect = StringEffect;
/**
 * Get's the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ReturnError_1 = require("../structural/ReturnError");
const space_lift_1 = require("space-lift");
// Application of a function. Assumes arg values passed in same order as FunDef args
class FunApp {
    /**
     * The constructor for a function application
     * @param name The name of the function
     * @param args Function arguments, if applicable
     * @param ws Preceding whitespace
     * @param defaultValue The default return value of the function, if any
     */
    constructor(name, args, ws, defaultValue) {
        this._defaultValue = undefined;
        this._newLine = false;
        this._name = name;
        this._args = args;
        this._defaultValue = defaultValue;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the function application
     * @param context
     */
    eval(context) {
        let fundef = context.lookup(this._name, context); // looking up function
        //let child = new Scope(fundef.scope); // avoiding overwrite; need to toss after returning
        let child = fundef.scope.copy(); // Copying definition scope
        // Assigns arg values to definition arguments
        if (this._args != null) {
            for (let i = 0; i < this._args.length; i++) { //lookups?
                //child.declare(this._funct.args[i]); // redeclare?
                child.assign(fundef.args[i], this._args[i]);
            }
        }
        let id = context.globalFunID; // Assigns an ID to the function
        context.globalFunID++;
        child.retValID = space_lift_1.Some(id); // new method
        // we only return a value with function application
        // if it is explicitly returned using a return statement;
        // we abuse JS exceptions for this purpose
        try {
            child.hadFunEval = true;
            fundef.body.eval(child);
            return this._defaultValue;
        }
        catch (e) {
            // make sure that we catch only the error intended for us
            if (e instanceof ReturnError_1.ReturnError && parseInt(e.ID) == id) {
                return e.retVal;
            }
            // error was not intended for us; rethrow
            throw e;
        }
        //return fundef.body.eval(child);
    }
    /**
     * Returns a string representation of the function application
     */
    toString() {
        let argsList = '';
        if (this._args.length > 0) {
            for (let i = 0; i < this._args.length - 1; i++) {
                argsList += this._args[i].toString() + ", ";
            }
            argsList += this._args[this._args.length - 1].toString();
        }
        return this._ws + this.name + '(' + argsList + ")";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Function applications cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a function application
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on functions");
    }
    /**
     * Returns the name of the function
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the arguments of the function
     */
    get args() {
        return this._args;
    }
}
exports.FunApp = FunApp;

},{"../structural/ReturnError":75,"space-lift":90}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
class FunDef {
    constructor(name, body, args, ws) {
        this._newLine = true;
        this._name = name;
        this._body = body;
        this._args = args;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    ;
    // Binds args in context of definition; no values
    // Binds name to parent context (cur context is new context)
    eval(context) {
        this._funScope = new Scope_1.Scope(context); // ************* copy????
        this._funScope.canvas = context.canvas;
        this._funScope.eventLog = context.eventLog;
        this._funScope.effects = context.effects;
        /*
        if(this._args != null){
            for(let entry of this._args){
                this._funScope.declare(entry);
            }
        }
        */
        context.declare(this._name); // assign with val function
        context.assign(this._name, this); // parent or current?
        return null;
    }
    newLine() {
        return this._newLine;
    }
    toString() {
        let argsList = '';
        if (this._args.length > 0) {
            for (let i = 0; i < this._args.length - 1; i++) {
                argsList += this._args[i] + ", ";
            }
            argsList += this._args[this._args.length - 1];
        }
        return this._ws + "fun " + this._name + "(" + argsList + ')' + ' {\n ' + this._body.toString() + '}';
    }
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    equalsVal(right) {
        throw new Error("Cannot call equals directly on functions");
    }
    // Get methods
    get name() {
        return this._name;
    }
    get body() {
        return this._body;
    }
    get args() {
        return this._args;
    }
    get scope() {
        return this._funScope;
    }
}
exports.FunDef = FunDef;

},{"../structural/Scope":76}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ListNode {
    /**
     * Constructor for an array-like list
     * @param list The list, stored in a TS array
     * @param ws Preceding whitespace
     */
    constructor(list, ws) {
        this._newLine = false;
        this._list = list;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates each element of the list and pushes it onto the internal representation
     * @param context
     */
    eval(context) {
        let evalList = [];
        for (let expr of this._list) {
            evalList.push(expr.eval(context));
        }
        return new ListNode(evalList);
    }
    /**
     * Returns a string representation of the list
     */
    toString() {
        let list = '';
        for (let i = 0; i < this._list.length - 1; i++) {
            list += this._list[i].toString() + ", ";
        }
        list += this._list[this._list.length - 1].toString();
        return this._ws + '[' + list + ']';
    }
    /**
     * Returns whether the list equals another list
     * @param right The right side of the equality (must be a ListNode)
     */
    equalsVal(right) {
        if (right instanceof ListNode) {
            for (let i = 0; i < this.list.length; i++) {
                if (!(this.list[i].equalsVal(right.list[i]))) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Draw cannot be called directly on a list
     */
    draw() {
        throw new Error("Cannot draw a ListNode");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the internal representation of the list
     */
    get list() {
        return this._list;
    }
}
exports.ListNode = ListNode;

},{}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class ClearEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for the Clear Event, which logs when the canvas is cleared
     * @param toLog What to log (spoiler: nothing)
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "clear";
    }
    /**
     * Assembles and returns message "Console cleared" with date and time attached
     */
    assembleLog() {
        let toPrint = "Console cleared";
        return this.logItem(toPrint);
    }
}
exports.ClearEvent = ClearEvent;

},{"./LogEvent":26}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class ClickEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Click Event, which logs when an object on the canvas is clicked
     * @param toLog The string representation of the object to log
     * @param x1 The x coordinate of the object to log
     * @param y1 The y coordinate of the object to log
     */
    constructor(toLog, x1, y1) {
        super(toLog, x1, y1);
        this.tag = "click";
    }
    /**
     * Assembles and returns message of form "Clicked on obj at x, y" with date and time attached
     */
    assembleLog() {
        let toPrint = "Clicked on " + this.toLog + " at " + this.x1.toString() + ", " + this.y1.toString();
        return this.logItem(toPrint);
    }
}
exports.ClickEvent = ClickEvent;

},{"./LogEvent":26}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class DragEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Drag Event, which logs when an object on the canvas is dragged
     * @param toLog The effect to log
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "drag";
        this._toPrint = this.assembleString();
    }
    /**
     * Assembles a log string using the Effect's toDragString() method
     */
    assembleString() {
        this._toPrint = this.toLog.toDragString();
        return this._toPrint;
    }
    /**
     * Assembles and returns final log message of form "Dragged obj from x1, y1 to x2, y2"
     * with date and time attached
     */
    assembleLog() {
        let print = "Dragged " + this._toPrint;
        return this.logItem(print);
    }
}
exports.DragEvent = DragEvent;

},{"./LogEvent":26}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class IDEvent extends LogEvent_1.LogEvent {
    /**
     * A constructor for an ID event, used when an object gets assigned an ID
     * @param toLog The effect to log
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "ID";
        this._toPrint = this.assembleString();
    }
    /**
     * Assembles string using the effect's toIDString() method
     */
    assembleString() {
        this._toPrint = this.toLog.toIDString();
        return this._toPrint;
    }
    /**
     * Assembles message of form "Assigned ID # to obj at x, y" with date and time attached
     */
    assembleLog() {
        let print = "Assigned ID " + this._toPrint;
        return this.logItem(print);
    }
}
exports.IDEvent = IDEvent;

},{"./LogEvent":26}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class LogEvent {
    /**
     * Abstract class constructor for a Log Event. Registers event time.
     * @param toLog The string, object, or array of objects to be logged
     * @param x1 Initial x position, if applicable
     * @param y1 Initial y position, if applicable
     * @param x2 Final x position, if applicable
     * @param y2 Final y position, if applicable
     */
    constructor(toLog, x1, y1, x2, y2) {
        let today = new Date();
        this._date = today.getFullYear() + '-' + (today.getMonth() + 1) + '-' + today.getDate();
        this._time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds();
        this._dateTime = this._date + ' ' + this._time;
        this._toLog = toLog;
        //this._toLogArray = toLogArray;
        this._x1 = x1;
        this._y1 = y1;
        this._x2 = x2;
        this._y2 = y2;
    }
    /**
     * Attaches date and time to log message
     * @param toLog The log message
     */
    logItem(toLog) {
        return " " + this._dateTime + ": " + toLog;
    }
    /**
     * Returns date-time string
     */
    get dateTime() {
        return this._dateTime;
    }
    /**
     * Returns string or effect(s) to be logged
     */
    get toLog() {
        return this._toLog;
    }
    /**
     * Returns event tag
     */
    get tag() {
        return this._tag;
    }
    /**
     * Sets tag string
     */
    set tag(tag) {
        this._tag = tag;
    }
    /**
     * Returns x1
     */
    get x1() {
        return this._x1;
    }
    /**
     * Returns y1
     */
    get y1() {
        return this._y1;
    }
    /**
     * Returns x2
     */
    get x2() {
        return this._x2;
    }
    /**
     * Returns y2
     */
    get y2() {
        return this._y2;
    }
}
exports.LogEvent = LogEvent;

},{}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class PaintEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Paint Event, used when an object is painted on the canvas
     * @param toLog The string representation of the object to be logged
     * @param x1 The x position of the object
     * @param y1 The y position of the object
     */
    constructor(toLog, x1, y1) {
        super(toLog, x1, y1);
        this.tag = "paint";
    }
    /**
     * Assembles and returns message of form "Painted obj at x, y" with date and time attached
     */
    assembleLog() {
        let toPrint = "Painted " + this.toLog + " at " + this.x1.toString() + ", " + this.y1.toString();
        return this.logItem(toPrint);
    }
}
exports.PaintEvent = PaintEvent;

},{"./LogEvent":26}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class ResizeEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for Resize Event, used when an object on the canvas is resized
     * @param toLog String representation of the object to be logged
     * @param x1 Initial x dimension of the object, or initial font size
     * @param y1 Initial y dimension of the object, or final font size
     * @param x2 Final x dimension of the object
     * @param y2 Final y dimension of the object
     */
    constructor(toLog, x1, y1, x2, y2) {
        super(toLog, x1, y1, x2, y2);
        this.tag = "resize";
    }
    /**
     * Assembles log message of form "Resized obj from size x1, y1 to size x1, y2" for rects and ellipses
     * or of form "Resized obj from size x1 to size y1" for strings
     * Has date and time attached
     */
    assembleLog() {
        if (this.x2 != undefined && this.y2 != undefined) {
            this.toPrint = "Resized " + this.toLog + " from size " + this.x1.toString() + " by " + this.y1.toString()
                + " to size " + this.x2.toString() + " by " + this.y2.toString();
        }
        else {
            this.toPrint = "Resized " + this.toLog + " from size " + this.x1.toString() + " to size " + this.y1.toString();
        }
        return this.logItem(this.toPrint);
    }
}
exports.ResizeEvent = ResizeEvent;

},{"./LogEvent":26}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class SelectEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Selection Event, used when multiple objects on the canvas are selected
     * @param toLog The array of objects selected
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "select";
        this._toPrint = this.assembleStrings();
    }
    /**
     * Assembles and returns a string representation of all the objects selected
     */
    assembleStrings() {
        let logStrings = [];
        for (let elem of this.toLog) {
            logStrings.push(elem.toSelString());
        }
        return "Selected" + logStrings;
    }
    /**
     * Returns the message with date and time attached
     */
    assembleLog() {
        return this.logItem(this._toPrint);
    }
}
exports.SelectEvent = SelectEvent;

},{"./LogEvent":26}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class And {
    /**
     * Constructor for logical 'and' (&&) operation
     * @param left The left side of the operation
     * @param right The right side of the operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the operation and returns a boolean of the result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof BooleanNode_1.BooleanNode && rhs instanceof BooleanNode_1.BooleanNode) {
            return new BooleanNode_1.BooleanNode(lhs.val && rhs.val);
        }
        else {
            throw new Error("The arguments to the 'and' operator must be booleans.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + ' and ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on the 'and' op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * The 'and' operation cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns the left side of the op
     */
    get left() {
        return this._left;
    }
    /**
     * Returns the right side of the op
     */
    get right() {
        return this._right;
    }
}
exports.And = And;

},{"../prims/BooleanNode":62}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class Equals {
    /**
     * Constructor for equality (==) operation
     * @param left The left side of the equality
     * @param right The right side of the equality
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the comparison and evaluates to a BooleanNode
     * @param context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        return new BooleanNode_1.BooleanNode(lhs.equalsVal(rhs));
    }
    /**
     * Returns a string representation of the equality op
     */
    toString() {
        return this._ws + this._left.toString() + ' equals ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals can't be called directly on an equality op
     * @param right
     */
    equalsVal(right) {
        throw new Error("well this is meta");
    }
    /**
     * Equality ops can't be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.Equals = Equals;

},{"../prims/BooleanNode":62}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class GreaterThan {
    /**
     * Constructor for GreaterThan (>) op
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs GreaterThan comparison and returns BooleanNode representation of result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val > rhs.val));
        }
        else {
            throw new Error("The arguments to the > operator must be numeric.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + " > " + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on GreaterThan op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * GreaterThan op cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.GreaterThan = GreaterThan;

},{"../prims/BooleanNode":62,"../prims/NumberNode":64}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class GreaterThanEq {
    /**
     * Constructor for GreaterThanEq (greater than or equal to, >=) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs GreaterThanEq operation and returns BooleanNode with result
     * @param context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val >= rhs.val));
        }
        else {
            throw new Error("The arguments to the >= operator must be numeric.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + ' >= ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on GreaterThanEq op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * GreaterThanEq op cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.GreaterThanEq = GreaterThanEq;

},{"../prims/BooleanNode":62,"../prims/NumberNode":64}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class LessThan {
    /**
     * Constructor for LessThan (<) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the LessThan comparison and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        //console.log(this._left.eval(context) + " is less than " + this._right.eval(context));
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            //console.log("They're both number nodes");
            //console.log(lhs.val + "<" + rhs.val);
            //let bool: boolean = lhs.val < rhs.val;
            //console.log("bool: " + bool);
            return (new BooleanNode_1.BooleanNode(lhs.val < rhs.val));
        }
        else {
            throw new Error("Arguments to less than must produce numeric values.");
        }
    }
    /**
     * Returns string representation of operation
     */
    toString() {
        return this._left.toString() + ' < ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on LessThan op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * LessThan op cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.LessThan = LessThan;

},{"../prims/BooleanNode":62,"../prims/NumberNode":64}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class LessThanEq {
    /**
     * Constructor for LessThanEq (less than or equal to, <=) operation
     * @param left The left side of the operation
     * @param right The right side of the operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the LessThanEq comparison and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val <= rhs.val));
        }
        else {
            throw new Error("The arguments to the <= operator must be numeric.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + " <= " + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on LessThanEq op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * LessThanEq ops cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.LessThanEq = LessThanEq;

},{"../prims/BooleanNode":62,"../prims/NumberNode":64}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class Not {
    /**
     * Constructor for the logical Not (!) operation
     * @param expr The expression to be operated on (must be a BooleanNode)
     * @param ws Preceding whitespace
     */
    constructor(expr, ws) {
        this._newLine = false;
        this._expr = expr;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the Not operation and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        let e = this._expr.eval(context);
        if (e instanceof BooleanNode_1.BooleanNode) {
            return new BooleanNode_1.BooleanNode(!e.val);
        }
        else {
            throw new Error("The argument to the ! operator must be boolean.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + "not " + this._expr.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on a Not op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * Not operations cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns expression to be operated on
     */
    get expr() {
        return this._expr;
    }
}
exports.Not = Not;

},{"../prims/BooleanNode":62}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class NotEqual {
    /**
     * Constructor for NotEqual (!=) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs NotEqual operation and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val !== rhs.val));
        }
        else {
            throw new Error("The arguments to the != operator must be numeric.");
        }
    }
    /**
     * Returns string representation of operation
     */
    toString() {
        return this._ws + this._left.toString() + " not equals " + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on a NotEqual op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * NotEqual ops cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.NotEqual = NotEqual;

},{"../prims/BooleanNode":62,"../prims/NumberNode":64}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class Or {
    /**
     * Constructor for logical 'or' (||) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs Or operation and returns BooleanNode with result
     * @param context Current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof BooleanNode_1.BooleanNode && rhs instanceof BooleanNode_1.BooleanNode) {
            return new BooleanNode_1.BooleanNode(lhs.val || rhs.val);
        }
        else {
            throw new Error("The arguments to the 'or' operator must be booleans.");
        }
    }
    /**
     * Returns string representation of operation
     */
    toString() {
        return this._ws + this._left.toString() + ' or ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on Or operation
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * Or operations cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.Or = Or;

},{"../prims/BooleanNode":62}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const BooleanNode_1 = require("../prims/BooleanNode");
const space_lift_1 = require("space-lift");
class ForNode {
    /**
     * Constructor for a For loop
     * @param init Initializes the variable used in the condition
     * @param cond The condition (must evaluate to BooleanNode)
     * @param post The postevaluation condition
     * @param body The body of the loop
     * @param ws Preceding whitespace
     */
    constructor(init, cond, post, body, ws) {
        this._newLine = true;
        this._init = init;
        this._cond = cond;
        this._post = post;
        this._body = body;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the For loop
     * @param context The current program context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        this._init.eval(childCtx); // initialize var
        let res = this._cond.eval(childCtx);
        if (!(res instanceof BooleanNode_1.BooleanNode)) {
            throw new Error("The condition must be a boolean expression.");
        }
        let ret;
        while (res.val) {
            ret = this._body.eval(childCtx);
            this._post.eval(childCtx);
            res = this._cond.eval(childCtx);
        }
        return ret;
    }
    /**
     * Equals cannot be called directly on ForNode
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on For loop");
    }
    /**
     * ForNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        return "Cannot call draw on For loop";
    }
    /**
     * Returns a string representation of the for loop
     */
    toString() {
        return this._ws + 'for(' + this._init.toString() + ", " + this._cond.toString() + ", " + this._post.toString() + ") {\n "
            + this._body.toString() + "}";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.ForNode = ForNode;

},{"../prims/BooleanNode":62,"../structural/Scope":76,"space-lift":90}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const BooleanNode_1 = require("../prims/BooleanNode");
const space_lift_1 = require("space-lift");
class WhileNode {
    /**
     * Constructor for a While loop
     * @param cond The While loop condition
     * @param body The body of the loop
     * @param ws Preceding whitespace
     */
    constructor(cond, body, ws) {
        this._newLine = true;
        this._cond = cond;
        this._body = body;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the body of the loop while the condition is true
     * @param context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        let res = this._cond.eval(childCtx);
        if (!(res instanceof BooleanNode_1.BooleanNode)) {
            throw new Error("The condition must be a boolean expression.");
        }
        let ret;
        while (res.val) {
            ret = this._body.eval(childCtx);
            res = this._cond.eval(childCtx);
        }
        return ret;
    }
    /**
     * Equals cannot be called directly on WhileNodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on While loop");
    }
    /**
     * WhileNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        return "Cannot call draw on While loop";
    }
    /**
     * Returns a string representation of the While loop
     */
    toString() {
        return this._ws + "while(" + this._cond.toString() + ") {\n " + this._body.toString() + "}";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.WhileNode = WhileNode;

},{"../prims/BooleanNode":62,"../structural/Scope":76,"space-lift":90}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Instruction {
    constructor(location, content) {
        this._location = location;
        this._content = content;
    }
}
exports.Instruction = Instruction;

},{}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonFourCpOne {
    constructor() {
        this._name = "l4c1";
        this._nextModule = 'l4c2';
        this._constraint = 'none';
        this._instructions = `<p> You've made it to the FINAL CHALLENGES! Complete these challenges to earn ETERNAL GLORY! </p>
    <p> Throughout this Hour of Code, you have learned: </p>
    <p> - How to print a word, circle, rectangle, and curve. </p>
    <p> - How to store any of the value above in a variable. </p>
    <p> - How to use if/else statement to check a condition about a variable. </p>
    <p> Each of the following challenges will test these concepts. Let's dive right in! </p>
    <p> Print a circle and put its height and width in one of the boxes to the side. Then print a rectangle and put its height and width in the box. </p>
    <p> CHALLENGE: Print a circle and rectangle. Put their respective width and height in the boxes provided. </p>`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonFourCpOne = LessonFourCpOne;

},{"../effects/EllipseEffect":13}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonFourCpTwo {
    constructor() {
        this._name = "l4c2";
        this._nextModule = 'l4c2';
        this._constraint = 'none';
        this._instructions = `<p> Yes! You got this! </p>
    <p> Now let's put those skills in if/else statements to work! </p>
    <p> Create a pair of if/else statements to print out to the CANVAS a claim of whether the circle is positioned ABOVE or BELOW the rectangle. </p>
    <p> CHALLENGE: Print a claim that states whether circle is ABOVE or BELOW the rectangle. </p>
    <p> HINT: Remember that the numbers in the print() statements determine the position of the shapes being printed. </p>`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonFourCpTwo = LessonFourCpTwo;

},{"../effects/EllipseEffect":13}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpFour {
    constructor() {
        this._name = "l1c4";
        this._prevModule = 'l1c2';
        this._nextModule = 'l2c1';
        this._constraint = 'canvas';
        this._instructions = `<p> Note that changing the first number in the print statement moves the words left or right, while changing the second number move them up or down. </p>
    <p> Now time for a challenge! Print the word "moo" on the CANVAS, and put it right in the center of the entire CANVAS. </p>
    <p> CHALLENGE: Print the word "moo" in the center of the CANVAS. </p>
    <p> HINT: Write print("moo", 50, 50) in the CODE area first, then change the numbers inside that print statement. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "moo") {
                if ((effect.x > 200 && effect.x < 240) && (effect.y > 230 && effect.y < 300)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpFour = LessonOneCpFour;

},{"../effects/StringEffect":18}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Instruction_1 = require("./Instruction");
class LessonOneCpOne {
    constructor() {
        this._name = "l1c1";
        this._nextModule = 'l1c2';
        this._constraint = 'none';
        this._instructions = `<p> To begin, let’s tell the computer to write something on the CANVAS. </p>
    <p> GOAL: write on the CANVAS. </p>
    <p> HINT: type in the CODE box: print("Hello, world!"), then hit the RUN button. </p>`;
        this._instrBoxes = [];
        this._instrIndex = 0;
        let content = "First, let's tell the computer to print something on the CANVAS. Click on the CODE box here.";
        this._instrBoxes.push(new Instruction_1.Instruction('code', content));
        content = 'Now type `print("Hello")` in this CODE box.';
        this._instrBoxes.push(new Instruction_1.Instruction('code', content));
        content = 'Notice that what you typed causes the computer to print the world "Hello" on the CANVAS here. Congratulations! You just wrote your first line of code!';
        this._instrBoxes.push(new Instruction_1.Instruction('canvas', content));
    }
    /**
     * render the current instruction of this checkpoint
     * @param document The HTML document
     */
    renderInstruction(document) {
        let instruction = this._instrBoxes[this._instrIndex];
        let instrDiv = document.createElement("div");
        instrDiv.className = "instruction";
        instrDiv.innerText = instruction._content;
        instrDiv.style.display = "block";
        let prevInstr = document.createElement("button");
        prevInstr.id = 'previous-instruction';
        prevInstr.innerText = "<";
        instrDiv.appendChild(prevInstr);
        let nextInstr = document.createElement("button");
        nextInstr.id = 'next-instruction';
        nextInstr.innerText = "<";
        instrDiv.appendChild(nextInstr);
        document.getElementById(instruction._location).appendChild(instrDiv);
    }
    /**
     * A lesson to print a string
     * goals: write any string on CANVAS
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        /*
        for (let effect of effects) {
          if (effect instanceof StringEffect) {
            if (effect.str !== "") {
              return true;
            }
          }
        }
        */
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpOne = LessonOneCpOne;

},{"./Instruction":41}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpThree {
    constructor() {
        this._name = "l1c3";
        this._prevModule = 'l1c2';
        this._nextModule = 'l1c4';
        this._constraint = 'canvas';
        this._instructions = `<p> Yep! Moving the words actually change the numbers in your CODE. </p>
    <p> Now the CANVAS has been frozen! Try changing your CODE to see if you can move the words to the bottom right corner. </p>
    <p> GOAL: Move the words to the bottom right of the CANVAS. </p>
    <p> HINT: Change one of the 2 numbers at a time, then click RUN to see how that changes the CANVAS.`;
        this.x = 10;
        this.y = 430;
    }
    drawGuides(ctx) {
        ctx.beginPath();
        ctx.rect(this.x, this.y, 100, 100);
        ctx.strokeStyle = '#6C6C6C';
        ctx.stroke();
        ctx.font = 20 + "px Courier New";
        ctx.fillStyle = '#6C6C6C';
        ctx.fillText("Put text", this.x, 390);
        ctx.fillText("in here", this.x, 410);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str !== "") {
                if (effect.x > this.x && effect.x < this.x + 100 && effect.y > this.y && effect.y < this.y + 100) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpThree = LessonOneCpThree;

},{"../effects/StringEffect":18}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpTwo {
    constructor() {
        this._name = "l1c2";
        this._nextModule = 'l1c3';
        this._constraint = 'code';
        this._instructions = `<p> You just told the computer to write words on the CANVAS! </p>
    <p> Now let's do something more interesting: click on the words on the CANVAS, then drag it inside the box at the top-right corner. Observe what happens to your code. </p>
    <p> GOAL: Move the words you just created inside the top-right box. </p>`;
        this.x = 390;
        this.y = 10;
    }
    drawGuides(ctx) {
        ctx.beginPath();
        ctx.rect(this.x, this.y, 100, 100);
        ctx.strokeStyle = '#6C6C6C';
        ctx.stroke();
        ctx.font = 20 + "px Courier New";
        ctx.fillStyle = '#6C6C6C';
        ctx.fillText("Put text", 390, 130);
        ctx.fillText("in here", 390, 150);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str !== "") {
                if (effect.x > this.x && effect.x < this.x + 100 && effect.y > this.y && effect.y < this.y + 100) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpTwo = LessonOneCpTwo;

},{"../effects/StringEffect":18}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpFive {
    constructor() {
        this._name = "l3c5";
        this._nextModule = 'l3c6';
        this._constraint = 'none';
        this._instructions = `<p> So we print a message to the CANVAS anytime c is exactly equal to 8. </p>
    <p> What if we want to print another message, "c is not equal to 8" any time c is not equal to 8? </p>
    <p> We do so by using an else statement. Observe the CODE above. </p>
    <p> When the condition inside the if() statement is satisfied, the code block inside the {} right after it would run. </p>
    <p> When that condition is not satisfied, the code block inside the {} after the else statement would run. </p>
    <p> GOAL: Change the value of c so that the line "c is NOT equal to 8." is printed on the CANVAS. </p>`;
        this._starterCode = `c = 8;
if(c == 8) {
  print("c is equal to 8.", 103, 143);
} else {
  print("c is NOT equal to 8.", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /c\s*=\s*[^8]\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "c is NOT equal to 8.") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpFive = LessonThreeCpFive;

},{"../effects/StringEffect":18}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpFour {
    constructor() {
        this._name = "l3c4";
        this._nextModule = 'l3c5';
        this._constraint = 'none';
        this._instructions = `<p> You can put an inequality condition in the if() clause, such as "a < 5" or "b > 20". </p>
    <p> You can also use an equality condition. Observe the CODE above with "c == 8". The 2 equal signs mean that you are checking whether c is exactly equal to 8 or not. </p>
    <p> Change the value of c so that the line "c is equal to 8." is printed on the CANVAS. </p>
    <p> GOAL: Change the value of c so that the line "c is equal to 8." is printed on the CANVAS. </p>`;
        this._starterCode = `c = 100;
if(c == 8) {
  print("c is equal to 8.", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /c\s*=\s*8\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "c is equal to 8.") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpFour = LessonThreeCpFour;

},{"../effects/StringEffect":18}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpOne {
    constructor() {
        this._name = "l3c1";
        this._nextModule = 'l3c2';
        this._constraint = 'none';
        this._instructions = `<p> We learned to tell the computer to print a lot of things. Unfortunately, the computer is kinda bad at math. </p>
    <p> Look at the CODE above. We let a = 5, then we print the value of a to the CANVAS. Then we print the line "a is less than 10". </p>
    <p> Since a = 5, and 5 < 10, we know that a is less than 10. But what would happen if we change the value of a to, say, 12? </p>
    <p> GOAL: change the value of a to 12. </p>
    <p> HINT: You can do this by changing the line a = 5 in the CODE area, or you can click on the number 5 on the CANVAS. </p>`;
        this._starterCode = `a = 5;
print(a, 118, 63);
print("a is less than 10", 103, 143);`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /a\s*=\s*12\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "a is less than 10") {
                //canvasIsCorrect = true;
                //break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpOne = LessonThreeCpOne;

},{"../effects/StringEffect":18}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonThreeCpSix {
    constructor() {
        this._name = "l3c6";
        this._nextModule = 'l4c1';
        this._constraint = 'none';
        this._instructions = `<p> Now that you know how to use if/else statements, let's put them all together! </p>
    <p> Above we have the CODE to draw 2 circles: circle A has height and width a, and circle B has height and width b. </p>
    <p> However, currently the claim that "Circle A is smaller than circle B." regardless of the circles' actual sizes. </p>
    <p> Create an if/else statement to print "Circle A is smaller than circle B." when it is actually so, and print "Circle A is bigger than circle B" otherwise. </p>
    <p> CHALLENGE: Create an if/else statement to print the correct claim about the sizes of the 2 circles. </p>`;
        this._starterCode = `a = 200;
print(a, 111, 103);
print(ellipse(a, a), 132, 287);
b = 100;
print(b, 337, 104);
print(ellipse(b, b), 371, 248);
print("Circle A is smaller than circle B.", 45, 453);
`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpSix = LessonThreeCpSix;

},{"../effects/EllipseEffect":13}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpThree {
    constructor() {
        this._name = "l3c3";
        this._nextModule = 'l3c4';
        this._constraint = 'none';
        this._instructions = `<p> if statements allow you to run a block of code inside the curly braces {} ONLY when the condition inside the if() clause is true. </p>
    <p> Let's have a quick challenge: observe the CODE above. Make it so that the line "b is greater than 20" is only printed on the CANVAS when b is actually greater than 20. </p>
    <p> GOAL: Make the line "b is greater than 20" only be printed on the CANVAS when b is actually greater than 20. </p>`;
        this._starterCode = `b = 8;
if(b < 10) {
  print("b is greater than 20.", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /if\s*\(\s*b\s*>\s*20\s*\)/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "b is greater than 20.") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpThree = LessonThreeCpThree;

},{"../effects/StringEffect":18}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpTwo {
    constructor() {
        this._name = "l3c2";
        this._nextModule = 'l3c3';
        this._constraint = 'none';
        this._instructions = `<p> Did you notice the claim that "a is less than 10" did not change? a is now 12 and clearly greater than 10! </p>
    <p> What we want is for the computer to only print "a is less than 10" ONLY when the value of a is truly less than 10. </p>
    <p> To do so, we use an if statement. Observe the CODE above. All we changed was to put in an if statement that checks whether a < 10. If a is, the code inside the curly braces {} are executed. </p>
    <p> Change the value of a to 12, 10, 8 and observe what happens. </p>
    <p> GOAL: RUN the CODE with a = 12 or 10 or 8. </p>`;
        this._starterCode = `a = 12;
print(a, 118, 63);
if(a < 10) {
  print("a is less than 10", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /a\s*=\s*8\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "a is less than 10") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpTwo = LessonThreeCpTwo;

},{"../effects/StringEffect":18}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpFive {
    constructor() {
        this._name = "l2c5";
        this._nextModule = 'l2c6';
        this._constraint = 'none';
        this._instructions = `<p> Did you see the CANVAS changed? </p>
    <p> In our code, we make variable a refer to the words "moo moo", and variable b refer to an ellipse(100, 100). </p>
    <p> As a result, when we tell the computer to print a, it will print "moo moo", and when we tell the computer to print b, it will print a circle. </p>
    <p> Let's take this one step further: Create a new variable c, and make it refer to an ellipse(100, 100). Then write 2 statements to print c. What do you think would happen? </p>
    <p> GOAL: Create a variable c referring to an ellipse(100, 100), then write 2 print statements to print c. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let assignment = /c\s*=\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*;/g;
            let matchAssign = code.match(assignment);
            let print = /print\s*\(\s*c\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/g;
            let matchPrint = code.match(print);
            codeIsCorrect = matchAssign != null && matchAssign.length > 0 && matchPrint != null && matchPrint.length >= 2;
        }
        //check for correct CANVAS effects
        let circleCount = 0;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                circleCount += 1;
            }
        }
        return codeIsCorrect && circleCount >= 2;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpFive = LessonTwoCpFive;

},{"../effects/EllipseEffect":13}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpFour {
    constructor() {
        this._name = "l2c4";
        this._nextModule = 'l2c5';
        this._constraint = 'none';
        this._instructions = `<p> There's no limit to how many print statements the computer can understand, so you can write 1000 print statements, and the computer will draw 1000 things on the CANVAS for you! </p>
    <p> Time to take your coding to the next level. Let's learn about variables. </p>
    <p> Variables are simply names you give to the things that you draw. </p>
    <p> For example, take a look at the code above. Change the a in the print statement to b, and observe what happened on the CANVAS. </p>
    <p> GOAL: Change a to b in the print statement. </p>`;
        this._starterCode = `a = "moo moo";\nb = ellipse(100, 100);\nprint(a, 50, 70);`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*b\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (!canvasIsCorrect && effect instanceof EllipseEffect_1.EllipseEffect) {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpFour = LessonTwoCpFour;

},{"../effects/EllipseEffect":13}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpOne {
    constructor() {
        this._name = "l2c1";
        this._nextModule = 'l2c2';
        this._constraint = 'none';
        this._instructions = `<p> Printing only words is kinda boring, so let's learn to print some shapes on the CANVAS! </p>
    <p> In the print statement, replace "moo" with ellipse(100,100). Hit the RUN button to see what happens. </p>
    <p> GOAL: replace "moo" with ellipse(100,100) in the print statement above. </p>
    <p> HINT: Highlight "moo" - including the double quotes ", and replace that with ellipse(100, 100). KEEP EVERYTHING ELSE THE SAME. </p>`;
        this._starterCode = `
    print("moo", 50, 70)`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpOne = LessonTwoCpOne;

},{"../effects/EllipseEffect":13}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class LessonTwoCpSeven {
    constructor() {
        this._name = "l2c7";
        this._nextModule = 'l3c1';
        this._constraint = 'none';
        this._instructions = `<p> Changing one circle changes c, which will then in turn change the other circle! </p>
    <p> Now let's put all we have learned to practice. </p>
    <p> Create a circle, and print out the size of that circle in the given box. </p>
    <p> IF we ever change the circle, we want the number in the box to change, too! </p>
    <p> CHALLENGE: Create a circle and print its size in the given box. </p>`;
        this.x = 10;
        this.y = 430;
    }
    drawGuides(ctx) {
        ctx.beginPath();
        ctx.rect(this.x, this.y, 100, 100);
        ctx.strokeStyle = '#6C6C6C';
        ctx.stroke();
        ctx.font = 20 + "px Courier New";
        ctx.fillStyle = '#6C6C6C';
        ctx.fillText("Put circle's size", this.x, 390);
        ctx.fillText("in here", this.x, 410);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpSeven = LessonTwoCpSeven;

},{}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpSix {
    constructor() {
        this._name = "l2c6";
        this._nextModule = 'l2c7';
        this._constraint = 'code';
        this._instructions = `<p> Now that you have drawn 2 circles both are called c, let's see what happens when you try to modify one of them. </p>
    <p> Click on one of the circles on the CANVAS, and try make it bigger. Observe what happens to your declaration of c. </p>
    <p> GOAL: Enlarge one of the circles referred to by c on the CANVAS. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                if (effect.w > 250 && effect.h > 250) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpSix = LessonTwoCpSix;

},{"../effects/EllipseEffect":13}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
const StringEffect_1 = require("../effects/StringEffect");
class LessonTwoCpThree {
    constructor() {
        this._name = "l2c3";
        this._nextModule = 'l2c4';
        this._constraint = 'none';
        this._instructions = `<p> So we can draw a circle and change it. But what if we want to draw both circles and words? </p>
    <p> Well, simple! Just write more print statements in the CODE area! </p>
    <p> GOAL: Draw 2 circles and a word on the CANVAS. </p>
    <p> HINT: Remember that the numbers right inside the ellipse(_,_) statement change the circle's sizes.`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        let stringExists = false;
        let circleCount = 0;
        for (let effect of effects) {
            if (!stringExists) {
                stringExists = effect instanceof StringEffect_1.StringEffect && effect.str !== "";
            }
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                circleCount += 1;
            }
        }
        return stringExists && circleCount >= 2;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpThree = LessonTwoCpThree;

},{"../effects/EllipseEffect":13,"../effects/StringEffect":18}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpTwo {
    /*
    `<p> So we can draw a circle and change it. But what if we want to draw both a circle and a word? </p>
    <p> Well, simple! Just write another print statement in the CODE area! </p>
    <p> GOAL: Draw 2 circles and a word on the CANVAS. </p>
    <p> HINT: Remember that the numbers right inside the ellipse(_,_) statement change the circle's sizes.`;
*/
    constructor() {
        this._name = "l2c2";
        this._nextModule = 'l2c3';
        this._constraint = 'code';
        this._instructions = `<p> We can write ellipse(100, 100) in the print statement to draw a circle on the CANVAS. </p>
    <p> What are the numbers (100, 100) for? I'm glad you asked... </p>
    <p> Because the CODE area is frozen again! Drag one of the 9 white tips around the circle on the CANVAS to see how the number changes! </p>
    <p> GOAL: Make the circle wider but shorter. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                if (effect.w > 200 && effect.h < 80) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpTwo = LessonTwoCpTwo;

},{"../effects/EllipseEffect":13}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pants_1 = require("pants");
const index_1 = require("../../index");
const space_lift_1 = require("space-lift");
var Parser;
(function (Parser) {
    /**
     * to be moved to Pants
     * number parses numbers by repeatedly applying the digit parser
     */
    function number() {
        return (istream) => {
            const o = pants_1.Primitives.many1(pants_1.Primitives.digit())(istream);
            switch (o.tag) {
                case "success":
                    let s = "";
                    for (let digit of o.result) {
                        s += digit.toString();
                    }
                    return new pants_1.Primitives.Success(o.inputstream, parseFloat(s));
                case "failure":
                    return o;
            }
        };
    }
    Parser.number = number;
    /**
     * to be moved to Pants
     * string is an arbitrary string parser that repeatedly applies the letter primitive
     * returns a CharStream representing the entire parsed string
     */
    function string() {
        let p = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.many1(pants_1.Primitives.letter()));
        let f = (xs) => pants_1.CharUtil.CharStream.concat(xs);
        return pants_1.Primitives.appfun(p)(f);
    }
    Parser.string = string;
    /**
     * to be moved to Pants
     * punctuation parses all possible punctuation characters
     */
    function punctuation() {
        return pants_1.Primitives.sat(x => x == "!"
            || x == "."
            || x == ','
            || x == ";"
            || x == '?'
            || x == "-"
            || x == "&"
            || x == '$'
            || x == ':'
            || x == '/'
            || x == '|'
            || x == '%'
            || x == '#'
            || x == "@"
            || x == "~"
            || x == '`'
            || x == '*'
            || x == '^'
            || x == '{'
            || x == '}'
            || x == "["
            || x == ']'
            || x == '('
            || x == ")"
            || x == "'"
            || x == "_");
    }
    Parser.punctuation = punctuation;
    let id = (x) => x;
    /**
     * parse is a function that wraps the input text in a CharStream
     * and passes it to the upper-level parse function
     * @param program a string representing program text
     */
    function parse(program) {
        program += "\n";
        let o = Parser.ExpressionParser(new pants_1.CharUtil.CharStream(program));
        switch (o.tag) {
            case "success":
                return space_lift_1.Some(o.result);
            case "failure":
                return space_lift_1.None;
        }
    }
    Parser.parse = parse;
    /**
     * Expression parser first searches for the first expression of a sequence and either
     * another expression or the end of the program (NOP) and returns a sequence node
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParser = i => {
        let f = (tup) => {
            return new index_1.SequenceNode(tup[0], tup[1]);
        };
        let p = pants_1.Primitives.seq(Parser.ExpressionParserNoSeq)(pants_1.Primitives.right(pants_1.Primitives.choice(pants_1.Primitives.char(';'))(pants_1.Primitives.nl()))(pants_1.Primitives.choice(pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser))(pants_1.Primitives.appfun(pants_1.Primitives.ws())(_ => new index_1.NOP()))))(f);
        return p(i);
    };
    /**
     * Searches through all possible expressions except for sequences
     * used to avoid infinite looping in upper level parse
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParserNoSeq = i => {
        let p1 = pants_1.Primitives.choice(lNumber())(lstring2());
        let p2 = pants_1.Primitives.choice(varNameParse())(p1);
        let p3 = pants_1.Primitives.choice(BoolParse())(p2);
        let p4 = pants_1.Primitives.choice(varDecParse())(p3);
        let p5 = pants_1.Primitives.choice(Parser.unOpsExpr)(p4);
        let p6 = pants_1.Primitives.choice(Declare())(p5);
        let p7 = pants_1.Primitives.choice(Parser.binOpExpr)(p6);
        let p8 = pants_1.Primitives.choice(LogicExpr())(p7);
        let p9 = pants_1.Primitives.choice(Parser.ListHead)(p8);
        let p10 = pants_1.Primitives.choice(Parser.funApp)(p9);
        let p11 = pants_1.Primitives.choice(Parser.returnParser)(p10);
        let p12 = pants_1.Primitives.choice(Parser.condParse)(p11);
        let p13 = pants_1.Primitives.choice(Parser.WhileLoop)(p12);
        let p14 = pants_1.Primitives.choice(Parser.ForLoop)(p13);
        let p15 = pants_1.Primitives.choice(Parser.funDef)(p14);
        return p15(i);
    };
    /**
     * Searches through all possible expressions except for binOp expressions
     * used to avoid infinite looping in the binary expression parser
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParserNoBinOp = i => {
        let p1 = pants_1.Primitives.choice(lNumber())(lstring2());
        let p2 = pants_1.Primitives.choice(varNameParse())(p1);
        let p3 = pants_1.Primitives.choice(BoolParse())(p2);
        let p4 = pants_1.Primitives.choice(varDecParse())(p3);
        let p5 = pants_1.Primitives.choice(Parser.unOpsExpr)(p4);
        let p6 = pants_1.Primitives.choice(Declare())(p5);
        let p7 = pants_1.Primitives.choice(Parser.ListHead)(p6);
        let p8 = pants_1.Primitives.choice(Parser.funApp)(p7);
        let p9 = pants_1.Primitives.choice(Parser.returnParser)(p8);
        let p10 = pants_1.Primitives.choice(Parser.condParse)(p9);
        let p11 = pants_1.Primitives.choice(Parser.WhileLoop)(p10);
        let p12 = pants_1.Primitives.choice(Parser.ForLoop)(p11);
        let p13 = pants_1.Primitives.choice(Parser.funDef)(p12);
        return p13(i);
    };
    /**
     * Searches through all possible expressions except for logical expressions
     * used to avoid infinite looping in the logical expression parser
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParserNoLogic = i => {
        let p1 = pants_1.Primitives.choice(lNumber())(lstring2());
        let p2 = pants_1.Primitives.choice(varNameParse())(p1);
        let p3 = pants_1.Primitives.choice(BoolParse())(p2);
        let p4 = pants_1.Primitives.choice(varDecParse())(p3);
        let p5 = pants_1.Primitives.choice(Parser.unOpsExpr)(p4);
        let p6 = pants_1.Primitives.choice(Declare())(p5);
        let p7 = pants_1.Primitives.choice(Parser.binOpExpr)(p6);
        let p8 = pants_1.Primitives.choice(Parser.ListHead)(p7);
        let p9 = pants_1.Primitives.choice(Parser.funApp)(p8);
        let p10 = pants_1.Primitives.choice(Parser.returnParser)(p9);
        let p11 = pants_1.Primitives.choice(Parser.condParse)(p10);
        let p12 = pants_1.Primitives.choice(Parser.WhileLoop)(p11);
        let p13 = pants_1.Primitives.choice(Parser.ForLoop)(p12);
        let p14 = pants_1.Primitives.choice(Parser.funDef)(p13);
        return p14(i);
    };
    /**
     * lNumber is used to wrap parsed numbers in NumberNodes for the AST
     */
    function lNumber() {
        return (istream) => {
            let o = number()(istream);
            switch (o.tag) {
                case "success":
                    return new pants_1.Primitives.Success(o.inputstream, new index_1.NumberNode(o.result));
                case "failure":
                    return o;
            }
        };
    }
    Parser.lNumber = lNumber;
    /**
     * binOpsChar parses all possible binary operators, such as + or -
     */
    function binOpsChar() {
        return (istream) => {
            return pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.sat(x => x == "+"
                || x == "-"
                || x == "/"
                || x == "="
                || x == "*"))(istream);
        };
    }
    Parser.binOpsChar = binOpsChar;
    /**
     * binOpsShort returns a tuple where the first element is the binary operator (CharStream)
     * and the second element is the expression to the right of the operator (Expression<{}>)
     */
    function binOpShort() {
        return pants_1.Primitives.seq(binOpsChar())(Parser.ExpressionParserNoSeq)((x) => x);
    }
    Parser.binOpShort = binOpShort;
    /**
     * binOpExpr parses all possible binary operation expressions and returns the
     * corresponding AST node construct (also parses postfix increments/decrements like i++)
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.binOpExpr = i => {
        var f = (tup) => {
            let lhs = tup[0];
            let op = tup[1][0];
            let rhs = tup[1][1];
            switch (op.toString()) {
                case "+":
                    return new index_1.PlusOp(lhs, rhs, ws);
                case "-":
                    return new index_1.MinusOp(lhs, rhs, ws);
                case "/":
                    return new index_1.DivOp(lhs, rhs, ws);
                case "*":
                    return new index_1.MulOp(lhs, rhs, ws);
                case "=":
                    return new index_1.AssignOp(lhs, rhs, ws);
                default:
                    throw new Error("Binary Operation not supported");
            }
        };
        let p1 = pants_1.Primitives.choice(Parser.ExpressionParserNoBinOp)(varDecParse());
        let p2 = binOpShort();
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let postPlus = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.ExpressionParserNoBinOp))(pants_1.Primitives.str('++'))(tup => { return new index_1.Increment(tup[0], ws); });
        let postMinus = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.ExpressionParserNoBinOp))(pants_1.Primitives.str('--'))(tup => { return new index_1.Decrement(tup[0], ws); });
        let binOp = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(p1))(p2)(f);
        return pants_1.Primitives.choice(binOp)(pants_1.Primitives.choice(postPlus)(postMinus))(i);
    };
    /**
     * unOpsChar parses all possible unary operators
     * Only negations are supported, but more can be added as needed
     * @param i nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.unOpsChar = i => {
        return pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char("-"))(i);
    };
    /**
     * unOpsExpr wraps a unary operation expression in the corresponding
     * AST node and returns it
     * @param i nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.unOpsExpr = i => {
        var f = (tup) => {
            return new index_1.NegOp(tup[1], ws);
        };
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        return pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.unOpsChar))(Parser.ExpressionParserNoSeq)(f)(i);
    };
    /**
     * lstring parses valid strings in the SWELL language
     * a valid string is surrounded by quotations and consists of letters, numbers, punctuation, and/or whitespace
     */
    function lstring() {
        let p1 = pants_1.Primitives.choice(pants_1.Primitives.choice(pants_1.Primitives.letter())(pants_1.Primitives.ws1()))(pants_1.Primitives.digit());
        //let p1 = Primitives.choice(Primitives.letter())(Primitives.ws1());
        let p = pants_1.Primitives.between(pants_1.Primitives.str("\""))(pants_1.Primitives.str("\""))(pants_1.Primitives.many(pants_1.Primitives.choice(p1)(punctuation())));
        let f = (xs) => pants_1.CharUtil.CharStream.concat(xs);
        return pants_1.Primitives.appfun(p)(f);
    }
    Parser.lstring = lstring;
    /**
     * lstring2 wraps strings parsed by lstring in StrinNode objects and returns them
     */
    function lstring2() {
        return (istream) => {
            let ws = "";
            let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
            let o = pants_1.Primitives.right(precedingWS)(lstring())(istream);
            switch (o.tag) {
                case "success":
                    return new pants_1.Primitives.Success(o.inputstream, new index_1.StringNode(o.result.toString(), ws));
                case "failure":
                    return o;
            }
        };
    }
    Parser.lstring2 = lstring2;
    /**
     * varNameParse parses valid variable names
     * variable names in SWELL begin with a lowercase char and are followed
     * by letters or digits
     */
    function varNameParse() {
        var f = (tup) => {
            return new index_1.VariableNode(tup[0].toString() + pants_1.CharUtil.CharStream.concat(tup[1]).toString(), ws);
        };
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let firstChar = pants_1.Primitives.right(precedingWS)(pants_1.Primitives.lower());
        let nextChars = pants_1.Primitives.many(pants_1.Primitives.choice(pants_1.Primitives.digit())(pants_1.Primitives.letter()));
        return pants_1.Primitives.seq(firstChar)(nextChars)(f);
    }
    Parser.varNameParse = varNameParse;
    /**
     * varDecParse parses valid variable declarations in the form "var x"
     * the parser then wraps the parsed value in a variable node for the AST
     */
    function varDecParse() {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str("var"));
        let varName = pants_1.Primitives.between(pants_1.Primitives.ws1())(pants_1.Primitives.ws())(varNameParse());
        let p = pants_1.Primitives.seq(p1)(varName)(tup => tup[1]);
        return p;
    }
    Parser.varDecParse = varDecParse;
    /**
     * Declare parses variable declarations in the form "var x = 2"
     * and returns a DeclareOp node
     */
    function Declare() {
        let eq = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('='));
        let p1 = pants_1.Primitives.left(varDecParse())(eq);
        return pants_1.Primitives.seq(p1)(Parser.ExpressionParserNoSeq)(tup => { return new index_1.DeclareOp(tup[0], tup[1]); });
    }
    Parser.Declare = Declare;
    /**
     * ListHead parses all lists in the SWELL language, including empty lists
     * Lists are surrounded by square brackets and each element is separated by a comma
     * returns a listNode object
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.ListHead = i => {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p0 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let p1 = pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.char('[')))(p0);
        var f = (tup) => {
            let hd = tup[0];
            let res = [hd];
            let tail = tup[1];
            for (let elem of tail) {
                res.push(elem);
            }
            return new index_1.ListNode(res, ws);
        };
        let p2 = pants_1.Primitives.seq(p1)(ListTail())(f);
        let p3 = pants_1.Primitives.appfun(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('[]')))(_ => new index_1.ListNode([], ws));
        return pants_1.Primitives.choice(p3)(p2)(i);
    };
    /**
     * List Tail parses second through last elements of a list, each separated by a comma
     * returns an array of Expressions that will be accessed by ListHead
     */
    function ListTail() {
        let p0 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char(','))(p0);
        let p2 = pants_1.Primitives.left(pants_1.Primitives.many(p1))(pants_1.Primitives.char(']'));
        return p2;
    }
    Parser.ListTail = ListTail;
    /**
     * funDefArgList parses argument lists for function definitions,
     * surrounded by parens and separated by commas
     * returns an array of the parameters
     */
    function funDefArgList() {
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char('('))(string());
        var f = (tup) => {
            let hd = tup[0].toString();
            let res = [hd];
            let tail = tup[1];
            for (let elem of tail) {
                res.push(elem.toString());
            }
            return res;
        };
        let p2 = pants_1.Primitives.seq(p1)(funDefArgListTail())(f);
        let p3 = pants_1.Primitives.appfun(pants_1.Primitives.str('()'))(_ => []);
        return pants_1.Primitives.choice(p3)(p2);
    }
    Parser.funDefArgList = funDefArgList;
    /**
     * funDefArgListTail parses the second through last elements of a function definition parameter list
     * parameters are separated by commas and end with a closing parens
     * returns an array of parameters, which is accessed by funDefArgList
     */
    function funDefArgListTail() {
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char(','))(string());
        let p2 = pants_1.Primitives.left(pants_1.Primitives.many(p1))(pants_1.Primitives.char(')'));
        return p2;
    }
    /**
     * funAppArgList parses argument lists for function applications, including empty args lists
     * the parser returns an array of Expression objects that represent the arguments
     */
    function funAppArgList() {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char('('))(expr);
        var f = (tup) => {
            let hd = tup[0];
            let res = [hd];
            let tail = tup[1];
            for (let elem of tail) {
                res.push(elem);
            }
            return res;
        };
        let p2 = pants_1.Primitives.seq(p1)(funAppArgListTail())(f);
        let p3 = pants_1.Primitives.appfun(pants_1.Primitives.str('()'))(_ => []);
        return pants_1.Primitives.choice(p3)(p2);
    }
    Parser.funAppArgList = funAppArgList;
    /**
     * funAppArgListTail parses the second through last elements of an argument list
     * each element is separated by a comma
     * returns an array of Expression objects, later accessed by funAppArgsList
     */
    function funAppArgListTail() {
        let comma = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char(','));
        let p1 = pants_1.Primitives.right(comma)(Parser.ExpressionParserNoSeq);
        let p2 = pants_1.Primitives.left(pants_1.Primitives.many(p1))(pants_1.Primitives.right(pants_1.Primitives.ws())(pants_1.Primitives.char(')')));
        return p2;
    }
    /**
     * returnParser parses valid return statements in the form "return x"
     * wraps the parsed value in a Return node for the AST
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.returnParser = i => {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p = pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('return')))(expr);
        var f = (e) => { return new index_1.Return(e, ws); };
        return pants_1.Primitives.appfun(p)(f)(i);
    };
    /**
     * funDef parses valid function definitions in the form "fun functionName(argList){ body;}"
     * the parser returns a funDef node for the AST
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.funDef = i => {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        return pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('fun')))(pants_1.Primitives.seq(
        /* function name */
        pants_1.Primitives.appfun(string())(cs => cs.toString()))(pants_1.Primitives.seq(
        /* function arguments */
        funDefArgList())(pants_1.Primitives.right(
        /* function body */
        pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{')))(pants_1.Primitives.left(pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser))(pants_1.Primitives.char('}'))))(id))(
        // create the AST node
        (tup) => {
            let fname = tup[0];
            let args = tup[1][0];
            let body = tup[1][1];
            return new index_1.FunDef(fname, body, args, ws);
        }))(i);
    };
    let printOffset = -1;
    /**
     * funApp parses valid function applications in the form "functionName(argsList)" and returns a funApp node
     * parser checks for built-in functions, like print, ellipse, and rect; and returns the valid AST node
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.funApp = i => {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        return pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(string()))(funAppArgList())(tup => {
            let fname = tup[0].toString();
            switch (fname) {
                case "print":
                    if (tup[1].length == 3) {
                        return new index_1.PrintNode(tup[1][0], new index_1.Dimensions(tup[1][1], tup[1][2], new index_1.NumberNode(1)), ws);
                    }
                    printOffset = (printOffset + 1) % 12;
                    return new index_1.PrintNode(tup[1][0], new index_1.Dimensions(new index_1.NumberNode(100 + 100 * (printOffset % 3)), new index_1.NumberNode(100 + 100 * (printOffset / 4)), new index_1.NumberNode(1)), ws);
                case "ellipse":
                    if (tup[1].length == 2) {
                        return new index_1.EllipseNode(tup[1][0], tup[1][1], ws);
                    }
                case "rect":
                    if (tup[1].length == 2) {
                        return new index_1.RectangleNode(tup[1][0], tup[1][1], ws);
                    }
                case "line":
                    if (tup[1].length == 2) {
                        return new index_1.LineNode(tup[1][0], tup[1][1], ws);
                    }
                case "curve":
                    if (tup[1].length == 3) {
                        return new index_1.CurveNode(tup[1][0], tup[1][1], tup[1][2], ws);
                    }
                case "eph":
                    if (tup[1].length == 2) {
                        return new index_1.EphNode(tup[1][0], tup[1][1], ws);
                    }
            }
            let args = tup[1];
            return new index_1.FunApp(fname, args, ws);
        })(i);
    };
    /**
     * BoolParse parses valid booleans, true and false, and returns a BooleanNode
     */
    function BoolParse() {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.appfun(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('true')))(_ => new index_1.BooleanNode(true, ws));
        let p2 = pants_1.Primitives.appfun(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('false')))(_ => new index_1.BooleanNode(false, ws));
        return pants_1.Primitives.choice(p1)(p2);
    }
    Parser.BoolParse = BoolParse;
    /**
     * logicChar parses all logical operators in the SWELL language and returns the consumed operator
     */
    function logicChar() {
        var logicChar = ["equals", '==', 'and', '>', '<', 'not equals', 'or'];
        var logicChar2 = ['>=', '<='];
        let p1 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.strSat(logicChar));
        let p2 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.strSat(logicChar2));
        return pants_1.Primitives.choice(p2)(p1);
    }
    Parser.logicChar = logicChar;
    /**
     * logicShort returns a tuple, where the first element represents the logical operator and
     * the second element is the expression to the right of the operator
     */
    function logicShort() {
        return pants_1.Primitives.seq(logicChar())(Parser.ExpressionParserNoSeq)((x) => x);
    }
    Parser.logicShort = logicShort;
    /**
     * logicExpr parses logical expressions and returns the corresponding AST node
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    function LogicExpr() {
        // TODO: Dan (2018-11-19), shouldn't parameterized type be BooleanNode?
        var f = (tup) => {
            let lhs = tup[0];
            let op = tup[1][0];
            let rhs = tup[1][1];
            switch (op.toString()) {
                case "equals":
                    return new index_1.Equals(lhs, rhs, ws);
                case "==":
                    return new index_1.Equals(lhs, rhs, ws);
                case "and":
                    return new index_1.And(lhs, rhs, ws);
                case ">":
                    return new index_1.GreaterThan(lhs, rhs, ws);
                case "<":
                    return new index_1.LessThan(lhs, rhs, ws);
                case ">=":
                    return new index_1.GreaterThanEq(lhs, rhs, ws);
                case "<=":
                    return new index_1.LessThanEq(lhs, rhs, ws);
                case "or":
                    return new index_1.Or(lhs, rhs, ws);
                case "not equals":
                    return new index_1.NotEqual(lhs, rhs, ws);
                default:
                    throw new Error("Logical expression not supported");
            }
        };
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let not = pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('not'));
        let p1 = pants_1.Primitives.right(not)(Parser.ExpressionParserNoSeq);
        let notExpr = pants_1.Primitives.appfun(p1)(x => new index_1.Not(x, ws));
        let logicExpr = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.ExpressionParserNoLogic))(logicShort())(f);
        return pants_1.Primitives.choice(notExpr)(logicExpr);
    }
    Parser.LogicExpr = LogicExpr;
    /**
     * IfParse parses valid if statements in the form "if(condition){ body; }"
     * returns an array where the first elem is the condition and the second is the body
     */
    function IfParse() {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let bodyParse = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let p1 = pants_1.Primitives.seq(pants_1.Primitives.str('if'))(pants_1.Primitives.char('('))(x => x);
        let cond = pants_1.Primitives.between(p1)(pants_1.Primitives.char(')'))(expr);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(bodyParse);
        return pants_1.Primitives.seq(cond)(body)(x => x);
    }
    Parser.IfParse = IfParse;
    /**
      * IfElseParse parses valid if else statements in the form "if(condition){ body; } else{ body2;}"
      * returns an array where the first elem is the condition and the second is the first body and the third is body2
      */
    function IfElseParse() {
        let e = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.str('else'));
        let body = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let body2 = pants_1.Primitives.between(pants_1.Primitives.str('{'))(pants_1.Primitives.str('}'))(body);
        let elseParse = pants_1.Primitives.right(e)(body2);
        var f = (tup) => {
            tup[0].push(tup[1]);
            return tup[0];
        };
        return pants_1.Primitives.seq(IfParse())(elseParse)(f);
    }
    Parser.IfElseParse = IfElseParse;
    /**
     * condParse parses possible conditional statements, including if and if/else statements
     * returns a Conditional node
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.condParse = i => {
        var f = (tup) => {
            if (tup.length == 3) {
                return new index_1.Conditional(tup[0], tup[1], tup[2]);
            }
            else {
                return new index_1.Conditional(tup[0], tup[1]);
            }
        };
        return pants_1.Primitives.appfun(pants_1.Primitives.choice(IfElseParse())(IfParse()))(f)(i);
    };
    /**
     * WhileLoop parses valid while loops in the form "while(condition) { body;}"
     * returns a WhileNode for the AST
     */
    Parser.WhileLoop = i => {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let bodyParse = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str("while")))(pants_1.Primitives.char('('))(x => x);
        let cond = pants_1.Primitives.between(p1)(pants_1.Primitives.char(')'))(expr);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(bodyParse);
        var f = (tup) => { return new index_1.WhileNode(tup[0], tup[1], ws); };
        return pants_1.Primitives.seq(cond)(body)(f)(i);
    };
    /**
     * ForLoop parses valid for loops in the form "for(initial, condition, post) { body;}" and returns a ForNode
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.ForLoop = i => {
        let args = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(funAppArgList());
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('for')))(args);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let expr = pants_1.Primitives.between(pants_1.Primitives.choice(pants_1.Primitives.ws())(pants_1.Primitives.nl()))(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(expr);
        var f = (tup) => {
            let init = tup[0][0];
            let cond = tup[0][1];
            let post = tup[0][2];
            let body = tup[1];
            return new index_1.ForNode(init, cond, post, body, ws);
        };
        return pants_1.Primitives.seq(p1)(body)(f)(i);
    };
    function singleComment() {
        let p1 = pants_1.Primitives.many1(pants_1.Primitives.item());
        let p2 = pants_1.Primitives.appfun(p1)(xs => pants_1.CharUtil.CharStream.concat(xs));
        return pants_1.Primitives.between(pants_1.Primitives.str('//'))(pants_1.Primitives.nl())(p2);
        //return Primitives.seq<CharUtil.CharStream, CharUtil.CharStream, CharUtil.CharStream[]>(Primitives.str('//'))(Primitives.nl())(x=>x);
    }
    Parser.singleComment = singleComment;
    function multiLineComment() {
        let p1 = pants_1.Primitives.many1(pants_1.Primitives.item());
        let p2 = pants_1.Primitives.appfun(p1)(xs => pants_1.CharUtil.CharStream.concat(xs));
        return pants_1.Primitives.between(pants_1.Primitives.str('\/**'))(pants_1.Primitives.str('*\/'))(p2);
    }
    Parser.multiLineComment = multiLineComment;
})(Parser = exports.Parser || (exports.Parser = {}));

},{"../../index":1,"pants":84,"space-lift":90}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BooleanNode {
    /**
     * Constructor for BooleanNode, a node representing a boolean
     * @param val The boolean value of the BooleanNode
     * @param ws Preceding white space
     */
    constructor(val, ws) {
        this._newLine = false;
        this._val = val;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    ;
    /**
     * Returns the BooleanNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * BooleanNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Returns whether this BooleanNode equals another
     * @param right The right side of the equality
     */
    equalsVal(right) {
        if (right instanceof BooleanNode) {
            return this.val === right.val;
        }
        return false;
    }
    /**
     * Returns a string representation of the BooleanNode
     */
    toString() {
        return this._ws + this._val;
    }
    /**
     * Returns the boolean value
     */
    get val() {
        return this._val;
    }
    /**
     * Sets the boolean value
     */
    set val(value) {
        this._val = value;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.BooleanNode = BooleanNode;

},{}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class NOP {
    constructor() {
        /* A NOP is a placeholder operation that evaluates to nothing */
        this._newLine = true;
    }
    /**
     * Returns the NOP
     * @param context
     */
    eval(context) {
        return this;
    }
    /**
     * NOPs cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("NOPs cannot be drawn.");
    }
    /**
     * Returns a string representation of the NOP
     */
    toString() {
        return "";
    }
    /**
     * Returns whether this NOP equals another (spoiler: it doesn't)
     * @param right
     */
    equalsVal(right) {
        return false;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.NOP = NOP;

},{}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberEffect_1 = require("../effects/NumberEffect");
// Nodes representing numbers
// Should abstract Node class implement Expression?
class NumberNode {
    /**
     * Constructor for a NumberNode, a node representing a number
     * @param val The number value
     * @param ws Preceding whitespace
     */
    constructor(val, ws) {
        this._newLine = false;
        this._val = val;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    ;
    /**
     * Returns this NumberNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * NumberNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        let e = new NumberEffect_1.NumberEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this NumberNode equals another NumberNode
     * @param right The right side of the equality (must be a NumberNode)
     */
    equalsVal(right) {
        if (right instanceof NumberNode) {
            return this.val === right.val;
        }
        return false;
    }
    /**
     * Returns a string representation of the NumberNode
     */
    toString() {
        return this._ws + this._val;
    }
    /**
     * Returns the number stored in the node
     */
    get val() {
        return this._val;
    }
    /**
     * Sets the value of the number stored in the node
     */
    set val(value) {
        this._val = value;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.NumberNode = NumberNode;

},{"../effects/NumberEffect":16}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class StringNode {
    /**
     * Constructor for a StringNode, a node representing a string
     * @param str The string stored in the node
     * @param ws Preceding whitespace
     */
    constructor(str, ws) {
        this._newLine = false;
        this._str = str;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this StringNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the String using StringEffect
     * @param context The current program context
     * @param dims The dimensions of the string to be drawn
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        let e = new StringEffect_1.StringEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this StringNode equals another StringNode
     * @param right The right side of the equality, must be a StringNode
     */
    equalsVal(right) {
        if (right instanceof StringNode) {
            return this.val === right.val;
        }
        return false;
    }
    /**
     * Returns a string representation of the StringNode
     */
    toString() {
        return this._ws + '\"' + this._str + '\"';
    }
    /**
     * Sets the string stored in the node
     */
    set str(value) {
        this._str = value;
    }
    /**
     * Returns the string stored in the node
     */
    get val() {
        return this._str;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.StringNode = StringNode;

},{"../effects/StringEffect":18}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ColorNode {
    /**
     * Constructor for a ColorNode, a node representing an RGB color
     */
    constructor(red, green, blue) {
        this._newLine = false;
        this._red = red;
        this._green = green;
        this._blue = blue;
    }
    ;
    /**
     * Evaluates into a string RGB value
     * @param context The current program context
     */
    eval(context) {
        return this._red + " " + this._green + " " + this._blue;
    }
    /**
     * ColorNodes cannot currently be drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Returns whether this ColorNode equals another ColorNode
     * @param right The right side of the equality (must be a BooleanNode)
     */
    equalsVal(right) {
        if (right instanceof ColorNode) {
            return (this.red === right.red && this.green === right.green && this.blue === right.blue);
        }
        return false;
    }
    /**
     * Returns a string representation of the ColorNode
     */
    toString() {
        return "";
    }
    /**
     * Returns the red value
     */
    get red() {
        return this._red;
    }
    /**
     * Sets the red value
     */
    set red(red) {
        this._red = red;
    }
    /**
     * Returns the green value
     */
    get green() {
        return this._green;
    }
    /**
     * Sets the green value
     */
    set green(green) {
        this._green = green;
    }
    /**
     * Returns the blue value
     */
    get blue() {
        return this._blue;
    }
    /**
     * Sets the blue value
     */
    set blue(blue) {
        this._blue = blue;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.ColorNode = ColorNode;

},{}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const CurveEffect_1 = require("../effects/CurveEffect");
class CurveNode {
    /**
     * Constructor for a CurveNode, a node representing a curve
     * @param dx the run of the curve
     * @param dy the rise of the curve
     * @param curvature how much the curve, umm, curves
     * @param ws Preceding whitespace
     */
    constructor(dx, dy, curvature, ws) {
        this._newLine = false;
        this._dx = dx;
        this._dy = dy;
        this._curvature = curvature;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this CurveNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the curve using CurveEffect
     * @param context The current program context
     * @param dims The line dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._dx.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._dy.eval(context).val, "");
        dims.curvature = new NumberNode_1.NumberNode(this._curvature.eval(context).val, "");
        let e = new CurveEffect_1.CurveEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this CurveNode equals another (if their dx, dy, and curvature are equal)
     * @param right The right side of the equality (must be a CurveNode)
     */
    equalsVal(right) {
        if (right instanceof CurveNode) {
            return (this.dx.equalsVal(right.dx) && this.dy.equalsVal(right.dy) && this.curvature.equalsVal(right.curvature));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the curve
     */
    toString() {
        return this._ws + "curve(" + this._dx.toString() + ", " + this._dy.toString() + ", " + this._curvature.toString() + ")";
    }
    /**
     * Returns the run of the curve
     */
    get dx() {
        return this._dx;
    }
    /**
     * Sets the run of the curve
     */
    set dx(dx) {
        this._dx = dx;
    }
    /**
     * Returns the rise of the curve
     */
    get dy() {
        return this._dy;
    }
    /**
     * Sets the rise of the curve
     */
    set dy(dy) {
        this._dy = dy;
    }
    /**
     * Returns the curvature of the curve
     */
    get curvature() {
        return this._curvature;
    }
    /**
     * Sets the curvature of the curve
     */
    set curvature(curvature) {
        this._curvature = curvature;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.CurveNode = CurveNode;

},{"../effects/CurveEffect":12,"../prims/NumberNode":64}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class EllipseNode {
    /**
     * Constructor for an EllipseNode, a node representing an ellipse
     * @param width The width of the ellipse
     * @param height The height of the ellipse
     * @param ws Preceding whitespace
     */
    constructor(width, height, ws) {
        this._newLine = false;
        this._width = width;
        this._height = height;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this EllipseNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the ellipse on the canvas using EllipseEffect
     * @param context The current program context
     * @param dims The dimensions of the ellipse
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = this._width;
        dims.height = this._height;
        let e = new EllipseEffect_1.EllipseEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this EllipseNode equals another EllipseNode (if their widths and heights are equal)
     * @param right The right side of the equality (must be an EllipseNode)
     */
    equalsVal(right) {
        if (right instanceof EllipseNode) {
            return (this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    /**
     * Returns a string representation of the ellipse
     */
    toString() {
        return this._ws + "ellipse(" + this._width.toString() + ", " + this._height.toString() + ")";
    }
    move() { }
    /**
     * Returns the ellipse width
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the ellipse width
     */
    set width(width) {
        this._width = width;
    }
    /**
    * Returns the ellipse height
    */
    get height() {
        return this._height;
    }
    /**
     * Sets the ellipse height
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.EllipseNode = EllipseNode;

},{"../effects/EllipseEffect":13}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const EphEffect_1 = require("../effects/EphEffect");
class EphNode {
    /**
     * Constructor for an EphNode, a node representing something very special
     * @param width The width of the EphNode
     * @param height The height of the EphNode
     * @param ws Preceding whitespace
     */
    constructor(width, height, ws) {
        this._newLine = false;
        //this._image = image;
        this._width = width;
        this._height = height;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this EphNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the rectangle using EphEffect
     * @param context The current program context
     * @param dims The rectangle dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._width.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._height.eval(context).val, "");
        let e = new EphEffect_1.EphEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this EphNode equals another (if their widths and heights are equal)
     * @param right The right side of the equality (must be an EphNode)
     */
    equalsVal(right) {
        if (right instanceof EphNode) {
            return (this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the EphNode
     */
    toString() {
        return this._ws + "eph(" + this._width.toString() + ", " + this._height.toString() + ")";
    }
    /**
     * Returns the width of the EphNode
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the EphNode
     */
    set width(width) {
        this._width = width;
    }
    /**
     * Returns the height of the EphNode
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the EphNode
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.EphNode = EphNode;

},{"../effects/EphEffect":14,"../prims/NumberNode":64}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const LineEffect_1 = require("../effects/LineEffect");
class LineNode {
    /**
     * Constructor for a LineNode, a node representing a line
     * @param dx the run of the line
     * @param dy the rise of the line
     * @param ws Preceding whitespace
     */
    constructor(dx, dy, ws) {
        this._newLine = false;
        this._dx = dx;
        this._dy = dy;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this LineNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the line using LineEffect
     * @param context The current program context
     * @param dims The line dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._dx.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._dy.eval(context).val, "");
        let e = new LineEffect_1.LineEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this LineNode equals another (if their dx and dy are equal)
     * @param right The right side of the equality (must be a LineNode)
     */
    equalsVal(right) {
        if (right instanceof LineNode) {
            return (this.dx.equalsVal(right.dx) && this.dy.equalsVal(right.dy));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the line
     */
    toString() {
        return this._ws + "line(" + this._dx.toString() + ", " + this._dy.toString() + ")";
    }
    /**
     * Returns the run of the line
     */
    get dx() {
        return this._dx;
    }
    /**
     * Sets the run of the line
     */
    set dx(dx) {
        this._dx = dx;
    }
    /**
     * Returns the rise of the line
     */
    get dy() {
        return this._dy;
    }
    /**
     * Sets the rise of the line
     */
    set dy(dy) {
        this._dy = dy;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.LineNode = LineNode;

},{"../effects/LineEffect":15,"../prims/NumberNode":64}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const RectangleEffect_1 = require("../effects/RectangleEffect");
class RectangleNode {
    /**
     * Constructor for a RectangleNode, a node representing a rectangle
     * @param width The width of the rectangle
     * @param height The height of the rectangle
     * @param ws Preceding whitespace
     */
    constructor(width, height, ws) {
        this._newLine = false;
        this._width = width;
        this._height = height;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this RectangleNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the rectangle using RectangleEffect
     * @param context The current program context
     * @param dims The rectangle dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._width.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._height.eval(context).val, "");
        let e = new RectangleEffect_1.RectangleEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this RectangleNode equals another (if their widths and heights are equal)
     * @param right The right side of the equality (must be a RectangleNode)
     */
    equalsVal(right) {
        if (right instanceof RectangleNode) {
            return (this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the rectangle
     */
    toString() {
        return this._ws + "rect(" + this._width.toString() + ", " + this._height.toString() + ")";
    }
    /**
     * Returns the width of the rectangle
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the rectangle
     */
    set width(width) {
        this._width = width;
    }
    /**
     * Returns the height of the rectangle
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the rectangle
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.RectangleNode = RectangleNode;

},{"../effects/RectangleEffect":17,"../prims/NumberNode":64}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
class Dimensions {
    /**
     * Constructor for Dimensions, which stores object dimensions
     * @param x The x coordinate of the object
     * @param y The y coordinate of the object
     * @param scale The scale of the object
     * @param radius The radius of the object
     */
    constructor(x, y, scale, radius) {
        this._x = x;
        this._y = y;
        this._scale = scale;
        this._radius = radius || new NumberNode_1.NumberNode(30, "");
    }
    /**
     * Returns a string representation of the dimensions
     */
    toString() {
        return this.x.toString() + ", " + this.y.toString();
    }
    /**
     * Returns the x coordinate of the object
     */
    get x() {
        return this._x;
    }
    /**
     * Sets the x coordinate of the object
     */
    set x(val) {
        this._x = val;
    }
    /**
     * Returns the y coordinate of the object
     */
    get y() {
        return this._y;
    }
    /**
     * Sets the y coordinate of the object
     */
    set y(val) {
        this._y = val;
    }
    /**
     * Returns the radius of the object
     */
    get radius() {
        return this._radius;
    }
    /**
     * Sets the radius of the object
     */
    set radius(val) {
        this._radius = val;
    }
    /**
     * Returns the scale of the object
     */
    get scale() {
        return this._scale;
    }
    /**
     * Sets the scale of the object
     */
    set scale(val) {
        this._scale = val;
    }
    /**
     * Returns the width of the object
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the object
     */
    set width(val) {
        this._width = val;
    }
    /**
     * Returns the height of the object
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the object
     */
    set height(val) {
        this._height = val;
    }
    /**
     * Returns the curvature of the object
     */
    get curvature() {
        return this._curvature;
    }
    /**
     * Sets the curvature of the object
     */
    set curvature(val) {
        this._curvature = val;
    }
}
exports.Dimensions = Dimensions;

},{"../prims/NumberNode":64}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class PrintNode {
    /**
     * Constructor for a PrintNode, representing an object to be printed
     * @param toPrint The object to be printed
     * @param dimensions The dimensions of the object to be printed
     * @param ws Preceding whitespace
     */
    constructor(toPrint, dimensions, ws) {
        this._scale = 1;
        this._newLine = false;
        this._toPrint = toPrint;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
        this._dims = dimensions || null;
    }
    /**
     * Returns a string representation of the object to be printed
     */
    toString() {
        return this._ws + "print(" + this.toPrint.toString() + ", " + this.dims.toString() + ")";
    }
    /**
     * Equals cannot be called directly on a PrintNode
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on PrintNode");
    }
    /**
     * PrintNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw() on printOp");
    }
    /**
     * Evaluates the object to be printed and draws it
     * @param context
     */
    eval(context) {
        let res = this._toPrint.eval(context);
        res.draw(context, this._dims, this);
        return res;
    }
    /**
     * Returns the object to be printed
     */
    get toPrint() {
        return this._toPrint;
    }
    /**
     * Returns the dimensions of the object to be printed
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.PrintNode = PrintNode;

},{}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ReturnError_1 = require("./ReturnError");
class Return {
    /**
     * Constructor for a Return object, representing something to be returned in a function
     * @param expr The expression to be returned
     * @param ws Preceding whitespace
     */
    constructor(expr, ws) {
        this._newLine = false;
        this._expr = expr;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the expression to be returned and returns via a ReturnErro
     * @param context The current program context
     */
    eval(context) {
        // If return val is a var, returns that var's value
        let result = this._expr.eval(context);
        throw new ReturnError_1.ReturnError(result, context.retIDLookup());
    }
    /**
     * Equals cannot be called directly on Return nodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on Return");
    }
    /**
     * Returns a string representation of the Return node
     */
    toString() {
        return this._ws + "return " + this._expr.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Return nodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw on Return");
    }
}
exports.Return = Return;

},{"./ReturnError":75}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ReturnError extends Error {
    /**
     * Constructor for ReturnError, a custom error class that we abuse to return values
     * @param retVal The value to be returned
     * @param ID The ID of the value to be returned
     */
    constructor(retVal, ID) {
        super(ID);
        this.retVal = retVal;
        this.ID = ID;
        Object.setPrototypeOf(this, ReturnError.prototype);
    }
}
exports.ReturnError = ReturnError;

},{}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const space_lift_1 = require("space-lift");
class Scope {
    /**
     * Constructor for Scope, an object keeping track of objects within a particular context
     * @param parent The parent Scope
     * @param effects Effects within this Scope
     * @param myState The scope state
     * @param eventLog The log of events that occurred
     */
    constructor(parent, effects, eventLog) {
        this._retValID = space_lift_1.None;
        this._canvas = space_lift_1.None;
        this._eventLog = []; // The event log
        this._hadFunEval = false; // Was this created in a function?
        //public globalFunID = Math.random();
        this.globalFunID = 10000000; // The global ID for functions in this context
        this._varBindings = new Map();
        this._parent = parent;
        this._effects = effects || null;
        this._eventLog = eventLog;
        if (this._parent != null && this._parent._hadFunEval)
            this._hadFunEval = true; // copy function eval flag from parent
    }
    /**
     * Copies information from this Scope into another Scope and returns the new Scope
     */
    copy() {
        let s = new Scope(this._parent, this._effects, this._eventLog);
        s.varBindings = new Map(this._varBindings);
        s.canvas = this.canvas;
        s.eventLog = this.eventLog;
        return s;
    }
    /**
     * Declares a new variable
     * @param name The name of the variable to be declared
     */
    declare(name) {
        if (this._varBindings.has(name)) {
            throw new Error("Scope already has var with name " + name);
        }
        this._varBindings.set(name, space_lift_1.None);
    }
    /**
     * Assigns a value to a variable in this Context
     * @param name The name of the variable
     * @param val The value of the variable
     */
    assign(name, val) {
        this._varBindings.set(name, space_lift_1.Some(val)); //Some(val)?
    }
    /**
     * Looks up a value within the Scope and all its ancestor Scopes
     * @param name The name of the value
     * @param context The context to search within
     */
    lookup(name, context) {
        if (context.varBindings.has(name)) {
            if (context.varBindings.get(name).isDefined()) {
                return (context.varBindings.get(name).get()); //extra get to manage Some()
            }
        }
        if (!(context.parent == null)) {
            return this.lookup(name, context.parent);
        }
        throw new Error("Variable could not be found.");
    }
    /**
     * Looks up and returns the return ID value
     */
    retIDLookup() {
        if (this._retValID.isDefined()) {
            return this._retValID.get();
        }
        else {
            if (this._parent) {
                return this._parent.retIDLookup();
            }
            else {
                throw new Error("Unknown caller.");
            }
        }
    }
    /**
     * Returns the Map of variable bindings
     */
    get varBindings() {
        return this._varBindings;
    }
    /**
     * Sets the Map of variable bindings
     */
    set varBindings(m) {
        this._varBindings = m;
    }
    /**
     * Returns the parent Scope
     */
    get parent() {
        return this._parent;
    }
    /**
     * Returns the return value ID
     */
    get retValID() {
        return this._retValID;
    }
    /**
     * Sets the return value ID
     */
    set retValID(val) {
        this._retValID = val;
    }
    /**
     * Returns the HTML canvas
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Sets the HTML canvas
     */
    set canvas(val) {
        this._canvas = val;
    }
    /**
     * Returns the effects array
     */
    get effects() {
        return this._effects;
    }
    /**
     * Sets the effects array
     */
    set effects(arr) {
        this._effects = arr;
    }
    /**
     * Returns the event log
     */
    get eventLog() {
        return this._eventLog;
    }
    /**
     * Sets the event log
     */
    set eventLog(update) {
        this._eventLog = update;
    }
    /**
     * Returns the array of effects
     */
    get mulSelArray() {
        return this._mulSelArray;
    }
    /**
     * Sets the array of effects
     */
    set mulSelArray(update) {
        this._mulSelArray = update;
    }
    /**
     * Returns whether this Scope was created in a function
     */
    get hadFunEval() {
        return this._hadFunEval;
    }
    /**
     * Sets whether this Scope was created in a function
     */
    set hadFunEval(val) {
        this._hadFunEval = val;
    }
}
exports.Scope = Scope;

},{"space-lift":90}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("./Scope");
const space_lift_1 = require("space-lift");
class SequenceNode {
    /**
     * Constructor for a SequenceNode, the building block of the AST
     * @param left The left side of the Sequence
     * @param right The right side of the Sequence
     */
    constructor(left, right) {
        this._newLine = true;
        this._left = left;
        this._right = right;
    }
    /**
     * Evaluates the children in postorder (left, right, parent)
     * @param context The current program context
     */
    eval(context) {
        let leftScope = new Scope_1.Scope(context, context.effects, context.eventLog);
        leftScope.canvas = space_lift_1.Some(context.canvas.get());
        //throwing away after evaling
        this._leftVal = this._left.eval(leftScope);
        this._rightVal = this._right.eval(leftScope); // leftScope may be modified now
    }
    /**
     * SequenceNodes cannot be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw() on SequenceNodes");
    }
    /**
     * Equals cannot be directly called on SequenceNodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on SequenceNode");
    }
    /**
     * Returns a string representation of the AST
     */
    toString() {
        let result = this._left.toString();
        if (this._left.newLine() == true) {
            result += '\n';
        }
        else {
            result += ";\n";
        }
        if (this._right.newLine() == false) {
            result += this._right.toString() + ";";
        }
        else {
            result += this._right.toString();
        }
        return result;
    }
    /**
     * Returns the left child
     */
    set left(left) {
        this._left = left;
    }
    /**
     * Sets the left child
     */
    get left() {
        return this._left;
    }
    /**
     * Returns the right child
     */
    set right(right) {
        this._right = right;
    }
    /**
     * Sets the right child
     */
    get right() {
        return this._right;
    }
    /**
     * Returns the value of the left chile
     */
    get leftVal() {
        return this._leftVal;
    }
    /**
     * Returns the value of the right chile
     */
    get rightVal() {
        return this._rightVal;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.SequenceNode = SequenceNode;

},{"./Scope":76,"space-lift":90}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../../index");
const index_2 = require("../../index");
const index_3 = require("../../index");
const index_4 = require("../../index");
const index_5 = require("../../index");
const index_6 = require("../../index");
const space_lift_1 = require("space-lift");
let canvas = document.querySelector('canvas');
let ctx = canvas.getContext("2d");
let inputBox = document.getElementById('input');
let lastWorkingInputText = "";
let starCount = 0;
//the effects array that holds all the text, ellipses, and rectangles
let effects = [];
let ast;
let context;
let showDebug = true; // flag to show or hide debug button
let masterLog = [];
let selectedElems = [];
let textBoxSelected; //sees if the text box is selected
let isPainting; //tests to see if you're painting to the canvas
let checkpointIsActive = false;
let checkpoint = null;
let canvasIsDisabled = false;
let selected = 0; //the number of selected effects if multiply selecting
let alreadyLogged = false;
let numLogged = 0;
let globalID = 1;
let eph;
/*
let bugButton = document.getElementById('debug');
if(!showDebug){
    bugButton.style.visibility='hidden';
}

bugButton.onclick = function(){
    printLog();
}
*/
/**
 * <div class="col-item">
 *  <button id='paint' style="background-color:#DFB534"> Run </button>
 * </div>
 *
 * Put this in html file for Run button's styling
 */
//let paintButton = document.getElementById('paint');
/**
 * makes the paint button paint text from the textarea to the canvas!
 */
/*
paintButton.onclick = function () {
    effects.length = 0; // slightly sketch clearing method to maintain reference to original array
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    isPainting = true;
    let inputText = inputBox.value;

    let astOpt = Parser.parse(inputText);
    if(astOpt.isDefined()){
        ast = astOpt.get();
        context = new Scope(null, effects, masterLog);
        context.canvas = Some(canvas);
        ast.eval(context); //this is where we draw the objects to the screen
    } else {
        let error = "error text";
        alert("Quan: so something with this syntax error: " + error);
    }

    //let paintEvt = new PaintEvent(inputText); // will need to get from ast when that's implemented

    // Adding context log to master log
    //logEvent.push(paintEvt.assembleLog());
    printLog();
    //event1.logItem();
    // }
};
*/
//clears the canvas!
let resetButton = document.getElementById('reset');
resetButton.onclick = function () {
    if (checkpoint._starterCode != null) {
        textBoxSelected = true;
        inputBox.value = checkpoint._starterCode;
    }
    context.eventLog.push(new index_2.ClearEvent());
    masterLog.push(context.eventLog[context.eventLog.length - 1]); // Does this actually work?
    printLog();
    //let clearEvt = new ClearEvent();
    //logEvent.push(clearEvt.assembleLog());
    //console.log("Log: " + logEvent);
};
/**
 * The animation function that basically recursively calls itself, clearing and
 * redrawing to the canvas at 60fps.
 */
function animate() {
    requestAnimationFrame(animate);
    ctx.clearRect(0, 0, canvas.width, canvas.height); //clears canvas
    selected = 0;
    for (let i = 0; i < effects.length; i++) {
        effects[i].update();
        if (effects[i].selected) {
            selectedElems.push(effects[i]);
            selected++;
        }
        if (effects[i].getJustDragged()) { // Logs drag event
            context.eventLog.push(new index_2.DragEvent(effects[i]));
            masterLog.push(context.eventLog[context.eventLog.length - 1]);
            effects[i].setJustDragged(false);
        }
        if (effects[i].idObj == undefined) { // Gives object an ID if it doesn't have one
            effects[i].initID(globalID);
            context.eventLog.push(new index_2.IDEvent(effects[i])); // Logs ID
            globalID++;
            //console.log(effects[i].getID());
        }
        // if(((effects[i] as EllipseEffect).justDragged)){
        //     //context.eventLog.push(new DragEvent(effects[i]));
        // }
    }
    // at this point, have iterated through all effects and have complete list to log
    if (selected != numLogged) { // if selections have changed, should log again
        alreadyLogged = false;
    }
    if (!alreadyLogged && selected >= 2) { // logs if hasn't already
        numLogged = selected;
        context.eventLog.push(new index_2.SelectEvent(selectedElems));
        masterLog.push(context.eventLog[context.eventLog.length - 1]);
        alreadyLogged = true;
    }
    //This does the prodirect manipulation, passing the new strings to the text box
    let inputText = inputBox.value;
    if (textBoxSelected && inputText !== lastWorkingInputText) {
        effects.length = 0; // slightly sketch clearing method to maintain reference to original array
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        //isPainting = true;
        //let inputText = inputBox.value;
        let astOpt = index_1.Parser.parse(inputText);
        if (astOpt.isDefined()) {
            ast = astOpt.get();
            context = new index_2.Scope(null, effects, masterLog);
            context.canvas = space_lift_1.Some(canvas);
            ast.eval(context); //this is where we draw the objects to the screen
            lastWorkingInputText = inputText;
        } /*else {
            let error = "error text";
            alert("Quan: so something with this syntax error: " + error);
        }*/
        //let paintEvt = new PaintEvent(inputText); // will need to get from ast when that's implemented
        // Adding context log to master log
        //logEvent.push(paintEvt.assembleLog());
        printLog();
        //event1.logItem();
        // }
    }
    else if (ast != undefined && !textBoxSelected /* && !isPainting */) {
        let newInput = ast.toString();
        inputBox.value = newInput;
    }
    if (checkpointIsActive) {
        checkpointChecksGoal();
    }
    if (checkpoint != null && checkpoint.drawGuides != null) {
        checkpoint.drawGuides(ctx);
        /*
              if (checkpoint._name == "l1c3") {
                ctx.beginPath();
                ctx.rect(10, 430, 100, 100);
                ctx.strokeStyle = '#6C6C6C';
                ctx.stroke();
        
                ctx.font = 20 + "px Courier New";
                ctx.fillStyle = '#6C6C6C';
                ctx.fillText("Put text", 10, 390);
                ctx.fillText("in here", 10, 410);
              }
        */
    }
    selectedElems = [];
}
//checks to see whether the text box is selected
window.addEventListener('mousedown', isInputBoxSelected);
/**
 * This function manages the state of the UI when the text box is selected and when it isn't.
 * If it is inside the text box, isPainting is false and textBoxSelected is true.
 * If it's not, if it's inside the paint button, then isPainting = true.
 * @param event the mouse down event
 */
function isInputBoxSelected(event) {
    let mouseX = event.clientX;
    let mouseY = event.clientY;
    let rect = inputBox.getBoundingClientRect();
    if (mouseX > rect.left && mouseX < rect.right && mouseY > rect.top && mouseY < rect.bottom) {
        //isPainting = false;
        textBoxSelected = true;
    }
    else {
        /*
          let paintButton = document.getElementById('paint');
          rect = paintButton.getBoundingClientRect();
          if(mouseX > rect.left && mouseX < rect.right && mouseY > rect.top && mouseY < rect.bottom) {
              isPainting = true;
          }
          else {
              isPainting = false;
          }
          */
        textBoxSelected = false;
    }
}
//checks to see whether the text box is selected
window.addEventListener('mousedown', disabledCanvasIsSelected);
/**
 * This function handles the case when a disabled canvas is selected.
 * @param event the mouse down event
 */
function disabledCanvasIsSelected(event) {
    let mouseX = event.clientX;
    let mouseY = event.clientY;
    let rect = canvas.getBoundingClientRect();
    let popUp = document.getElementById('popup');
    if (canvasIsDisabled && mouseX > rect.left && mouseX < rect.right && mouseY > rect.top && mouseY < rect.bottom) {
        popUp.style.display = 'block';
    }
    else {
        popUp.style.display = 'none';
    }
}
function printLog() {
    console.log("Log: ");
    for (let elem of masterLog) {
        console.log(elem.assembleLog());
    }
}
let paletteButtons = [
    "ellipse", "rect", "string", "number",
    "line", "curve"
];
for (let buttonName of paletteButtons) {
    let paletteButton = document.getElementById(buttonName);
    paletteButton.onclick = function () {
        textBoxSelected = true;
        printNewNode(buttonName);
    };
}
function printNewNode(buttonName) {
    let printLine = "";
    switch (buttonName) {
        case "ellipse":
            printLine = "print(ellipse(100,100));";
            break;
        case "rect":
            printLine = "print(rect(100,100));";
            break;
        case "string":
            printLine = 'print("newWord");';
            break;
        case "number":
            printLine = "print(10);";
            break;
        case "line":
            printLine = "print(line(100,100));";
            break;
        case "curve":
            printLine = "print(curve(100,100,100));";
            break;
        default:
            console.log("Problem with " + buttonName);
    }
    inputBox.value += printLine;
}
let instructions = document.getElementById('goal');
let rewardBox = document.getElementById('reward-container');
let instrLabel = document.getElementById('instr-label');
//Map maintaining code last used at a checkpoint
let cpCode = new Map([
    ['l1c1', ""],
    ['l1c2', ""],
    ['l1c3', ""],
    ['l1c4', ""],
    ['l2c1', ""],
    ['l2c2', ""],
    ['l2c3', ""],
    ['l2c4', ""],
    ['l2c5', ""],
    ['l2c6', ""],
    ['l2c7', ""],
    ['l3c1', ""],
    ['l3c2', ""],
    ['l3c3', ""],
    ['l3c4', ""],
    ['l3c5', ""],
    ['l3c6', ""],
    ['l4c1', ""],
    ['l4c2', ""]
]);
//Map maintaining whether a checkpoint has been completed
let cpCompletion = new Map([
    ['l1c1', false],
    ['l1c2', false],
    ['l1c3', false],
    ['l1c4', false],
    ['l2c1', false],
    ['l2c2', false],
    ['l2c3', false],
    ['l2c4', false],
    ['l2c5', false],
    ['l2c6', false],
    ['l2c7', false],
    ['l3c1', false],
    ['l3c2', false],
    ['l3c3', false],
    ['l3c4', false],
    ['l3c5', false],
    ['l3c6', false],
    ['l4c1', false],
    ['l4c2', false]
]);
let checkpoints = new Map([
    ['l1c1', () => new index_3.LessonOneCpOne()],
    ['l1c2', () => new index_3.LessonOneCpTwo()],
    ['l1c3', () => new index_3.LessonOneCpThree()],
    ['l1c4', () => new index_3.LessonOneCpFour()],
    ['l2c1', () => new index_4.LessonTwoCpOne()],
    ['l2c2', () => new index_4.LessonTwoCpTwo()],
    ['l2c3', () => new index_4.LessonTwoCpThree()],
    ['l2c4', () => new index_4.LessonTwoCpFour()],
    ['l2c5', () => new index_4.LessonTwoCpFive()],
    ['l2c6', () => new index_4.LessonTwoCpSix()],
    ['l2c7', () => new index_4.LessonTwoCpSeven()],
    ['l3c1', () => new index_5.LessonThreeCpOne()],
    ['l3c2', () => new index_5.LessonThreeCpTwo()],
    ['l3c3', () => new index_5.LessonThreeCpThree()],
    ['l3c4', () => new index_5.LessonThreeCpFour()],
    ['l3c5', () => new index_5.LessonThreeCpFive()],
    ['l3c6', () => new index_5.LessonThreeCpSix()],
    ['l4c1', () => new index_6.LessonFourCpOne()],
    ['l4c2', () => new index_6.LessonFourCpTwo()]
]);
for (let cp of checkpoints.keys()) {
    let cpButton = document.getElementById(cp);
    cpButton.onclick = function () {
        initCheckpoint(cp);
    };
}
/**
 * Creates a module corresponding to a checkpoint passed in.
 * Sets up the instruction, CODE area, and goal box accordingly.
 * @param cp: the name of the checkpoint
 */
function initCheckpoint(cp) {
    if (checkpoints.has(cp)) {
        if (checkpoint != null) {
            cpCode.set(checkpoint._name, inputBox.value);
        }
        console.log("Initiating checkpoint " + cp);
        checkpoint = checkpoints.get(cp)();
        instrLabel.innerHTML = cp + " - INSTRUCTIONS";
        instructions.innerHTML = checkpoint._instructions;
        //set up the CODE and CANVAS areas
        if (checkpoint._constraint == 'code') {
            inputBox.setAttribute('disabled', 'disabled');
            inputBox.style.opacity = '0.5';
            canvas.style.pointerEvents = "auto";
            canvas.style.background = '#EBEBEB';
            canvasIsDisabled = false;
        }
        else if (checkpoint._constraint == 'canvas') {
            inputBox.removeAttribute('disabled');
            inputBox.style.opacity = '1.0';
            canvas.style.pointerEvents = "none";
            canvas.style.background = '#C0C0C0';
            canvasIsDisabled = true;
        }
        else {
            inputBox.removeAttribute('disabled');
            inputBox.style.opacity = '1.0';
            canvas.style.pointerEvents = "auto";
            canvas.style.background = '#EBEBEB';
            canvasIsDisabled = false;
        }
        let popUp = document.getElementById('popup');
        popUp.style.display = 'none';
        if (cpCode.get(checkpoint._name) !== "") {
            textBoxSelected = true;
            inputBox.value = cpCode.get(checkpoint._name);
        }
        //set up the instruction and goal boxes
        if (cpCompletion.get(cp)) {
            updateRewardBox();
        }
        else {
            if (checkpoint._starterCode != null) {
                textBoxSelected = true;
                inputBox.value = checkpoint._starterCode;
            }
            if (checkpoint._name === "l1c1") {
                checkpoint.renderInstruction(document);
            }
            rewardBox.style.background = '#C0C0C0';
            let reward = document.getElementById('reward-text');
            reward.style.color = 'black';
            reward.innerHTML = 'Complete goal to earn a star!';
            let rewardImg = document.getElementById('reward-image');
            rewardImg.src = 'pics/greystar.svg';
            rewardImg.alt = 'a star to be earned';
            let nextBtn = document.getElementById('next');
            nextBtn.style.display = 'none';
            instructions.scrollTop = 0;
            checkpointIsActive = true;
        }
    }
}
function checkpointChecksGoal() {
    if (checkpoint.checkGoal(document, effects)) {
        updateRewardBox();
        cpCompletion.set(checkpoint._name, true);
    }
}
function updateRewardBox() {
    rewardBox.style.background = '#673AB7';
    console.log(document);
    let rewardText = document.getElementById('reward-text');
    rewardText.style.color = '#D8D8D8';
    rewardText.innerHTML = 'Goal met!';
    let rewardImg = document.getElementById('reward-image');
    rewardImg.src = 'pics/star.svg';
    rewardImg.alt = 'star earned';
    let nextBtn = document.getElementById('next');
    nextBtn.style.display = 'block';
    instructions.innerHTML += "\nHooray! Goal met! Click 'Next' to proceed to next checkpoint!";
    instructions.scrollTop = instructions.scrollHeight;
    checkpointIsActive = false;
}
let nextButton = document.getElementById('next');
nextButton.onclick = function () {
    let nextModule = checkpoint._nextModule;
    if (nextModule != '') {
        initCheckpoint(nextModule);
    }
};
let prevButton = document.getElementById('prev');
prevButton.onclick = function () {
    let prevModule = checkpoint._prevModule;
    if (prevModule != '') {
        initCheckpoint(prevModule);
    }
};
//call to animate
animate();
//--------------------------------------------------------------
/* test lines of S.W.E.L.L. code

print("hello world", 180, 421);
print(ellipse(75, 50), 100, 100);
print(rect(60, 70), 250, 250);

print("hello");
print("world");

Our sample program
print("hello world");
print(ellipse(130, 100));
*/

},{"../../index":1,"space-lift":90}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const UnaryOperation_1 = require("./UnaryOperation");
const NumberNode_1 = require("../prims/NumberNode");
class NegOp extends UnaryOperation_1.UnaryOperation {
    /**
     * Constructor for a NegationOperation
     * @param val The value to be negated (must be a NumberNode)
     * @param ws Preceding whitespace
     */
    constructor(val, ws) {
        super(val);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the value into the negative version
     * @param context The current program context
     */
    eval(context) {
        let v = this.val.eval(context);
        return new NumberNode_1.NumberNode(-v.val, "");
    }
    /**
     * NegOps cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Negation ops cannot be drawn directly");
    }
    /**
     * Equals cannot be called directly on a NegOp
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on NegOp");
    }
    /**
     * Returns a string representation of the NegOp
     */
    toString() {
        return this._ws + "-" + this.val;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.NegOp = NegOp;

},{"../prims/NumberNode":64,"./UnaryOperation":80}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class UnaryOperation {
    /**
     * Abstract class constructor for Unary Operations
     * @param _val The object to be operated on
     */
    constructor(_val) {
        this._val = _val;
        this._newLine = false;
    }
    ;
    /**
     * Abstract draw method for undrawable UnaryOps
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Unary Operations cannot be drawn directly");
    }
    /**
     * Equals cannot be called directly on UnaryOps
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on UnaryOp");
    }
    ;
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the UnaryOp value
     */
    get val() {
        return this._val;
    }
    /**
     * Sets the UnaryOp value
     */
    set val(value) {
        this._val = value;
    }
}
exports.UnaryOperation = UnaryOperation;

},{}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class VariableNode {
    /**
     * Constructor for a VariableNode, a node representing a variable
     * @param name The variable name
     * @param ws Preceding whitespace
     */
    constructor(name, ws) {
        this._newLine = false;
        this._name = name;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Looks up the value of the variable in the context
     * @param context The current program context
     */
    eval(context) {
        return context.lookup(this._name, context);
    }
    /**
     * VariableNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw on variable nodes");
    }
    /**
     * Equals cannot be called directly on VariableNodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot directly compare vars, eval first");
    }
    /**
     * Returns a string representation of the VariableNode
     */
    toString() {
        return this._ws + this._name;
    }
    /**
     * Returns the name of the variable
     */
    get name() {
        return this._name;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.VariableNode = VariableNode;

},{}],82:[function(require,module,exports){
"use strict";
//--------------------------------------
//  Shallow update
//--------------------------------------
exports.__esModule = true;
/** Performs a shallow update of an object using a partial object of the same shape. A new object is returned. */
function update(host, spec) {
    var result = clone(host);
    for (var key in spec) {
        var specValue = spec[key];
        if (specValue === exports.DELETE) {
            delete result[key];
        }
        else {
            result[key] = specValue;
        }
    }
    return result;
}
exports.update = update;
// We lie about the public type so that only a property that is optional or that can be assigned to undefined can be DELETE'd
/** Marker used to delete a key */
exports.DELETE = {};
var _Updater = /** @class */ (function () {
    function _Updater(data) {
        this.data = data;
    }
    _Updater.prototype.at = function (keyOrIndex) {
        return new _Updater({ type: 'at', parent: this, field: keyOrIndex });
    };
    _Updater.prototype.set = function (value) {
        var _this = this;
        var doSet = function (target) {
            var result = _this.cloneForUpdate(target);
            if (result.name === 'aborted')
                return target;
            var clonedTarget = result.clonedTarget, leafHost = result.leafHost, field = result.field;
            value === exports.DELETE ? delete leafHost[field] : leafHost[field] = value;
            return clonedTarget;
        };
        var boundTarget = this.findBoundTarget();
        return boundTarget
            ? doSet(boundTarget)
            : doSet;
    };
    _Updater.prototype.modify = function (modifier) {
        var _this = this;
        var doModify = function (target) {
            var result = _this.cloneForUpdate(target);
            if (result.name === 'aborted')
                return target;
            var clonedTarget = result.clonedTarget, leafHost = result.leafHost, field = result.field;
            var value = modifier(leafHost[field]);
            value === exports.DELETE ? delete leafHost[field] : leafHost[field] = value;
            return clonedTarget;
        };
        var boundTarget = this.findBoundTarget();
        return boundTarget
            ? doModify(boundTarget)
            : doModify;
    };
    _Updater.prototype.withDefault = function (value) {
        return new _Updater({ type: 'withDefault', parent: this, defaultValue: value });
    };
    _Updater.prototype.abortIfUndef = function () {
        return new _Updater({ type: 'abortIfUndef', parent: this });
    };
    _Updater.prototype.findBoundTarget = function () {
        var current = this;
        while (true) {
            if (current.data.type === 'root')
                return current.data.boundTarget;
            current = current.data.parent;
        }
    };
    _Updater.prototype.parentUpdaters = function () {
        var updaters = [this];
        var parentUpdater = this.data.parent;
        // Ignore the root updater
        while (parentUpdater && parentUpdater.data.parent) {
            updaters.unshift(parentUpdater);
            parentUpdater = parentUpdater.data.parent;
        }
        return updaters;
    };
    _Updater.prototype.getNextValue = function (previousHost, host, field, isLast) {
        if (this.data.type === 'at') {
            var newField = this.data.field;
            var value_1 = host[newField];
            var nextValue = isObjectOrArray(value_1) ? clone(value_1) : value_1;
            var newHost_1 = isLast ? host : nextValue;
            host[this.data.field] = nextValue;
            return { host: newHost_1, field: newField };
        }
        var value = previousHost[field];
        if (this.data.type === 'abortIfUndef' && value === undefined) {
            return { host: host, field: field, aborted: true };
        }
        if (this.data.type === 'withDefault' && value === undefined) {
            var nextValue = this.data.defaultValue;
            var newHost_2 = isLast ? previousHost : nextValue;
            previousHost[field] = nextValue;
            return { host: newHost_2, field: field };
        }
        var newHost = isLast ? previousHost : host;
        return { host: newHost, field: field };
    };
    _Updater.prototype.cloneForUpdate = function (target) {
        var updaters = this.parentUpdaters();
        var obj = clone(target);
        var previousHost = obj;
        var host = obj;
        var field = '';
        for (var i = 0; i < updaters.length; i++) {
            var result = updaters[i].getNextValue(previousHost, host, field, i === updaters.length - 1);
            if (result.aborted)
                return { name: 'aborted' };
            previousHost = host;
            host = result.host;
            field = result.field;
        }
        return {
            name: 'result',
            clonedTarget: obj,
            leafHost: host,
            field: field
        };
    };
    return _Updater;
}());
function isObjectOrArray(obj) {
    return obj !== null && typeof obj === 'object';
}
function clone(obj) {
    if (Array.isArray(obj))
        return obj.slice();
    var cloned = {};
    Object.keys(obj).forEach(function (key) { cloned[key] = obj[key]; });
    return cloned;
}
function deepUpdate(target) {
    return new _Updater({ type: 'root', boundTarget: target });
}
exports.deepUpdate = deepUpdate;

},{}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CharUtil;
(function (CharUtil) {
    class CharStream {
        constructor(s, startpos, endpos, hasEOF) {
            this.hasEOF = true;
            this.input = s;
            if (hasEOF != undefined) {
                this.hasEOF = hasEOF;
            }
            if (startpos == undefined) {
                this.startpos = 0; // not specified; set default
            }
            else if (startpos > s.length) {
                this.startpos = s.length; // seek too far; set EOF
            }
            else {
                this.startpos = startpos; // specified and in bounds
            }
            if (endpos == undefined) {
                this.endpos = s.length; // not specified; set default
            }
            else if (endpos > s.length) {
                this.endpos = s.length; // seek too far; set EOF
            }
            else {
                this.endpos = endpos; // specified and in bounds
            }
            if (this.startpos > this.endpos) {
                this.startpos = this.endpos; // if the user flipped positions
            }
        }
        /**
         * Returns true of the end of the input has been reached.
         */
        isEOF() {
            return this.hasEOF && this.startpos == this.input.length;
        }
        /**
         * Returns a Javscript primitive string of the slice of input
         * represented by this CharStream.
         */
        toString() {
            return this.input.substring(this.startpos, this.endpos);
        }
        /**
         * Returns a new CharStream representing the input from the
         * current start position to an end position num chars from
         * the current start position.  If startpos + num > endpos,
         * the current CharStream is returned.
         * @param num
         */
        peek(num) {
            if (this.startpos + num > this.endpos) {
                return this;
            }
            else {
                let newHasEOF = this.startpos + num == this.endpos && this.hasEOF;
                return new CharStream(this.input, this.startpos, this.startpos + num, newHasEOF);
            }
        }
        /**
         * Returns a new CharStream representing the string after
         * seeking num characters from the current position.
         * @param num
         */
        seek(num) {
            if (this.startpos + num > this.endpos) {
                return new CharStream(this.input, this.endpos, this.endpos, this.hasEOF);
            }
            else {
                return new CharStream(this.input, this.startpos + num, this.endpos, this.hasEOF);
            }
        }
        /**
         * Returns a new CharStream representing the head of the input at
         * the current position.  Throws an exception if the CharStream is
         * empty.
         */
        head() {
            if (!this.isEmpty()) {
                const newHasEOF = this.startpos + 1 == this.endpos && this.hasEOF;
                return new CharStream(this.input, this.startpos, this.startpos + 1, newHasEOF);
            }
            else {
                throw new Error("Cannot get the head of an empty string.");
            }
        }
        /**
         * Returns a new CharStream representing the tail of the input at
         * the current position.  Throws an exception if the CharStream is
         * empty.
         */
        tail() {
            if (!this.isEmpty()) {
                return new CharStream(this.input, this.startpos + 1, this.endpos, this.hasEOF);
            }
            else {
                throw new Error("Cannot get the tail of an empty string.");
            }
        }
        /**
         * Returns true if the input at the current position is empty. Note
         * that a CharStream at the end of the input contains an empty
         * string but that an empty string may not be the end-of-file (i.e.,
         * isEOF is false).
         */
        isEmpty() {
            return this.startpos == this.endpos;
        }
        /**
         * Returns the number of characters remaining at
         * the current position.
         */
        length() {
            return this.endpos - this.startpos;
        }
        /**
         * Returns the substring between start and end at the
         * current position.
         * @param start the start index of the substring, inclusive
         * @param end the end index of the substring, exclusive
         */
        substring(start, end) {
            const start2 = this.startpos + start;
            const end2 = this.startpos + end;
            const newHasEOF = this.endpos == end2 && this.hasEOF;
            return new CharStream(this.input, start2, end2, newHasEOF);
        }
        /**
         * Returns the concatenation of the current CharStream with
         * the given CharStream. Note: returned object does not
         * reuse original input string, and startpos and endpos
         * are reset. If the given CharStream contains EOF, the
         * concatenated CharStream will also contain EOF.
         * @param cs the CharStream to concat to this CharStream
         */
        concat(cs) {
            const s = this.toString() + cs.toString();
            return new CharStream(s, 0, s.length, cs.hasEOF);
        }
        /**
         * Concatenate an array of CharStream objects into a single
         * CharStream object.
         * @param css a CharStream[]
         */
        static concat(css) {
            if (css.length == 0) {
                return new CharStream("", 0, 0, false);
            }
            else {
                let cs = css[0];
                for (let i = 1; i < css.length; i++) {
                    cs = cs.concat(css[i]);
                }
                return cs;
            }
        }
    }
    CharUtil.CharStream = CharStream;
})(CharUtil = exports.CharUtil || (exports.CharUtil = {}));

},{}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var primitives_1 = require("./primitives");
exports.Primitives = primitives_1.Primitives;
var charstream_1 = require("./charstream");
exports.CharUtil = charstream_1.CharUtil;

},{"./charstream":83,"./primitives":85}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const charstream_1 = require("./charstream");
var Primitives;
(function (Primitives) {
    class EOFMark {
        constructor() { }
        static get Instance() {
            return this._instance || (this._instance = new this());
        }
    }
    Primitives.EOFMark = EOFMark;
    Primitives.EOF = EOFMark.Instance;
    /**
     * Represents a successful parse.
     */
    class Success {
        /**
         * Returns an object representing a successful parse.
         * @param istream The remaining string.
         * @param res The result of the parse
         */
        constructor(istream, res) {
            this.tag = "success";
            this.inputstream = istream;
            this.result = res;
        }
    }
    Primitives.Success = Success;
    /**
     * Represents a failed parse.
     */
    class Failure {
        /**
         * Returns an object representing a failed parse.
         * @param istream The string, unmodified, that was given to the parser.
         */
        constructor(istream) {
            this.tag = "failure";
            this.inputstream = istream;
        }
    }
    Primitives.Failure = Failure;
    /**
     * result succeeds without consuming any input, and returns v.
     * @param v The result of the parse.
     */
    function result(v) {
        return (istream) => new Success(istream, v);
    }
    Primitives.result = result;
    /**
     * zero fails without consuming any input.
     */
    function zero() {
        return (istream) => new Failure(istream);
    }
    Primitives.zero = zero;
    /**
     * item successfully consumes the first character if the input
     * string is non-empty, otherwise it fails.
     */
    function item() {
        return (istream) => {
            if (istream.isEmpty()) {
                return new Failure(istream);
            }
            else {
                return new Success(istream.tail(), istream.head());
            }
        };
    }
    Primitives.item = item;
    /**
     * bind is a curried function that takes a parser p and returns
     * a function that takes a parser f which returns the composition
     * of p and f.  If _any_ of the parsers fail, the original inputstream
     * is returned in the Failure object (i.e., bind backtracks).
     * @param p A parser
     */
    function bind(p) {
        return (f) => {
            return (istream) => {
                let r = p(istream);
                switch (r.tag) {
                    case "success":
                        let o = f(r.result)(r.inputstream);
                        switch (o.tag) {
                            case "success": return o;
                            case "failure":
                                // note: backtracks, returning original istream
                                return new Failure(istream);
                        }
                    case "failure": return new Failure(istream);
                }
            };
        };
    }
    Primitives.bind = bind;
    function delay(p) {
        return () => p;
    }
    Primitives.delay = delay;
    /**
     * seq is a curried function that takes a parser p, a parser q,
     * and a function f. It applies p to the input, passing the
     * remaining input stream to q; q is then applied.  The function
     * f takes the result of p and q, as a tuple, and returns
     * a single result.
     * @param p A parser
     */
    // export let seq = function<T,U,V>(p: IParser<T>) {
    //     return (q: IParser<U>) => {
    //         return (f: (e: [T,U]) => V) => {
    //             return bind<T,V>(p)((x) => {
    //                 return bind<U,V>(q)((y) => {
    //                     let tup : [T,U] = [x,y];
    //                     return result<V>(f(tup));
    //                 });
    //             });
    //         }
    //     };
    // }
    function seq(p) {
        return (q) => {
            return (f) => {
                return bind(p)((x) => {
                    return bind(q)((y) => {
                        let tup = [x, y];
                        return result(f(tup));
                    });
                });
            };
        };
    }
    Primitives.seq = seq;
    /**
     * sat takes a predicate and yields a parser that consumes a
     * single character if the character satisfies the predicate,
     * otherwise it fails.
     * @param pred a character predicate
     */
    function sat(pred) {
        let pred2 = (cs) => pred(cs.toString());
        let a = item();
        let b = (x) => {
            if (pred2(x)) {
                return result(x);
            }
            else {
                return zero();
            }
        };
        return bind(a)(b);
    }
    Primitives.sat = sat;
    /**
     * char takes a character and yields a parser that consume
     * that character. The returned parser succeeds if the next
     * character in the input stream is c, otherwise it fails.
     * @param c
     */
    function char(c) {
        if (c.length != 1) {
            throw new Error("char parser takes a string of length 1 (i.e., a char)");
        }
        return sat(x => x == c);
    }
    Primitives.char = char;
    /**
     * letter returns a parser that consumes a single alphabetic
     * character, from a-z, regardless of case.
     */
    function letter() {
        let contains_letter = (x) => {
            let a_letter = /[A-Za-z]/;
            return x.match(a_letter) != undefined;
        };
        return sat(contains_letter);
    }
    Primitives.letter = letter;
    /**
     * digit returns a parser that consumes a single numeric
     * character, from 0-9.  Note that the type of the result
     * is a string, not a number.
     */
    function digit() {
        return sat(x => x == "0"
            || x == "1"
            || x == "2"
            || x == "3"
            || x == "4"
            || x == "5"
            || x == "6"
            || x == "7"
            || x == "8"
            || x == "9");
    }
    Primitives.digit = digit;
    /**
     * upper returns a parser that consumes a single character
     * if that character is uppercase.
     */
    function upper() {
        return (istream) => {
            let o1 = letter()(istream);
            switch (o1.tag) {
                case "success":
                    let o2 = sat(x => x == x.toUpperCase())(o1.result);
                    switch (o2.tag) {
                        case "success":
                            return o1;
                        case "failure":
                            return new Failure(istream);
                    }
                    break;
                case "failure":
                    return o1;
            }
            throw new Error("never happens");
        };
    }
    Primitives.upper = upper;
    /**
     * lower returns a parser that consumes a single character
     * if that character is lowercase.
     */
    function lower() {
        return (istream) => {
            let o1 = letter()(istream);
            switch (o1.tag) {
                case "success":
                    let o2 = sat(x => x == x.toLowerCase())(o1.result);
                    switch (o2.tag) {
                        case "success":
                            return o1;
                        case "failure":
                            return new Failure(istream);
                    }
                    break;
                case "failure":
                    return o1;
            }
            throw new Error("never happens");
        };
    }
    Primitives.lower = lower;
    /**
     * choice specifies an ordered choice between two parsers,
     * p1 and p2. The returned parser will first apply
     * parser p1.  If p1 succeeds, p1's Outcome is returned.
     * If p1 fails, p2 is applied and the Outcome of p2 is returned.
     * Note that the input stream given to p1 and p2 is exactly
     * the same input stream.
     * @param p1 A parser.
     */
    function choice(p1) {
        return (p2) => {
            return (istream) => {
                let o = p1(istream);
                switch (o.tag) {
                    case "success":
                        return o;
                    case "failure":
                        return p2(istream);
                }
            };
        };
    }
    Primitives.choice = choice;
    /**
     * appfun allows the user to apply a function f to
     * the result of a parser p, assuming that p is successful.
     * @param p A parser.  This is the same as the |>>
     * function from FParsec.
     */
    function appfun(p) {
        return (f) => {
            return (istream) => {
                let o = p(istream);
                switch (o.tag) {
                    case "success":
                        return new Success(o.inputstream, f(o.result));
                    case "failure":
                        return o;
                }
            };
        };
    }
    Primitives.appfun = appfun;
    /**
     * many repeatedly applies the parser p until p fails. many always
     * succeeds, even if it matches nothing.  many tries to guard
     * against an infinite loop by raising an exception if p succeeds
     * without changing the parser state.
     * @param p
     */
    function many(p) {
        return (istream) => {
            let istream2 = istream;
            let outputs = [];
            let succeeds = true;
            while (!istream2.isEmpty() && succeeds) {
                let o = p(istream2);
                switch (o.tag) {
                    case "success":
                        if (istream2 == o.inputstream) {
                            throw new Error("Parser loops infinitely.");
                        }
                        istream2 = o.inputstream;
                        outputs.push(o.result);
                        break;
                    case "failure":
                        succeeds = false;
                        break;
                }
            }
            return new Success(istream2, outputs);
        };
    }
    Primitives.many = many;
    /**
     * many1 repeatedly applies the parser p until p fails. many1 must
     * succeed at least once.  many1 tries to guard against an infinite
     * loop by raising an exception if p succeeds without changing the
     * parser state.
     * @param p
     */
    function many1(p) {
        return (istream) => {
            return seq(p)(many(p))(tup => {
                let hd = tup["0"];
                let tl = tup["1"];
                tl.unshift(hd);
                return tl;
            })(istream);
        };
    }
    Primitives.many1 = many1;
    /**
     * str yields a parser for the given string.
     * @param s A string
     */
    // TODO: this should actually be a sequence of parsers constructed
    // from the string s
    function str(s) {
        return (istream) => {
            // escape regex metacharacters
            // (this likely needs work)
            let s2 = s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
            let re = new RegExp("^" + s2);
            if (istream.toString().match(re)) {
                const rem = istream.substring(s.length, istream.length());
                const res = istream.substring(0, s.length);
                return new Success(rem, res);
            }
            else {
                return new Failure(istream);
            }
        };
    }
    Primitives.str = str;
    /**
     * Returns a parser that succeeds only if the end of the
     * input has been reached.
     */
    function eof() {
        return (istream) => {
            if (istream.isEOF()) {
                return new Success(istream, Primitives.EOF);
            }
            else {
                return new Failure(istream);
            }
        };
    }
    Primitives.eof = eof;
    /**
     * fresult returns a parser that applies the parser p,
     * and if p succeeds, returns the value x.
     * @param p a parser
     */
    function fresult(p) {
        return (x) => {
            return (istream) => {
                return bind(p)((t) => result(x))(istream);
            };
        };
    }
    Primitives.fresult = fresult;
    /**
     * left returns a parser that applies the parser p,
     * then the parser q, and if both are successful,
     * returns the result of p.
     * @param p a parser
     */
    function left(p) {
        return (q) => {
            return (istream) => {
                return bind(p)((t) => fresult(q)(t))(istream);
            };
        };
    }
    Primitives.left = left;
    /**
     * right returns a parser that applies the parser p,
     * then the parser q, and if both are successful,
     * returns the result of q.
     * @param p a parser
     */
    function right(p) {
        return (q) => {
            return (istream) => {
                return bind(p)(_ => q)(istream);
            };
        };
    }
    Primitives.right = right;
    /**
     * between returns a parser that applies the parser
     * popen, p, and pclose in sequence, and if all are
     * successful, returns the result of p.
     * @param popen the first parser
     */
    function between(popen) {
        return (pclose) => {
            return (p) => {
                let l = left(p)(pclose);
                let r = right(popen)(l);
                return r;
            };
        };
    }
    Primitives.between = between;
    /**
     * The debug parser takes a parser p and a debug string,
     * printing the debug string as a side-effect before
     * applying p to the input.
     * @param p a parser
     */
    function debug(p) {
        return (label) => {
            return (istream) => {
                console.log("apply: " + label);
                let o = p(istream);
                switch (o.tag) {
                    case "success":
                        console.log("success: " + label + ", startpos: " + istream.startpos + ", endpos: " + istream.endpos);
                        break;
                    case "failure":
                        console.log("failure: " + label + ", startpos: " + istream.startpos + ", endpos: " + istream.endpos);
                        break;
                }
                return o;
            };
        };
    }
    Primitives.debug = debug;
    let wschars = choice(sat(c => c == ' ' || c == '\t'))(nl());
    /**
     * ws matches zero or more of the following whitespace characters:
     * ' ', '\t', '\n', or '\r\n'
     * ws returns matched whitespace in a single CharStream result.
     */
    function ws() {
        return (istream) => {
            let o = many(wschars)(istream);
            switch (o.tag) {
                case "success":
                    return new Success(o.inputstream, charstream_1.CharUtil.CharStream.concat(o.result));
                // ws never fails
            }
        };
    }
    Primitives.ws = ws;
    /**
     * ws1 matches one or more of the following whitespace characters:
     * ' ', '\t', '\n', or '\r\n'
     * ws1 returns matched whitespace in a single CharStream result.
     */
    function ws1() {
        return (istream) => {
            let o = many1(wschars)(istream);
            switch (o.tag) {
                case "success":
                    return new Success(o.inputstream, charstream_1.CharUtil.CharStream.concat(o.result));
                case "failure":
                    return o;
            }
        };
    }
    Primitives.ws1 = ws1;
    /**
     * nl matches and returns a newline.
     */
    function nl() {
        return Primitives.choice(Primitives.str("\n"))(Primitives.str("\r\n"));
    }
    Primitives.nl = nl;
    function groupBy(list, keyGetter) {
        let m = new Map();
        list.forEach((item) => {
            const key = keyGetter(item);
            if (!m.has(key)) {
                m.set(key, []);
            }
            let collection = m.get(key);
            collection.push(item);
        });
        return m;
    }
    function strSat(strs) {
        // sort strings first by length, and then lexicograpically;
        // slice() called here so as not to modify original array
        let smap = groupBy(strs, s => s.length);
        let sizes = [];
        // find size classes;
        // also sort each set of equivalent-length values
        smap.forEach((vals, key, m) => {
            sizes.push(key);
            vals.sort();
        });
        sizes.sort();
        return (istream) => {
            // start with the smallest size class       
            for (let peekIndex = 0; peekIndex < sizes.length; peekIndex++) {
                // for each size class, try matching all of
                // the strings; if one is found, return the
                // appropriate CharStream; if not, fail.
                let peek = istream.peek(sizes[peekIndex]);
                let tail = istream.seek(sizes[peekIndex]);
                let candidates = smap.get(sizes[peekIndex]);
                for (let cIndex = 0; cIndex < candidates.length; cIndex++) {
                    if (candidates[cIndex] === peek.toString()) {
                        return new Success(tail, peek);
                    }
                }
            }
            return new Failure(istream);
        };
    }
    Primitives.strSat = strSat;
})(Primitives = exports.Primitives || (exports.Primitives = {}));

},{"./charstream":83}],86:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
/**
 * Converts an Array-like object (such as an arguments or NodeList instance) to a regular Array
 */
function fromArrayLike(arrayLike) {
    return new lift_1.ArrayOps([].slice.call(arrayLike));
}
exports.fromArrayLike = fromArrayLike;

},{"../lift":91}],87:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
/*
* Returns a number[] wrapper with all numbers from start to stop (inclusive),
* incremented or decremented by step.
*/
function range(start, stop, step) {
    if (arguments.length === 1) {
        stop = arguments[0] - 1;
        start = 0;
    }
    step = step || 1;
    var result = [];
    var increasing = step > 0;
    var next = start;
    while ((increasing && next <= stop) || (!increasing && next >= stop)) {
        result.push(next);
        next = next + step;
    }
    return new lift_1.ArrayOps(result);
}
exports.range = range;

},{"../lift":91}],88:[function(require,module,exports){
"use strict";
exports.__esModule = true;
function tuple(arr) {
    return arr;
}
exports.tuple = tuple;

},{}],89:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var is_1 = require("../object/is");
var currentMemoId = 0;
/**
 * Memoizes a function of arbitrary arity.
 * This has two main uses:
 *   1) Reducing the CPU time taken by expensive calculations at the cost of some memory overhead
 *   2) Producing stable references for a given set of arguments. Useful when relying on reference equality.
 *
 * Memoized functions keep internal state. If you wish to clear that state entirely, you can recreate the function.
 */
function memoize(fun, options) {
    // The unique property name used by this memoize function instance.
    // This is used to store the id/reference of object arguments, as Weak maps/sets are very limited.
    var memoKey = "__memo__" + currentMemoId++;
    var lastArgKeys = [];
    var cacheSize = (options && options.cacheSize) || 30;
    var keyFunction = options && options.key;
    // The unique ids/references of objects inside the arityNCache cache
    var objId = 0;
    var arity0Cache;
    var arityNCache;
    var keyCache;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // 0 arguments edge-case
        if (args.length === 0) {
            if (!arity0Cache)
                arity0Cache = fun();
            return arity0Cache;
        }
        // custom key function
        else if (keyFunction) {
            keyCache = keyCache || {};
            var key = keyFunction.apply(null, args);
            var result = keyCache[key];
            if (!result) {
                lastArgKeys.push(key);
                limitCacheSize(keyCache, lastArgKeys, cacheSize);
                result = keyCache[key] = fun.apply(null, args);
            }
            return result;
        }
        // N arguments
        else {
            arityNCache = arityNCache || {};
            var key = '';
            for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                var argKey = void 0;
                if (is_1.object(arg)) {
                    argKey = arg[memoKey];
                    if (!argKey) {
                        // Non enumerable
                        Object.defineProperty(arg, memoKey, { value: "obj" + objId++ });
                        argKey = arg[memoKey];
                    }
                }
                else {
                    argKey = arg;
                }
                key += (argKey + '_');
            }
            var result = arityNCache[key];
            if (!result) {
                lastArgKeys.push(key);
                limitCacheSize(arityNCache, lastArgKeys, cacheSize);
                result = arityNCache[key] = fun.apply(null, args);
            }
            return result;
        }
    };
}
exports.memoize = memoize;
function limitCacheSize(cache, lastArgKeys, size) {
    if (lastArgKeys.length === size + 1) {
        var key = lastArgKeys.shift();
        delete cache[key];
    }
}

},{"../object/is":92}],90:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("./lift");
exports["default"] = lift_1["default"];
var lift_2 = require("./lift");
exports.ArrayOps = lift_2.ArrayOps;
exports.ObjectOps = lift_2.ObjectOps;
exports.NumberOps = lift_2.NumberOps;
exports.StringOps = lift_2.StringOps;
exports.DateOps = lift_2.DateOps;
exports.getValue = lift_2.getValue;
var immupdate_1 = require("immupdate");
exports.update = immupdate_1.update;
exports.deepUpdate = immupdate_1.deepUpdate;
exports.DELETE = immupdate_1.DELETE;
var option_1 = require("./option");
exports.Option = option_1.Option;
exports.None = option_1.None;
exports.Some = option_1.Some;
var result_1 = require("./result");
exports.Result = result_1.Result;
exports.Ok = result_1.Ok;
exports.Err = result_1.Err;
var range_1 = require("./array/range");
exports.range = range_1.range;
var fromArrayLike_1 = require("./array/fromArrayLike");
exports.fromArrayLike = fromArrayLike_1.fromArrayLike;
var tuple_1 = require("./array/tuple");
exports.tuple = tuple_1.tuple;
var set_1 = require("./object/set");
exports.Set = set_1.Set;
var memoize_1 = require("./function/memoize");
exports.memoize = memoize_1.memoize;
var isType = require("./object/is");
exports.is = isType;

},{"./array/fromArrayLike":86,"./array/range":87,"./array/tuple":88,"./function/memoize":89,"./lift":91,"./object/is":92,"./object/set":93,"./option":94,"./result":95,"immupdate":82}],91:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift = function (obj) {
    if (obj instanceof Array)
        return new exports.ArrayOps(obj);
    if (obj instanceof Date)
        return new exports.DateOps(obj);
    if (typeof obj === 'string')
        return new exports.StringOps(obj);
    if (typeof obj === 'number')
        return new exports.NumberOps(obj);
    return new exports.ObjectOps(obj);
};
exports["default"] = lift;
function getValue(input) {
    return input && input['_isLiftWrapper']
        ? input.value()
        : input;
}
exports.getValue = getValue;
function makeOps() {
    var Ops = /** @class */ (function () {
        function Ops(_value) {
            this._value = _value;
            this._isLiftWrapper = true;
        }
        Ops.prototype.value = function () { return this._value; };
        return Ops;
    }());
    return Ops;
}
exports.ArrayOps = makeOps();
exports.ObjectOps = makeOps();
exports.NumberOps = makeOps();
exports.StringOps = makeOps();
exports.DateOps = makeOps();

},{}],92:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/** Returns whether an object is an Array */
exports.array = Array.isArray;
/** Returns whether this object is a function */
function func(obj) {
    return (typeof obj === 'function');
}
exports.func = func;
/** Returns whether this object is a string */
function string(obj) {
    return (typeof obj === 'string');
}
exports.string = string;
/** Returns whether this object is a number */
function number(obj) {
    return (typeof obj === 'number');
}
exports.number = number;
/** Returns whether this object is a boolean */
function boolean(obj) {
    return (typeof obj === 'boolean');
}
exports.boolean = boolean;
/** Returns whether this value is an object (e.g not a primitive: dates, arrays, functions, objects, regexes, `new Number(0)`, and `new String('')) */
function object(obj) {
    var type = typeof obj;
    return (type == 'object' || type == 'function');
}
exports.object = object;

},{}],93:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
/**
 * Creates a Set-like object (string keys, true values) from a list of keys
 */
function Set() {
    var keys = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        keys[_i] = arguments[_i];
    }
    var result = {};
    keys.forEach(function (key) { return result[key] = true; });
    return new lift_1.ObjectOps(result);
}
exports.Set = Set;

},{"../lift":91}],94:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
// The Option factory / static object
var OptionObject = function (value) {
    return isDef(value) ? Some(value) : exports.None;
};
OptionObject.all = function (arr) {
    var values = [];
    for (var i = 0; i < arr.length; i++) {
        var value = arr[i];
        if (exports.Option.isOption(value))
            value = value.get();
        if (!isDef(value))
            return exports.None;
        values.push(value);
    }
    return Some(values);
};
OptionObject.isOption = function (value) {
    return !!value && (value.type === 'some' || value.type === 'none');
};
function makeNone() {
    var self = {};
    function returnNone() { return exports.None; }
    self.type = 'none';
    self.get = function () { return undefined; };
    self.isDefined = function () { return false; };
    self.forEach = function () { };
    self.map = returnNone;
    self.flatMap = returnNone;
    self.filter = returnNone;
    self.fold = function (ifEmpty) { return ifEmpty(); };
    self.orElse = function (alt) { return alt(); };
    self.getOrElse = function (alt) { return alt; };
    self.toArray = function () { return lift_1["default"]([]); };
    self.toString = function () { return 'None'; };
    self.toJSON = function () { return null; };
    return self;
}
function _Some(value) {
    this.value = value;
}
_Some.prototype = {
    type: 'some',
    get: function () {
        return this.value;
    },
    isDefined: function () {
        return true;
    },
    forEach: function (fn) {
        fn(this.value);
    },
    map: function (fn) {
        return exports.Option(lift_1.getValue(fn(this.value)));
    },
    flatMap: function (fn) {
        return fn(this.value);
    },
    filter: function (fn) {
        return fn(this.value) ? this : exports.None;
    },
    fold: function (ifEmpty, ifDefined) {
        return ifDefined(this.value);
    },
    orElse: function () {
        return this;
    },
    getOrElse: function () {
        return this.value;
    },
    toArray: function () {
        return lift_1["default"]([this.value]);
    },
    toString: function () {
        return "Some(" + this.value + ")";
    },
    toJSON: function () {
        return this.value;
    }
};
function isDef(value) {
    return value !== null && value !== undefined;
}
exports.Option = OptionObject;
/** Creates a new Some instance using a non nullable value */
// extends {} to prevent null and undefined being passed
function Some(value) {
    return new _Some(value);
}
exports.Some = Some;
exports.None = makeNone();

},{"../lift":91}],95:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
var ResultObject = {};
ResultObject.all = function (arr) {
    var okValues = [];
    var currentResult;
    for (var i = 0; i < arr.length; i++) {
        var currentResult_1 = arr[i];
        if (!currentResult_1.isOk())
            return currentResult_1;
        okValues.push(currentResult_1.get());
    }
    return Ok(okValues);
};
ResultObject.isResult = function (value) {
    return !!value && (value.type === 'ok' || value.type === 'err');
};
function _Ok(value) {
    this._value = value;
}
_Ok.prototype = {
    type: 'ok',
    isOk: function () {
        return true;
    },
    map: function (fn) {
        return Ok(lift_1.getValue(fn(this._value)));
    },
    mapError: function (fn) {
        return this;
    },
    flatMap: function (fn) {
        return fn(this._value);
    },
    fold: function (ifErr, ifOk) {
        return ifOk(this._value);
    },
    toString: function () {
        return "Ok(" + this._value + ")";
    },
    get: function () {
        return this._value;
    }
};
function _Err(error) {
    this._error = error;
}
_Err.prototype = {
    type: 'err',
    isOk: function () {
        return false;
    },
    map: function (fn) {
        return this;
    },
    mapError: function (fn) {
        return Err(fn(this._error));
    },
    flatMap: function (fn) {
        return this;
    },
    fold: function (ifErr, ifOk) {
        return ifErr(this._error);
    },
    toString: function () {
        return "Err(" + this._error + ")";
    },
    get: function () {
        return this._error;
    }
};
exports.Result = ResultObject;
function Ok(value) {
    return new _Ok(value);
}
exports.Ok = Ok;
function Err(error) {
    return new _Err(error);
}
exports.Err = Err;

},{"../lift":91}]},{},[78])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImRpc3QvaW5kZXguanMiLCJkaXN0L2xpYi9iaW5vcHMvQXNzaWduT3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvQmluYXJ5T3BlcmF0aW9uLmpzIiwiZGlzdC9saWIvYmlub3BzL0RlY2xhcmVPcC5qcyIsImRpc3QvbGliL2Jpbm9wcy9EZWNyZW1lbnQuanMiLCJkaXN0L2xpYi9iaW5vcHMvRGl2T3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvSW5jcmVtZW50LmpzIiwiZGlzdC9saWIvYmlub3BzL01pbnVzT3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvTXVsT3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvUGx1c09wLmpzIiwiZGlzdC9saWIvY29uZGl0aW9uYWxzL0NvbmRpdGlvbmFsLmpzIiwiZGlzdC9saWIvZWZmZWN0cy9DdXJ2ZUVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvRWxsaXBzZUVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvRXBoRWZmZWN0LmpzIiwiZGlzdC9saWIvZWZmZWN0cy9MaW5lRWZmZWN0LmpzIiwiZGlzdC9saWIvZWZmZWN0cy9OdW1iZXJFZmZlY3QuanMiLCJkaXN0L2xpYi9lZmZlY3RzL1JlY3RhbmdsZUVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvU3RyaW5nRWZmZWN0LmpzIiwiZGlzdC9saWIvZnVuaG91c2UvRnVuQXBwLmpzIiwiZGlzdC9saWIvZnVuaG91c2UvRnVuRGVmLmpzIiwiZGlzdC9saWIvbGlzdHMvTGlzdE5vZGUuanMiLCJkaXN0L2xpYi9sb2dnaW5nL0NsZWFyRXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL0NsaWNrRXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL0RyYWdFdmVudC5qcyIsImRpc3QvbGliL2xvZ2dpbmcvSURFdmVudC5qcyIsImRpc3QvbGliL2xvZ2dpbmcvTG9nRXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL1BhaW50RXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL1Jlc2l6ZUV2ZW50LmpzIiwiZGlzdC9saWIvbG9nZ2luZy9TZWxlY3RFdmVudC5qcyIsImRpc3QvbGliL2xvZ2ljL0FuZC5qcyIsImRpc3QvbGliL2xvZ2ljL0VxdWFscy5qcyIsImRpc3QvbGliL2xvZ2ljL0dyZWF0ZXJUaGFuLmpzIiwiZGlzdC9saWIvbG9naWMvR3JlYXRlclRoYW5FcS5qcyIsImRpc3QvbGliL2xvZ2ljL0xlc3NUaGFuLmpzIiwiZGlzdC9saWIvbG9naWMvTGVzc1RoYW5FcS5qcyIsImRpc3QvbGliL2xvZ2ljL05vdC5qcyIsImRpc3QvbGliL2xvZ2ljL05vdEVxdWFsLmpzIiwiZGlzdC9saWIvbG9naWMvT3IuanMiLCJkaXN0L2xpYi9sb29wcy9Gb3JOb2RlLmpzIiwiZGlzdC9saWIvbG9vcHMvV2hpbGVOb2RlLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9JbnN0cnVjdGlvbi5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uRm91ckNwT25lLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Gb3VyQ3BUd28uanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3Nvbk9uZUNwRm91ci5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uT25lQ3BPbmUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3Nvbk9uZUNwVGhyZWUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3Nvbk9uZUNwVHdvLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25UaHJlZUNwRml2ZS5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcEZvdXIuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BPbmUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BTaXguanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BUaHJlZS5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFR3by5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVHdvQ3BGaXZlLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Ud29DcEZvdXIuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwT25lLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFNldmVuLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFNpeC5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVHdvQ3BUaHJlZS5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVHdvQ3BUd28uanMiLCJkaXN0L2xpYi9wYXJzZXIvcGFyc2VyLmpzIiwiZGlzdC9saWIvcHJpbXMvQm9vbGVhbk5vZGUuanMiLCJkaXN0L2xpYi9wcmltcy9OT1AuanMiLCJkaXN0L2xpYi9wcmltcy9OdW1iZXJOb2RlLmpzIiwiZGlzdC9saWIvcHJpbXMvU3RyaW5nTm9kZS5qcyIsImRpc3QvbGliL3NoYXBlcy9Db2xvck5vZGUuanMiLCJkaXN0L2xpYi9zaGFwZXMvQ3VydmVOb2RlLmpzIiwiZGlzdC9saWIvc2hhcGVzL0VsbGlwc2VOb2RlLmpzIiwiZGlzdC9saWIvc2hhcGVzL0VwaE5vZGUuanMiLCJkaXN0L2xpYi9zaGFwZXMvTGluZU5vZGUuanMiLCJkaXN0L2xpYi9zaGFwZXMvUmVjdGFuZ2xlTm9kZS5qcyIsImRpc3QvbGliL3N0cnVjdHVyYWwvRGltZW5zaW9ucy5qcyIsImRpc3QvbGliL3N0cnVjdHVyYWwvUHJpbnROb2RlLmpzIiwiZGlzdC9saWIvc3RydWN0dXJhbC9SZXR1cm4uanMiLCJkaXN0L2xpYi9zdHJ1Y3R1cmFsL1JldHVybkVycm9yLmpzIiwiZGlzdC9saWIvc3RydWN0dXJhbC9TY29wZS5qcyIsImRpc3QvbGliL3N0cnVjdHVyYWwvU2VxdWVuY2VOb2RlLmpzIiwiZGlzdC9saWIvdWkvdWkuanMiLCJkaXN0L2xpYi91bm9wcy9OZWdPcC5qcyIsImRpc3QvbGliL3Vub3BzL1VuYXJ5T3BlcmF0aW9uLmpzIiwiZGlzdC9saWIvdmFycy9WYXJpYWJsZU5vZGUuanMiLCJub2RlX21vZHVsZXMvaW1tdXBkYXRlL2NvbW1vbmpzL2ltbXVwZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9wYW50cy9saWIvY2hhcnN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9wYW50cy9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFudHMvbGliL3ByaW1pdGl2ZXMuanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9hcnJheS9mcm9tQXJyYXlMaWtlLmpzIiwibm9kZV9tb2R1bGVzL3NwYWNlLWxpZnQvY29tbW9uanMvYXJyYXkvcmFuZ2UuanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9hcnJheS90dXBsZS5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL2Z1bmN0aW9uL21lbW9pemUuanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL2xpZnQuanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9vYmplY3QvaXMuanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9vYmplY3Qvc2V0LmpzIiwibm9kZV9tb2R1bGVzL3NwYWNlLWxpZnQvY29tbW9uanMvb3B0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NwYWNlLWxpZnQvY29tbW9uanMvcmVzdWx0L2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3J3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2h2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9qQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNydkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9wQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25kQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTY29wZV8xID0gcmVxdWlyZShcIi4vbGliL3N0cnVjdHVyYWwvU2NvcGVcIik7XG5leHBvcnRzLlNjb3BlID0gU2NvcGVfMS5TY29wZTtcbi8qIEJJTkFSWSBPUFMgKi9cbnZhciBBc3NpZ25PcF8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9Bc3NpZ25PcFwiKTtcbmV4cG9ydHMuQXNzaWduT3AgPSBBc3NpZ25PcF8xLkFzc2lnbk9wO1xudmFyIEJpbmFyeU9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9CaW5hcnlPcGVyYXRpb25cIik7XG5leHBvcnRzLkJpbmFyeU9wZXJhdGlvbiA9IEJpbmFyeU9wZXJhdGlvbl8xLkJpbmFyeU9wZXJhdGlvbjtcbnZhciBEaXZPcF8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9EaXZPcFwiKTtcbmV4cG9ydHMuRGl2T3AgPSBEaXZPcF8xLkRpdk9wO1xudmFyIE1pbnVzT3BfMSA9IHJlcXVpcmUoXCIuL2xpYi9iaW5vcHMvTWludXNPcFwiKTtcbmV4cG9ydHMuTWludXNPcCA9IE1pbnVzT3BfMS5NaW51c09wO1xudmFyIE11bE9wXzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL011bE9wXCIpO1xuZXhwb3J0cy5NdWxPcCA9IE11bE9wXzEuTXVsT3A7XG52YXIgUGx1c09wXzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL1BsdXNPcFwiKTtcbmV4cG9ydHMuUGx1c09wID0gUGx1c09wXzEuUGx1c09wO1xudmFyIEdyZWF0ZXJUaGFuXzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvR3JlYXRlclRoYW5cIik7XG5leHBvcnRzLkdyZWF0ZXJUaGFuID0gR3JlYXRlclRoYW5fMS5HcmVhdGVyVGhhbjtcbnZhciBHcmVhdGVyVGhhbkVxXzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvR3JlYXRlclRoYW5FcVwiKTtcbmV4cG9ydHMuR3JlYXRlclRoYW5FcSA9IEdyZWF0ZXJUaGFuRXFfMS5HcmVhdGVyVGhhbkVxO1xudmFyIExlc3NUaGFuXzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvTGVzc1RoYW5cIik7XG5leHBvcnRzLkxlc3NUaGFuID0gTGVzc1RoYW5fMS5MZXNzVGhhbjtcbnZhciBMZXNzVGhhbkVxXzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvTGVzc1RoYW5FcVwiKTtcbmV4cG9ydHMuTGVzc1RoYW5FcSA9IExlc3NUaGFuRXFfMS5MZXNzVGhhbkVxO1xudmFyIERlY2xhcmVPcF8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9EZWNsYXJlT3BcIik7XG5leHBvcnRzLkRlY2xhcmVPcCA9IERlY2xhcmVPcF8xLkRlY2xhcmVPcDtcbnZhciBBbmRfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9BbmRcIik7XG5leHBvcnRzLkFuZCA9IEFuZF8xLkFuZDtcbnZhciBPcl8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2ljL09yXCIpO1xuZXhwb3J0cy5PciA9IE9yXzEuT3I7XG52YXIgRXF1YWxzXzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvRXF1YWxzXCIpO1xuZXhwb3J0cy5FcXVhbHMgPSBFcXVhbHNfMS5FcXVhbHM7XG52YXIgTm90RXF1YWxfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9Ob3RFcXVhbFwiKTtcbmV4cG9ydHMuTm90RXF1YWwgPSBOb3RFcXVhbF8xLk5vdEVxdWFsO1xudmFyIEluY3JlbWVudF8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9JbmNyZW1lbnRcIik7XG5leHBvcnRzLkluY3JlbWVudCA9IEluY3JlbWVudF8xLkluY3JlbWVudDtcbnZhciBEZWNyZW1lbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9iaW5vcHMvRGVjcmVtZW50XCIpO1xuZXhwb3J0cy5EZWNyZW1lbnQgPSBEZWNyZW1lbnRfMS5EZWNyZW1lbnQ7XG4vKiBVTkFSWSBPUFMgKi9cbnZhciBVbmFyeU9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vbGliL3Vub3BzL1VuYXJ5T3BlcmF0aW9uXCIpO1xuZXhwb3J0cy5VbmFyeU9wZXJhdGlvbiA9IFVuYXJ5T3BlcmF0aW9uXzEuVW5hcnlPcGVyYXRpb247XG52YXIgTmVnT3BfMSA9IHJlcXVpcmUoXCIuL2xpYi91bm9wcy9OZWdPcFwiKTtcbmV4cG9ydHMuTmVnT3AgPSBOZWdPcF8xLk5lZ09wO1xudmFyIE5vdF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2ljL05vdFwiKTtcbmV4cG9ydHMuTm90ID0gTm90XzEuTm90O1xuLyogREFUQSBUWVBFUyAqL1xudmFyIExpc3ROb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvbGlzdHMvTGlzdE5vZGVcIik7XG5leHBvcnRzLkxpc3ROb2RlID0gTGlzdE5vZGVfMS5MaXN0Tm9kZTtcbnZhciBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmV4cG9ydHMuTnVtYmVyTm9kZSA9IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlO1xudmFyIFN0cmluZ05vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9wcmltcy9TdHJpbmdOb2RlXCIpO1xuZXhwb3J0cy5TdHJpbmdOb2RlID0gU3RyaW5nTm9kZV8xLlN0cmluZ05vZGU7XG52YXIgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmV4cG9ydHMuQm9vbGVhbk5vZGUgPSBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlO1xudmFyIE5PUF8xID0gcmVxdWlyZShcIi4vbGliL3ByaW1zL05PUFwiKTtcbmV4cG9ydHMuTk9QID0gTk9QXzEuTk9QO1xuLyogVkFSSUFCTEVTICovXG52YXIgVmFyaWFibGVOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvdmFycy9WYXJpYWJsZU5vZGVcIik7XG5leHBvcnRzLlZhcmlhYmxlTm9kZSA9IFZhcmlhYmxlTm9kZV8xLlZhcmlhYmxlTm9kZTtcbi8qIENPTlRST0wgQ09OU1RSVUNUUyAqL1xudmFyIENvbmRpdGlvbmFsXzEgPSByZXF1aXJlKFwiLi9saWIvY29uZGl0aW9uYWxzL0NvbmRpdGlvbmFsXCIpO1xuZXhwb3J0cy5Db25kaXRpb25hbCA9IENvbmRpdGlvbmFsXzEuQ29uZGl0aW9uYWw7XG52YXIgRnVuQXBwXzEgPSByZXF1aXJlKFwiLi9saWIvZnVuaG91c2UvRnVuQXBwXCIpO1xuZXhwb3J0cy5GdW5BcHAgPSBGdW5BcHBfMS5GdW5BcHA7XG52YXIgRnVuRGVmXzEgPSByZXF1aXJlKFwiLi9saWIvZnVuaG91c2UvRnVuRGVmXCIpO1xuZXhwb3J0cy5GdW5EZWYgPSBGdW5EZWZfMS5GdW5EZWY7XG52YXIgU2VxdWVuY2VOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvc3RydWN0dXJhbC9TZXF1ZW5jZU5vZGVcIik7XG5leHBvcnRzLlNlcXVlbmNlTm9kZSA9IFNlcXVlbmNlTm9kZV8xLlNlcXVlbmNlTm9kZTtcbnZhciBXaGlsZU5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb29wcy9XaGlsZU5vZGVcIik7XG5leHBvcnRzLldoaWxlTm9kZSA9IFdoaWxlTm9kZV8xLldoaWxlTm9kZTtcbnZhciBGb3JOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvbG9vcHMvRm9yTm9kZVwiKTtcbmV4cG9ydHMuRm9yTm9kZSA9IEZvck5vZGVfMS5Gb3JOb2RlO1xuLyogQlVJTFRJTiBGVU5DVElPTlMgKi9cbnZhciBDb2xvck5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zaGFwZXMvQ29sb3JOb2RlXCIpO1xuZXhwb3J0cy5Db2xvck5vZGUgPSBDb2xvck5vZGVfMS5Db2xvck5vZGU7XG52YXIgRWxsaXBzZU5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zaGFwZXMvRWxsaXBzZU5vZGVcIik7XG5leHBvcnRzLkVsbGlwc2VOb2RlID0gRWxsaXBzZU5vZGVfMS5FbGxpcHNlTm9kZTtcbnZhciBSZWN0YW5nbGVOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvc2hhcGVzL1JlY3RhbmdsZU5vZGVcIik7XG5leHBvcnRzLlJlY3RhbmdsZU5vZGUgPSBSZWN0YW5nbGVOb2RlXzEuUmVjdGFuZ2xlTm9kZTtcbnZhciBMaW5lTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3NoYXBlcy9MaW5lTm9kZVwiKTtcbmV4cG9ydHMuTGluZU5vZGUgPSBMaW5lTm9kZV8xLkxpbmVOb2RlO1xudmFyIEN1cnZlTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3NoYXBlcy9DdXJ2ZU5vZGVcIik7XG5leHBvcnRzLkN1cnZlTm9kZSA9IEN1cnZlTm9kZV8xLkN1cnZlTm9kZTtcbnZhciBFcGhOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvc2hhcGVzL0VwaE5vZGVcIik7XG5leHBvcnRzLkVwaE5vZGUgPSBFcGhOb2RlXzEuRXBoTm9kZTtcbnZhciBQcmludE5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zdHJ1Y3R1cmFsL1ByaW50Tm9kZVwiKTtcbmV4cG9ydHMuUHJpbnROb2RlID0gUHJpbnROb2RlXzEuUHJpbnROb2RlO1xudmFyIFJldHVybl8xID0gcmVxdWlyZShcIi4vbGliL3N0cnVjdHVyYWwvUmV0dXJuXCIpO1xuZXhwb3J0cy5SZXR1cm4gPSBSZXR1cm5fMS5SZXR1cm47XG52YXIgUmV0dXJuRXJyb3JfMSA9IHJlcXVpcmUoXCIuL2xpYi9zdHJ1Y3R1cmFsL1JldHVybkVycm9yXCIpO1xuZXhwb3J0cy5SZXR1cm5FcnJvciA9IFJldHVybkVycm9yXzEuUmV0dXJuRXJyb3I7XG52YXIgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4vbGliL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmV4cG9ydHMuRWxsaXBzZUVmZmVjdCA9IEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0O1xudmFyIE51bWJlckVmZmVjdF8xID0gcmVxdWlyZShcIi4vbGliL2VmZmVjdHMvTnVtYmVyRWZmZWN0XCIpO1xuZXhwb3J0cy5OdW1iZXJFZmZlY3QgPSBOdW1iZXJFZmZlY3RfMS5OdW1iZXJFZmZlY3Q7XG52YXIgU3RyaW5nRWZmZWN0XzEgPSByZXF1aXJlKFwiLi9saWIvZWZmZWN0cy9TdHJpbmdFZmZlY3RcIik7XG5leHBvcnRzLlN0cmluZ0VmZmVjdCA9IFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdDtcbnZhciBEaW1lbnNpb25zXzEgPSByZXF1aXJlKFwiLi9saWIvc3RydWN0dXJhbC9EaW1lbnNpb25zXCIpO1xuZXhwb3J0cy5EaW1lbnNpb25zID0gRGltZW5zaW9uc18xLkRpbWVuc2lvbnM7XG52YXIgUmVjdGFuZ2xlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi9saWIvZWZmZWN0cy9SZWN0YW5nbGVFZmZlY3RcIik7XG5leHBvcnRzLlJlY3RhbmdsZUVmZmVjdCA9IFJlY3RhbmdsZUVmZmVjdF8xLlJlY3RhbmdsZUVmZmVjdDtcbnZhciBMaW5lRWZmZWN0XzEgPSByZXF1aXJlKFwiLi9saWIvZWZmZWN0cy9MaW5lRWZmZWN0XCIpO1xuZXhwb3J0cy5MaW5lRWZmZWN0ID0gTGluZUVmZmVjdF8xLkxpbmVFZmZlY3Q7XG52YXIgQ3VydmVFZmZlY3RfMSA9IHJlcXVpcmUoXCIuL2xpYi9lZmZlY3RzL0N1cnZlRWZmZWN0XCIpO1xuZXhwb3J0cy5DdXJ2ZUVmZmVjdCA9IEN1cnZlRWZmZWN0XzEuQ3VydmVFZmZlY3Q7XG52YXIgRXBoRWZmZWN0XzEgPSByZXF1aXJlKFwiLi9saWIvZWZmZWN0cy9FcGhFZmZlY3RcIik7XG5leHBvcnRzLkVwaEVmZmVjdCA9IEVwaEVmZmVjdF8xLkVwaEVmZmVjdDtcbi8qIEVWRU5UUyAqL1xudmFyIExvZ0V2ZW50XzEgPSByZXF1aXJlKFwiLi9saWIvbG9nZ2luZy9Mb2dFdmVudFwiKTtcbmV4cG9ydHMuTG9nRXZlbnQgPSBMb2dFdmVudF8xLkxvZ0V2ZW50O1xudmFyIENsZWFyRXZlbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dnaW5nL0NsZWFyRXZlbnRcIik7XG5leHBvcnRzLkNsZWFyRXZlbnQgPSBDbGVhckV2ZW50XzEuQ2xlYXJFdmVudDtcbnZhciBEcmFnRXZlbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dnaW5nL0RyYWdFdmVudFwiKTtcbmV4cG9ydHMuRHJhZ0V2ZW50ID0gRHJhZ0V2ZW50XzEuRHJhZ0V2ZW50O1xudmFyIFBhaW50RXZlbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dnaW5nL1BhaW50RXZlbnRcIik7XG5leHBvcnRzLlBhaW50RXZlbnQgPSBQYWludEV2ZW50XzEuUGFpbnRFdmVudDtcbnZhciBSZXNpemVFdmVudF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2dpbmcvUmVzaXplRXZlbnRcIik7XG5leHBvcnRzLlJlc2l6ZUV2ZW50ID0gUmVzaXplRXZlbnRfMS5SZXNpemVFdmVudDtcbnZhciBTZWxlY3RFdmVudF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2dpbmcvU2VsZWN0RXZlbnRcIik7XG5leHBvcnRzLlNlbGVjdEV2ZW50ID0gU2VsZWN0RXZlbnRfMS5TZWxlY3RFdmVudDtcbnZhciBJREV2ZW50XzEgPSByZXF1aXJlKFwiLi9saWIvbG9nZ2luZy9JREV2ZW50XCIpO1xuZXhwb3J0cy5JREV2ZW50ID0gSURFdmVudF8xLklERXZlbnQ7XG52YXIgTGVzc29uT25lQ3BPbmVfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3Nvbk9uZUNwT25lXCIpO1xuZXhwb3J0cy5MZXNzb25PbmVDcE9uZSA9IExlc3Nvbk9uZUNwT25lXzEuTGVzc29uT25lQ3BPbmU7XG52YXIgTGVzc29uT25lQ3BUd29fMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3Nvbk9uZUNwVHdvXCIpO1xuZXhwb3J0cy5MZXNzb25PbmVDcFR3byA9IExlc3Nvbk9uZUNwVHdvXzEuTGVzc29uT25lQ3BUd287XG52YXIgTGVzc29uT25lQ3BUaHJlZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uT25lQ3BUaHJlZVwiKTtcbmV4cG9ydHMuTGVzc29uT25lQ3BUaHJlZSA9IExlc3Nvbk9uZUNwVGhyZWVfMS5MZXNzb25PbmVDcFRocmVlO1xudmFyIExlc3Nvbk9uZUNwRm91cl8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uT25lQ3BGb3VyXCIpO1xuZXhwb3J0cy5MZXNzb25PbmVDcEZvdXIgPSBMZXNzb25PbmVDcEZvdXJfMS5MZXNzb25PbmVDcEZvdXI7XG52YXIgTGVzc29uVHdvQ3BPbmVfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwT25lXCIpO1xuZXhwb3J0cy5MZXNzb25Ud29DcE9uZSA9IExlc3NvblR3b0NwT25lXzEuTGVzc29uVHdvQ3BPbmU7XG52YXIgTGVzc29uVHdvQ3BUd29fMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwVHdvXCIpO1xuZXhwb3J0cy5MZXNzb25Ud29DcFR3byA9IExlc3NvblR3b0NwVHdvXzEuTGVzc29uVHdvQ3BUd287XG52YXIgTGVzc29uVHdvQ3BUaHJlZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVHdvQ3BUaHJlZVwiKTtcbmV4cG9ydHMuTGVzc29uVHdvQ3BUaHJlZSA9IExlc3NvblR3b0NwVGhyZWVfMS5MZXNzb25Ud29DcFRocmVlO1xudmFyIExlc3NvblR3b0NwRm91cl8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVHdvQ3BGb3VyXCIpO1xuZXhwb3J0cy5MZXNzb25Ud29DcEZvdXIgPSBMZXNzb25Ud29DcEZvdXJfMS5MZXNzb25Ud29DcEZvdXI7XG52YXIgTGVzc29uVHdvQ3BGaXZlXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Ud29DcEZpdmVcIik7XG5leHBvcnRzLkxlc3NvblR3b0NwRml2ZSA9IExlc3NvblR3b0NwRml2ZV8xLkxlc3NvblR3b0NwRml2ZTtcbnZhciBMZXNzb25Ud29DcFNpeF8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVHdvQ3BTaXhcIik7XG5leHBvcnRzLkxlc3NvblR3b0NwU2l4ID0gTGVzc29uVHdvQ3BTaXhfMS5MZXNzb25Ud29DcFNpeDtcbnZhciBMZXNzb25Ud29DcFNldmVuXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFNldmVuXCIpO1xuZXhwb3J0cy5MZXNzb25Ud29DcFNldmVuID0gTGVzc29uVHdvQ3BTZXZlbl8xLkxlc3NvblR3b0NwU2V2ZW47XG52YXIgTGVzc29uVGhyZWVDcE9uZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcE9uZVwiKTtcbmV4cG9ydHMuTGVzc29uVGhyZWVDcE9uZSA9IExlc3NvblRocmVlQ3BPbmVfMS5MZXNzb25UaHJlZUNwT25lO1xudmFyIExlc3NvblRocmVlQ3BUd29fMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BUd29cIik7XG5leHBvcnRzLkxlc3NvblRocmVlQ3BUd28gPSBMZXNzb25UaHJlZUNwVHdvXzEuTGVzc29uVGhyZWVDcFR3bztcbnZhciBMZXNzb25UaHJlZUNwVGhyZWVfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BUaHJlZVwiKTtcbmV4cG9ydHMuTGVzc29uVGhyZWVDcFRocmVlID0gTGVzc29uVGhyZWVDcFRocmVlXzEuTGVzc29uVGhyZWVDcFRocmVlO1xudmFyIExlc3NvblRocmVlQ3BGb3VyXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25UaHJlZUNwRm91clwiKTtcbmV4cG9ydHMuTGVzc29uVGhyZWVDcEZvdXIgPSBMZXNzb25UaHJlZUNwRm91cl8xLkxlc3NvblRocmVlQ3BGb3VyO1xudmFyIExlc3NvblRocmVlQ3BGaXZlXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25UaHJlZUNwRml2ZVwiKTtcbmV4cG9ydHMuTGVzc29uVGhyZWVDcEZpdmUgPSBMZXNzb25UaHJlZUNwRml2ZV8xLkxlc3NvblRocmVlQ3BGaXZlO1xudmFyIExlc3NvblRocmVlQ3BTaXhfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BTaXhcIik7XG5leHBvcnRzLkxlc3NvblRocmVlQ3BTaXggPSBMZXNzb25UaHJlZUNwU2l4XzEuTGVzc29uVGhyZWVDcFNpeDtcbnZhciBMZXNzb25Gb3VyQ3BPbmVfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvbkZvdXJDcE9uZVwiKTtcbmV4cG9ydHMuTGVzc29uRm91ckNwT25lID0gTGVzc29uRm91ckNwT25lXzEuTGVzc29uRm91ckNwT25lO1xudmFyIExlc3NvbkZvdXJDcFR3b18xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uRm91ckNwVHdvXCIpO1xuZXhwb3J0cy5MZXNzb25Gb3VyQ3BUd28gPSBMZXNzb25Gb3VyQ3BUd29fMS5MZXNzb25Gb3VyQ3BUd287XG4vKiBQQVJTRVIgKi9cbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuL2xpYi9wYXJzZXIvcGFyc2VyXCIpO1xuZXhwb3J0cy5QYXJzZXIgPSBwYXJzZXJfMS5QYXJzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJpbmFyeU9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vQmluYXJ5T3BlcmF0aW9uXCIpO1xuY29uc3QgVmFyaWFibGVOb2RlXzEgPSByZXF1aXJlKFwiLi4vdmFycy9WYXJpYWJsZU5vZGVcIik7XG4vLyBsZWZ0IHNpZGUgaXMgdmFyaWFibGUsIHJpZ2h0IHNpZGUgaXMgdmFsXG4vLyBSZWFzc2lnbiBuZXcgdmFsdWUgdG8gdmFyXG5jbGFzcyBBc3NpZ25PcCBleHRlbmRzIEJpbmFyeU9wZXJhdGlvbl8xLkJpbmFyeU9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGFuIGFzc2lnbm1lbnQgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgc2lkZSBvZiB0aGUgYXNzaWdubWVudCAodGhlIHZhcilcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGFzc2lnbm1lbnQgKHRoZSB2YWx1ZSlcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgc3VwZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoIShsZWZ0IGluc3RhbmNlb2YgVmFyaWFibGVOb2RlXzEuVmFyaWFibGVOb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxlZnQgaGFuZCBzaWRlIG9mIHRoZSBhc3NpZ25tZW50IG11c3QgYmUgYSB2YXJpYWJsZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyBhc3NpZ24gb3AgYnkgYXNzaWduaW5nIHZhbHVlIHRvIHZhclxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMubGVmdCBpbnN0YW5jZW9mIFZhcmlhYmxlTm9kZV8xLlZhcmlhYmxlTm9kZSkge1xuICAgICAgICAgICAgbGV0IHIgPSB0aGlzLnJpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgICAgICBjb250ZXh0LmFzc2lnbih0aGlzLmxlZnQubmFtZSwgcik7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIQUxQIChpbiBBc3NpZ25PcClcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEFzc2lnbk9wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMubGVmdC50b1N0cmluZygpICsgJyA9ICcgKyB0aGlzLnJpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2lnbk9wcyBjYW4ndCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2FuJ3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIEFzc2lnbk9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBiaW5hcnkgb3BlcmF0aW9uc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLkFzc2lnbk9wID0gQXNzaWduT3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3NpZ25PcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEJpbmFyeU9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBCaW5PcCBhYnN0cmFjdCBjbGFzc1xuICAgICAqIEBwYXJhbSBfbGVmdCBUaGUgbGVmdCBzaWRlIG9mIHRoZSBiaW5hcnkgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIF9yaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgYmluYXJ5IG9wZXJhdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9sZWZ0LCBfcmlnaHQpIHtcbiAgICAgICAgdGhpcy5fbGVmdCA9IF9sZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IF9yaWdodDtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGJpbmFyeSBvcGVyYXRpb24sIGlmIGFwcGxpY2FibGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSBhc3QgVGhlIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7IH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgZXF1YWwgdG8gYW5vdGhlciBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gQmluT3BcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJpbmFyeSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIFwiXCI7IH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2V0cyBsZWZ0IHNpZGUgb2YgdGhlIGJpbmFyeSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgbGVmdCBzaWRlIG9mIHRoZSBiaW5hcnkgb3BlcmF0aW9uXG4gICAgICovXG4gICAgc2V0IGxlZnQobGVmdCkge1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyByaWdodCBzaWRlIG9mIHRoZSBiaW5hcnkgb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgcmlnaHQgc2lkZSBvZiB0aGUgYmluYXJ5IG9wZXJhdGlvblxuICAgICAqL1xuICAgIHNldCByaWdodChyaWdodCkge1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5CaW5hcnlPcGVyYXRpb24gPSBCaW5hcnlPcGVyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaW5hcnlPcGVyYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCaW5hcnlPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL0JpbmFyeU9wZXJhdGlvblwiKTtcbmNvbnN0IFZhcmlhYmxlTm9kZV8xID0gcmVxdWlyZShcIi4uL3ZhcnMvVmFyaWFibGVOb2RlXCIpO1xuLy8gbGVmdCBzaWRlIGlzIHZhcmlhYmxlLCByaWdodCBzaWRlIGlzIHZhbFxuLy8gRGVjbGFyZXMgbmV3IHZhbFxuY2xhc3MgRGVjbGFyZU9wIGV4dGVuZHMgQmluYXJ5T3BlcmF0aW9uXzEuQmluYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIGRlY2xhcmUgb3BlcmF0aW9uLCB3aGljaCBkZWNsYXJlcyBhIHZhcmlhYmxlIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IHNpZGUgb2YgdGhlIGRlY2xhcmUgb3AgKHRoZSB2YXJpYWJsZSlcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIG9wICh0aGUgdmFsdWUpXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHN1cGVyKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKCEobGVmdCBpbnN0YW5jZW9mIFZhcmlhYmxlTm9kZV8xLlZhcmlhYmxlTm9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBsZWZ0IGhhbmQgc2lkZSBvZiB0aGUgYXNzaWdubWVudCBtdXN0IGJlIGEgdmFyaWFibGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgdGhlIGRlY2xhcmF0aW9uIGJ5IGRlY2xhcmluZyB0aGUgdmFyaWFibGUgaW4gdGhlIGNvbnRleHQgYW5kIGFzc2lnbmluZyB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMubGVmdCBpbnN0YW5jZW9mIFZhcmlhYmxlTm9kZV8xLlZhcmlhYmxlTm9kZSkge1xuICAgICAgICAgICAgY29udGV4dC5kZWNsYXJlKHRoaXMubGVmdC5uYW1lKTtcbiAgICAgICAgICAgIGxldCByID0gdGhpcy5yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICAgICAgY29udGV4dC5hc3NpZ24odGhpcy5sZWZ0Lm5hbWUsIHIpO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSEFMUCAoaW4gRGVjbGFyZU9wKVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGVjbGFyZSBvcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyBcInZhciBcIiArIHRoaXMubGVmdC50b1N0cmluZygpICsgJyA9ICcgKyB0aGlzLnJpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY2xhcmVPcHMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW4ndCBiZSBjYWxsZWQgZGlyZWNseSBvbiBhIERlY2xhcmVPcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5EZWNsYXJlT3AgPSBEZWNsYXJlT3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWNsYXJlT3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IE1pbnVzT3BfMSA9IHJlcXVpcmUoXCIuL01pbnVzT3BcIik7XG5jb25zdCBBc3NpZ25PcF8xID0gcmVxdWlyZShcIi4vQXNzaWduT3BcIik7XG5jb25zdCBWYXJpYWJsZU5vZGVfMSA9IHJlcXVpcmUoXCIuLi92YXJzL1ZhcmlhYmxlTm9kZVwiKTtcbmNsYXNzIERlY3JlbWVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBkZWNyZW1lbnQgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHZhcmlhYmxlIFRoZSBleHByZXNzaW9uIHRvIGJlIGRlY3JlbWVudGVkXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFyaWFibGUsIHdzKSB7XG4gICAgICAgIHRoaXMuZXhwciA9IHZhcmlhYmxlO1xuICAgICAgICBpZiAodmFyaWFibGUgaW5zdGFuY2VvZiBWYXJpYWJsZU5vZGVfMS5WYXJpYWJsZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJSZXAgPSBuZXcgQXNzaWduT3BfMS5Bc3NpZ25PcCh2YXJpYWJsZSwgbmV3IE1pbnVzT3BfMS5NaW51c09wKHZhcmlhYmxlLCBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJSZXAgPSBuZXcgTWludXNPcF8xLk1pbnVzT3AodmFyaWFibGUsIG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyB0aGUgZGVjcmVtZW50IG9wIHRvIGEgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbm5lclJlcC5ldmFsKGNvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkZWNyZW1lbnQgb3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5leHByLnRvU3RyaW5nKCkgKyBcIi0tXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY3JlbWVudCBvcHMgY2FuJ3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbid0IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBkZWNyZW1lbnRcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGJpbmFyeSBvcGVyYXRpb25zXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuRGVjcmVtZW50ID0gRGVjcmVtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVjcmVtZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmluYXJ5T3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9CaW5hcnlPcGVyYXRpb25cIik7XG5jb25zdCBTY29wZV8xID0gcmVxdWlyZShcIi4uL3N0cnVjdHVyYWwvU2NvcGVcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIERpdk9wIGV4dGVuZHMgQmluYXJ5T3BlcmF0aW9uXzEuQmluYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIGRpdmlzaW9uIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBkaXZpZGVuZFxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgZGl2aXNvclxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICBzdXBlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgZGl2aXNpb24gYW5kIGV2YWx1YXRlcyBpbnRvIGEgc2luZ2xlIE51bWJlck5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLmxlZnQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwgLyB0aGlzLnJpZ2h0LmV2YWwobmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCkpLmV2YWwoY29udGV4dCkudmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGl2aXNpb24gb3BzIGNhbid0IGJlIGRpcmVjdGx5IGRyYXduXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW4ndCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBkaXZpc2lvbiBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRpdmlzaW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMubGVmdC50b1N0cmluZygpICsgJyAvICcgKyB0aGlzLnJpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5EaXZPcCA9IERpdk9wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGl2T3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IFBsdXNPcF8xID0gcmVxdWlyZShcIi4vUGx1c09wXCIpO1xuY29uc3QgQXNzaWduT3BfMSA9IHJlcXVpcmUoXCIuL0Fzc2lnbk9wXCIpO1xuY29uc3QgVmFyaWFibGVOb2RlXzEgPSByZXF1aXJlKFwiLi4vdmFycy9WYXJpYWJsZU5vZGVcIik7XG5jbGFzcyBJbmNyZW1lbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBJbmNyZW1lbnRcbiAgICAgKiBAcGFyYW0gdmFyaWFibGUgVGhlIGV4cHJlc3Npb24gdG8gaW5jcmVtZW50XG4gICAgICogQHBhcmFtIHdzIFRyYWNrcyBwcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhcmlhYmxlLCB3cykge1xuICAgICAgICB0aGlzLmV4cHIgPSB2YXJpYWJsZTtcbiAgICAgICAgaWYgKHZhcmlhYmxlIGluc3RhbmNlb2YgVmFyaWFibGVOb2RlXzEuVmFyaWFibGVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyUmVwID0gbmV3IEFzc2lnbk9wXzEuQXNzaWduT3AodmFyaWFibGUsIG5ldyBQbHVzT3BfMS5QbHVzT3AodmFyaWFibGUsIG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbm5lclJlcCA9IG5ldyBQbHVzT3BfMS5QbHVzT3AodmFyaWFibGUsIG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxLCBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyBpbmNyZW1lbnQgaW50byBhIG51bWJlciBub2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGZ1bmN0aW9uIHNjb3BlXG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlubmVyUmVwLmV2YWwoY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluY3JlbWVudHMgY2Fubm90IGJlIGRyYXduXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBiaW5vcHNcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGJpbmFyeSBvcGVyYXRpb25zXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbmNyZW1lbnQgZXhwcmVzc2lvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLmV4cHIudG9TdHJpbmcoKSArIFwiKytcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLkluY3JlbWVudCA9IEluY3JlbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUluY3JlbWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJpbmFyeU9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vQmluYXJ5T3BlcmF0aW9uXCIpO1xuY29uc3QgU2NvcGVfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3R1cmFsL1Njb3BlXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jbGFzcyBNaW51c09wIGV4dGVuZHMgQmluYXJ5T3BlcmF0aW9uXzEuQmluYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBzdWJ0cmFjdGlvbiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbWludWVuZFxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgc3VicmFoZW5kXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHN1cGVyKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBzdWJ0cmFjdGlvbiBhbmQgZXZhbHVhdGVzIHRvIGEgc2luZ2xlIE51bWJlck5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLmxlZnQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwgLSB0aGlzLnJpZ2h0LmV2YWwobmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCkpLmV2YWwoY29udGV4dCkudmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3Rpb24gb3BzIGNhbid0IGJlIGRpcmVjdGx5IGRyYXduXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW4ndCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gc3VidHJhY3Rpb25cbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGJpbmFyeSBvcGVyYXRpb25zXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdWJ0cmFjdGlvbiBvcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLmxlZnQudG9TdHJpbmcoKSArICcgLSAnICsgdGhpcy5yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuTWludXNPcCA9IE1pbnVzT3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NaW51c09wLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmluYXJ5T3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9CaW5hcnlPcGVyYXRpb25cIik7XG5jb25zdCBTY29wZV8xID0gcmVxdWlyZShcIi4uL3N0cnVjdHVyYWwvU2NvcGVcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIE11bE9wIGV4dGVuZHMgQmluYXJ5T3BlcmF0aW9uXzEuQmluYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIG11bHRpcGxpY2F0aW9uIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBtdWx0aXBsaWNhbmRcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIG11bHRpcGxpZXJcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgc3VwZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIG11bHRpcGxpY2F0aW9uIGFuZCByZXR1cm5zIGEgc2luZ2xlIE51bWJlck5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLmxlZnQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwgKiB0aGlzLnJpZ2h0LmV2YWwobmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCkpLmV2YWwoY29udGV4dCkudmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbXVsdGlwbGljYXRpb24gb3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5sZWZ0LnRvU3RyaW5nKCkgKyAnICogJyArIHRoaXMucmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGljYXRpb24gb3BzIGNhbm5vdCBiZSBkaXJlY3RseSBkcmF3blxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhIG11bHRpcGxpY2FpdG9uIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5NdWxPcCA9IE11bE9wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TXVsT3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCaW5hcnlPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL0JpbmFyeU9wZXJhdGlvblwiKTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuLy8gbGVmdCBhbmQgcmlnaHQgYXJlIGJvdGggZXhwcmVzc2lvbnNcbmNsYXNzIFBsdXNPcCBleHRlbmRzIEJpbmFyeU9wZXJhdGlvbl8xLkJpbmFyeU9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBhZGRpdGlvbiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBUaGUgZmlyc3QgYWRkZW5kXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSBzZWNvbmQgYWRkZW5kXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHN1cGVyKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBhZGRpdGlvbiBhbmQgcmV0dXJucyBhIHNpbmdsZSBOdW1iZXJOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5sZWZ0LmV2YWwobmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCkpLmV2YWwoY29udGV4dCkudmFsICsgdGhpcy5yaWdodC5ldmFsKG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpKS5ldmFsKGNvbnRleHQpLnZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZGl0aW9uIG9wcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYW4gYWRkaXRpb24gb3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGJpbmFyeSBvcGVyYXRpb25zXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhZGRpdGlvbiBvcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLmxlZnQudG9TdHJpbmcoKSArICcgKyAnICsgdGhpcy5yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuUGx1c09wID0gUGx1c09wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGx1c09wLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU2NvcGVfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3R1cmFsL1Njb3BlXCIpO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xuY2xhc3MgQ29uZGl0aW9uYWwge1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgY29uZGl0aW9uYWxzIChpZiwgZWxzZSBpZiwgYW5kIGVsc2Ugc3RhdGVtZW50cylcbiAgICAgKiBAcGFyYW0gdGVzdCBUaGUgY29uZGl0aW9uIG9mIHRoZSBzdGF0ZW1lbnRcbiAgICAgKiBAcGFyYW0gdHJ1ZUJyYW5jaCBUaGUgYnJhbmNoIHRvIGZvbGxvdyBpZiB0aGUgY29uZGl0aW9uIGV2YWx1YXRlcyB0byB0cnVlXG4gICAgICogQHBhcmFtIGZhbHNlQnJhbmNoIFRoZSBicmFuY2ggdG8gZm9sbG93IGlmIHRoZSBjb25kaXRpb24gZXZhbHVhdGVzIHRvIGZhbHNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGVzdCwgdHJ1ZUJyYW5jaCwgZmFsc2VCcmFuY2gpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Rlc3QgPSB0ZXN0O1xuICAgICAgICB0aGlzLl90cnVlQnJhbmNoID0gdHJ1ZUJyYW5jaDtcbiAgICAgICAgdGhpcy5fZmFsc2VCcmFuY2ggPSBmYWxzZUJyYW5jaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSB0ZXN0IHJlc3VsdCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSB0cnVlIG9yIGZhbHNlIGJyYW5jaCwgZGVwZW5kaW5nIG9uIHRoZSB0ZXN0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBjaGlsZEN0eCA9IG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQsIGNvbnRleHQuZWZmZWN0cywgY29udGV4dC5ldmVudExvZyk7XG4gICAgICAgIGNoaWxkQ3R4LmNhbnZhcyA9IHNwYWNlX2xpZnRfMS5Tb21lKGNvbnRleHQuY2FudmFzLmdldCgpKTtcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMuX3Rlc3QuZXZhbChjaGlsZEN0eCk7XG4gICAgICAgIGlmICghKHJlcyBpbnN0YW5jZW9mIEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29uZGl0aW9uIG11c3QgYmUgYSBib29sZWFuIGV4cHJlc3Npb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMudmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJ1ZUJyYW5jaC5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9mYWxzZUJyYW5jaCAhPSBudWxsKSB7IC8vIGNoZWNrIGlmIGVsc2UvZWxzZSBpZiBpcyBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZhbHNlQnJhbmNoLmV2YWwoY2hpbGRDdHgpOyAvLyBwb3NzaWJseSBhIGJhZCBpZGVhXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29uZGl0aW9uYWwgc3RhdGVtZW50XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXMgPSAnaWYoJyArIHRoaXMuX3Rlc3QudG9TdHJpbmcoKSArIFwiKSB7XFxuIFwiICsgdGhpcy5fdHJ1ZUJyYW5jaC50b1N0cmluZygpICsgXCJ9XCI7XG4gICAgICAgIGlmICh0aGlzLl9mYWxzZUJyYW5jaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXMgKz0gJ1xcbmVsc2Uge1xcbiAnICsgdGhpcy5fZmFsc2VCcmFuY2gudG9TdHJpbmcoKSArICd9JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRydWUgYnJhbmNoIG9mIHRoZSBjb25kaXRpb25hbFxuICAgICAqL1xuICAgIGdldCB0cnVlQnJhbmNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJ1ZUJyYW5jaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmFsc2UgYnJhbmNoIG9mIHRoZSBjb25kaXRpb25hbFxuICAgICAqL1xuICAgIGdldCBmYWxzZUJyYW5jaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhbHNlQnJhbmNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25kaXRpb25hbHMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhIGNvbmRpdGlvbmFsXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBjb25kaXRpb25hbHNcIik7XG4gICAgfVxufVxuZXhwb3J0cy5Db25kaXRpb25hbCA9IENvbmRpdGlvbmFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29uZGl0aW9uYWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IFBhaW50RXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1BhaW50RXZlbnRcIik7XG5jb25zdCBSZXNpemVFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUmVzaXplRXZlbnRcIik7XG5jb25zdCBDbGlja0V2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9DbGlja0V2ZW50XCIpO1xuY2xhc3MgQ3VydmVFZmZlY3Qge1xuICAgIGNvbnN0cnVjdG9yKGN1cnZlKSB7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTsgLy8gcHJpdmF0ZSBib29sc1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yYXRpbyA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSAwO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9tb3VzZSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2N1cnZlID0gY3VydmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiBldmFsdWF0aW5nIG5vZGVzIChTdHJpbmdOb2RlLCBFbGxpcHNlTm9kZSwgZXRjKVxuICAgICAqIFRoaXMgbWV0aG9kIGFzc2lnbnMgYWxsIHBhcmFtcyB0byBwcml2YXRlIHZhcmlhYmxlcyBhbmQgZHJhd3MgdGhlIGluaXRpYWwgb2JqZWN0IHRvIHRoZSBjYW52YXNcbiAgICAgKiBieSBjYWxsaW5nIHVwZGF0ZSgpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIHBhcmVudCBTY29wZSB0aGF0IGNvbnRhaW5zIHRoZSBjYW52YXMgYW1vbmcgb3RoZXIgdGhpbmdzXG4gICAgICogQHBhcmFtIGRpbXMgVGhlIG9iamVjdCdzIGRpbWVuc2lvbnMgaW5jbHVkaW5nIHggYW5kIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gYXN0IFVubmVjZXNzYXJ5IG5vdywgdXNlZCB0byBiZSB0aGUgcGFyZW50IEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNhbnZhcy5pc0RlZmluZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZGltcyA9IGRpbXM7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBjb250ZXh0LmNhbnZhcy5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgbGV0IGN0eCA9IGNvbnRleHQuY2FudmFzLmdldCgpLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dQYWludCgpKTtcbiAgICAgICAgY29udGV4dC5lZmZlY3RzLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGluIG9yZGVyIHRvIGRyYXcgYW5kIHJlZHJhdyB0aGUgb2JqZWN0IHdoZW4gbWFuaXB1bGF0aW9ucyBhcmUgbWFkZVxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnc7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmg7XG4gICAgICAgIGxldCBjdXJ2YXR1cmUgPSB0aGlzLmN1cnZhdHVyZTtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICBsZXQgdiA9IHRoaXMucGVycGVuZGljdWxhclZlY3Rvcih3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fY3R4LnF1YWRyYXRpY0N1cnZlVG8oKHggKyB3aWR0aCAvIDIpICsgY3VydmF0dXJlICogdlswXSwgKHkgKyBoZWlnaHQgLyAyKSArIGN1cnZhdHVyZSAqIHZbMV0sIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9IFwiIzY3M0FCN1wiO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdHdWlkZXMoeCwgeSwgd2lkdGgsIGhlaWdodCwgdGhpcy5fY29ybmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL2EgKiB3ICsgYiAqIGggPSAwXG4gICAgcGVycGVuZGljdWxhclZlY3Rvcih3LCBoKSB7XG4gICAgICAgIGlmICh3ID09IDAgJiYgaCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHcgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFsxLCAwXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbMCwgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsxLCAoLXcpIC8gaF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIG9uZSBmZWxsIHN3b29wXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpOyAvLyBiaW5kIGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBtZWFuaW5nIG9mICd0aGlzJ1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uU2hpZnREb3duLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uU2hpZnRVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaXNNb3VzZU91dHNpZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vbWFrZXMgaXQgc28gdGhhdCBkb3VibGUgY2xpY2tpbmcgZG9lc24ndCBzZWxlY3QgdGV4dCBvbiB0aGUgcGFnZVxuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBmdW5jdGlvbiAoZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IHJldHVybiBmYWxzZTsgfSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBhbm90aGVyIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb2YgdGhlIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSwgZmFsc2UgaWYgb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgaWYgKG14ID4geCAmJiBteCA8IHggKyB3ICYmIG15ID4geSAmJiBteSA8IHkgKyBoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgPiAwIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb25lIG9mIHRoZSBjb3JuZXIvc2lkZSBndWlkZXMsIHJldHVybnMgMCBpZiBub3RcbiAgICAgKiBUaGUgY29ybmVyIGd1aWRlcyBhcmUgbnVtYmVyZWQgMS00IHdpdGggMSBiZWluZyB0aGUgdG9wIGxlZnQsIDIgYmVpbmcgdGhlIHRvcCByaWdodCwgYW5kIHNvIG9uLlxuICAgICAqIFRoZSBtaWRkbGUgZ3VpZGVzIGFyZSBudW1iZXJlZCA1LTgsIHdpdGggNSBiZWluZyB0aGUgdG9wIG1pZGRsZSwgNiBiZWluZyB0aGUgcmlnaHQgbWlkZGxlLCBhbmQgc28gb24uXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGd1aWRlQ29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBsZXQgeGRpZiA9IG14IC0geDtcbiAgICAgICAgbGV0IHlkaWYgPSBteSAtIHk7XG4gICAgICAgIC8qIENvcm5lciBHdWlkZXMgKi9cbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGgpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSB4O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICB9XG4gICAgICAgIC8qIE1pZGRsZSBHdWlkZXMgKi9cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3IC8gMik7XG4gICAgICAgIHlkaWYgPSBteSAtIHk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGggLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3IC8gMik7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSB4O1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGggLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBhbmQgZ3VpZGVzIGZvciB0aGUgb2JqZWN0IHdoZW4gdGhlIG9iamVjdCBpcyBzZWxlY3RlZFxuICAgICAqIElmIG9uZSBvZiB0aGUgZ3VpZGVzIGlzIHNlbGVjdGVkLCBpdCBjb2xvcnMgdGhhdCBndWlkZSBibHVlXG4gICAgICogQHBhcmFtIHggdGhlIHggY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHkgdGhlIHkgY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHcgdGhlIHdpZHRoIG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29ybmVyIHRoZSBudW1iZXIgb2YgdGhlIGNvcm5lciB0byBiZSBjb2xvcmVkIGJsdWUgKGlmIGFueSBhdCBhbGwsIGlmIDAsIGFsbCBhcmUgd2hpdGUpXG4gICAgICovXG4gICAgZHJhd0d1aWRlcyh4LCB5LCB3LCBoLCBjb3JuZXIpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmIChjb3JuZXIgIT09IDAgJiYgY29ybmVyIDw9IDQpIHsgLy8gYSBjb3JuZXIgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29ybmVyICE9PSAwKSB7IC8vIGEgbWlkZGxlIGd1aWRlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgY29ycmVjdCBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvL2lmIG5vIGd1aWRlcyBhcmUgc2VsZWN0ZWQsIGNvbG9ycyBldmVyeXRoaW5nIHdoaXRlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgbWV0aG9kIHRoYXQgZHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geCB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5IHkgY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHcgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIGNvbG9yIG9mIHRoZSByZWN0YW5nbGUncyBmaWxsXG4gICAgICovXG4gICAgZHJhd1NxdWFyZSh4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgd2l0aGluIHRoZSBjYW52YXMuXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24sIGNhbGxzIHRoZSBtb2RpZnkgbWV0aG9kcyBpZiB0aGUgYm9vbGVhbnMgc2F0aXNmeSB0aGVtLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRNb3VzZVBvc2l0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5RHJhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemUodGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0NoYW5naW5nRGltcyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXModGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIGNsaWNrcyBpbnNpZGUgdGhlIGNhbnZhcy5cbiAgICAgKiBNb2RpZmllcyB0aGUgc3RhdGUgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGd1aWRlcyBjb250YWluIHRoZSBtb3VzZSBvciB0aGUgYm91bmRpbmcgcmVjdCBjb250YWlucyB0aGUgbW91c2UuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVN0YXRlKHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSwgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgdW5jbGlja3MuXG4gICAgICogQ2FsbHMgbW9kaWZ5UmVzZXQgdG8gcmVzZXQgZHJhZ2dpbmcgYW5kIHJlc2l6aW5nIGJvb2xlYW5zIGFtb25nIG90aGVycy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNldXAgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlSZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcHJlc3NlZCBkb3duXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcHJlc3NlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdERvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHJlbGVhc2VkXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcmVsZWFzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnRVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogTW9kaWZpY2F0aW9uIGZ1bmN0aW9ucyAqL1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBpbiBvcmRlciB0byBkcmFnIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgbW9kaWZ5RHJhZygpIHtcbiAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueCAtIHRoaXMuX2RyYWdvZmZ4O1xuICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy5fZHJhZ29mZnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHNpemUgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZCAod2hlbiBhIGNvcm5lciBndWlkZSBpcyBjbGlja2VkIGFuZCBkcmFnZ2VkKS5cbiAgICAgKlxuICAgICAqIElmIGFueSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgdG9vIHNtYWxsLCBpdCBzZXRzIHRoZW0gZXF1YWwgdG8gMTAgYW5kIHRoZSBvdGhlciBlcXVhbCB0b1xuICAgICAqIDEwIGRpdmlkZWQgb3IgbXVsdGlwbGllZCBieSB0aGUgcmF0aW8gb2Ygd2lkdGgvaGVpZ2h0IHRvIGtlZXAgaXQgdGhlIHNhbWUuXG4gICAgICpcbiAgICAgKiBUaGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBpcyBkb25lIGJ5IGNhbGxpbmcgdGhlIGhlbHBlciBtZXRob2QgbW9kaWZ5UmVzaXplSGVscGVyLlxuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZSh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBpZiAod2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fY3VydmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApOyAvLyBzZXQgZm9yIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwIC8gdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDEwIC8gdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTsgLy8gc2V0IGZvciB0aGUgcHJvZGlyZWN0IG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwICogdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDEwICogdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGUgcmVjdGFuZ2xlIG9yaWdpbmF0ZXMgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIGFuZCBub3QgdGhlIGNlbnRlcixcbiAgICAgKiBpdCBjaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFzIHdlbGwgaWYgZ3VpZGVzIDEsIDIsIG9yIDQgYXJlIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3RGlzdGFuY2UgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG1vdXNlIGFuZCB0aGUgbG9jYXRpb24gb3Bwb3NpdGUgdG8gaXRcbiAgICAgKiAoaWYgdG9wIHJpZ2h0IGd1aWRlIGlzIGNsaWNrZWQsIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoYXQgYW5kIHRoZSBib3R0b20gbGVmdCBndWlkZSBpcyBuZXdEaXN0YW5jZSlcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMudyA+IDEwICYmIHRoaXMuaCA+IDEwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQoKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAvIHRoaXMuX3JhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICB0aGlzLl9jdXJ2ZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW87XG4gICAgICAgIHRoaXMuX2N1cnZlLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQuXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMC5cbiAgICAgKiBDYWxscyBtb2RpZnlDaGFuZ2VEaW1zSGVscGVyIHRvIGFjdHVhbGx5IGRvIHRoZSB3b3JrXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5Q2hhbmdlRGltcyh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBpZiAod2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fY3VydmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIHRoZSByZWN0YW5nbGUgb3JpZ2luYXRlcyBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgYW5kIG5vdCB0aGUgY2VudGVyLFxuICAgICAqIGl0IGNoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXMgd2VsbCBpZiBndWlkZXMgNSBvciA4IGFyZSBzZWxlY3RlZFxuICAgICAqL1xuICAgIG1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKSB7XG4gICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaCA+IDEwKSB7IC8vYXMgbG9uZyBhcyB0aGUgaGVpZ2h0IGlzID4gMTBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VydmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLncgPiAxMCkgeyAvLyBhcyBsb25nIGFzIHdpZHRoIGlzID4gMTBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgZGVwZW5kaW5nIG9uIHRoZSBtb3VzZSBwb3NpdGlvbiB3aGVuIGNhbGxlZCAob25Nb3VzZURvd24pXG4gICAgICogZS5nLiBpZiB0aGUgbW91c2UgaXMgd2l0aGluIHRoZSBib3VuZGluZyByZWN0YW5nbGUgd2hlbiB0aGlzIGlzIGNhbGxlZCwgaXNTZWxlY3RlZCA9IHRydWVcbiAgICAgKiBAcGFyYW0gZ3VpZGVDb250YWluc1xuICAgICAqIEBwYXJhbSBjb250YWluc1xuICAgICAqL1xuICAgIG1vZGlmeVN0YXRlKGd1aWRlQ29udGFpbnMsIGNvbnRhaW5zKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkgeyAvL3ByZXBhcmVzIHRoZSBvYmplY3QgZm9yIGRyYWdnaW5nIHdoZXRoZXIgaXQgaXMgcGVyc29uYWxseSBzZWxlY3RlZCBvciBub3RcbiAgICAgICAgICAgIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kxID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gMCAmJiBndWlkZUNvbnRhaW5zIDw9IDQpIHsgLy9yZXNpemluZ1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gdGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0MSA9IHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoMSA9IHRoaXMudztcbiAgICAgICAgICAgIC8vdGhpcy5fc2l6ZTEgPSBNYXRoLnNxcnQoTWF0aC5wb3codywyKSArIE1hdGgucG93KGgsMikpOyAvLyBzaXplIGlzIGRpYWdvbmFsIGxlbmd0aFxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHsgLy8gc2V0cyB0aGUgb2Zmc2V0cyBkZXBlbmRpbmcgb24gd2hpY2ggY29ybmVyIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgY2FzZSAxOiAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3OyAvLyBvZmZzZXQgaXMgYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoOyAvLyBvZmZzZXQgaXMgYm90dG9tIGxlZnQsIGV0Y1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucyA+IDQpIHsgLy9jaGFuZ2luZyBzaGFwZSBkaW1lbnNpb25zXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IGd1aWRlQ29udGFpbnM7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikgeyAvLyBzZXRzIHRoZSBvZmZzZXRzIGRlcGVuZGluZyBvbiB3aGljaCBtaWRkbGUgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIDU6IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyOyAvLyBvZmZzZXQgaXMgYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6IC8vcmlnaHQgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaCAvIDI7IC8vIG9mZnNldCBpcyBsZWZ0IG1pZGRsZSBldGNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdyAvIDIsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5ICsgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbnMpIHsgLy8gZHJhZ2dpbmdcbiAgICAgICAgICAgIHRoaXMuX3gxID0geDsgLy8gU2F2aW5nIG9yaWdpbmFsIHggYW5kIHlcbiAgICAgICAgICAgIHRoaXMuX3kxID0geTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7IC8vIG5vdCBzZWxlY3RlZFxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgdG8gZmFsc2UgKGxpa2UgZHJhZ2dpbmcsIHJlc2l6aW5nLCBldGMpIHdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkXG4gICAgICovXG4gICAgbW9kaWZ5UmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl94MSAtIHRoaXMueCkgPiAxIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0gdGhpcy55KSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHRoaXMuX2lzUmVzaXppbmcgfHwgdGhpcy5faXNDaGFuZ2luZ0RpbXMpICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBzaXplMiA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLncsIDIpICsgTWF0aC5wb3codGhpcy5oLCAyKSk7XG4gICAgICAgICAgICBpZiAoKE1hdGguYWJzKHRoaXMuX3dpZHRoMSAtIHRoaXMudykgPiAwKSB8fCAoTWF0aC5hYnModGhpcy5faGVpZ2h0MSAtIHRoaXMuaCkgPiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1Jlc2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqL1xuICAgIGdldE1vdXNlUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuX21vdXNlLnggPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS54O1xuICAgICAgICB0aGlzLl9tb3VzZS55ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0NoYW5naW5nRGltcywgYW5kIGlzU2VsZWN0ZWQgdG8gZmFsc2UgaWYgdGhlIG1vdXNlIGNsaWNrcyBvdXRzaWRlIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIGlzTW91c2VPdXRzaWRlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgICAgICBsZXQgbW91c2VZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtb3VzZVggPCByZWN0LmxlZnQgfHwgbW91c2VYID4gcmVjdC5yaWdodCB8fCBtb3VzZVkgPCByZWN0LnRvcCB8fCBtb3VzZVkgPiByZWN0LmJvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlY3RhbmdsZSBwYWludCBldmVudFxuICAgICAqL1xuICAgIGxvZ1BhaW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhaW50RXZlbnRfMS5QYWludEV2ZW50KFwicmVjdGFuZ2xlXCIsIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlY3RhbmdsZSByZXNpemUgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dSZXNpemUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplRXZlbnRfMS5SZXNpemVFdmVudChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIE1hdGgucm91bmQodGhpcy5fd2lkdGgxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLl9oZWlnaHQxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLncgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuaCAqIDEwMCkgLyAxMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIGNsaWNrIGV2ZW50XG4gICAgICovXG4gICAgbG9nQ2xpY2soKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xpY2tFdmVudF8xLkNsaWNrRXZlbnQoXCJyZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCBhc3NpZ25zIGFuIElEIHRvIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSBpZCBUaGUgSUQgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBpbml0SUQoaWQpIHtcbiAgICAgICAgdGhpcy5pZE9iaiA9IHsgX2lkOiBpZCB9O1xuICAgIH1cbiAgICBhc3QoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnZhdHVyZSBvZiB0aGUgY3VydmVcbiAgICAgKi9cbiAgICBnZXQgY3VydmF0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy5jdXJ2YXR1cmUuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERpbWVuc2lvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRPYmouX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqL1xuICAgIGdldEp1c3REcmFnZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fanVzdERyYWdnZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBzZXRKdXN0RHJhZ2dlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaXMgZHJhZ2dpbmdcbiAgICAgKi9cbiAgICBnZXQgaXNEcmFnZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRHJhZ2dpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3Igc2VsZWN0aW9uIGV2ZW50c1xuICAgICAqL1xuICAgIHRvU2VsU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCIgcmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgZHJhZyBldmVudHNcbiAgICAqL1xuICAgIHRvRHJhZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBmcm9tIFwiICsgdGhpcy5feDEgKyBcIiwgXCIgKyB0aGlzLl95MSArIFwiIHRvIFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBJRCBhc3NpZ25tZW50IGV2ZW50c1xuICAgICAqL1xuICAgIHRvSURTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pZE9iai5faWQudG9TdHJpbmcoKSArIFwiIHRvIHJlY3RhbmdsZSBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxufVxuZXhwb3J0cy5DdXJ2ZUVmZmVjdCA9IEN1cnZlRWZmZWN0O1xuLyoqXG4gKiBHZXRzIHRoZSBtb3VzZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGluIHJlbGF0aW9uIHRvIHRoZSBjYW52YXNcbiAqIEBwYXJhbSBjYW52YXMgdGhlIGNhbnZhcyBvYmplY3RcbiAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGdldE1vdXNlUG9zKGNhbnZhcywgZXZlbnQpIHtcbiAgICBsZXQgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0LFxuICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gcmVjdC50b3BcbiAgICB9O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0geDEgeCBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geTEgeSBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geDIgeCBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICogQHBhcmFtIHkyIHkgY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDIsIDIpICsgTWF0aC5wb3coeTEgLSB5MiwgMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3VydmVFZmZlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBQYWludEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9QYWludEV2ZW50XCIpO1xuY29uc3QgUmVzaXplRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1Jlc2l6ZUV2ZW50XCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBDbGlja0V2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9DbGlja0V2ZW50XCIpO1xuY2xhc3MgRWxsaXBzZUVmZmVjdCB7XG4gICAgY29uc3RydWN0b3IoY2lyY2xlKSB7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTsgLy8gUHJpdmF0ZSBib29sc1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlOyAvLyBIYXMgdGhpcyBvYmplY3QganVzdCBiZWVuIGRyYWdnZWQ/XG4gICAgICAgIHRoaXMuX3JhdGlvID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnggPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IDA7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX21vdXNlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY2lyY2xlID0gY2lyY2xlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gZXZhbHVhdGluZyBub2RlcyAoU3RyaW5nTm9kZSwgRWxsaXBzZU5vZGUsIGV0YylcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3NpZ25zIGFsbCBwYXJhbXMgdG8gcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIGRyYXdzIHRoZSBpbml0aWFsIG9iamVjdCB0byB0aGUgY2FudmFzXG4gICAgICogYnkgY2FsbGluZyB1cGRhdGUoKVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBwYXJlbnQgU2NvcGUgdGhhdCBjb250YWlucyB0aGUgY2FudmFzIGFtb25nIG90aGVyIHRoaW5nc1xuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBvYmplY3QncyBkaW1lbnNpb25zIGluY2x1ZGluZyB4IGFuZCB5IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGFzdCBVbm5lY2Vzc2FyeSBub3csIHVzZWQgdG8gYmUgdGhlIHBhcmVudCBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBpZiAoY29udGV4dC5jYW52YXMuaXNEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMgPSBkaW1zO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gY29udGV4dC5jYW52YXMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0LmNhbnZhcy5nZXQoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9nZ2luZ1xuICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dQYWludCgpKTtcbiAgICAgICAgY29udGV4dC5lZmZlY3RzLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGluIG9yZGVyIHRvIGRyYXcgYW5kIHJlZHJhdyB0aGUgb2JqZWN0IHdoZW4gbWFuaXB1bGF0aW9ucyBhcmUgbWFkZVxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LmVsbGlwc2UoeCwgeSwgdyAvIDIsIGggLyAyLCAwLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgICAvL3RoaXMuX2N0eC5zdHJva2VTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgLy90aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBcIiNENUI4RkZcIjtcbiAgICAgICAgdGhpcy5fY3R4LnNoYWRvd0NvbG9yID0gXCIjNkM2QzZDXCI7XG4gICAgICAgIHRoaXMuX2N0eC5zaGFkb3dCbHVyID0gMTU7XG4gICAgICAgIC8vdGhpcy5fY3R4LnNoYWRvd09mZnNldFggPSAyO1xuICAgICAgICAvL3RoaXMuX2N0eC5zaGFkb3dPZmZzZXRZID0gMjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGwoKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0d1aWRlcyh4IC0gdyAvIDIsIHkgLSBoIC8gMiwgdywgaCwgdGhpcy5fY29ybmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgICAgICBwcml2YXRlIG1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgcHJpdmF0ZSBtb3VzZURvd24gPSB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHByaXZhdGUgbW91c2VVcCA9IHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICAgIHByaXZhdGUgc2hpZnREb3duID0gdGhpcy5vblNoaWZ0RG93bi5iaW5kKHRoaXMpO1xuICAgICAgICBwcml2YXRlIHNoaWZ0VXAgPSB0aGlzLm9uU2hpZnRVcC5iaW5kKHRoaXMpO1xuICAgICAgICBwcml2YXRlIG1vdXNlT3V0c2lkZSA9IHRoaXMuaXNNb3VzZU91dHNpZGUuYmluZCh0aGlzKTtcbiAgICAgICAgcHJpdmF0ZSBzZWxlY3RTdGFydCA9IGZ1bmN0aW9uKGU6YW55KSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGZhbHNlOyB9O1xuICAgICovXG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gb25lIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7IC8vIGJpbmQgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIG1lYW5pbmcgb2YgJ3RoaXMnXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25TaGlmdERvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25TaGlmdFVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy9tYWtlcyBpdCBzbyB0aGF0IGRvdWJsZSBjbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0ZXh0IG9uIHRoZSBwYWdlXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uIChlKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGZhbHNlOyB9LCBmYWxzZSk7XG4gICAgfVxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICAvKlxuICAgICAgICBjb25zb2xlLmxvZyhcInJlbW92aW5nIEV2ZW50TGlzdG5lcnNcIik7XG4gICAgICAgICAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlKTsgLy8gYmluZCBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgbWVhbmluZyBvZiAndGhpcydcbiAgICAgICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZURvd24pO1xuICAgICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5tb3VzZVVwKTtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuc2hpZnREb3duKTtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLnNoaWZ0VXApO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlT3V0c2lkZSk7XG4gICAgICAgICAgLy9tYWtlcyBpdCBzbyB0aGF0IGRvdWJsZSBjbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0ZXh0IG9uIHRoZSBwYWdlXG4gICAgICAgICAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgdGhpcy5zZWxlY3RTdGFydCwgZmFsc2UpO1xuICAgICAgICAgICovXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9mIHRoZSBvYmplY3QncyBib3VuZGluZyByZWN0YW5nbGUsIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBjb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhteCAtIHgsIDIpIC8gTWF0aC5wb3codyAvIDIsIDIpICsgTWF0aC5wb3cobXkgLSB5LCAyKSAvIE1hdGgucG93KGggLyAyLCAyKSA8PSAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbnVtYmVyID4gMCBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9uZSBvZiB0aGUgY29ybmVyL3NpZGUgZ3VpZGVzLCByZXR1cm5zIDAgaWYgbm90XG4gICAgICogVGhlIGNvcm5lciBndWlkZXMgYXJlIG51bWJlcmVkIDEtNCB3aXRoIDEgYmVpbmcgdGhlIHRvcCBsZWZ0LCAyIGJlaW5nIHRoZSB0b3AgcmlnaHQsIGFuZCBzbyBvbi5cbiAgICAgKiBUaGUgbWlkZGxlIGd1aWRlcyBhcmUgbnVtYmVyZWQgNS04LCB3aXRoIDUgYmVpbmcgdGhlIHRvcCBtaWRkbGUsIDYgYmVpbmcgdGhlIHJpZ2h0IG1pZGRsZSwgYW5kIHNvIG9uLlxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBndWlkZUNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgbGV0IHhkaWYgPSBteCAtICh4IC0gdyAvIDIpO1xuICAgICAgICBsZXQgeWRpZiA9IG15IC0gKHkgLSBoIC8gMik7XG4gICAgICAgIC8qIENvcm5lciBHdWlkZXMgKi9cbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3IC8gMik7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCAtIHcgLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgfVxuICAgICAgICAvKiBNaWRkbGUgR3VpZGVzICovXG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIHlkaWYgPSBteSAtICh5IC0gaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIG1pZGRsZVxuICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3IC8gMik7XG4gICAgICAgIHlkaWYgPSBteSAtIHk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9taWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiA2O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgcmV0dXJuIDc7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggLSB3IC8gMik7XG4gICAgICAgIHlkaWYgPSBteSAtIHk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9taWRkbGUgbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBib3VuZGluZyByZWN0YW5nbGUgYW5kIGd1aWRlcyBmb3IgdGhlIG9iamVjdCB3aGVuIHRoZSBvYmplY3QgaXMgc2VsZWN0ZWRcbiAgICAgKiBJZiBvbmUgb2YgdGhlIGd1aWRlcyBpcyBzZWxlY3RlZCwgaXQgY29sb3JzIHRoYXQgZ3VpZGUgYmx1ZVxuICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB5IHRoZSB5IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB3IHRoZSB3aWR0aCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggdGhlIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvcm5lciB0aGUgbnVtYmVyIG9mIHRoZSBjb3JuZXIgdG8gYmUgY29sb3JlZCBibHVlIChpZiBhbnkgYXQgYWxsLCBpZiAwLCBhbGwgYXJlIHdoaXRlKVxuICAgICAqL1xuICAgIGRyYXdHdWlkZXMoeCwgeSwgdywgaCwgY29ybmVyKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAoY29ybmVyICE9PSAwICYmIGNvcm5lciA8PSA0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgY29ycmVjdCBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvcm5lciAhPT0gMCAmJiBjb3JuZXIgPiA0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgY29ycmVjdCBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltcGxlIG1ldGhvZCB0aGF0IGRyYXdzIGEgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHggeCBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geSB5IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB3IHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb2xvciBjb2xvciBvZiB0aGUgcmVjdGFuZ2xlJ3MgZmlsbFxuICAgICAqL1xuICAgIGRyYXdTcXVhcmUoeCwgeSwgdywgaCwgY29sb3IpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIHdpdGhpbiB0aGUgY2FudmFzLlxuICAgICAqIEdldHMgdGhlIG1vdXNlIHBvc2l0aW9uLCBjYWxscyB0aGUgbW9kaWZ5IG1ldGhvZHMgaWYgdGhlIGJvb2xlYW5zIHNhdGlzZnkgdGhlbS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZ2V0TW91c2VQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeURyYWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jlc2l6aW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplKHRoaXMudyA8IDE0LCB0aGlzLmggPCAxNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNDaGFuZ2luZ0RpbXMgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zKHRoaXMudyA8IDE0LCB0aGlzLmggPCAxNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBjbGlja3MgaW5zaWRlIHRoZSBjYW52YXMuXG4gICAgICogTW9kaWZpZXMgdGhlIHN0YXRlIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBndWlkZXMgY29udGFpbiB0aGUgbW91c2Ugb3IgdGhlIGJvdW5kaW5nIHJlY3QgY29udGFpbnMgdGhlIG1vdXNlLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlTdGF0ZSh0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSksIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIHVuY2xpY2tzLlxuICAgICAqIENhbGxzIG1vZGlmeVJlc2V0IHRvIHJlc2V0IGRyYWdnaW5nIGFuZCByZXNpemluZyBib29sZWFucyBhbW9uZyBvdGhlcnMuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZXVwIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJJJ20gYW4gZWxsaXBzZSFcIik7XG4gICAgICAgIHRoaXMubW9kaWZ5UmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHByZXNzZWQgZG93blxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHByZXNzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnREb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyByZWxlYXNlZFxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHJlbGVhc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0VXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIE1vZGlmaWNhdGlvbiBmdW5jdGlvbnMgKi9cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgaW4gb3JkZXIgdG8gZHJhZyB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIG1vZGlmeURyYWcoKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJlbGxpcHNlIGRyYWdvZmZ4OiBcIiArIHRoaXMuX2RyYWdvZmZ4KTtcbiAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueCAtIHRoaXMuX2RyYWdvZmZ4O1xuICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy5fZHJhZ29mZnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHNpemUgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZCAod2hlbiBhIGNvcm5lciBndWlkZSBpcyBjbGlja2VkIGFuZCBkcmFnZ2VkKS5cbiAgICAgKlxuICAgICAqIElmIGFueSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgdG9vIHNtYWxsLCBpdCBzZXRzIHRoZW0gZXF1YWwgdG8gMTQgYW5kIHRoZSBvdGhlciBlcXVhbCB0b1xuICAgICAqIDEwIGRpdmlkZWQgb3IgbXVsdGlwbGllZCBieSB0aGUgcmF0aW8gb2Ygd2lkdGgvaGVpZ2h0IHRvIGtlZXAgaXQgdGhlIHNhbWUuXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTRcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDE0XG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTQ7XG4gICAgICAgICAgICB0aGlzLl9jaXJjbGUud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTQpOyAvLyBzZXQgZm9yIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDE0IC8gdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9jaXJjbGUuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTQgLyB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyIC8gdGhpcy5fcmF0aW87XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxNDtcbiAgICAgICAgICAgIHRoaXMuX2NpcmNsZS5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTQpOyAvLyBzZXQgZm9yIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTQgKiB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2NpcmNsZS53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDE0ICogdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMiAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyO1xuICAgICAgICAgICAgdGhpcy5fY2lyY2xlLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMiAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fY2lyY2xlLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkLlxuICAgICAqIElmIGFueSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgdG9vIHNtYWxsLCBpdCBzZXRzIHRoZW0gZXF1YWwgdG8gMTAuXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5Q2hhbmdlRGltcyh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBpZiAodGhpcy5fY29ybmVyID09IDUgfHwgdGhpcy5fY29ybmVyID09IDcpIHsgLy8gaWYgbW9kaWZ5aW5nIGhlaWdodFxuICAgICAgICAgICAgaWYgKCFoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyIC8gdGhpcy5fcmF0aW87XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oOyAvLyBzZXR0aW5nIHdpZHRoL2hlaWdodCByYXRpbyA9IHRvIHRoZSBuZXcgcmF0aW9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxNCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMiAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIG1vZGlmeWluZyB3aWR0aFxuICAgICAgICAgICAgaWYgKCF3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxNDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgZGVwZW5kaW5nIG9uIHRoZSBtb3VzZSBwb3NpdGlvbiB3aGVuIGNhbGxlZCAob25Nb3VzZURvd24pXG4gICAgICogZS5nLiBpZiB0aGUgbW91c2UgaXMgd2l0aGluIHRoZSBib3VuZGluZyByZWN0YW5nbGUgd2hlbiB0aGlzIGlzIGNhbGxlZCwgaXNTZWxlY3RlZCA9IHRydWVcbiAgICAgKiBAcGFyYW0gZ3VpZGVDb250YWluc1xuICAgICAqIEBwYXJhbSBjb250YWluc1xuICAgICAqL1xuICAgIG1vZGlmeVN0YXRlKGd1aWRlQ29udGFpbnMsIGNvbnRhaW5zKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7IC8vcHJlcGFyZXMgdGhlIG9iamVjdCBmb3IgZHJhZ2dpbmcgd2hldGhlciBpdCBpcyBwZXJzb25hbGx5IHNlbGVjdGVkIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5feTEgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucyA+IDAgJiYgZ3VpZGVDb250YWlucyA8PSA0KSB7IC8vcmVzaXppbmdcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IGd1aWRlQ29udGFpbnM7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMueDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy55O1xuICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgdGhpcy5fd2lkdGgxID0gdGhpcy53O1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0MSA9IHRoaXMuaDtcbiAgICAgICAgICAgIC8vdGhpcy5fc2l6ZTEgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53LDIpICsgTWF0aC5wb3codGhpcy5oLDIpKTsgLy8gc2F2aW5nIG9sZCBzaXplXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucyA+IDQpIHsgLy9jaGFuZ2luZyBzaGFwZSBkaW1lbnNpb25zXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IGd1aWRlQ29udGFpbnM7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMueDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy55O1xuICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKSB7IC8vc2ltcGx5IHNlbGVjdGluZyB0aGUgc2hhcGUgb3IgZHJhZ2dpbmdcbiAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy54OyAvLyBTYXZpbmcgb3JpZ2luYWwgeCBhbmQgeVxuICAgICAgICAgICAgdGhpcy5feTEgPSB0aGlzLnk7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLng7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIHRvIGZhbHNlIChsaWtlIGRyYWdnaW5nLCByZXNpemluZywgZXRjKSB3aGVuIHRoZSBtb3VzZSBpcyByZWxlYXNlZFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7IC8vIHByb2JzIG9ubHkgbmVlZCBkcmFnZ2luZyBidXQgb2ggd2VsbCB8IGlzU2VsIHx8IHNlbE11bD9cbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl94MSAtIHRoaXMueCkgPiAxIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0gdGhpcy55KSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy90aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dNb3ZlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh0aGlzLl9pc1Jlc2l6aW5nIHx8IHRoaXMuX2lzQ2hhbmdpbmdEaW1zKSAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwicmVzaXppbmcgZWxsaXBzZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vbGV0IHNpemUyID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMudywyKSArIE1hdGgucG93KHRoaXMuaCwyKSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU2l6ZSBkaWZmOiBcIiArIE1hdGguYWJzKHRoaXMuX3NpemUxIC0gc2l6ZTIpKTtcbiAgICAgICAgICAgIGlmICgoTWF0aC5hYnModGhpcy5fd2lkdGgxIC0gdGhpcy53KSA+IDApIHx8IChNYXRoLmFicyh0aGlzLl9oZWlnaHQxIC0gdGhpcy5oKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUmVzaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmKHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpe1xuICAgICAgICAvLyAgICAgaWYoTWF0aC5hYnModGhpcy5feDEgLSB0aGlzLngpID4gMSB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHRoaXMueSkgPiAxKSB7XG4gICAgICAgIC8vICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nTW92ZSgpKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqL1xuICAgIGdldE1vdXNlUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuX21vdXNlLnggPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS54O1xuICAgICAgICB0aGlzLl9tb3VzZS55ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0NoYW5naW5nRGltcywgYW5kIGlzU2VsZWN0ZWQgdG8gZmFsc2UgaWYgdGhlIG1vdXNlIGNsaWNrcyBvdXRzaWRlIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIGlzTW91c2VPdXRzaWRlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgICAgICBsZXQgbW91c2VZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtb3VzZVggPCByZWN0LmxlZnQgfHwgbW91c2VYID4gcmVjdC5yaWdodCB8fCBtb3VzZVkgPCByZWN0LnRvcCB8fCBtb3VzZVkgPiByZWN0LmJvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcGFpbnQgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dQYWludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWludEV2ZW50XzEuUGFpbnRFdmVudChcImVsbGlwc2VcIiwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVzaXplIGV2ZW50XG4gICAgICovXG4gICAgbG9nUmVzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZUV2ZW50XzEuUmVzaXplRXZlbnQoXCJlbGxpcHNlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgTWF0aC5yb3VuZCh0aGlzLl93aWR0aDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuX2hlaWdodDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMudyAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5oICogMTAwKSAvIDEwMCk7XG4gICAgICAgIC8vTWF0aC5yb3VuZCh0aGlzLl9zaXplMSoxMDApLzEwMCwgTWF0aC5yb3VuZCgoTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMudywyKSArIE1hdGgucG93KHRoaXMuaCwyKSkqMTAwKSkvMTAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIGNsaWNrIGV2ZW50XG4gICAgICovXG4gICAgbG9nQ2xpY2soKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xpY2tFdmVudF8xLkNsaWNrRXZlbnQoXCJlbGxpcHNlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgYXNzaWducyBhbiBJRCB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgaW5pdElEKGlkKSB7XG4gICAgICAgIHRoaXMuaWRPYmogPSB7IF9pZDogaWQgfTtcbiAgICB9XG4gICAgYXN0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgZWxsaXBzZVxuICAgICAqL1xuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBlbGxpcHNlXG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBlbGxpcHNlXG4gICAgICovXG4gICAgZ2V0IHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGVsbGlwc2VcbiAgICAgKi9cbiAgICBnZXQgaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBEaW1lbnNpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBkaW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZWxsaXBzZSBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEIG9mIHRoZSBlbGxpcHNlXG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkT2JqLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZWxsaXBzZSBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKi9cbiAgICBnZXRKdXN0RHJhZ2dlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1c3REcmFnZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgc2V0SnVzdERyYWdnZWQodmFsKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGlzIGRyYWdnaW5nXG4gICAgICovXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIHNlbGVjdGlvbiBldmVudHNcbiAgICAgKi9cbiAgICB0b1NlbFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChcIiBlbGxpcHNlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIGRyYWcgZXZlbnRzXG4gICAgKi9cbiAgICB0b0RyYWdTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoXCJlbGxpcHNlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94MSArIFwiLCBcIiArIHRoaXMuX3kxICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gZWxsaXBzZSBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxufVxuZXhwb3J0cy5FbGxpcHNlRWZmZWN0ID0gRWxsaXBzZUVmZmVjdDtcbi8qKlxuICogR2V0J3MgdGhlIG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZXMgaW4gcmVsYXRpb24gdG8gdGhlIGNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB0aGUgY2FudmFzIG9iamVjdFxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0TW91c2VQb3MoY2FudmFzLCBldmVudCkge1xuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB4MSB4IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB5MSB5IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB4MiB4IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKiBAcGFyYW0geTIgeSBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MiwgMikgKyBNYXRoLnBvdyh5MSAtIHkyLCAyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbGxpcHNlRWZmZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBQYWludEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9QYWludEV2ZW50XCIpO1xuY29uc3QgUmVzaXplRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1Jlc2l6ZUV2ZW50XCIpO1xuY29uc3QgQ2xpY2tFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvQ2xpY2tFdmVudFwiKTtcbmNsYXNzIEVwaEVmZmVjdCB7XG4gICAgY29uc3RydWN0b3IoZXBoKSB7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTsgLy8gcHJpdmF0ZSBib29sc1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yYXRpbyA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSAwO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9tb3VzZSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2VwaCA9IGVwaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIGV2YWx1YXRpbmcgbm9kZXMgKFN0cmluZ05vZGUsIEVsbGlwc2VOb2RlLCBldGMpXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyBhbGwgcGFyYW1zIHRvIHByaXZhdGUgdmFyaWFibGVzIGFuZCBkcmF3cyB0aGUgaW5pdGlhbCBvYmplY3QgdG8gdGhlIGNhbnZhc1xuICAgICAqIGJ5IGNhbGxpbmcgdXBkYXRlKClcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgcGFyZW50IFNjb3BlIHRoYXQgY29udGFpbnMgdGhlIGNhbnZhcyBhbW9uZyBvdGhlciB0aGluZ3NcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgb2JqZWN0J3MgZGltZW5zaW9ucyBpbmNsdWRpbmcgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBhc3QgVW5uZWNlc3Nhcnkgbm93LCB1c2VkIHRvIGJlIHRoZSBwYXJlbnQgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY2FudmFzLmlzRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zID0gZGltcztcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IGNvbnRleHQuY2FudmFzLmdldCgpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgY3R4ID0gY29udGV4dC5jYW52YXMuZ2V0KCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgICAgICAgICAgdGhpcy5fZXBoSW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICB0aGlzLl9lcGhJbWcuc3JjID0gJy4vcGljcy9kZW1vbmNvdy5wbmcnO1xuICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1BhaW50KCkpO1xuICAgICAgICBjb250ZXh0LmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gZHJhdyBhbmQgcmVkcmF3IHRoZSBvYmplY3Qgd2hlbiBtYW5pcHVsYXRpb25zIGFyZSBtYWRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudztcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuaDtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAvL3ZhciBpbWdPYmogPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgLy9sZXQgY3R4ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIC8vIHRoaXMuX2VwaEltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAvLyB0aGlzLl9lcGhJbWcuc3JjID0gJy4vcGljcy9kZW1vbmNvdy5wbmcnO1xuICAgICAgICAvL2ltZ09iai5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICAvL3RoaXMuX2VwaEltZy5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLl9jdHguZHJhd0ltYWdlKHRoaXMuX2VwaEltZywgdGhpcy54LCB0aGlzLnksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvL3RoaXMuX2VwaEltZy5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICAvLyB0aGlzLl9lcGhJbWcud2lkdGggPSB3aWR0aDtcbiAgICAgICAgLy8gdGhpcy5fZXBoSW1nLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgLy99XG4gICAgICAgIC8vfVxuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3R3VpZGVzKHgsIHksIHdpZHRoLCBoZWlnaHQsIHRoaXMuX2Nvcm5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gb25lIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25TaGlmdERvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25TaGlmdFVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy9tYWtlcyBpdCBzbyB0aGF0IGRvdWJsZSBjbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0ZXh0IG9uIHRoZSBwYWdlXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uIChlKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGZhbHNlOyB9LCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIGFub3RoZXIgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvZiB0aGUgb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgY29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAobXggPiB4ICYmIG14IDwgeCArIHcgJiYgbXkgPiB5ICYmIG15IDwgeSArIGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciA+IDAgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvbmUgb2YgdGhlIGNvcm5lci9zaWRlIGd1aWRlcywgcmV0dXJucyAwIGlmIG5vdFxuICAgICAqIFRoZSBjb3JuZXIgZ3VpZGVzIGFyZSBudW1iZXJlZCAxLTQgd2l0aCAxIGJlaW5nIHRoZSB0b3AgbGVmdCwgMiBiZWluZyB0aGUgdG9wIHJpZ2h0LCBhbmQgc28gb24uXG4gICAgICogVGhlIG1pZGRsZSBndWlkZXMgYXJlIG51bWJlcmVkIDUtOCwgd2l0aCA1IGJlaW5nIHRoZSB0b3AgbWlkZGxlLCA2IGJlaW5nIHRoZSByaWdodCBtaWRkbGUsIGFuZCBzbyBvbi5cbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ3VpZGVDb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGxldCB4ZGlmID0gbXggLSB4O1xuICAgICAgICBsZXQgeWRpZiA9IG15IC0geTtcbiAgICAgICAgLyogQ29ybmVyIEd1aWRlcyAqL1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIGxlZnRcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogTWlkZGxlIEd1aWRlcyAqL1xuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0geTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGFuZCBndWlkZXMgZm9yIHRoZSBvYmplY3Qgd2hlbiB0aGUgb2JqZWN0IGlzIHNlbGVjdGVkXG4gICAgICogSWYgb25lIG9mIHRoZSBndWlkZXMgaXMgc2VsZWN0ZWQsIGl0IGNvbG9ycyB0aGF0IGd1aWRlIGJsdWVcbiAgICAgKiBAcGFyYW0geCB0aGUgeCBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0geSB0aGUgeSBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb3JuZXIgdGhlIG51bWJlciBvZiB0aGUgY29ybmVyIHRvIGJlIGNvbG9yZWQgYmx1ZSAoaWYgYW55IGF0IGFsbCwgaWYgMCwgYWxsIGFyZSB3aGl0ZSlcbiAgICAgKi9cbiAgICBkcmF3R3VpZGVzKHgsIHksIHcsIGgsIGNvcm5lcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKGNvcm5lciAhPT0gMCAmJiBjb3JuZXIgPD0gNCkge1xuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcmVwaCBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvcm5lciAhPT0gMCkge1xuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcmVwaCBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltcGxlIG1ldGhvZCB0aGF0IGRyYXdzIGEgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHggeCBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geSB5IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB3IHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb2xvciBjb2xvciBvZiB0aGUgcmVjdGFuZ2xlJ3MgZmlsbFxuICAgICAqL1xuICAgIGRyYXdTcXVhcmUoeCwgeSwgdywgaCwgY29sb3IpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIHdpdGhpbiB0aGUgY2FudmFzLlxuICAgICAqIEdldHMgdGhlIG1vdXNlIHBvc2l0aW9uLCBjYWxscyB0aGUgbW9kaWZ5IG1ldGhvZHMgaWYgdGhlIGJvb2xlYW5zIHNhdGlzZnkgdGhlbS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZ2V0TW91c2VQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeURyYWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jlc2l6aW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplKHRoaXMudyA8IDEwLCB0aGlzLmggPCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNDaGFuZ2luZ0RpbXMgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zKHRoaXMudyA8IDEwLCB0aGlzLmggPCAxMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBjbGlja3MgaW5zaWRlIHRoZSBjYW52YXMuXG4gICAgICogTW9kaWZpZXMgdGhlIHN0YXRlIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBndWlkZXMgY29udGFpbiB0aGUgbW91c2Ugb3IgdGhlIGJvdW5kaW5nIHJlY3QgY29udGFpbnMgdGhlIG1vdXNlLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlTdGF0ZSh0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSksIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIHVuY2xpY2tzLlxuICAgICAqIENhbGxzIG1vZGlmeVJlc2V0IHRvIHJlc2V0IGRyYWdnaW5nIGFuZCByZXNpemluZyBib29sZWFucyBhbW9uZyBvdGhlcnMuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZXVwIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5UmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHByZXNzZWQgZG93blxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHByZXNzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnREb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnRVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogTW9kaWZpY2F0aW9uIGZ1bmN0aW9ucyAqL1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBpbiBvcmRlciB0byBkcmFnIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgbW9kaWZ5RHJhZygpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImVwaGFuZ2xlIGRyYWdvZmZ4OiBcIiArIHRoaXMuX2RyYWdvZmZ4KTtcbiAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueCAtIHRoaXMuX2RyYWdvZmZ4O1xuICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy5fZHJhZ29mZnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHNpemUgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZCAod2hlbiBhIGNvcm5lciBndWlkZSBpcyBjbGlja2VkIGFuZCBkcmFnZ2VkKS5cbiAgICAgKlxuICAgICAqIElmIGFueSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgdG9vIHNtYWxsLCBpdCBzZXRzIHRoZW0gZXF1YWwgdG8gMTAgYW5kIHRoZSBvdGhlciBlcXVhbCB0b1xuICAgICAqIDEwIGRpdmlkZWQgb3IgbXVsdGlwbGllZCBieSB0aGUgcmF0aW8gb2Ygd2lkdGgvaGVpZ2h0IHRvIGtlZXAgaXQgdGhlIHNhbWUuXG4gICAgICpcbiAgICAgKiBUaGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBpcyBkb25lIGJ5IGNhbGxpbmcgdGhlIGhlbHBlciBtZXRob2QgbW9kaWZ5UmVzaXplSGVscGVyLlxuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZSh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBpZiAod2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fZXBoLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2VwaC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAvIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9lcGguaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMCAqIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fZXBoLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTAgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIHRoZSByZWN0YW5nbGUgb3JpZ2luYXRlcyBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgYW5kIG5vdCB0aGUgY2VudGVyLFxuICAgICAqIGl0IGNoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXMgd2VsbCBpZiBndWlkZXMgMSwgMiwgb3IgNCBhcmUgc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdEaXN0YW5jZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbW91c2UgYW5kIHRoZSBsb2NhdGlvbiBvcHBvc2l0ZSB0byBpdFxuICAgICAqIChpZiB0b3AgcmlnaHQgZ3VpZGUgaXMgY2xpY2tlZCwgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhhdCBhbmQgdGhlIGJvdHRvbSBsZWZ0IGd1aWRlIGlzIG5ld0Rpc3RhbmNlKVxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSkge1xuICAgICAgICBpZiAodGhpcy53ID4gMTAgJiYgdGhpcy5oID4gMTApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQoKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAvIHRoaXMuX3JhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgIHRoaXMuX2VwaC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW87XG4gICAgICAgIHRoaXMuX2VwaC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZC5cbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDEwLlxuICAgICAqIENhbGxzIG1vZGlmeUNoYW5nZURpbXNIZWxwZXIgdG8gYWN0dWFsbHkgZG8gdGhlIHdvcmtcbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9lcGgud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2VwaC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyA1IG9yIDggYXJlIHNlbGVjdGVkXG4gICAgICovXG4gICAgbW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53ID4gMTAgJiYgdGhpcy5oID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcGguaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcGgud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcGguaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudyA+IDEwICYmIHRoaXMuaCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcGgud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyBkZXBlbmRpbmcgb24gdGhlIG1vdXNlIHBvc2l0aW9uIHdoZW4gY2FsbGVkIChvbk1vdXNlRG93bilcbiAgICAgKiBlLmcuIGlmIHRoZSBtb3VzZSBpcyB3aXRoaW4gdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSB3aGVuIHRoaXMgaXMgY2FsbGVkLCBpc1NlbGVjdGVkID0gdHJ1ZVxuICAgICAqIEBwYXJhbSBndWlkZUNvbnRhaW5zXG4gICAgICogQHBhcmFtIGNvbnRhaW5zXG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGUoZ3VpZGVDb250YWlucywgY29udGFpbnMpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94MSA9IHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl95MSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucyA+IDAgJiYgZ3VpZGVDb250YWlucyA8PSA0KSB7IC8vcmVzaXppbmdcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KTtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodDEgPSB0aGlzLmg7XG4gICAgICAgICAgICB0aGlzLl93aWR0aDEgPSB0aGlzLnc7XG4gICAgICAgICAgICAvL3RoaXMuX3NpemUxID0gTWF0aC5zcXJ0KE1hdGgucG93KHcsMikgKyBNYXRoLnBvdyhoLDIpKTsgLy8gc2l6ZSBpcyBkaWFnb25hbCBsZW5ndGhcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3RoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSArIGggLyAyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gNCkgeyAvL2NoYW5naW5nIHNoYXBlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gZ3VpZGVDb250YWlucztcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdyAvIDIsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdyAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdyAvIDIsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5ICsgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3gxID0geDsgLy8gU2F2aW5nIG9yaWdpbmFsIHggYW5kIHlcbiAgICAgICAgICAgIHRoaXMuX3kxID0geTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyB0byBmYWxzZSAobGlrZSBkcmFnZ2luZywgcmVzaXppbmcsIGV0Yykgd2hlbiB0aGUgbW91c2UgaXMgcmVsZWFzZWRcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0gdGhpcy54KSA+IDEgfHwgTWF0aC5hYnModGhpcy5feTEgLSB0aGlzLnkpID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodGhpcy5faXNSZXNpemluZyB8fCB0aGlzLl9pc0NoYW5naW5nRGltcykgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHNpemUyID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMudywgMikgKyBNYXRoLnBvdyh0aGlzLmgsIDIpKTtcbiAgICAgICAgICAgIGlmICgoTWF0aC5hYnModGhpcy5fd2lkdGgxIC0gdGhpcy53KSA+IDApIHx8IChNYXRoLmFicyh0aGlzLl9oZWlnaHQxIC0gdGhpcy5oKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUmVzaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICovXG4gICAgZ2V0TW91c2VQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbW91c2UueCA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLng7XG4gICAgICAgIHRoaXMuX21vdXNlLnkgPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzQ2hhbmdpbmdEaW1zLCBhbmQgaXNTZWxlY3RlZCB0byBmYWxzZSBpZiB0aGUgbW91c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgaXNNb3VzZU91dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBsZXQgZXBoID0gdGhpcy5fY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobW91c2VYIDwgZXBoLmxlZnQgfHwgbW91c2VYID4gZXBoLnJpZ2h0IHx8IG1vdXNlWSA8IGVwaC50b3AgfHwgbW91c2VZID4gZXBoLmJvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGFuIGVwaCBwYWludCBldmVudFxuICAgICAqL1xuICAgIGxvZ1BhaW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhaW50RXZlbnRfMS5QYWludEV2ZW50KFwiZXBoXCIsIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhbiBlcGggcmVzaXplIGV2ZW50XG4gICAgICovXG4gICAgbG9nUmVzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZUV2ZW50XzEuUmVzaXplRXZlbnQoXCJlcGggd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCBNYXRoLnJvdW5kKHRoaXMuX3dpZHRoMSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5faGVpZ2h0MSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy53ICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLmggKiAxMDApIC8gMTAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhbiBlcGggY2xpY2sgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dDbGljaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGlja0V2ZW50XzEuQ2xpY2tFdmVudChcImVwaCB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIGFzc2lnbnMgYW4gSUQgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIGlkIFRoZSBJRCB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIGluaXRJRChpZCkge1xuICAgICAgICB0aGlzLmlkT2JqID0geyBfaWQ6IGlkIH07XG4gICAgfVxuICAgIGFzdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICB1cGRhdGVBU1QoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgZXBoXG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIGVwaFxuICAgICAqL1xuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgZXBoXG4gICAgICovXG4gICAgZ2V0IHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGVwaFxuICAgICAqL1xuICAgIGdldCBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERpbWVuc2lvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlcGggaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbWFnZVxuICAgICAqL1xuICAgIGdldCBpbWFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VwaEltZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIGVwaFxuICAgICAqL1xuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZE9iai5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVwaCBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKi9cbiAgICBnZXRKdXN0RHJhZ2dlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1c3REcmFnZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBlcGggaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBzZXRKdXN0RHJhZ2dlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVwaCBpcyBkcmFnZ2luZ1xuICAgICAqL1xuICAgIGdldCBpc0RyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEcmFnZ2luZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBzZWxlY3Rpb24gZXZlbnRzXG4gICAgICovXG4gICAgdG9TZWxTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIiBlcGggd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBkcmFnIGV2ZW50c1xuICAgICovXG4gICAgdG9EcmFnU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKFwiZXBoIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94MSArIFwiLCBcIiArIHRoaXMuX3kxICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gZXBoIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG59XG5leHBvcnRzLkVwaEVmZmVjdCA9IEVwaEVmZmVjdDtcbi8qKlxuICogR2V0cyB0aGUgbW91c2UgeCBhbmQgeSBjb29yZGluYXRlcyBpbiByZWxhdGlvbiB0byB0aGUgY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHRoZSBjYW52YXMgb2JqZWN0XG4gKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICovXG5mdW5jdGlvbiBnZXRNb3VzZVBvcyhjYW52YXMsIGV2ZW50KSB7XG4gICAgbGV0IGVwaCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gZXBoLmxlZnQsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSBlcGgudG9wXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHgxIHggY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHkxIHkgY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHgyIHggY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSB5MiB5IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgyLCAyKSArIE1hdGgucG93KHkxIC0geTIsIDIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVwaEVmZmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgUGFpbnRFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUGFpbnRFdmVudFwiKTtcbmNvbnN0IFJlc2l6ZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9SZXNpemVFdmVudFwiKTtcbmNvbnN0IENsaWNrRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL0NsaWNrRXZlbnRcIik7XG5jbGFzcyBMaW5lRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihsaW5lKSB7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTsgLy8gcHJpdmF0ZSBib29sc1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yYXRpbyA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSAwO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9tb3VzZSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2xpbmUgPSBsaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gZXZhbHVhdGluZyBub2RlcyAoU3RyaW5nTm9kZSwgRWxsaXBzZU5vZGUsIGV0YylcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3NpZ25zIGFsbCBwYXJhbXMgdG8gcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIGRyYXdzIHRoZSBpbml0aWFsIG9iamVjdCB0byB0aGUgY2FudmFzXG4gICAgICogYnkgY2FsbGluZyB1cGRhdGUoKVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBwYXJlbnQgU2NvcGUgdGhhdCBjb250YWlucyB0aGUgY2FudmFzIGFtb25nIG90aGVyIHRoaW5nc1xuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBvYmplY3QncyBkaW1lbnNpb25zIGluY2x1ZGluZyB4IGFuZCB5IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGFzdCBVbm5lY2Vzc2FyeSBub3csIHVzZWQgdG8gYmUgdGhlIHBhcmVudCBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBpZiAoY29udGV4dC5jYW52YXMuaXNEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMgPSBkaW1zO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gY29udGV4dC5jYW52YXMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0LmNhbnZhcy5nZXQoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUGFpbnQoKSk7XG4gICAgICAgIGNvbnRleHQuZWZmZWN0cy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBpbiBvcmRlciB0byBkcmF3IGFuZCByZWRyYXcgdGhlIG9iamVjdCB3aGVuIG1hbmlwdWxhdGlvbnMgYXJlIG1hZGVcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy53O1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5oO1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuX2N0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gXCIjNjczQUI3XCI7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0d1aWRlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0aGlzLl9jb3JuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIG9uZSBmZWxsIHN3b29wXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpOyAvLyBiaW5kIGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBtZWFuaW5nIG9mICd0aGlzJ1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uU2hpZnREb3duLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uU2hpZnRVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaXNNb3VzZU91dHNpZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vbWFrZXMgaXQgc28gdGhhdCBkb3VibGUgY2xpY2tpbmcgZG9lc24ndCBzZWxlY3QgdGV4dCBvbiB0aGUgcGFnZVxuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBmdW5jdGlvbiAoZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IHJldHVybiBmYWxzZTsgfSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBhbm90aGVyIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb2YgdGhlIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSwgZmFsc2UgaWYgb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgaWYgKG14ID4geCAmJiBteCA8IHggKyB3ICYmIG15ID4geSAmJiBteSA8IHkgKyBoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgPiAwIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb25lIG9mIHRoZSBjb3JuZXIvc2lkZSBndWlkZXMsIHJldHVybnMgMCBpZiBub3RcbiAgICAgKiBUaGUgY29ybmVyIGd1aWRlcyBhcmUgbnVtYmVyZWQgMS00IHdpdGggMSBiZWluZyB0aGUgdG9wIGxlZnQsIDIgYmVpbmcgdGhlIHRvcCByaWdodCwgYW5kIHNvIG9uLlxuICAgICAqIFRoZSBtaWRkbGUgZ3VpZGVzIGFyZSBudW1iZXJlZCA1LTgsIHdpdGggNSBiZWluZyB0aGUgdG9wIG1pZGRsZSwgNiBiZWluZyB0aGUgcmlnaHQgbWlkZGxlLCBhbmQgc28gb24uXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGd1aWRlQ29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBsZXQgeGRpZiA9IG14IC0geDtcbiAgICAgICAgbGV0IHlkaWYgPSBteSAtIHk7XG4gICAgICAgIC8qIENvcm5lciBHdWlkZXMgKi9cbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGgpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSB4O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICB9XG4gICAgICAgIC8qIE1pZGRsZSBHdWlkZXMgKi9cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3IC8gMik7XG4gICAgICAgIHlkaWYgPSBteSAtIHk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGggLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3IC8gMik7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSB4O1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGggLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBhbmQgZ3VpZGVzIGZvciB0aGUgb2JqZWN0IHdoZW4gdGhlIG9iamVjdCBpcyBzZWxlY3RlZFxuICAgICAqIElmIG9uZSBvZiB0aGUgZ3VpZGVzIGlzIHNlbGVjdGVkLCBpdCBjb2xvcnMgdGhhdCBndWlkZSBibHVlXG4gICAgICogQHBhcmFtIHggdGhlIHggY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHkgdGhlIHkgY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHcgdGhlIHdpZHRoIG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29ybmVyIHRoZSBudW1iZXIgb2YgdGhlIGNvcm5lciB0byBiZSBjb2xvcmVkIGJsdWUgKGlmIGFueSBhdCBhbGwsIGlmIDAsIGFsbCBhcmUgd2hpdGUpXG4gICAgICovXG4gICAgZHJhd0d1aWRlcyh4LCB5LCB3LCBoLCBjb3JuZXIpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmIChjb3JuZXIgIT09IDAgJiYgY29ybmVyIDw9IDQpIHsgLy8gYSBjb3JuZXIgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29ybmVyICE9PSAwKSB7IC8vIGEgbWlkZGxlIGd1aWRlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgY29ycmVjdCBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvL2lmIG5vIGd1aWRlcyBhcmUgc2VsZWN0ZWQsIGNvbG9ycyBldmVyeXRoaW5nIHdoaXRlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgbWV0aG9kIHRoYXQgZHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geCB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5IHkgY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHcgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIGNvbG9yIG9mIHRoZSByZWN0YW5nbGUncyBmaWxsXG4gICAgICovXG4gICAgZHJhd1NxdWFyZSh4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgd2l0aGluIHRoZSBjYW52YXMuXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24sIGNhbGxzIHRoZSBtb2RpZnkgbWV0aG9kcyBpZiB0aGUgYm9vbGVhbnMgc2F0aXNmeSB0aGVtLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRNb3VzZVBvc2l0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5RHJhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemUodGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0NoYW5naW5nRGltcyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXModGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIGNsaWNrcyBpbnNpZGUgdGhlIGNhbnZhcy5cbiAgICAgKiBNb2RpZmllcyB0aGUgc3RhdGUgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGd1aWRlcyBjb250YWluIHRoZSBtb3VzZSBvciB0aGUgYm91bmRpbmcgcmVjdCBjb250YWlucyB0aGUgbW91c2UuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVN0YXRlKHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSwgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgdW5jbGlja3MuXG4gICAgICogQ2FsbHMgbW9kaWZ5UmVzZXQgdG8gcmVzZXQgZHJhZ2dpbmcgYW5kIHJlc2l6aW5nIGJvb2xlYW5zIGFtb25nIG90aGVycy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNldXAgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlSZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcHJlc3NlZCBkb3duXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcHJlc3NlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdERvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHJlbGVhc2VkXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcmVsZWFzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnRVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogTW9kaWZpY2F0aW9uIGZ1bmN0aW9ucyAqL1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBpbiBvcmRlciB0byBkcmFnIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgbW9kaWZ5RHJhZygpIHtcbiAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueCAtIHRoaXMuX2RyYWdvZmZ4O1xuICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy5fZHJhZ29mZnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHNpemUgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZCAod2hlbiBhIGNvcm5lciBndWlkZSBpcyBjbGlja2VkIGFuZCBkcmFnZ2VkKS5cbiAgICAgKlxuICAgICAqIElmIGFueSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgdG9vIHNtYWxsLCBpdCBzZXRzIHRoZW0gZXF1YWwgdG8gMTAgYW5kIHRoZSBvdGhlciBlcXVhbCB0b1xuICAgICAqIDEwIGRpdmlkZWQgb3IgbXVsdGlwbGllZCBieSB0aGUgcmF0aW8gb2Ygd2lkdGgvaGVpZ2h0IHRvIGtlZXAgaXQgdGhlIHNhbWUuXG4gICAgICpcbiAgICAgKiBUaGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBpcyBkb25lIGJ5IGNhbGxpbmcgdGhlIGhlbHBlciBtZXRob2QgbW9kaWZ5UmVzaXplSGVscGVyLlxuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZSh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBpZiAod2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fbGluZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7IC8vIHNldCBmb3IgdGhlIHByb2RpcmVjdCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2xpbmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAvIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9saW5lLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTsgLy8gc2V0IGZvciB0aGUgcHJvZGlyZWN0IG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwICogdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9saW5lLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTAgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIHRoZSByZWN0YW5nbGUgb3JpZ2luYXRlcyBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgYW5kIG5vdCB0aGUgY2VudGVyLFxuICAgICAqIGl0IGNoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXMgd2VsbCBpZiBndWlkZXMgMSwgMiwgb3IgNCBhcmUgc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdEaXN0YW5jZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbW91c2UgYW5kIHRoZSBsb2NhdGlvbiBvcHBvc2l0ZSB0byBpdFxuICAgICAqIChpZiB0b3AgcmlnaHQgZ3VpZGUgaXMgY2xpY2tlZCwgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhhdCBhbmQgdGhlIGJvdHRvbSBsZWZ0IGd1aWRlIGlzIG5ld0Rpc3RhbmNlKVxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSkge1xuICAgICAgICBpZiAodGhpcy53ID4gMTAgJiYgdGhpcy5oID4gMTApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQoKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAvIHRoaXMuX3JhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgIHRoaXMuX2xpbmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAvIHRoaXMuX3JhdGlvO1xuICAgICAgICB0aGlzLl9saW5lLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQuXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMC5cbiAgICAgKiBDYWxscyBtb2RpZnlDaGFuZ2VEaW1zSGVscGVyIHRvIGFjdHVhbGx5IGRvIHRoZSB3b3JrXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5Q2hhbmdlRGltcyh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBpZiAod2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fbGluZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fbGluZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGUgcmVjdGFuZ2xlIG9yaWdpbmF0ZXMgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIGFuZCBub3QgdGhlIGNlbnRlcixcbiAgICAgKiBpdCBjaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFzIHdlbGwgaWYgZ3VpZGVzIDUgb3IgOCBhcmUgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmggPiAxMCkgeyAvL2FzIGxvbmcgYXMgdGhlIGhlaWdodCBpcyA+IDEwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53ID4gMTApIHsgLy8gYXMgbG9uZyBhcyB3aWR0aCBpcyA+IDEwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgZGVwZW5kaW5nIG9uIHRoZSBtb3VzZSBwb3NpdGlvbiB3aGVuIGNhbGxlZCAob25Nb3VzZURvd24pXG4gICAgICogZS5nLiBpZiB0aGUgbW91c2UgaXMgd2l0aGluIHRoZSBib3VuZGluZyByZWN0YW5nbGUgd2hlbiB0aGlzIGlzIGNhbGxlZCwgaXNTZWxlY3RlZCA9IHRydWVcbiAgICAgKiBAcGFyYW0gZ3VpZGVDb250YWluc1xuICAgICAqIEBwYXJhbSBjb250YWluc1xuICAgICAqL1xuICAgIG1vZGlmeVN0YXRlKGd1aWRlQ29udGFpbnMsIGNvbnRhaW5zKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkgeyAvL3ByZXBhcmVzIHRoZSBvYmplY3QgZm9yIGRyYWdnaW5nIHdoZXRoZXIgaXQgaXMgcGVyc29uYWxseSBzZWxlY3RlZCBvciBub3RcbiAgICAgICAgICAgIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kxID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gMCAmJiBndWlkZUNvbnRhaW5zIDw9IDQpIHsgLy9yZXNpemluZ1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gdGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0MSA9IHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoMSA9IHRoaXMudztcbiAgICAgICAgICAgIC8vdGhpcy5fc2l6ZTEgPSBNYXRoLnNxcnQoTWF0aC5wb3codywyKSArIE1hdGgucG93KGgsMikpOyAvLyBzaXplIGlzIGRpYWdvbmFsIGxlbmd0aFxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHsgLy8gc2V0cyB0aGUgb2Zmc2V0cyBkZXBlbmRpbmcgb24gd2hpY2ggY29ybmVyIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgY2FzZSAxOiAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3OyAvLyBvZmZzZXQgaXMgYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoOyAvLyBvZmZzZXQgaXMgYm90dG9tIGxlZnQsIGV0Y1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucyA+IDQpIHsgLy9jaGFuZ2luZyBzaGFwZSBkaW1lbnNpb25zXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IGd1aWRlQ29udGFpbnM7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikgeyAvLyBzZXRzIHRoZSBvZmZzZXRzIGRlcGVuZGluZyBvbiB3aGljaCBtaWRkbGUgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIDU6IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyOyAvLyBvZmZzZXQgaXMgYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6IC8vcmlnaHQgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaCAvIDI7IC8vIG9mZnNldCBpcyBsZWZ0IG1pZGRsZSBldGNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdyAvIDIsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5ICsgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbnMpIHsgLy8gZHJhZ2dpbmdcbiAgICAgICAgICAgIHRoaXMuX3gxID0geDsgLy8gU2F2aW5nIG9yaWdpbmFsIHggYW5kIHlcbiAgICAgICAgICAgIHRoaXMuX3kxID0geTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7IC8vIG5vdCBzZWxlY3RlZFxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgdG8gZmFsc2UgKGxpa2UgZHJhZ2dpbmcsIHJlc2l6aW5nLCBldGMpIHdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkXG4gICAgICovXG4gICAgbW9kaWZ5UmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl94MSAtIHRoaXMueCkgPiAxIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0gdGhpcy55KSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHRoaXMuX2lzUmVzaXppbmcgfHwgdGhpcy5faXNDaGFuZ2luZ0RpbXMpICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBzaXplMiA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLncsIDIpICsgTWF0aC5wb3codGhpcy5oLCAyKSk7XG4gICAgICAgICAgICBpZiAoKE1hdGguYWJzKHRoaXMuX3dpZHRoMSAtIHRoaXMudykgPiAwKSB8fCAoTWF0aC5hYnModGhpcy5faGVpZ2h0MSAtIHRoaXMuaCkgPiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1Jlc2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqL1xuICAgIGdldE1vdXNlUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuX21vdXNlLnggPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS54O1xuICAgICAgICB0aGlzLl9tb3VzZS55ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0NoYW5naW5nRGltcywgYW5kIGlzU2VsZWN0ZWQgdG8gZmFsc2UgaWYgdGhlIG1vdXNlIGNsaWNrcyBvdXRzaWRlIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIGlzTW91c2VPdXRzaWRlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgICAgICBsZXQgbW91c2VZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtb3VzZVggPCByZWN0LmxlZnQgfHwgbW91c2VYID4gcmVjdC5yaWdodCB8fCBtb3VzZVkgPCByZWN0LnRvcCB8fCBtb3VzZVkgPiByZWN0LmJvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlY3RhbmdsZSBwYWludCBldmVudFxuICAgICAqL1xuICAgIGxvZ1BhaW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhaW50RXZlbnRfMS5QYWludEV2ZW50KFwicmVjdGFuZ2xlXCIsIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlY3RhbmdsZSByZXNpemUgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dSZXNpemUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplRXZlbnRfMS5SZXNpemVFdmVudChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIE1hdGgucm91bmQodGhpcy5fd2lkdGgxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLl9oZWlnaHQxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLncgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuaCAqIDEwMCkgLyAxMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIGNsaWNrIGV2ZW50XG4gICAgICovXG4gICAgbG9nQ2xpY2soKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xpY2tFdmVudF8xLkNsaWNrRXZlbnQoXCJyZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCBhc3NpZ25zIGFuIElEIHRvIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSBpZCBUaGUgSUQgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBpbml0SUQoaWQpIHtcbiAgICAgICAgdGhpcy5pZE9iaiA9IHsgX2lkOiBpZCB9O1xuICAgIH1cbiAgICBhc3QoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERpbWVuc2lvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRPYmouX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqL1xuICAgIGdldEp1c3REcmFnZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fanVzdERyYWdnZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBzZXRKdXN0RHJhZ2dlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaXMgZHJhZ2dpbmdcbiAgICAgKi9cbiAgICBnZXQgaXNEcmFnZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRHJhZ2dpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3Igc2VsZWN0aW9uIGV2ZW50c1xuICAgICAqL1xuICAgIHRvU2VsU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCIgcmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgZHJhZyBldmVudHNcbiAgICAqL1xuICAgIHRvRHJhZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBmcm9tIFwiICsgdGhpcy5feDEgKyBcIiwgXCIgKyB0aGlzLl95MSArIFwiIHRvIFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBJRCBhc3NpZ25tZW50IGV2ZW50c1xuICAgICAqL1xuICAgIHRvSURTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pZE9iai5faWQudG9TdHJpbmcoKSArIFwiIHRvIHJlY3RhbmdsZSBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxufVxuZXhwb3J0cy5MaW5lRWZmZWN0ID0gTGluZUVmZmVjdDtcbi8qKlxuICogR2V0cyB0aGUgbW91c2UgeCBhbmQgeSBjb29yZGluYXRlcyBpbiByZWxhdGlvbiB0byB0aGUgY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHRoZSBjYW52YXMgb2JqZWN0XG4gKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICovXG5mdW5jdGlvbiBnZXRNb3VzZVBvcyhjYW52YXMsIGV2ZW50KSB7XG4gICAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHgxIHggY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHkxIHkgY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHgyIHggY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSB5MiB5IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgyLCAyKSArIE1hdGgucG93KHkxIC0geTIsIDIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmVFZmZlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBQYWludEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9QYWludEV2ZW50XCIpO1xuY29uc3QgUmVzaXplRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1Jlc2l6ZUV2ZW50XCIpO1xuY29uc3QgQ2xpY2tFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvQ2xpY2tFdmVudFwiKTtcbmNsYXNzIE51bWJlckVmZmVjdCB7XG4gICAgY29uc3RydWN0b3IobnVtKSB7XG4gICAgICAgIHRoaXMuX2ZvbnRTaXplID0gMjA7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0xpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gMDtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5fbW91c2UgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzID0ge1xuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBpbnRlcnZhbDogMCxcbiAgICAgICAgICAgIHN0cjogXCJcIixcbiAgICAgICAgICAgIGluaXRNb3VzZVBvczogMCxcbiAgICAgICAgICAgIGN1cnNvclBvczogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9udW0gPSBudW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiBldmFsdWF0aW5nIG5vZGVzIChTdHJpbmdOb2RlLCBFbGxpcHNlTm9kZSwgZXRjKVxuICAgICAqIFRoaXMgbWV0aG9kIGFzc2lnbnMgYWxsIHBhcmFtcyB0byBwcml2YXRlIHZhcmlhYmxlcyBhbmQgZHJhd3MgdGhlIGluaXRpYWwgb2JqZWN0IHRvIHRoZSBjYW52YXNcbiAgICAgKiBieSBjYWxsaW5nIHVwZGF0ZSgpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIHBhcmVudCBTY29wZSB0aGF0IGNvbnRhaW5zIHRoZSBjYW52YXMgYW1vbmcgb3RoZXIgdGhpbmdzXG4gICAgICogQHBhcmFtIGRpbXMgVGhlIG9iamVjdCdzIGRpbWVuc2lvbnMgaW5jbHVkaW5nIHggYW5kIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gYXN0IFVubmVjZXNzYXJ5IG5vdywgdXNlZCB0byBiZSB0aGUgcGFyZW50IEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNhbnZhcyAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gY29udGV4dC5jYW52YXMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9kaW1zID0gZGltcztcbiAgICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0LmNhbnZhcy5nZXQoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgLy8gbG9nZ2luZ1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUGFpbnQoKSk7IC8vIHRoaXMuY29udGV4dCBvciBjb250ZXh0P1xuICAgICAgICAgICAgY29udGV4dC5lZmZlY3RzLnB1c2godGhpcyk7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNhbnZhcyBpcyBOT1QgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gZHJhdyBhbmQgcmVkcmF3IHRoZSBvYmplY3Qgd2hlbiBtYW5pcHVsYXRpb25zIGFyZSBtYWRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgZm9udERlZXRzID0gdGhpcy5fZm9udFNpemUgKyBcInB4IENvdXJpZXIgTmV3XCI7XG4gICAgICAgIHRoaXMuX2N0eC5mb250ID0gZm9udERlZXRzO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gXCIjNjczQUI3XCI7XG4gICAgICAgIGxldCBzdHIgPSB0aGlzLl9udW0udG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxUZXh0KHN0ciwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICBsZXQgbnVtYmVyRGltcyA9IHRoaXMuX2N0eC5tZWFzdXJlVGV4dChzdHIpO1xuICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLndpZHRoID0gbnVtYmVyRGltcy53aWR0aDtcbiAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5oZWlnaHQgPSB0aGlzLl9mb250U2l6ZTtcbiAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5zdHIgPSBzdHI7XG4gICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuaW50ZXJ2YWwgPSB0aGlzLl9udW1iZXJNZXRyaWNzLndpZHRoIC8gdGhpcy5fbnVtYmVyTWV0cmljcy5zdHIubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3VGV4dEd1aWRlcyh0aGlzLngsIHRoaXMueSAtIHRoaXMuX2ZvbnRTaXplLCB0aGlzLl9udW1iZXJNZXRyaWNzLndpZHRoLCB0aGlzLl9udW1iZXJNZXRyaWNzLmhlaWdodCwgdGhpcy5fY29ybmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNFZGl0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBvbmUgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTsgLy8gYmluZCBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgbWVhbmluZyBvZiAndGhpcydcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vblNoaWZ0RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vblNoaWZ0VXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmlzTW91c2VPdXRzaWRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL21ha2VzIGl0IHNvIHRoYXQgZG91YmxlIGNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRleHQgb24gdGhlIHBhZ2VcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgZnVuY3Rpb24gKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZmFsc2U7IH0sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gYW5vdGhlciBmZWxsIHN3b29wXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9mIHRoZSBvYmplY3QncyBib3VuZGluZyByZWN0YW5nbGUsIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBjb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnggPD0gbXgpICYmICh0aGlzLnggKyB0aGlzLl9udW1iZXJNZXRyaWNzLndpZHRoID49IG14KSAmJlxuICAgICAgICAgICAgKHRoaXMueSAtIHRoaXMuX2ZvbnRTaXplIDw9IG15KSAmJiAodGhpcy55ID49IG15KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciA+IDAgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvbmUgb2YgdGhlIGNvcm5lci9zaWRlIGd1aWRlcywgcmV0dXJucyAwIGlmIG5vdFxuICAgICAqIFRoZSBjb3JuZXIgZ3VpZGVzIGFyZSBudW1iZXJlZCAxLTQgd2l0aCAxIGJlaW5nIHRoZSB0b3AgbGVmdCwgMiBiZWluZyB0aGUgdG9wIHJpZ2h0LCBhbmQgc28gb24uXG4gICAgICogVGhlIG1pZGRsZSBndWlkZXMgYXJlIG51bWJlcmVkIDUtOCwgd2l0aCA1IGJlaW5nIHRoZSB0b3AgbWlkZGxlLCA2IGJlaW5nIHRoZSByaWdodCBtaWRkbGUsIGFuZCBzbyBvbi5cbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ3VpZGVDb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHhkaWYgPSBteCAtICh0aGlzLnggKyB0aGlzLl9udW1iZXJNZXRyaWNzLndpZHRoKTtcbiAgICAgICAgbGV0IHlkaWYgPSBteSAtICh0aGlzLnkgLSB0aGlzLl9mb250U2l6ZSk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBib3VuZGluZyByZWN0YW5nbGUgYW5kIGd1aWRlcyBmb3IgdGhlIG9iamVjdCB3aGVuIHRoZSBvYmplY3QgaXMgc2VsZWN0ZWRcbiAgICAgKiBJZiBvbmUgb2YgdGhlIGd1aWRlcyBpcyBzZWxlY3RlZCwgaXQgY29sb3JzIHRoYXQgZ3VpZGUgYmx1ZVxuICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB5IHRoZSB5IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB3IHRoZSB3aWR0aCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggdGhlIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvcm5lciB0aGUgbnVtYmVyIG9mIHRoZSBjb3JuZXIgdG8gYmUgY29sb3JlZCBibHVlIChpZiBhbnkgYXQgYWxsLCBpZiAwLCBhbGwgYXJlIHdoaXRlKVxuICAgICAqL1xuICAgIGRyYXdUZXh0R3VpZGVzKHgsIHksIHcsIGgsIGNvcm5lcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKGNvcm5lciAhPT0gMCkge1xuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGd1aWRlIGJsdWUgaWYgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBtZXRob2QgdGhhdCBkcmF3cyBhIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB4IHggY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHkgeSBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gdyB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29sb3IgY29sb3Igb2YgdGhlIHJlY3RhbmdsZSdzIGZpbGxcbiAgICAgKi9cbiAgICBkcmF3U3F1YXJlKHgsIHksIHcsIGgsIGNvbG9yKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgLyogRXZlbnQgbGlzdGVuZXIgZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBtb3ZlcyB3aXRoaW4gdGhlIGNhbnZhcy5cbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiwgY2FsbHMgdGhlIG1vZGlmeSBtZXRob2RzIGlmIHRoZSBib29sZWFucyBzYXRpc2Z5IHRoZW0uXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICB0aGlzLmdldE1vdXNlUG9zaXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQgJiYgdGhpcy5faXNEcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlEcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZXNpemluZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZSh0aGlzLl9mb250U2l6ZSA8IDE1KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIGNsaWNrcyBpbnNpZGUgdGhlIGNhbnZhcy5cbiAgICAgKiBNb2RpZmllcyB0aGUgc3RhdGUgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGd1aWRlcyBjb250YWluIHRoZSBtb3VzZSBvciB0aGUgYm91bmRpbmcgcmVjdCBjb250YWlucyB0aGUgbW91c2UuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgJiYgdGhpcy5faXNTZWxlY3RlZCAmJiB0aGlzLmNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpKSB7IC8vdGV4dCBlZGl0aW5nXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm1vZGlmeVRleHQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pc0xpc3RlbmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5pbml0TW91c2VQb3MgPSB0aGlzLl9tb3VzZS54O1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RpZnlTdGF0ZSh0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkgPiAwLCB0aGlzLmNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSB1bmNsaWNrcy5cbiAgICAgKiBDYWxscyBtb2RpZnlSZXNldCB0byByZXNldCBkcmFnZ2luZyBhbmQgcmVzaXppbmcgYm9vbGVhbnMgYW1vbmcgb3RoZXJzLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2V1cCBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VVcChldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyBwcmVzc2VkIGRvd25cbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSBwcmVzc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcmVsZWFzZWRcbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSByZWxlYXNlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdFVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBNb2RpZmljYXRpb24gZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGRyYWcgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBtb2RpZnlEcmFnKCkge1xuICAgICAgICAvLyhcInN0cmluZyBkcmFnb2ZmeDogXCIgKyB0aGlzLl9kcmFnb2ZmeCk7XG4gICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLl9kcmFnb2ZmeDtcbiAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueSAtIHRoaXMuX2RyYWdvZmZ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCBtb3ZlcyB0aGUgdGV4dCBlZGl0IGN1cnNvciBiYXNlZCBvbiB3aGVyZSB0aGUgbW91c2UgaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIG1vZGlmeVRleHRDdXJzb3IoKSB7XG4gICAgICAgIGxldCBsZWZ0V2FsbCA9IHRoaXMueDsgLy8gdGhlIHggcG9zaXRpb24gb2YgdGhlIGxlZnQgbW9zdCBzaWRlIG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgICAgbGV0IHhEaWYgPSB0aGlzLl9udW1iZXJNZXRyaWNzLmluaXRNb3VzZVBvcyAtIGxlZnRXYWxsOyAvLyBkaWZmZXJlbmNlIGJldHdlZW4gbW91c2UgeCBhbmQgbGVmdCB3YWxsXG4gICAgICAgIGxldCBpbnRlcnZhbCA9IHRoaXMuX251bWJlck1ldHJpY3MuaW50ZXJ2YWw7IC8vIHRoZSB0ZXh0IHdpZHRoIGRpdmlkZWQgYnkgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nXG4gICAgICAgIGxldCBtb3ZlRmFjdG9yID0gMDtcbiAgICAgICAgaWYgKHhEaWYgPj0gaW50ZXJ2YWwgLyAyICYmIHhEaWYgPD0gaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIG1vdmVGYWN0b3IgPSBsZWZ0V2FsbCArIGludGVydmFsO1xuICAgICAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5jdXJzb3JQb3MgPSBpbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4RGlmIDw9IGludGVydmFsIC8gMikge1xuICAgICAgICAgICAgbW92ZUZhY3RvciA9IGxlZnRXYWxsO1xuICAgICAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5jdXJzb3JQb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHhEaWYgJSBpbnRlcnZhbCA+PSBpbnRlcnZhbCAvIDIpIHtcbiAgICAgICAgICAgIG1vdmVGYWN0b3IgPSBsZWZ0V2FsbCArIGludGVydmFsICogTWF0aC5jZWlsKHhEaWYgLyBpbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmN1cnNvclBvcyA9IGludGVydmFsICogTWF0aC5jZWlsKHhEaWYgLyBpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeERpZiAlIGludGVydmFsIDwgaW50ZXJ2YWwgLyAyKSB7XG4gICAgICAgICAgICBtb3ZlRmFjdG9yID0gbGVmdFdhbGwgKyBpbnRlcnZhbCAqIE1hdGguZmxvb3IoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuY3Vyc29yUG9zID0gaW50ZXJ2YWwgKiBNYXRoLmZsb29yKHhEaWYgLyBpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3R4Lm1vdmVUbyhtb3ZlRmFjdG9yLCB0aGlzLnkgLSB0aGlzLl9mb250U2l6ZSk7XG4gICAgICAgIHRoaXMuX2N0eC5saW5lVG8obW92ZUZhY3RvciwgdGhpcy55KTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gXCJncmV5XCI7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBlZGl0cyB0aGUgc3RyaW5nIHdoZW4gZWRpdGluZyB0ZXh0XG4gICAgICogQHBhcmFtIGV2ZW50IGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBtb2RpZnlUZXh0KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdEhhbGY7XG4gICAgICAgICAgICBsZXQgc2Vjb25kSGFsZjtcbiAgICAgICAgICAgIGxldCBzdHIgPSB0aGlzLl9udW0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBicmVha1BvaW50ID0gdGhpcy5fbnVtYmVyTWV0cmljcy5jdXJzb3JQb3MgLyB0aGlzLl9udW1iZXJNZXRyaWNzLmludGVydmFsO1xuICAgICAgICAgICAgZmlyc3RIYWxmID0gc3RyLnN1YnN0cmluZygwLCBicmVha1BvaW50KTtcbiAgICAgICAgICAgIHNlY29uZEhhbGYgPSBzdHIuc3Vic3RyaW5nKGJyZWFrUG9pbnQpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzcgJiYgdGhpcy5fbnVtYmVyTWV0cmljcy5pbml0TW91c2VQb3MgPiB0aGlzLnggKyB0aGlzLl9udW1iZXJNZXRyaWNzLmludGVydmFsIC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuaW5pdE1vdXNlUG9zIC09IHRoaXMuX251bWJlck1ldHJpY3MuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDM5ICYmIHRoaXMuX251bWJlck1ldHJpY3MuaW5pdE1vdXNlUG9zIDwgdGhpcy54ICsgdGhpcy5fbnVtYmVyTWV0cmljcy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuaW5pdE1vdXNlUG9zICs9IHRoaXMuX251bWJlck1ldHJpY3MuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDggJiYgc3RyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmaXJzdEhhbGYgPSBmaXJzdEhhbGYuc3Vic3RyaW5nKDAsIGZpcnN0SGFsZi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBzdHIgPSBmaXJzdEhhbGYgKyBzZWNvbmRIYWxmO1xuICAgICAgICAgICAgICAgIHRoaXMuX251bS52YWwgPSBOdW1iZXIoc3RyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmluaXRNb3VzZVBvcyAtPSB0aGlzLl9udW1iZXJNZXRyaWNzLmludGVydmFsO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGtleU5hbWUgPSBldmVudC5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKGtleU5hbWUubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RIYWxmICs9IGtleU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGZpcnN0SGFsZiArIHNlY29uZEhhbGY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX251bS52YWwgPSBOdW1iZXIoc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5pbml0TW91c2VQb3MgKz0gdGhpcy5fbnVtYmVyTWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIHRoZSBmb250IHNpemUgb2YgdGhlIHRleHRcbiAgICAgKiBJZiB0aGUgdGV4dCBmb250IGlzIHNtYWxsZXIgdGhhbiAxNXB0LCBpdCBzZXQncyBpdCBlcXVhbCB0byAxNXB0XG4gICAgICogQHBhcmFtIGlzVG9vU21hbGwgdHJ1ZSBpZiB0aGUgZm9udCBzaXplIGlzIDwgMTVcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNpemUoaXNUb29TbWFsbCkge1xuICAgICAgICBpZiAoaXNUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZm9udFNpemUgPSAxNTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9udFNpemUgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDAuMjtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICB0aGlzLl9mb250U2l6ZSArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMC4yO1xuICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgZGVwZW5kaW5nIG9uIHRoZSBtb3VzZSBwb3NpdGlvbiB3aGVuIGNhbGxlZCAob25Nb3VzZURvd24pXG4gICAgICogZS5nLiBpZiB0aGUgbW91c2UgaXMgd2l0aGluIHRoZSBib3VuZGluZyByZWN0YW5nbGUgd2hlbiB0aGlzIGlzIGNhbGxlZCwgaXNTZWxlY3RlZCA9IHRydWVcbiAgICAgKiBAcGFyYW0gZ3VpZGVDb250YWluc1xuICAgICAqIEBwYXJhbSBjb250YWluc1xuICAgICAqL1xuICAgIG1vZGlmeVN0YXRlKGd1aWRlQ29udGFpbnMsIGNvbnRhaW5zKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7IC8vcHJlcGFyZXMgdGhlIG9iamVjdCBmb3IgZHJhZ2dpbmcgd2hldGhlciBpdCBpcyBwZXJzb25hbGx5IHNlbGVjdGVkIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYodGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC5tdWxTZWwpe1xuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKFwic3RyaW5nIGVmZmVjdCBtdWxTZWxlY3RlZDogXCIgKyB0aGlzLl9jb250ZXh0Lm11bFNlbGVjdGVkLm11bFNlbCk7XG4gICAgICAgICAgICAvLyAgICAgLy9pZih0aGlzLl9jb250ZXh0Lm11bFNlbGVjdGVkLnZhbCl7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nU2VsZWN0ZWQoKSk7XG4gICAgICAgICAgICAvLyAgICAgLy90aGlzLmxvZ1NlbGVjdGVkKCk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucykgeyAvL2lmIHRoZSBjb3JuZXIgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIHdlIGFyZSByZXNpemluZ1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSB0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy54O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLnk7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3NpemUxID0gdGhpcy5fZm9udFNpemU7IC8vIHNhdmluZyBvbGQgZm9udCBzaXplXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSB0aGlzLng7IC8vIFNhdmluZyBvcmlnaW5hbCB4IGFuZCB5XG4gICAgICAgICAgICB0aGlzLl95ID0gdGhpcy55O1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHRoaXMueDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNFZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgdG8gZmFsc2UgKGxpa2UgZHJhZ2dpbmcsIHJlc2l6aW5nLCBldGMpIHdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkXG4gICAgICovXG4gICAgbW9kaWZ5UmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl94IC0gdGhpcy54KSA+IDEgfHwgTWF0aC5hYnModGhpcy5feSAtIHRoaXMueSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nTW92ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jlc2l6aW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl9zaXplMSAtIHRoaXMuX2ZvbnRTaXplKSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dSZXNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3RyaW5nIGVmZmVjdCBtdWxTZWxlY3RlZDogXCIgKyB0aGlzLl9jb250ZXh0Lm11bFNlbGVjdGVkLnZhbCk7XG4gICAgICAgIC8vIGlmKHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQudmFsKXtcbiAgICAgICAgLy8gICAgIHRoaXMubG9nU2VsZWN0ZWQoKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZih0aGlzLmlzTXVsdGlwbGVTZWxlY3RlZCl7XG4gICAgICAgIC8vICAgICBjb250ZXh0LmV2ZW50TG9nLnB1c2gobmV3IFNlbGVjdEV2ZW50KHNlbGVjdGVkRWxlbXMpKTtcbiAgICAgICAgLy8gICAgIG1hc3RlckxvZy5wdXNoKGNvbnRleHQuZXZlbnRMb2dbY29udGV4dC5ldmVudExvZy5sZW5ndGggLSAxXSk7XG4gICAgICAgIC8vICAgICAvL2NvbnNvbGUubG9nKFwibXVsdGlwbGUgc2VsZWN0ZWRcIik7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gLy90aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dNb3ZlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICovXG4gICAgZ2V0TW91c2VQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbW91c2UueCA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLng7XG4gICAgICAgIHRoaXMuX21vdXNlLnkgPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzQ2hhbmdpbmdEaW1zLCBhbmQgaXNTZWxlY3RlZCB0byBmYWxzZSBpZiB0aGUgbW91c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgaXNNb3VzZU91dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1vdXNlWCA8IHJlY3QubGVmdCB8fCBtb3VzZVggPiByZWN0LnJpZ2h0IHx8IG1vdXNlWSA8IHJlY3QudG9wIHx8IG1vdXNlWSA+IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHBhaW50IGV2ZW50XG4gICAgICovXG4gICAgbG9nUGFpbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpbnRFdmVudF8xLlBhaW50RXZlbnQodGhpcy5fbnVtLnRvU3RyaW5nKCksIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlc2l6ZSBldmVudFxuICAgICAqL1xuICAgIGxvZ1Jlc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVFdmVudF8xLlJlc2l6ZUV2ZW50KHRoaXMuX251bS50b1N0cmluZygpICsgXCIgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCBNYXRoLnJvdW5kKHRoaXMuX3NpemUxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLl9mb250U2l6ZSAqIDEwMCkgLyAxMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgY2xpY2sgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dDbGljaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGlja0V2ZW50XzEuQ2xpY2tFdmVudCh0aGlzLl9udW0udG9TdHJpbmcoKSArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgYXNzaWducyBhbiBJRCB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgaW5pdElEKGlkKSB7XG4gICAgICAgIHRoaXMuaWRPYmogPSB7IF9pZDogaWQsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIGdldCBjYW52YXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBjYW52YXMgVGhlIGNhbnZhcyB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldCBjYW52YXMoY2FudmFzKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgICB9XG4gICAgYXN0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIG51bWJlclxuICAgICAqL1xuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBEaW1lbnNpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBkaW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICovXG4gICAgZ2V0SnVzdERyYWdnZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdXN0RHJhZ2dlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgZWxsaXBzZSBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldEp1c3REcmFnZ2VkKHZhbCkge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZWxsaXBzZSBpcyBkcmFnZ2luZ1xuICAgICAqL1xuICAgIGdldCBpc0RyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEcmFnZ2luZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0IG51bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX251bS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9iamVjdCBJRFxuICAgICAqL1xuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZE9iai5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3Igc2VsZWN0aW9uIGV2ZW50c1xuICAgICAqL1xuICAgIHRvU2VsU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCIgXCIgKyB0aGlzLl9udW0udG9TdHJpbmcoKSArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgZHJhZyBldmVudHNcbiAgICAqL1xuICAgIHRvRHJhZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9udW0udG9TdHJpbmcoKSArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94ICsgXCIsIFwiICsgdGhpcy5feSArIFwiIHRvIFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBJRCBhc3NpZ25tZW50IGV2ZW50c1xuICAgICAqL1xuICAgIHRvSURTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pZE9iai5faWQudG9TdHJpbmcoKSArIFwiIHRvIFwiICsgdGhpcy5fbnVtLnRvU3RyaW5nKCkgKyBcIiBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxufVxuZXhwb3J0cy5OdW1iZXJFZmZlY3QgPSBOdW1iZXJFZmZlY3Q7XG4vKipcbiAqIEdldCdzIHRoZSBtb3VzZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGluIHJlbGF0aW9uIHRvIHRoZSBjYW52YXNcbiAqIEBwYXJhbSBjYW52YXMgdGhlIGNhbnZhcyBvYmplY3RcbiAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGdldE1vdXNlUG9zKGNhbnZhcywgZXZlbnQpIHtcbiAgICBsZXQgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0LFxuICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gcmVjdC50b3BcbiAgICB9O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0geDEgeCBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geTEgeSBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geDIgeCBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICogQHBhcmFtIHkyIHkgY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDIsIDIpICsgTWF0aC5wb3coeTEgLSB5MiwgMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TnVtYmVyRWZmZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBQYWludEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9QYWludEV2ZW50XCIpO1xuY29uc3QgUmVzaXplRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1Jlc2l6ZUV2ZW50XCIpO1xuY29uc3QgQ2xpY2tFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvQ2xpY2tFdmVudFwiKTtcbmNsYXNzIFJlY3RhbmdsZUVmZmVjdCB7XG4gICAgY29uc3RydWN0b3IocmVjdCkge1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7IC8vIHByaXZhdGUgYm9vbHNcbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmF0aW8gPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gMDtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5fbW91c2UgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9yZWN0ID0gcmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIGV2YWx1YXRpbmcgbm9kZXMgKFN0cmluZ05vZGUsIEVsbGlwc2VOb2RlLCBldGMpXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyBhbGwgcGFyYW1zIHRvIHByaXZhdGUgdmFyaWFibGVzIGFuZCBkcmF3cyB0aGUgaW5pdGlhbCBvYmplY3QgdG8gdGhlIGNhbnZhc1xuICAgICAqIGJ5IGNhbGxpbmcgdXBkYXRlKClcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgcGFyZW50IFNjb3BlIHRoYXQgY29udGFpbnMgdGhlIGNhbnZhcyBhbW9uZyBvdGhlciB0aGluZ3NcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgb2JqZWN0J3MgZGltZW5zaW9ucyBpbmNsdWRpbmcgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBhc3QgVW5uZWNlc3Nhcnkgbm93LCB1c2VkIHRvIGJlIHRoZSBwYXJlbnQgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY2FudmFzLmlzRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zID0gZGltcztcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IGNvbnRleHQuY2FudmFzLmdldCgpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgY3R4ID0gY29udGV4dC5jYW52YXMuZ2V0KCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1BhaW50KCkpO1xuICAgICAgICBjb250ZXh0LmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gZHJhdyBhbmQgcmVkcmF3IHRoZSBvYmplY3Qgd2hlbiBtYW5pcHVsYXRpb25zIGFyZSBtYWRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudztcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuaDtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgLy90aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIC8vdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gXCIjZDViOGZmXCI7XG4gICAgICAgIHRoaXMuX2N0eC5zaGFkb3dDb2xvciA9IFwiIzZDNkM2Q1wiO1xuICAgICAgICB0aGlzLl9jdHguc2hhZG93Qmx1ciA9IDE1O1xuICAgICAgICAvL3RoaXMuX2N0eC5zaGFkb3dPZmZzZXRYID0gMjtcbiAgICAgICAgLy90aGlzLl9jdHguc2hhZG93T2Zmc2V0WSA9IDI7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdHdWlkZXMoeCwgeSwgd2lkdGgsIGhlaWdodCwgdGhpcy5fY29ybmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBvbmUgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTsgLy8gYmluZCBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgbWVhbmluZyBvZiAndGhpcydcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vblNoaWZ0RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vblNoaWZ0VXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmlzTW91c2VPdXRzaWRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL21ha2VzIGl0IHNvIHRoYXQgZG91YmxlIGNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRleHQgb24gdGhlIHBhZ2VcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgZnVuY3Rpb24gKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZmFsc2U7IH0sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gYW5vdGhlciBmZWxsIHN3b29wXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9mIHRoZSBvYmplY3QncyBib3VuZGluZyByZWN0YW5nbGUsIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBjb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGlmIChteCA+IHggJiYgbXggPCB4ICsgdyAmJiBteSA+IHkgJiYgbXkgPCB5ICsgaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbnVtYmVyID4gMCBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9uZSBvZiB0aGUgY29ybmVyL3NpZGUgZ3VpZGVzLCByZXR1cm5zIDAgaWYgbm90XG4gICAgICogVGhlIGNvcm5lciBndWlkZXMgYXJlIG51bWJlcmVkIDEtNCB3aXRoIDEgYmVpbmcgdGhlIHRvcCBsZWZ0LCAyIGJlaW5nIHRoZSB0b3AgcmlnaHQsIGFuZCBzbyBvbi5cbiAgICAgKiBUaGUgbWlkZGxlIGd1aWRlcyBhcmUgbnVtYmVyZWQgNS04LCB3aXRoIDUgYmVpbmcgdGhlIHRvcCBtaWRkbGUsIDYgYmVpbmcgdGhlIHJpZ2h0IG1pZGRsZSwgYW5kIHNvIG9uLlxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBndWlkZUNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgbGV0IHhkaWYgPSBteCAtIHg7XG4gICAgICAgIGxldCB5ZGlmID0gbXkgLSB5O1xuICAgICAgICAvKiBDb3JuZXIgR3VpZGVzICovXG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgfVxuICAgICAgICAvKiBNaWRkbGUgR3VpZGVzICovXG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICB5ZGlmID0gbXkgLSB5O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIG1pZGRsZVxuICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9taWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiA2O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGgpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgcmV0dXJuIDc7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9taWRkbGUgbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBib3VuZGluZyByZWN0YW5nbGUgYW5kIGd1aWRlcyBmb3IgdGhlIG9iamVjdCB3aGVuIHRoZSBvYmplY3QgaXMgc2VsZWN0ZWRcbiAgICAgKiBJZiBvbmUgb2YgdGhlIGd1aWRlcyBpcyBzZWxlY3RlZCwgaXQgY29sb3JzIHRoYXQgZ3VpZGUgYmx1ZVxuICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB5IHRoZSB5IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB3IHRoZSB3aWR0aCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggdGhlIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvcm5lciB0aGUgbnVtYmVyIG9mIHRoZSBjb3JuZXIgdG8gYmUgY29sb3JlZCBibHVlIChpZiBhbnkgYXQgYWxsLCBpZiAwLCBhbGwgYXJlIHdoaXRlKVxuICAgICAqL1xuICAgIGRyYXdHdWlkZXMoeCwgeSwgdywgaCwgY29ybmVyKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAoY29ybmVyICE9PSAwICYmIGNvcm5lciA8PSA0KSB7IC8vIGEgY29ybmVyIGd1aWRlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgY29ycmVjdCBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvcm5lciAhPT0gMCkgeyAvLyBhIG1pZGRsZSBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcnJlY3QgZ3VpZGUgYmx1ZVxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy9pZiBubyBndWlkZXMgYXJlIHNlbGVjdGVkLCBjb2xvcnMgZXZlcnl0aGluZyB3aGl0ZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltcGxlIG1ldGhvZCB0aGF0IGRyYXdzIGEgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHggeCBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geSB5IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB3IHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb2xvciBjb2xvciBvZiB0aGUgcmVjdGFuZ2xlJ3MgZmlsbFxuICAgICAqL1xuICAgIGRyYXdTcXVhcmUoeCwgeSwgdywgaCwgY29sb3IpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIHdpdGhpbiB0aGUgY2FudmFzLlxuICAgICAqIEdldHMgdGhlIG1vdXNlIHBvc2l0aW9uLCBjYWxscyB0aGUgbW9kaWZ5IG1ldGhvZHMgaWYgdGhlIGJvb2xlYW5zIHNhdGlzZnkgdGhlbS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZ2V0TW91c2VQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeURyYWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jlc2l6aW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplKHRoaXMudyA8IDEwLCB0aGlzLmggPCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNDaGFuZ2luZ0RpbXMgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zKHRoaXMudyA8IDEwLCB0aGlzLmggPCAxMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBjbGlja3MgaW5zaWRlIHRoZSBjYW52YXMuXG4gICAgICogTW9kaWZpZXMgdGhlIHN0YXRlIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBndWlkZXMgY29udGFpbiB0aGUgbW91c2Ugb3IgdGhlIGJvdW5kaW5nIHJlY3QgY29udGFpbnMgdGhlIG1vdXNlLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlTdGF0ZSh0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSksIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIHVuY2xpY2tzLlxuICAgICAqIENhbGxzIG1vZGlmeVJlc2V0IHRvIHJlc2V0IGRyYWdnaW5nIGFuZCByZXNpemluZyBib29sZWFucyBhbW9uZyBvdGhlcnMuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZXVwIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5UmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHByZXNzZWQgZG93blxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHByZXNzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnREb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyByZWxlYXNlZFxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHJlbGVhc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0VXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIE1vZGlmaWNhdGlvbiBmdW5jdGlvbnMgKi9cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgaW4gb3JkZXIgdG8gZHJhZyB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIG1vZGlmeURyYWcoKSB7XG4gICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLl9kcmFnb2ZmeDtcbiAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueSAtIHRoaXMuX2RyYWdvZmZ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBzaXplIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQgKHdoZW4gYSBjb3JuZXIgZ3VpZGUgaXMgY2xpY2tlZCBhbmQgZHJhZ2dlZCkuXG4gICAgICpcbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDEwIGFuZCB0aGUgb3RoZXIgZXF1YWwgdG9cbiAgICAgKiAxMCBkaXZpZGVkIG9yIG11bHRpcGxpZWQgYnkgdGhlIHJhdGlvIG9mIHdpZHRoL2hlaWdodCB0byBrZWVwIGl0IHRoZSBzYW1lLlxuICAgICAqXG4gICAgICogVGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgaXMgZG9uZSBieSBjYWxsaW5nIHRoZSBoZWxwZXIgbWV0aG9kIG1vZGlmeVJlc2l6ZUhlbHBlci5cbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNpemUod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgaWYgKHdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX3JlY3Qud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApOyAvLyBzZXQgZm9yIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwIC8gdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9yZWN0LmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDEwIC8gdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX3JlY3QuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTsgLy8gc2V0IGZvciB0aGUgcHJvZGlyZWN0IG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwICogdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9yZWN0LndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTAgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIHRoZSByZWN0YW5nbGUgb3JpZ2luYXRlcyBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgYW5kIG5vdCB0aGUgY2VudGVyLFxuICAgICAqIGl0IGNoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXMgd2VsbCBpZiBndWlkZXMgMSwgMiwgb3IgNCBhcmUgc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdEaXN0YW5jZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbW91c2UgYW5kIHRoZSBsb2NhdGlvbiBvcHBvc2l0ZSB0byBpdFxuICAgICAqIChpZiB0b3AgcmlnaHQgZ3VpZGUgaXMgY2xpY2tlZCwgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhhdCBhbmQgdGhlIGJvdHRvbSBsZWZ0IGd1aWRlIGlzIG5ld0Rpc3RhbmNlKVxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSkge1xuICAgICAgICBpZiAodGhpcy53ID4gMTAgJiYgdGhpcy5oID4gMTApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQoKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAvIHRoaXMuX3JhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgIHRoaXMuX3JlY3Qud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAvIHRoaXMuX3JhdGlvO1xuICAgICAgICB0aGlzLl9yZWN0LmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkLlxuICAgICAqIElmIGFueSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgdG9vIHNtYWxsLCBpdCBzZXRzIHRoZW0gZXF1YWwgdG8gMTAuXG4gICAgICogQ2FsbHMgbW9kaWZ5Q2hhbmdlRGltc0hlbHBlciB0byBhY3R1YWxseSBkbyB0aGUgd29ya1xuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqL1xuICAgIG1vZGlmeUNoYW5nZURpbXMod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgaWYgKHdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX3JlY3Qud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX3JlY3QuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIHRoZSByZWN0YW5nbGUgb3JpZ2luYXRlcyBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgYW5kIG5vdCB0aGUgY2VudGVyLFxuICAgICAqIGl0IGNoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXMgd2VsbCBpZiBndWlkZXMgNSBvciA4IGFyZSBzZWxlY3RlZFxuICAgICAqL1xuICAgIG1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKSB7XG4gICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaCA+IDEwKSB7IC8vYXMgbG9uZyBhcyB0aGUgaGVpZ2h0IGlzID4gMTBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0LmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudyA+IDEwKSB7IC8vIGFzIGxvbmcgYXMgd2lkdGggaXMgPiAxMFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIGRlcGVuZGluZyBvbiB0aGUgbW91c2UgcG9zaXRpb24gd2hlbiBjYWxsZWQgKG9uTW91c2VEb3duKVxuICAgICAqIGUuZy4gaWYgdGhlIG1vdXNlIGlzIHdpdGhpbiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIHdoZW4gdGhpcyBpcyBjYWxsZWQsIGlzU2VsZWN0ZWQgPSB0cnVlXG4gICAgICogQHBhcmFtIGd1aWRlQ29udGFpbnNcbiAgICAgKiBAcGFyYW0gY29udGFpbnNcbiAgICAgKi9cbiAgICBtb2RpZnlTdGF0ZShndWlkZUNvbnRhaW5zLCBjb250YWlucykge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy9wcmVwYXJlcyB0aGUgb2JqZWN0IGZvciBkcmFnZ2luZyB3aGV0aGVyIGl0IGlzIHBlcnNvbmFsbHkgc2VsZWN0ZWQgb3Igbm90XG4gICAgICAgICAgICBpZiAoY29udGFpbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94MSA9IHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl95MSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucyA+IDAgJiYgZ3VpZGVDb250YWlucyA8PSA0KSB7IC8vcmVzaXppbmdcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KTtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodDEgPSB0aGlzLmg7XG4gICAgICAgICAgICB0aGlzLl93aWR0aDEgPSB0aGlzLnc7XG4gICAgICAgICAgICAvL3RoaXMuX3NpemUxID0gTWF0aC5zcXJ0KE1hdGgucG93KHcsMikgKyBNYXRoLnBvdyhoLDIpKTsgLy8gc2l6ZSBpcyBkaWFnb25hbCBsZW5ndGhcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7IC8vIHNldHMgdGhlIG9mZnNldHMgZGVwZW5kaW5nIG9uIHdoaWNoIGNvcm5lciBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdzsgLy8gb2Zmc2V0IGlzIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDsgLy8gb2Zmc2V0IGlzIGJvdHRvbSBsZWZ0LCBldGNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiA0KSB7IC8vY2hhbmdpbmcgc2hhcGUgZGltZW5zaW9uc1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSBndWlkZUNvbnRhaW5zO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHsgLy8gc2V0cyB0aGUgb2Zmc2V0cyBkZXBlbmRpbmcgb24gd2hpY2ggbWlkZGxlIGd1aWRlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgY2FzZSA1OiAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3IC8gMjsgLy8gb2Zmc2V0IGlzIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OiAvL3JpZ2h0IG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5ICsgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyOyAvLyBvZmZzZXQgaXMgbGVmdCBtaWRkbGUgZXRjXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdyAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSArIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKSB7IC8vIGRyYWdnaW5nXG4gICAgICAgICAgICB0aGlzLl94MSA9IHg7IC8vIFNhdmluZyBvcmlnaW5hbCB4IGFuZCB5XG4gICAgICAgICAgICB0aGlzLl95MSA9IHk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkgeyAvLyBub3Qgc2VsZWN0ZWRcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIHRvIGZhbHNlIChsaWtlIGRyYWdnaW5nLCByZXNpemluZywgZXRjKSB3aGVuIHRoZSBtb3VzZSBpcyByZWxlYXNlZFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB0aGlzLngpID4gMSB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHRoaXMueSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh0aGlzLl9pc1Jlc2l6aW5nIHx8IHRoaXMuX2lzQ2hhbmdpbmdEaW1zKSAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc2l6ZTIgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53LCAyKSArIE1hdGgucG93KHRoaXMuaCwgMikpO1xuICAgICAgICAgICAgaWYgKChNYXRoLmFicyh0aGlzLl93aWR0aDEgLSB0aGlzLncpID4gMCkgfHwgKE1hdGguYWJzKHRoaXMuX2hlaWdodDEgLSB0aGlzLmgpID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dSZXNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKi9cbiAgICBnZXRNb3VzZVBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLl9tb3VzZS54ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueDtcbiAgICAgICAgdGhpcy5fbW91c2UueSA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNDaGFuZ2luZ0RpbXMsIGFuZCBpc1NlbGVjdGVkIHRvIGZhbHNlIGlmIHRoZSBtb3VzZSBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBpc01vdXNlT3V0c2lkZShldmVudCkge1xuICAgICAgICBsZXQgbW91c2VYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgbGV0IG1vdXNlWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5fY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobW91c2VYIDwgcmVjdC5sZWZ0IHx8IG1vdXNlWCA+IHJlY3QucmlnaHQgfHwgbW91c2VZIDwgcmVjdC50b3AgfHwgbW91c2VZID4gcmVjdC5ib3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZWN0YW5nbGUgcGFpbnQgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dQYWludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWludEV2ZW50XzEuUGFpbnRFdmVudChcInJlY3RhbmdsZVwiLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZWN0YW5nbGUgcmVzaXplIGV2ZW50XG4gICAgICovXG4gICAgbG9nUmVzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZUV2ZW50XzEuUmVzaXplRXZlbnQoXCJyZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCBNYXRoLnJvdW5kKHRoaXMuX3dpZHRoMSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5faGVpZ2h0MSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy53ICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLmggKiAxMDApIC8gMTAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlY3RhbmdsZSBjbGljayBldmVudFxuICAgICAqL1xuICAgIGxvZ0NsaWNrKCkge1xuICAgICAgICByZXR1cm4gbmV3IENsaWNrRXZlbnRfMS5DbGlja0V2ZW50KFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgYXNzaWducyBhbiBJRCB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgaW5pdElEKGlkKSB7XG4gICAgICAgIHRoaXMuaWRPYmogPSB7IF9pZDogaWQgfTtcbiAgICB9XG4gICAgYXN0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBEaW1lbnNpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBkaW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkT2JqLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKi9cbiAgICBnZXRKdXN0RHJhZ2dlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1c3REcmFnZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgc2V0SnVzdERyYWdnZWQodmFsKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGlzIGRyYWdnaW5nXG4gICAgICovXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIHNlbGVjdGlvbiBldmVudHNcbiAgICAgKi9cbiAgICB0b1NlbFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiIHJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIGRyYWcgZXZlbnRzXG4gICAgKi9cbiAgICB0b0RyYWdTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoXCJyZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgZnJvbSBcIiArIHRoaXMuX3gxICsgXCIsIFwiICsgdGhpcy5feTEgKyBcIiB0byBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgSUQgYXNzaWdubWVudCBldmVudHNcbiAgICAgKi9cbiAgICB0b0lEU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaWRPYmouX2lkLnRvU3RyaW5nKCkgKyBcIiB0byByZWN0YW5nbGUgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVjdGFuZ2xlRWZmZWN0ID0gUmVjdGFuZ2xlRWZmZWN0O1xuLyoqXG4gKiBHZXRzIHRoZSBtb3VzZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGluIHJlbGF0aW9uIHRvIHRoZSBjYW52YXNcbiAqIEBwYXJhbSBjYW52YXMgdGhlIGNhbnZhcyBvYmplY3RcbiAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGdldE1vdXNlUG9zKGNhbnZhcywgZXZlbnQpIHtcbiAgICBsZXQgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0LFxuICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gcmVjdC50b3BcbiAgICB9O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0geDEgeCBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geTEgeSBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geDIgeCBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICogQHBhcmFtIHkyIHkgY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDIsIDIpICsgTWF0aC5wb3coeTEgLSB5MiwgMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVjdGFuZ2xlRWZmZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUGFpbnRFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUGFpbnRFdmVudFwiKTtcbmNvbnN0IFJlc2l6ZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9SZXNpemVFdmVudFwiKTtcbmNvbnN0IENsaWNrRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL0NsaWNrRXZlbnRcIik7XG5jbGFzcyBTdHJpbmdFZmZlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHN0cikge1xuICAgICAgICB0aGlzLl9mb250U2l6ZSA9IDIwO1xuICAgICAgICAvL3ByaXZhdGUgX3NpemUyOiBudW1iZXI7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTsgLy8gUHJpdmF0ZSBib29sc1xuICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTsgLy8gSGFzIHRoaXMgb2JqZWN0IGp1c3QgYmVlbiBkcmFnZ2VkP1xuICAgICAgICAvL3ByaXZhdGUgX2xvZzogc3RyaW5nW107XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSAwO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9tb3VzZSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3RleHRNZXRyaWNzID0ge1xuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBpbnRlcnZhbDogMCxcbiAgICAgICAgICAgIHN0cjogXCJcIixcbiAgICAgICAgICAgIGluaXRNb3VzZVBvczogMCxcbiAgICAgICAgICAgIGN1cnNvclBvczogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zdHIgPSBzdHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiBldmFsdWF0aW5nIG5vZGVzIChTdHJpbmdOb2RlLCBFbGxpcHNlTm9kZSwgZXRjKVxuICAgICAqIFRoaXMgbWV0aG9kIGFzc2lnbnMgYWxsIHBhcmFtcyB0byBwcml2YXRlIHZhcmlhYmxlcyBhbmQgZHJhd3MgdGhlIGluaXRpYWwgb2JqZWN0IHRvIHRoZSBjYW52YXNcbiAgICAgKiBieSBjYWxsaW5nIHVwZGF0ZSgpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIHBhcmVudCBTY29wZSB0aGF0IGNvbnRhaW5zIHRoZSBjYW52YXMgYW1vbmcgb3RoZXIgdGhpbmdzXG4gICAgICogQHBhcmFtIGRpbXMgVGhlIG9iamVjdCdzIGRpbWVuc2lvbnMgaW5jbHVkaW5nIHggYW5kIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gYXN0IFVubmVjZXNzYXJ5IG5vdywgdXNlZCB0byBiZSB0aGUgcGFyZW50IEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNhbnZhcyAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gY29udGV4dC5jYW52YXMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9kaW1zID0gZGltcztcbiAgICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0LmNhbnZhcy5nZXQoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgLy8gbG9nZ2luZ1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUGFpbnQoKSk7IC8vIHRoaXMuY29udGV4dCBvciBjb250ZXh0P1xuICAgICAgICAgICAgY29udGV4dC5lZmZlY3RzLnB1c2godGhpcyk7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNhbnZhcyBpcyBOT1QgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gZHJhdyBhbmQgcmVkcmF3IHRoZSBvYmplY3Qgd2hlbiBtYW5pcHVsYXRpb25zIGFyZSBtYWRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgZm9udERlZXRzID0gdGhpcy5fZm9udFNpemUgKyBcInB4IENvdXJpZXIgTmV3XCI7XG4gICAgICAgIHRoaXMuX2N0eC5mb250ID0gZm9udERlZXRzO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gXCIjNjczQUI3XCI7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsVGV4dCh0aGlzLl9zdHIudmFsLCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIGxldCB0ZXh0RGltcyA9IHRoaXMuX2N0eC5tZWFzdXJlVGV4dCh0aGlzLl9zdHIudmFsKTtcbiAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3Mud2lkdGggPSB0ZXh0RGltcy53aWR0aDtcbiAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuaGVpZ2h0ID0gdGhpcy5fZm9udFNpemU7XG4gICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLnN0ciA9IHRoaXMuX3N0ci52YWw7XG4gICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmludGVydmFsID0gdGhpcy5fdGV4dE1ldHJpY3Mud2lkdGggLyB0aGlzLl90ZXh0TWV0cmljcy5zdHIubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3VGV4dEd1aWRlcyh0aGlzLngsIHRoaXMueSAtIHRoaXMuX2ZvbnRTaXplLCB0aGlzLl90ZXh0TWV0cmljcy53aWR0aCwgdGhpcy5fdGV4dE1ldHJpY3MuaGVpZ2h0LCB0aGlzLl9jb3JuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIG9uZSBmZWxsIHN3b29wXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpOyAvLyBiaW5kIGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBtZWFuaW5nIG9mICd0aGlzJ1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uU2hpZnREb3duLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uU2hpZnRVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaXNNb3VzZU91dHNpZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vbWFrZXMgaXQgc28gdGhhdCBkb3VibGUgY2xpY2tpbmcgZG9lc24ndCBzZWxlY3QgdGV4dCBvbiB0aGUgcGFnZVxuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBmdW5jdGlvbiAoZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IHJldHVybiBmYWxzZTsgfSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBhbm90aGVyIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb2YgdGhlIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSwgZmFsc2UgaWYgb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICByZXR1cm4gKHRoaXMueCA8PSBteCkgJiYgKHRoaXMueCArIHRoaXMuX3RleHRNZXRyaWNzLndpZHRoID49IG14KSAmJlxuICAgICAgICAgICAgKHRoaXMueSAtIHRoaXMuX2ZvbnRTaXplIDw9IG15KSAmJiAodGhpcy55ID49IG15KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciA+IDAgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvbmUgb2YgdGhlIGNvcm5lci9zaWRlIGd1aWRlcywgcmV0dXJucyAwIGlmIG5vdFxuICAgICAqIFRoZSBjb3JuZXIgZ3VpZGVzIGFyZSBudW1iZXJlZCAxLTQgd2l0aCAxIGJlaW5nIHRoZSB0b3AgbGVmdCwgMiBiZWluZyB0aGUgdG9wIHJpZ2h0LCBhbmQgc28gb24uXG4gICAgICogVGhlIG1pZGRsZSBndWlkZXMgYXJlIG51bWJlcmVkIDUtOCwgd2l0aCA1IGJlaW5nIHRoZSB0b3AgbWlkZGxlLCA2IGJlaW5nIHRoZSByaWdodCBtaWRkbGUsIGFuZCBzbyBvbi5cbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ3VpZGVDb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHhkaWYgPSBteCAtICh0aGlzLnggKyB0aGlzLl90ZXh0TWV0cmljcy53aWR0aCk7XG4gICAgICAgIGxldCB5ZGlmID0gbXkgLSAodGhpcy55IC0gdGhpcy5fZm9udFNpemUpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGFuZCBndWlkZXMgZm9yIHRoZSBvYmplY3Qgd2hlbiB0aGUgb2JqZWN0IGlzIHNlbGVjdGVkXG4gICAgICogSWYgb25lIG9mIHRoZSBndWlkZXMgaXMgc2VsZWN0ZWQsIGl0IGNvbG9ycyB0aGF0IGd1aWRlIGJsdWVcbiAgICAgKiBAcGFyYW0geCB0aGUgeCBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0geSB0aGUgeSBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb3JuZXIgdGhlIG51bWJlciBvZiB0aGUgY29ybmVyIHRvIGJlIGNvbG9yZWQgYmx1ZSAoaWYgYW55IGF0IGFsbCwgaWYgMCwgYWxsIGFyZSB3aGl0ZSlcbiAgICAgKi9cbiAgICBkcmF3VGV4dEd1aWRlcyh4LCB5LCB3LCBoLCBjb3JuZXIpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmIChjb3JuZXIgIT09IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBndWlkZSBibHVlIGlmIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgbWV0aG9kIHRoYXQgZHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geCB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5IHkgY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHcgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIGNvbG9yIG9mIHRoZSByZWN0YW5nbGUncyBmaWxsXG4gICAgICovXG4gICAgZHJhd1NxdWFyZSh4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qIEV2ZW50IGxpc3RlbmVyIGZ1bmN0aW9ucyAqL1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgd2l0aGluIHRoZSBjYW52YXMuXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24sIGNhbGxzIHRoZSBtb2RpZnkgbWV0aG9kcyBpZiB0aGUgYm9vbGVhbnMgc2F0aXNmeSB0aGVtLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRNb3VzZVBvc2l0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGVkICYmIHRoaXMuX2lzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2codGhpcy5fc3RyLnZhbCArIFwiIGlzIGJlaW5nIGRyYWdnZWQuXCIpO1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlEcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZXNpemluZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZSh0aGlzLl9mb250U2l6ZSA8IDE1KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIGNsaWNrcyBpbnNpZGUgdGhlIGNhbnZhcy5cbiAgICAgKiBNb2RpZmllcyB0aGUgc3RhdGUgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGd1aWRlcyBjb250YWluIHRoZSBtb3VzZSBvciB0aGUgYm91bmRpbmcgcmVjdCBjb250YWlucyB0aGUgbW91c2UuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgJiYgdGhpcy5faXNTZWxlY3RlZCAmJiB0aGlzLmNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpKSB7IC8vdGV4dCBlZGl0aW5nXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm1vZGlmeVRleHQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pc0xpc3RlbmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLl9zdHIudmFsICsgXCIgaXMgc2V0dGluZyBkcmFnZ2luZyB0byBmYWxzZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmluaXRNb3VzZVBvcyA9IHRoaXMuX21vdXNlLng7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGlmeVN0YXRlKHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSA+IDAsIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIHVuY2xpY2tzLlxuICAgICAqIENhbGxzIG1vZGlmeVJlc2V0IHRvIHJlc2V0IGRyYWdnaW5nIGFuZCByZXNpemluZyBib29sZWFucyBhbW9uZyBvdGhlcnMuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZXVwIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5UmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHByZXNzZWQgZG93blxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHByZXNzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnREb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyByZWxlYXNlZFxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHJlbGVhc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0VXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIE1vZGlmaWNhdGlvbiBmdW5jdGlvbnMgKi9cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgaW4gb3JkZXIgdG8gZHJhZyB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIG1vZGlmeURyYWcoKSB7XG4gICAgICAgIC8vKFwic3RyaW5nIGRyYWdvZmZ4OiBcIiArIHRoaXMuX2RyYWdvZmZ4KTtcbiAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueCAtIHRoaXMuX2RyYWdvZmZ4O1xuICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy5fZHJhZ29mZnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIG1vdmVzIHRoZSB0ZXh0IGVkaXQgY3Vyc29yIGJhc2VkIG9uIHdoZXJlIHRoZSBtb3VzZSBpcyBjbGlja2VkXG4gICAgICovXG4gICAgbW9kaWZ5VGV4dEN1cnNvcigpIHtcbiAgICAgICAgbGV0IGxlZnRXYWxsID0gdGhpcy54OyAvLyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgbGVmdCBtb3N0IHNpZGUgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAgICBsZXQgeERpZiA9IHRoaXMuX3RleHRNZXRyaWNzLmluaXRNb3VzZVBvcyAtIGxlZnRXYWxsOyAvLyBkaWZmZXJlbmNlIGJldHdlZW4gbW91c2UgeCBhbmQgbGVmdCB3YWxsXG4gICAgICAgIGxldCBpbnRlcnZhbCA9IHRoaXMuX3RleHRNZXRyaWNzLmludGVydmFsOyAvLyB0aGUgdGV4dCB3aWR0aCBkaXZpZGVkIGJ5IHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZ1xuICAgICAgICBsZXQgbW92ZUZhY3RvciA9IDA7XG4gICAgICAgIGlmICh4RGlmID49IGludGVydmFsIC8gMiAmJiB4RGlmIDw9IGludGVydmFsKSB7XG4gICAgICAgICAgICBtb3ZlRmFjdG9yID0gbGVmdFdhbGwgKyBpbnRlcnZhbDtcbiAgICAgICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmN1cnNvclBvcyA9IGludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHhEaWYgPD0gaW50ZXJ2YWwgLyAyKSB7XG4gICAgICAgICAgICBtb3ZlRmFjdG9yID0gbGVmdFdhbGw7XG4gICAgICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5jdXJzb3JQb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHhEaWYgJSBpbnRlcnZhbCA+PSBpbnRlcnZhbCAvIDIpIHtcbiAgICAgICAgICAgIG1vdmVGYWN0b3IgPSBsZWZ0V2FsbCArIGludGVydmFsICogTWF0aC5jZWlsKHhEaWYgLyBpbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5jdXJzb3JQb3MgPSBpbnRlcnZhbCAqIE1hdGguY2VpbCh4RGlmIC8gaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHhEaWYgJSBpbnRlcnZhbCA8IGludGVydmFsIC8gMikge1xuICAgICAgICAgICAgbW92ZUZhY3RvciA9IGxlZnRXYWxsICsgaW50ZXJ2YWwgKiBNYXRoLmZsb29yKHhEaWYgLyBpbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5jdXJzb3JQb3MgPSBpbnRlcnZhbCAqIE1hdGguZmxvb3IoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdHgubW92ZVRvKG1vdmVGYWN0b3IsIHRoaXMueSAtIHRoaXMuX2ZvbnRTaXplKTtcbiAgICAgICAgdGhpcy5fY3R4LmxpbmVUbyhtb3ZlRmFjdG9yLCB0aGlzLnkpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSBcImdyZXlcIjtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGVkaXRzIHRoZSBzdHJpbmcgd2hlbiBlZGl0aW5nIHRleHRcbiAgICAgKiBAcGFyYW0gZXZlbnQga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG1vZGlmeVRleHQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRWRpdGluZykge1xuICAgICAgICAgICAgbGV0IGZpcnN0SGFsZjtcbiAgICAgICAgICAgIGxldCBzZWNvbmRIYWxmO1xuICAgICAgICAgICAgbGV0IGJyZWFrUG9pbnQgPSB0aGlzLl90ZXh0TWV0cmljcy5jdXJzb3JQb3MgLyB0aGlzLl90ZXh0TWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgICAgIGZpcnN0SGFsZiA9IHRoaXMuX3N0ci52YWwuc3Vic3RyaW5nKDAsIGJyZWFrUG9pbnQpO1xuICAgICAgICAgICAgc2Vjb25kSGFsZiA9IHRoaXMuX3N0ci52YWwuc3Vic3RyaW5nKGJyZWFrUG9pbnQpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzcgJiYgdGhpcy5fdGV4dE1ldHJpY3MuaW5pdE1vdXNlUG9zID4gdGhpcy54ICsgdGhpcy5fdGV4dE1ldHJpY3MuaW50ZXJ2YWwgLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuaW5pdE1vdXNlUG9zIC09IHRoaXMuX3RleHRNZXRyaWNzLmludGVydmFsO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzOSAmJiB0aGlzLl90ZXh0TWV0cmljcy5pbml0TW91c2VQb3MgPCB0aGlzLnggKyB0aGlzLl90ZXh0TWV0cmljcy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmluaXRNb3VzZVBvcyArPSB0aGlzLl90ZXh0TWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gOCAmJiB0aGlzLl9zdHIudmFsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmaXJzdEhhbGYgPSBmaXJzdEhhbGYuc3Vic3RyaW5nKDAsIGZpcnN0SGFsZi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHIuc3RyID0gZmlyc3RIYWxmICsgc2Vjb25kSGFsZjtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5pbml0TW91c2VQb3MgLT0gdGhpcy5fdGV4dE1ldHJpY3MuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQga2V5TmFtZSA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5TmFtZS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEhhbGYgKz0ga2V5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RyLnN0ciA9IGZpcnN0SGFsZiArIHNlY29uZEhhbGY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmluaXRNb3VzZVBvcyArPSB0aGlzLl90ZXh0TWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIHRoZSBmb250IHNpemUgb2YgdGhlIHRleHRcbiAgICAgKiBJZiB0aGUgdGV4dCBmb250IGlzIHNtYWxsZXIgdGhhbiAxNXB0LCBpdCBzZXQncyBpdCBlcXVhbCB0byAxNXB0XG4gICAgICogQHBhcmFtIGlzVG9vU21hbGwgdHJ1ZSBpZiB0aGUgZm9udCBzaXplIGlzIDwgMTVcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNpemUoaXNUb29TbWFsbCkge1xuICAgICAgICBpZiAoaXNUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZm9udFNpemUgPSAxNTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9udFNpemUgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDAuMjtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICB0aGlzLl9mb250U2l6ZSArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMC4yO1xuICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgZGVwZW5kaW5nIG9uIHRoZSBtb3VzZSBwb3NpdGlvbiB3aGVuIGNhbGxlZCAob25Nb3VzZURvd24pXG4gICAgICogZS5nLiBpZiB0aGUgbW91c2UgaXMgd2l0aGluIHRoZSBib3VuZGluZyByZWN0YW5nbGUgd2hlbiB0aGlzIGlzIGNhbGxlZCwgaXNTZWxlY3RlZCA9IHRydWVcbiAgICAgKiBAcGFyYW0gZ3VpZGVDb250YWluc1xuICAgICAqIEBwYXJhbSBjb250YWluc1xuICAgICAqL1xuICAgIG1vZGlmeVN0YXRlKGd1aWRlQ29udGFpbnMsIGNvbnRhaW5zKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7IC8vcHJlcGFyZXMgdGhlIG9iamVjdCBmb3IgZHJhZ2dpbmcgd2hldGhlciBpdCBpcyBwZXJzb25hbGx5IHNlbGVjdGVkIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5feTEgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZih0aGlzLl9jb250ZXh0Lm11bFNlbGVjdGVkLm11bFNlbCl7XG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJzdHJpbmcgZWZmZWN0IG11bFNlbGVjdGVkOiBcIiArIHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQubXVsU2VsKTtcbiAgICAgICAgICAgIC8vICAgICAvL2lmKHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQudmFsKXtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dTZWxlY3RlZCgpKTtcbiAgICAgICAgICAgIC8vICAgICAvL3RoaXMubG9nU2VsZWN0ZWQoKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zKSB7IC8vaWYgdGhlIGNvcm5lciBndWlkZXMgY29udGFpbiB0aGUgbW91c2Ugd2UgYXJlIHJlc2l6aW5nXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLl9zdHIudmFsICsgXCJpcyBzZWxlY3RlZD9cIiArIHRoaXMuX3NlbGVjdGVkKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJzdGF0ZSBzZWxlY3Rpb24gaXMgXCIgKyB0aGlzLl9zdHIudmFsKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy54O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLnk7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3NpemUxID0gdGhpcy5fZm9udFNpemU7IC8vIHNhdmluZyBvbGQgZm9udCBzaXplXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy54OyAvLyBTYXZpbmcgb3JpZ2luYWwgeCBhbmQgeVxuICAgICAgICAgICAgdGhpcy5feTEgPSB0aGlzLnk7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLl9zdHIudmFsICsgXCJpcyBzZWxlY3RlZD9cIiArIHRoaXMuX3NlbGVjdGVkKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJzdGF0ZSBzZWxlY3Rpb24gaXMgXCIgKyB0aGlzLl9zdHIudmFsKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHRoaXMueDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNFZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLl9zdHIudmFsICsgXCIgaXMgZHJhZ2dpbmc/IFwiICsgdGhpcy5faXNEcmFnZ2luZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgdG8gZmFsc2UgKGxpa2UgZHJhZ2dpbmcsIHJlc2l6aW5nLCBldGMpIHdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkXG4gICAgICovXG4gICAgbW9kaWZ5UmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2codGhpcy5fc3RyLnZhbCArIFwiIGxvZ2dpbmcgZHJhZ1wiKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl94MSAtIHRoaXMueCkgPiAxIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0gdGhpcy55KSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy90aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dNb3ZlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLl9zdHIudmFsICsgXCIgbG9nZ2luZyByZXNpemVcIik7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5fc2l6ZTEgLSB0aGlzLl9mb250U2l6ZSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUmVzaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcInN0cmluZyBlZmZlY3QgbXVsU2VsZWN0ZWQ6IFwiICsgdGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC52YWwpO1xuICAgICAgICAvLyBpZih0aGlzLl9jb250ZXh0Lm11bFNlbGVjdGVkLnZhbCl7XG4gICAgICAgIC8vICAgICB0aGlzLmxvZ1NlbGVjdGVkKCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYodGhpcy5pc011bHRpcGxlU2VsZWN0ZWQpe1xuICAgICAgICAvLyAgICAgY29udGV4dC5ldmVudExvZy5wdXNoKG5ldyBTZWxlY3RFdmVudChzZWxlY3RlZEVsZW1zKSk7XG4gICAgICAgIC8vICAgICBtYXN0ZXJMb2cucHVzaChjb250ZXh0LmV2ZW50TG9nW2NvbnRleHQuZXZlbnRMb2cubGVuZ3RoIC0gMV0pO1xuICAgICAgICAvLyAgICAgLy9jb25zb2xlLmxvZyhcIm11bHRpcGxlIHNlbGVjdGVkXCIpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIC8vdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nTW92ZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqL1xuICAgIGdldE1vdXNlUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuX21vdXNlLnggPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS54O1xuICAgICAgICB0aGlzLl9tb3VzZS55ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0NoYW5naW5nRGltcywgYW5kIGlzU2VsZWN0ZWQgdG8gZmFsc2UgaWYgdGhlIG1vdXNlIGNsaWNrcyBvdXRzaWRlIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIGlzTW91c2VPdXRzaWRlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgICAgICBsZXQgbW91c2VZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtb3VzZVggPCByZWN0LmxlZnQgfHwgbW91c2VYID4gcmVjdC5yaWdodCB8fCBtb3VzZVkgPCByZWN0LnRvcCB8fCBtb3VzZVkgPiByZWN0LmJvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSBwYWludCBldmVudFxuICAgICAqL1xuICAgIGxvZ1BhaW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhaW50RXZlbnRfMS5QYWludEV2ZW50KHRoaXMuX3N0ci52YWwsIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlc2l6ZSBldmVudFxuICAgICAqL1xuICAgIGxvZ1Jlc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVFdmVudF8xLlJlc2l6ZUV2ZW50KHRoaXMuX3N0ci52YWwgKyBcIiB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIE1hdGgucm91bmQodGhpcy5fc2l6ZTEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuX2ZvbnRTaXplICogMTAwKSAvIDEwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSBjbGljayBldmVudFxuICAgICAqL1xuICAgIGxvZ0NsaWNrKCkge1xuICAgICAgICByZXR1cm4gbmV3IENsaWNrRXZlbnRfMS5DbGlja0V2ZW50KHRoaXMuX3N0ci52YWwgKyBcIiB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIGFzc2lnbnMgYW4gSUQgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIGlkIFRoZSBJRCB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIGluaXRJRChpZCkge1xuICAgICAgICB0aGlzLmlkT2JqID0geyBfaWQ6IGlkLCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgICBnZXQgY2FudmFzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gY2FudmFzIFRoZSBjYW52YXMgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBzZXQgY2FudmFzKGNhbnZhcykge1xuICAgICAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gICAgfVxuICAgIGFzdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHggcG9zaXRpb24gb2YgdGhlIGVsbGlwc2VcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgZWxsaXBzZVxuICAgICAqL1xuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBEaW1lbnNpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBkaW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICovXG4gICAgZ2V0SnVzdERyYWdnZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdXN0RHJhZ2dlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgZWxsaXBzZSBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldEp1c3REcmFnZ2VkKHZhbCkge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZWxsaXBzZSBpcyBkcmFnZ2luZ1xuICAgICAqL1xuICAgIGdldCBpc0RyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEcmFnZ2luZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nXG4gICAgICovXG4gICAgZ2V0IHN0cigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ci52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9iamVjdCBJRFxuICAgICAqL1xuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZE9iai5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3Igc2VsZWN0aW9uIGV2ZW50c1xuICAgICAqL1xuICAgIHRvU2VsU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCIgXCIgKyB0aGlzLl9zdHIudmFsICsgXCIgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBkcmFnIGV2ZW50c1xuICAgICovXG4gICAgdG9EcmFnU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3N0ci52YWwgKyBcIiB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBmcm9tIFwiICsgdGhpcy5feDEgKyBcIiwgXCIgKyB0aGlzLl95MSArIFwiIHRvIFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBJRCBhc3NpZ25tZW50IGV2ZW50c1xuICAgICAqL1xuICAgIHRvSURTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pZE9iai5faWQudG9TdHJpbmcoKSArIFwiIHRvIFwiICsgdGhpcy5fc3RyLnZhbCArIFwiIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG59XG5leHBvcnRzLlN0cmluZ0VmZmVjdCA9IFN0cmluZ0VmZmVjdDtcbi8qKlxuICogR2V0J3MgdGhlIG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZXMgaW4gcmVsYXRpb24gdG8gdGhlIGNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB0aGUgY2FudmFzIG9iamVjdFxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0TW91c2VQb3MoY2FudmFzLCBldmVudCkge1xuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB4MSB4IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB5MSB5IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB4MiB4IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKiBAcGFyYW0geTIgeSBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MiwgMikgKyBNYXRoLnBvdyh5MSAtIHkyLCAyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdHJpbmdFZmZlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBSZXR1cm5FcnJvcl8xID0gcmVxdWlyZShcIi4uL3N0cnVjdHVyYWwvUmV0dXJuRXJyb3JcIik7XG5jb25zdCBzcGFjZV9saWZ0XzEgPSByZXF1aXJlKFwic3BhY2UtbGlmdFwiKTtcbi8vIEFwcGxpY2F0aW9uIG9mIGEgZnVuY3Rpb24uIEFzc3VtZXMgYXJnIHZhbHVlcyBwYXNzZWQgaW4gc2FtZSBvcmRlciBhcyBGdW5EZWYgYXJnc1xuY2xhc3MgRnVuQXBwIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIGEgZnVuY3Rpb24gYXBwbGljYXRpb25cbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gYXJncyBGdW5jdGlvbiBhcmd1bWVudHMsIGlmIGFwcGxpY2FibGVcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24sIGlmIGFueVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGFyZ3MsIHdzLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5fZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBmdW5jdGlvbiBhcHBsaWNhdGlvblxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBmdW5kZWYgPSBjb250ZXh0Lmxvb2t1cCh0aGlzLl9uYW1lLCBjb250ZXh0KTsgLy8gbG9va2luZyB1cCBmdW5jdGlvblxuICAgICAgICAvL2xldCBjaGlsZCA9IG5ldyBTY29wZShmdW5kZWYuc2NvcGUpOyAvLyBhdm9pZGluZyBvdmVyd3JpdGU7IG5lZWQgdG8gdG9zcyBhZnRlciByZXR1cm5pbmdcbiAgICAgICAgbGV0IGNoaWxkID0gZnVuZGVmLnNjb3BlLmNvcHkoKTsgLy8gQ29weWluZyBkZWZpbml0aW9uIHNjb3BlXG4gICAgICAgIC8vIEFzc2lnbnMgYXJnIHZhbHVlcyB0byBkZWZpbml0aW9uIGFyZ3VtZW50c1xuICAgICAgICBpZiAodGhpcy5fYXJncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FyZ3MubGVuZ3RoOyBpKyspIHsgLy9sb29rdXBzP1xuICAgICAgICAgICAgICAgIC8vY2hpbGQuZGVjbGFyZSh0aGlzLl9mdW5jdC5hcmdzW2ldKTsgLy8gcmVkZWNsYXJlP1xuICAgICAgICAgICAgICAgIGNoaWxkLmFzc2lnbihmdW5kZWYuYXJnc1tpXSwgdGhpcy5fYXJnc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkID0gY29udGV4dC5nbG9iYWxGdW5JRDsgLy8gQXNzaWducyBhbiBJRCB0byB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29udGV4dC5nbG9iYWxGdW5JRCsrO1xuICAgICAgICBjaGlsZC5yZXRWYWxJRCA9IHNwYWNlX2xpZnRfMS5Tb21lKGlkKTsgLy8gbmV3IG1ldGhvZFxuICAgICAgICAvLyB3ZSBvbmx5IHJldHVybiBhIHZhbHVlIHdpdGggZnVuY3Rpb24gYXBwbGljYXRpb25cbiAgICAgICAgLy8gaWYgaXQgaXMgZXhwbGljaXRseSByZXR1cm5lZCB1c2luZyBhIHJldHVybiBzdGF0ZW1lbnQ7XG4gICAgICAgIC8vIHdlIGFidXNlIEpTIGV4Y2VwdGlvbnMgZm9yIHRoaXMgcHVycG9zZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2hpbGQuaGFkRnVuRXZhbCA9IHRydWU7XG4gICAgICAgICAgICBmdW5kZWYuYm9keS5ldmFsKGNoaWxkKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHdlIGNhdGNoIG9ubHkgdGhlIGVycm9yIGludGVuZGVkIGZvciB1c1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSZXR1cm5FcnJvcl8xLlJldHVybkVycm9yICYmIHBhcnNlSW50KGUuSUQpID09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUucmV0VmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXJyb3Igd2FzIG5vdCBpbnRlbmRlZCBmb3IgdXM7IHJldGhyb3dcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZXR1cm4gZnVuZGVmLmJvZHkuZXZhbChjaGlsZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBhcmdzTGlzdCA9ICcnO1xuICAgICAgICBpZiAodGhpcy5fYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FyZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc0xpc3QgKz0gdGhpcy5fYXJnc1tpXS50b1N0cmluZygpICsgXCIsIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnc0xpc3QgKz0gdGhpcy5fYXJnc1t0aGlzLl9hcmdzLmxlbmd0aCAtIDFdLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5uYW1lICsgJygnICsgYXJnc0xpc3QgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBhcHBsaWNhdGlvbnMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgZnVuY3Rpb24gYXBwbGljYXRpb25cbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGZ1bmN0aW9uc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFyZ3VtZW50cyBvZiB0aGUgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBnZXQgYXJncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FyZ3M7XG4gICAgfVxufVxuZXhwb3J0cy5GdW5BcHAgPSBGdW5BcHA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GdW5BcHAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTY29wZV8xID0gcmVxdWlyZShcIi4uL3N0cnVjdHVyYWwvU2NvcGVcIik7XG5jbGFzcyBGdW5EZWYge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGJvZHksIGFyZ3MsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5fYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMuX2FyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8vIEJpbmRzIGFyZ3MgaW4gY29udGV4dCBvZiBkZWZpbml0aW9uOyBubyB2YWx1ZXNcbiAgICAvLyBCaW5kcyBuYW1lIHRvIHBhcmVudCBjb250ZXh0IChjdXIgY29udGV4dCBpcyBuZXcgY29udGV4dClcbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fZnVuU2NvcGUgPSBuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KTsgLy8gKioqKioqKioqKioqKiBjb3B5Pz8/P1xuICAgICAgICB0aGlzLl9mdW5TY29wZS5jYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICAgICAgdGhpcy5fZnVuU2NvcGUuZXZlbnRMb2cgPSBjb250ZXh0LmV2ZW50TG9nO1xuICAgICAgICB0aGlzLl9mdW5TY29wZS5lZmZlY3RzID0gY29udGV4dC5lZmZlY3RzO1xuICAgICAgICAvKlxuICAgICAgICBpZih0aGlzLl9hcmdzICE9IG51bGwpe1xuICAgICAgICAgICAgZm9yKGxldCBlbnRyeSBvZiB0aGlzLl9hcmdzKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdW5TY29wZS5kZWNsYXJlKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICBjb250ZXh0LmRlY2xhcmUodGhpcy5fbmFtZSk7IC8vIGFzc2lnbiB3aXRoIHZhbCBmdW5jdGlvblxuICAgICAgICBjb250ZXh0LmFzc2lnbih0aGlzLl9uYW1lLCB0aGlzKTsgLy8gcGFyZW50IG9yIGN1cnJlbnQ/XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBhcmdzTGlzdCA9ICcnO1xuICAgICAgICBpZiAodGhpcy5fYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FyZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc0xpc3QgKz0gdGhpcy5fYXJnc1tpXSArIFwiLCBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3NMaXN0ICs9IHRoaXMuX2FyZ3NbdGhpcy5fYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyBcImZ1biBcIiArIHRoaXMuX25hbWUgKyBcIihcIiArIGFyZ3NMaXN0ICsgJyknICsgJyB7XFxuICcgKyB0aGlzLl9ib2R5LnRvU3RyaW5nKCkgKyAnfSc7XG4gICAgfVxuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBmdW5jdGlvbnNcIik7XG4gICAgfVxuICAgIC8vIEdldCBtZXRob2RzXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHk7XG4gICAgfVxuICAgIGdldCBhcmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXJncztcbiAgICB9XG4gICAgZ2V0IHNjb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnVuU2NvcGU7XG4gICAgfVxufVxuZXhwb3J0cy5GdW5EZWYgPSBGdW5EZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GdW5EZWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBMaXN0Tm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGFuIGFycmF5LWxpa2UgbGlzdFxuICAgICAqIEBwYXJhbSBsaXN0IFRoZSBsaXN0LCBzdG9yZWQgaW4gYSBUUyBhcnJheVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxpc3QsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGlzdCA9IGxpc3Q7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgZWFjaCBlbGVtZW50IG9mIHRoZSBsaXN0IGFuZCBwdXNoZXMgaXQgb250byB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgZXZhbExpc3QgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZXhwciBvZiB0aGlzLl9saXN0KSB7XG4gICAgICAgICAgICBldmFsTGlzdC5wdXNoKGV4cHIuZXZhbChjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0Tm9kZShldmFsTGlzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxpc3RcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGxpc3QgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9saXN0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgbGlzdCArPSB0aGlzLl9saXN0W2ldLnRvU3RyaW5nKCkgKyBcIiwgXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdCArPSB0aGlzLl9saXN0W3RoaXMuX2xpc3QubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgJ1snICsgbGlzdCArICddJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBsaXN0IGVxdWFscyBhbm90aGVyIGxpc3RcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5IChtdXN0IGJlIGEgTGlzdE5vZGUpXG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIExpc3ROb2RlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghKHRoaXMubGlzdFtpXS5lcXVhbHNWYWwocmlnaHQubGlzdFtpXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXcgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhIGxpc3RcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZHJhdyBhIExpc3ROb2RlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsaXN0XG4gICAgICovXG4gICAgZ2V0IGxpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGlzdE5vZGUgPSBMaXN0Tm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpc3ROb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0xvZ0V2ZW50XCIpO1xuY2xhc3MgQ2xlYXJFdmVudCBleHRlbmRzIExvZ0V2ZW50XzEuTG9nRXZlbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgQ2xlYXIgRXZlbnQsIHdoaWNoIGxvZ3Mgd2hlbiB0aGUgY2FudmFzIGlzIGNsZWFyZWRcbiAgICAgKiBAcGFyYW0gdG9Mb2cgV2hhdCB0byBsb2cgKHNwb2lsZXI6IG5vdGhpbmcpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9Mb2cpIHtcbiAgICAgICAgc3VwZXIodG9Mb2cpO1xuICAgICAgICB0aGlzLnRhZyA9IFwiY2xlYXJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGFuZCByZXR1cm5zIG1lc3NhZ2UgXCJDb25zb2xlIGNsZWFyZWRcIiB3aXRoIGRhdGUgYW5kIHRpbWUgYXR0YWNoZWRcbiAgICAgKi9cbiAgICBhc3NlbWJsZUxvZygpIHtcbiAgICAgICAgbGV0IHRvUHJpbnQgPSBcIkNvbnNvbGUgY2xlYXJlZFwiO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dJdGVtKHRvUHJpbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xlYXJFdmVudCA9IENsZWFyRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DbGVhckV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0xvZ0V2ZW50XCIpO1xuY2xhc3MgQ2xpY2tFdmVudCBleHRlbmRzIExvZ0V2ZW50XzEuTG9nRXZlbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIENsaWNrIEV2ZW50LCB3aGljaCBsb2dzIHdoZW4gYW4gb2JqZWN0IG9uIHRoZSBjYW52YXMgaXMgY2xpY2tlZFxuICAgICAqIEBwYXJhbSB0b0xvZyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QgdG8gbG9nXG4gICAgICogQHBhcmFtIHgxIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdCB0byBsb2dcbiAgICAgKiBAcGFyYW0geTEgVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0IHRvIGxvZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRvTG9nLCB4MSwgeTEpIHtcbiAgICAgICAgc3VwZXIodG9Mb2csIHgxLCB5MSk7XG4gICAgICAgIHRoaXMudGFnID0gXCJjbGlja1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYW5kIHJldHVybnMgbWVzc2FnZSBvZiBmb3JtIFwiQ2xpY2tlZCBvbiBvYmogYXQgeCwgeVwiIHdpdGggZGF0ZSBhbmQgdGltZSBhdHRhY2hlZFxuICAgICAqL1xuICAgIGFzc2VtYmxlTG9nKCkge1xuICAgICAgICBsZXQgdG9QcmludCA9IFwiQ2xpY2tlZCBvbiBcIiArIHRoaXMudG9Mb2cgKyBcIiBhdCBcIiArIHRoaXMueDEudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMueTEudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nSXRlbSh0b1ByaW50KTtcbiAgICB9XG59XG5leHBvcnRzLkNsaWNrRXZlbnQgPSBDbGlja0V2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xpY2tFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ0V2ZW50XzEgPSByZXF1aXJlKFwiLi9Mb2dFdmVudFwiKTtcbmNsYXNzIERyYWdFdmVudCBleHRlbmRzIExvZ0V2ZW50XzEuTG9nRXZlbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIERyYWcgRXZlbnQsIHdoaWNoIGxvZ3Mgd2hlbiBhbiBvYmplY3Qgb24gdGhlIGNhbnZhcyBpcyBkcmFnZ2VkXG4gICAgICogQHBhcmFtIHRvTG9nIFRoZSBlZmZlY3QgdG8gbG9nXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9Mb2cpIHtcbiAgICAgICAgc3VwZXIodG9Mb2cpO1xuICAgICAgICB0aGlzLnRhZyA9IFwiZHJhZ1wiO1xuICAgICAgICB0aGlzLl90b1ByaW50ID0gdGhpcy5hc3NlbWJsZVN0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBsb2cgc3RyaW5nIHVzaW5nIHRoZSBFZmZlY3QncyB0b0RyYWdTdHJpbmcoKSBtZXRob2RcbiAgICAgKi9cbiAgICBhc3NlbWJsZVN0cmluZygpIHtcbiAgICAgICAgdGhpcy5fdG9QcmludCA9IHRoaXMudG9Mb2cudG9EcmFnU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl90b1ByaW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYW5kIHJldHVybnMgZmluYWwgbG9nIG1lc3NhZ2Ugb2YgZm9ybSBcIkRyYWdnZWQgb2JqIGZyb20geDEsIHkxIHRvIHgyLCB5MlwiXG4gICAgICogd2l0aCBkYXRlIGFuZCB0aW1lIGF0dGFjaGVkXG4gICAgICovXG4gICAgYXNzZW1ibGVMb2coKSB7XG4gICAgICAgIGxldCBwcmludCA9IFwiRHJhZ2dlZCBcIiArIHRoaXMuX3RvUHJpbnQ7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0l0ZW0ocHJpbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuRHJhZ0V2ZW50ID0gRHJhZ0V2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHJhZ0V2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0xvZ0V2ZW50XCIpO1xuY2xhc3MgSURFdmVudCBleHRlbmRzIExvZ0V2ZW50XzEuTG9nRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEEgY29uc3RydWN0b3IgZm9yIGFuIElEIGV2ZW50LCB1c2VkIHdoZW4gYW4gb2JqZWN0IGdldHMgYXNzaWduZWQgYW4gSURcbiAgICAgKiBAcGFyYW0gdG9Mb2cgVGhlIGVmZmVjdCB0byBsb2dcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b0xvZykge1xuICAgICAgICBzdXBlcih0b0xvZyk7XG4gICAgICAgIHRoaXMudGFnID0gXCJJRFwiO1xuICAgICAgICB0aGlzLl90b1ByaW50ID0gdGhpcy5hc3NlbWJsZVN0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgc3RyaW5nIHVzaW5nIHRoZSBlZmZlY3QncyB0b0lEU3RyaW5nKCkgbWV0aG9kXG4gICAgICovXG4gICAgYXNzZW1ibGVTdHJpbmcoKSB7XG4gICAgICAgIHRoaXMuX3RvUHJpbnQgPSB0aGlzLnRvTG9nLnRvSURTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvUHJpbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBtZXNzYWdlIG9mIGZvcm0gXCJBc3NpZ25lZCBJRCAjIHRvIG9iaiBhdCB4LCB5XCIgd2l0aCBkYXRlIGFuZCB0aW1lIGF0dGFjaGVkXG4gICAgICovXG4gICAgYXNzZW1ibGVMb2coKSB7XG4gICAgICAgIGxldCBwcmludCA9IFwiQXNzaWduZWQgSUQgXCIgKyB0aGlzLl90b1ByaW50O1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dJdGVtKHByaW50KTtcbiAgICB9XG59XG5leHBvcnRzLklERXZlbnQgPSBJREV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SURFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIExvZ0V2ZW50IHtcbiAgICAvKipcbiAgICAgKiBBYnN0cmFjdCBjbGFzcyBjb25zdHJ1Y3RvciBmb3IgYSBMb2cgRXZlbnQuIFJlZ2lzdGVycyBldmVudCB0aW1lLlxuICAgICAqIEBwYXJhbSB0b0xvZyBUaGUgc3RyaW5nLCBvYmplY3QsIG9yIGFycmF5IG9mIG9iamVjdHMgdG8gYmUgbG9nZ2VkXG4gICAgICogQHBhcmFtIHgxIEluaXRpYWwgeCBwb3NpdGlvbiwgaWYgYXBwbGljYWJsZVxuICAgICAqIEBwYXJhbSB5MSBJbml0aWFsIHkgcG9zaXRpb24sIGlmIGFwcGxpY2FibGVcbiAgICAgKiBAcGFyYW0geDIgRmluYWwgeCBwb3NpdGlvbiwgaWYgYXBwbGljYWJsZVxuICAgICAqIEBwYXJhbSB5MiBGaW5hbCB5IHBvc2l0aW9uLCBpZiBhcHBsaWNhYmxlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9Mb2csIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIGxldCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuX2RhdGUgPSB0b2RheS5nZXRGdWxsWWVhcigpICsgJy0nICsgKHRvZGF5LmdldE1vbnRoKCkgKyAxKSArICctJyArIHRvZGF5LmdldERhdGUoKTtcbiAgICAgICAgdGhpcy5fdGltZSA9IHRvZGF5LmdldEhvdXJzKCkgKyBcIjpcIiArIHRvZGF5LmdldE1pbnV0ZXMoKSArIFwiOlwiICsgdG9kYXkuZ2V0U2Vjb25kcygpO1xuICAgICAgICB0aGlzLl9kYXRlVGltZSA9IHRoaXMuX2RhdGUgKyAnICcgKyB0aGlzLl90aW1lO1xuICAgICAgICB0aGlzLl90b0xvZyA9IHRvTG9nO1xuICAgICAgICAvL3RoaXMuX3RvTG9nQXJyYXkgPSB0b0xvZ0FycmF5O1xuICAgICAgICB0aGlzLl94MSA9IHgxO1xuICAgICAgICB0aGlzLl95MSA9IHkxO1xuICAgICAgICB0aGlzLl94MiA9IHgyO1xuICAgICAgICB0aGlzLl95MiA9IHkyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBkYXRlIGFuZCB0aW1lIHRvIGxvZyBtZXNzYWdlXG4gICAgICogQHBhcmFtIHRvTG9nIFRoZSBsb2cgbWVzc2FnZVxuICAgICAqL1xuICAgIGxvZ0l0ZW0odG9Mb2cpIHtcbiAgICAgICAgcmV0dXJuIFwiIFwiICsgdGhpcy5fZGF0ZVRpbWUgKyBcIjogXCIgKyB0b0xvZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXRlLXRpbWUgc3RyaW5nXG4gICAgICovXG4gICAgZ2V0IGRhdGVUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIG9yIGVmZmVjdChzKSB0byBiZSBsb2dnZWRcbiAgICAgKi9cbiAgICBnZXQgdG9Mb2coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b0xvZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBldmVudCB0YWdcbiAgICAgKi9cbiAgICBnZXQgdGFnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRhZyBzdHJpbmdcbiAgICAgKi9cbiAgICBzZXQgdGFnKHRhZykge1xuICAgICAgICB0aGlzLl90YWcgPSB0YWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgeDFcbiAgICAgKi9cbiAgICBnZXQgeDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94MTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB5MVxuICAgICAqL1xuICAgIGdldCB5MSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3kxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHgyXG4gICAgICovXG4gICAgZ2V0IHgyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feDI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgeTJcbiAgICAgKi9cbiAgICBnZXQgeTIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl95MjtcbiAgICB9XG59XG5leHBvcnRzLkxvZ0V2ZW50ID0gTG9nRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2dFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ0V2ZW50XzEgPSByZXF1aXJlKFwiLi9Mb2dFdmVudFwiKTtcbmNsYXNzIFBhaW50RXZlbnQgZXh0ZW5kcyBMb2dFdmVudF8xLkxvZ0V2ZW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBQYWludCBFdmVudCwgdXNlZCB3aGVuIGFuIG9iamVjdCBpcyBwYWludGVkIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gdG9Mb2cgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0IHRvIGJlIGxvZ2dlZFxuICAgICAqIEBwYXJhbSB4MSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHkxIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b0xvZywgeDEsIHkxKSB7XG4gICAgICAgIHN1cGVyKHRvTG9nLCB4MSwgeTEpO1xuICAgICAgICB0aGlzLnRhZyA9IFwicGFpbnRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGFuZCByZXR1cm5zIG1lc3NhZ2Ugb2YgZm9ybSBcIlBhaW50ZWQgb2JqIGF0IHgsIHlcIiB3aXRoIGRhdGUgYW5kIHRpbWUgYXR0YWNoZWRcbiAgICAgKi9cbiAgICBhc3NlbWJsZUxvZygpIHtcbiAgICAgICAgbGV0IHRvUHJpbnQgPSBcIlBhaW50ZWQgXCIgKyB0aGlzLnRvTG9nICsgXCIgYXQgXCIgKyB0aGlzLngxLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLnkxLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0l0ZW0odG9QcmludCk7XG4gICAgfVxufVxuZXhwb3J0cy5QYWludEV2ZW50ID0gUGFpbnRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhaW50RXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMb2dFdmVudF8xID0gcmVxdWlyZShcIi4vTG9nRXZlbnRcIik7XG5jbGFzcyBSZXNpemVFdmVudCBleHRlbmRzIExvZ0V2ZW50XzEuTG9nRXZlbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBSZXNpemUgRXZlbnQsIHVzZWQgd2hlbiBhbiBvYmplY3Qgb24gdGhlIGNhbnZhcyBpcyByZXNpemVkXG4gICAgICogQHBhcmFtIHRvTG9nIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0IHRvIGJlIGxvZ2dlZFxuICAgICAqIEBwYXJhbSB4MSBJbml0aWFsIHggZGltZW5zaW9uIG9mIHRoZSBvYmplY3QsIG9yIGluaXRpYWwgZm9udCBzaXplXG4gICAgICogQHBhcmFtIHkxIEluaXRpYWwgeSBkaW1lbnNpb24gb2YgdGhlIG9iamVjdCwgb3IgZmluYWwgZm9udCBzaXplXG4gICAgICogQHBhcmFtIHgyIEZpbmFsIHggZGltZW5zaW9uIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0geTIgRmluYWwgeSBkaW1lbnNpb24gb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRvTG9nLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICBzdXBlcih0b0xvZywgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICB0aGlzLnRhZyA9IFwicmVzaXplXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBsb2cgbWVzc2FnZSBvZiBmb3JtIFwiUmVzaXplZCBvYmogZnJvbSBzaXplIHgxLCB5MSB0byBzaXplIHgxLCB5MlwiIGZvciByZWN0cyBhbmQgZWxsaXBzZXNcbiAgICAgKiBvciBvZiBmb3JtIFwiUmVzaXplZCBvYmogZnJvbSBzaXplIHgxIHRvIHNpemUgeTFcIiBmb3Igc3RyaW5nc1xuICAgICAqIEhhcyBkYXRlIGFuZCB0aW1lIGF0dGFjaGVkXG4gICAgICovXG4gICAgYXNzZW1ibGVMb2coKSB7XG4gICAgICAgIGlmICh0aGlzLngyICE9IHVuZGVmaW5lZCAmJiB0aGlzLnkyICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy50b1ByaW50ID0gXCJSZXNpemVkIFwiICsgdGhpcy50b0xvZyArIFwiIGZyb20gc2l6ZSBcIiArIHRoaXMueDEudG9TdHJpbmcoKSArIFwiIGJ5IFwiICsgdGhpcy55MS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgKyBcIiB0byBzaXplIFwiICsgdGhpcy54Mi50b1N0cmluZygpICsgXCIgYnkgXCIgKyB0aGlzLnkyLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRvUHJpbnQgPSBcIlJlc2l6ZWQgXCIgKyB0aGlzLnRvTG9nICsgXCIgZnJvbSBzaXplIFwiICsgdGhpcy54MS50b1N0cmluZygpICsgXCIgdG8gc2l6ZSBcIiArIHRoaXMueTEudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2dJdGVtKHRoaXMudG9QcmludCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXNpemVFdmVudCA9IFJlc2l6ZUV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVzaXplRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMb2dFdmVudF8xID0gcmVxdWlyZShcIi4vTG9nRXZlbnRcIik7XG5jbGFzcyBTZWxlY3RFdmVudCBleHRlbmRzIExvZ0V2ZW50XzEuTG9nRXZlbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIFNlbGVjdGlvbiBFdmVudCwgdXNlZCB3aGVuIG11bHRpcGxlIG9iamVjdHMgb24gdGhlIGNhbnZhcyBhcmUgc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0gdG9Mb2cgVGhlIGFycmF5IG9mIG9iamVjdHMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b0xvZykge1xuICAgICAgICBzdXBlcih0b0xvZyk7XG4gICAgICAgIHRoaXMudGFnID0gXCJzZWxlY3RcIjtcbiAgICAgICAgdGhpcy5fdG9QcmludCA9IHRoaXMuYXNzZW1ibGVTdHJpbmdzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhbmQgcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbGwgdGhlIG9iamVjdHMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBhc3NlbWJsZVN0cmluZ3MoKSB7XG4gICAgICAgIGxldCBsb2dTdHJpbmdzID0gW107XG4gICAgICAgIGZvciAobGV0IGVsZW0gb2YgdGhpcy50b0xvZykge1xuICAgICAgICAgICAgbG9nU3RyaW5ncy5wdXNoKGVsZW0udG9TZWxTdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiU2VsZWN0ZWRcIiArIGxvZ1N0cmluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1lc3NhZ2Ugd2l0aCBkYXRlIGFuZCB0aW1lIGF0dGFjaGVkXG4gICAgICovXG4gICAgYXNzZW1ibGVMb2coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0l0ZW0odGhpcy5fdG9QcmludCk7XG4gICAgfVxufVxuZXhwb3J0cy5TZWxlY3RFdmVudCA9IFNlbGVjdEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VsZWN0RXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY2xhc3MgQW5kIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgbG9naWNhbCAnYW5kJyAoJiYpIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IHNpZGUgb2YgdGhlIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgb3BlcmF0aW9uIGFuZCByZXR1cm5zIGEgYm9vbGVhbiBvZiB0aGUgcmVzdWx0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsaHMgPSB0aGlzLl9sZWZ0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGxldCByaHMgPSB0aGlzLl9yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZSAmJiByaHMgaW5zdGFuY2VvZiBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLnZhbCAmJiByaHMudmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudHMgdG8gdGhlICdhbmQnIG9wZXJhdG9yIG11c3QgYmUgYm9vbGVhbnMuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLl9sZWZ0LnRvU3RyaW5nKCkgKyAnIGFuZCAnICsgdGhpcy5fcmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiB0aGUgJ2FuZCcgb3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgJ2FuZCcgb3BlcmF0aW9uIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxlZnQgc2lkZSBvZiB0aGUgb3BcbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIG9wXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG4gICAgfVxufVxuZXhwb3J0cy5BbmQgPSBBbmQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BbmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY2xhc3MgRXF1YWxzIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgZXF1YWxpdHkgKD09KSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbGVmdCBzaWRlIG9mIHRoZSBlcXVhbGl0eVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHlcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBjb21wYXJpc29uIGFuZCBldmFsdWF0ZXMgdG8gYSBCb29sZWFuTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsaHMgPSB0aGlzLl9sZWZ0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGxldCByaHMgPSB0aGlzLl9yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLmVxdWFsc1ZhbChyaHMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXF1YWxpdHkgb3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5fbGVmdC50b1N0cmluZygpICsgJyBlcXVhbHMgJyArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbid0IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhbiBlcXVhbGl0eSBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWxsIHRoaXMgaXMgbWV0YVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxpdHkgb3BzIGNhbid0IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG4gICAgfVxufVxuZXhwb3J0cy5FcXVhbHMgPSBFcXVhbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcXVhbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jbGFzcyBHcmVhdGVyVGhhbiB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIEdyZWF0ZXJUaGFuICg+KSBvcFxuICAgICAqIEBwYXJhbSBsZWZ0IExlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gcmlnaHQgUmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIEdyZWF0ZXJUaGFuIGNvbXBhcmlzb24gYW5kIHJldHVybnMgQm9vbGVhbk5vZGUgcmVwcmVzZW50YXRpb24gb2YgcmVzdWx0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsaHMgPSB0aGlzLl9sZWZ0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGxldCByaHMgPSB0aGlzLl9yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUgJiYgcmhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLnZhbCA+IHJocy52YWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudHMgdG8gdGhlID4gb3BlcmF0b3IgbXVzdCBiZSBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5fbGVmdC50b1N0cmluZygpICsgXCIgPiBcIiArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gR3JlYXRlclRoYW4gb3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHcmVhdGVyVGhhbiBvcCBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLkdyZWF0ZXJUaGFuID0gR3JlYXRlclRoYW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmVhdGVyVGhhbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIEdyZWF0ZXJUaGFuRXEge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBHcmVhdGVyVGhhbkVxIChncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8sID49KSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBMZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0IFJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBHcmVhdGVyVGhhbkVxIG9wZXJhdGlvbiBhbmQgcmV0dXJucyBCb29sZWFuTm9kZSB3aXRoIHJlc3VsdFxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsaHMgPSB0aGlzLl9sZWZ0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGxldCByaHMgPSB0aGlzLl9yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUgJiYgcmhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLnZhbCA+PSByaHMudmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJndW1lbnRzIHRvIHRoZSA+PSBvcGVyYXRvciBtdXN0IGJlIG51bWVyaWMuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLl9sZWZ0LnRvU3RyaW5nKCkgKyAnID49ICcgKyB0aGlzLl9yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIEdyZWF0ZXJUaGFuRXEgb3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHcmVhdGVyVGhhbkVxIG9wIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbn1cbmV4cG9ydHMuR3JlYXRlclRoYW5FcSA9IEdyZWF0ZXJUaGFuRXE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmVhdGVyVGhhbkVxLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgTGVzc1RoYW4ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBMZXNzVGhhbiAoPCkgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgTGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSByaWdodCBSaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIExlc3NUaGFuIGNvbXBhcmlzb24gYW5kIHJldHVybnMgQm9vbGVhbk5vZGUgd2l0aCByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLl9sZWZ0LmV2YWwoY29udGV4dCkgKyBcIiBpcyBsZXNzIHRoYW4gXCIgKyB0aGlzLl9yaWdodC5ldmFsKGNvbnRleHQpKTtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSAmJiByaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlRoZXkncmUgYm90aCBudW1iZXIgbm9kZXNcIik7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGxocy52YWwgKyBcIjxcIiArIHJocy52YWwpO1xuICAgICAgICAgICAgLy9sZXQgYm9vbDogYm9vbGVhbiA9IGxocy52YWwgPCByaHMudmFsO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImJvb2w6IFwiICsgYm9vbCk7XG4gICAgICAgICAgICByZXR1cm4gKG5ldyBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKGxocy52YWwgPCByaHMudmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudHMgdG8gbGVzcyB0aGFuIG11c3QgcHJvZHVjZSBudW1lcmljIHZhbHVlcy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0LnRvU3RyaW5nKCkgKyAnIDwgJyArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gTGVzc1RoYW4gb3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXNzVGhhbiBvcCBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLkxlc3NUaGFuID0gTGVzc1RoYW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzVGhhbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIExlc3NUaGFuRXEge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBMZXNzVGhhbkVxIChsZXNzIHRoYW4gb3IgZXF1YWwgdG8sIDw9KSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbGVmdCBzaWRlIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIExlc3NUaGFuRXEgY29tcGFyaXNvbiBhbmQgcmV0dXJucyBCb29sZWFuTm9kZSB3aXRoIHJlc3VsdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgbGhzID0gdGhpcy5fbGVmdC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBsZXQgcmhzID0gdGhpcy5fcmlnaHQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgaWYgKGxocyBpbnN0YW5jZW9mIE51bWJlck5vZGVfMS5OdW1iZXJOb2RlICYmIHJocyBpbnN0YW5jZW9mIE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gKG5ldyBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKGxocy52YWwgPD0gcmhzLnZhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50cyB0byB0aGUgPD0gb3BlcmF0b3IgbXVzdCBiZSBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5fbGVmdC50b1N0cmluZygpICsgXCIgPD0gXCIgKyB0aGlzLl9yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIExlc3NUaGFuRXEgb3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXNzVGhhbkVxIG9wcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLkxlc3NUaGFuRXEgPSBMZXNzVGhhbkVxO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc1RoYW5FcS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jbGFzcyBOb3Qge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgbG9naWNhbCBOb3QgKCEpIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBleHByIFRoZSBleHByZXNzaW9uIHRvIGJlIG9wZXJhdGVkIG9uIChtdXN0IGJlIGEgQm9vbGVhbk5vZGUpXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZXhwciwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9leHByID0gZXhwcjtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBOb3Qgb3BlcmF0aW9uIGFuZCByZXR1cm5zIEJvb2xlYW5Ob2RlIHdpdGggcmVzdWx0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBlID0gdGhpcy5fZXhwci5ldmFsKGNvbnRleHQpO1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZSghZS52YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50IHRvIHRoZSAhIG9wZXJhdG9yIG11c3QgYmUgYm9vbGVhbi5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwibm90IFwiICsgdGhpcy5fZXhwci50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgTm90IG9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90IG9wZXJhdGlvbnMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBleHByZXNzaW9uIHRvIGJlIG9wZXJhdGVkIG9uXG4gICAgICovXG4gICAgZ2V0IGV4cHIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHByO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90ID0gTm90O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm90LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgTm90RXF1YWwge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBOb3RFcXVhbCAoIT0pIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IExlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gcmlnaHQgUmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIE5vdEVxdWFsIG9wZXJhdGlvbiBhbmQgcmV0dXJucyBCb29sZWFuTm9kZSB3aXRoIHJlc3VsdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgbGhzID0gdGhpcy5fbGVmdC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBsZXQgcmhzID0gdGhpcy5fcmlnaHQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgaWYgKGxocyBpbnN0YW5jZW9mIE51bWJlck5vZGVfMS5OdW1iZXJOb2RlICYmIHJocyBpbnN0YW5jZW9mIE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gKG5ldyBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKGxocy52YWwgIT09IHJocy52YWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudHMgdG8gdGhlICE9IG9wZXJhdG9yIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArIFwiIG5vdCBlcXVhbHMgXCIgKyB0aGlzLl9yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgTm90RXF1YWwgb3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RFcXVhbCBvcHMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RFcXVhbCA9IE5vdEVxdWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm90RXF1YWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY2xhc3MgT3Ige1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBsb2dpY2FsICdvcicgKHx8KSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBMZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0IFJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBPciBvcGVyYXRpb24gYW5kIHJldHVybnMgQm9vbGVhbk5vZGUgd2l0aCByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBDdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgbGhzID0gdGhpcy5fbGVmdC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBsZXQgcmhzID0gdGhpcy5fcmlnaHQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgaWYgKGxocyBpbnN0YW5jZW9mIEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUgJiYgcmhzIGluc3RhbmNlb2YgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKGxocy52YWwgfHwgcmhzLnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJndW1lbnRzIHRvIHRoZSAnb3InIG9wZXJhdG9yIG11c3QgYmUgYm9vbGVhbnMuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLl9sZWZ0LnRvU3RyaW5nKCkgKyAnIG9yICcgKyB0aGlzLl9yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIE9yIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9yIG9wZXJhdGlvbnMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG4gICAgfVxufVxuZXhwb3J0cy5PciA9IE9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTY29wZV8xID0gcmVxdWlyZShcIi4uL3N0cnVjdHVyYWwvU2NvcGVcIik7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY29uc3Qgc3BhY2VfbGlmdF8xID0gcmVxdWlyZShcInNwYWNlLWxpZnRcIik7XG5jbGFzcyBGb3JOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBGb3IgbG9vcFxuICAgICAqIEBwYXJhbSBpbml0IEluaXRpYWxpemVzIHRoZSB2YXJpYWJsZSB1c2VkIGluIHRoZSBjb25kaXRpb25cbiAgICAgKiBAcGFyYW0gY29uZCBUaGUgY29uZGl0aW9uIChtdXN0IGV2YWx1YXRlIHRvIEJvb2xlYW5Ob2RlKVxuICAgICAqIEBwYXJhbSBwb3N0IFRoZSBwb3N0ZXZhbHVhdGlvbiBjb25kaXRpb25cbiAgICAgKiBAcGFyYW0gYm9keSBUaGUgYm9keSBvZiB0aGUgbG9vcFxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluaXQsIGNvbmQsIHBvc3QsIGJvZHksIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbml0ID0gaW5pdDtcbiAgICAgICAgdGhpcy5fY29uZCA9IGNvbmQ7XG4gICAgICAgIHRoaXMuX3Bvc3QgPSBwb3N0O1xuICAgICAgICB0aGlzLl9ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyB0aGUgRm9yIGxvb3BcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGNoaWxkQ3R4ID0gbmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCwgY29udGV4dC5lZmZlY3RzLCBjb250ZXh0LmV2ZW50TG9nKTtcbiAgICAgICAgY2hpbGRDdHguY2FudmFzID0gc3BhY2VfbGlmdF8xLlNvbWUoY29udGV4dC5jYW52YXMuZ2V0KCkpO1xuICAgICAgICB0aGlzLl9pbml0LmV2YWwoY2hpbGRDdHgpOyAvLyBpbml0aWFsaXplIHZhclxuICAgICAgICBsZXQgcmVzID0gdGhpcy5fY29uZC5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgaWYgKCEocmVzIGluc3RhbmNlb2YgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjb25kaXRpb24gbXVzdCBiZSBhIGJvb2xlYW4gZXhwcmVzc2lvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJldDtcbiAgICAgICAgd2hpbGUgKHJlcy52YWwpIHtcbiAgICAgICAgICAgIHJldCA9IHRoaXMuX2JvZHkuZXZhbChjaGlsZEN0eCk7XG4gICAgICAgICAgICB0aGlzLl9wb3N0LmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICAgICAgcmVzID0gdGhpcy5fY29uZC5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBGb3JOb2RlXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBGb3IgbG9vcFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yTm9kZXMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICByZXR1cm4gXCJDYW5ub3QgY2FsbCBkcmF3IG9uIEZvciBsb29wXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGZvciBsb29wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArICdmb3IoJyArIHRoaXMuX2luaXQudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuX2NvbmQudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuX3Bvc3QudG9TdHJpbmcoKSArIFwiKSB7XFxuIFwiXG4gICAgICAgICAgICArIHRoaXMuX2JvZHkudG9TdHJpbmcoKSArIFwifVwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5Gb3JOb2RlID0gRm9yTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZvck5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTY29wZV8xID0gcmVxdWlyZShcIi4uL3N0cnVjdHVyYWwvU2NvcGVcIik7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY29uc3Qgc3BhY2VfbGlmdF8xID0gcmVxdWlyZShcInNwYWNlLWxpZnRcIik7XG5jbGFzcyBXaGlsZU5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIFdoaWxlIGxvb3BcbiAgICAgKiBAcGFyYW0gY29uZCBUaGUgV2hpbGUgbG9vcCBjb25kaXRpb25cbiAgICAgKiBAcGFyYW0gYm9keSBUaGUgYm9keSBvZiB0aGUgbG9vcFxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmQsIGJvZHksIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jb25kID0gY29uZDtcbiAgICAgICAgdGhpcy5fYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgdGhlIGJvZHkgb2YgdGhlIGxvb3Agd2hpbGUgdGhlIGNvbmRpdGlvbiBpcyB0cnVlXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGNoaWxkQ3R4ID0gbmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCwgY29udGV4dC5lZmZlY3RzLCBjb250ZXh0LmV2ZW50TG9nKTtcbiAgICAgICAgY2hpbGRDdHguY2FudmFzID0gc3BhY2VfbGlmdF8xLlNvbWUoY29udGV4dC5jYW52YXMuZ2V0KCkpO1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5fY29uZC5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgaWYgKCEocmVzIGluc3RhbmNlb2YgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjb25kaXRpb24gbXVzdCBiZSBhIGJvb2xlYW4gZXhwcmVzc2lvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJldDtcbiAgICAgICAgd2hpbGUgKHJlcy52YWwpIHtcbiAgICAgICAgICAgIHJldCA9IHRoaXMuX2JvZHkuZXZhbChjaGlsZEN0eCk7XG4gICAgICAgICAgICByZXMgPSB0aGlzLl9jb25kLmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIFdoaWxlTm9kZXNcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIFdoaWxlIGxvb3BcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoaWxlTm9kZXMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICByZXR1cm4gXCJDYW5ub3QgY2FsbCBkcmF3IG9uIFdoaWxlIGxvb3BcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgV2hpbGUgbG9vcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyBcIndoaWxlKFwiICsgdGhpcy5fY29uZC50b1N0cmluZygpICsgXCIpIHtcXG4gXCIgKyB0aGlzLl9ib2R5LnRvU3RyaW5nKCkgKyBcIn1cIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuV2hpbGVOb2RlID0gV2hpbGVOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2hpbGVOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGxvY2F0aW9uLCBjb250ZW50KSB7XG4gICAgICAgIHRoaXMuX2xvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbn1cbmV4cG9ydHMuSW5zdHJ1Y3Rpb24gPSBJbnN0cnVjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUluc3RydWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvbkZvdXJDcE9uZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImw0YzFcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsNGMyJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBZb3UndmUgbWFkZSBpdCB0byB0aGUgRklOQUwgQ0hBTExFTkdFUyEgQ29tcGxldGUgdGhlc2UgY2hhbGxlbmdlcyB0byBlYXJuIEVURVJOQUwgR0xPUlkhIDwvcD5cbiAgICA8cD4gVGhyb3VnaG91dCB0aGlzIEhvdXIgb2YgQ29kZSwgeW91IGhhdmUgbGVhcm5lZDogPC9wPlxuICAgIDxwPiAtIEhvdyB0byBwcmludCBhIHdvcmQsIGNpcmNsZSwgcmVjdGFuZ2xlLCBhbmQgY3VydmUuIDwvcD5cbiAgICA8cD4gLSBIb3cgdG8gc3RvcmUgYW55IG9mIHRoZSB2YWx1ZSBhYm92ZSBpbiBhIHZhcmlhYmxlLiA8L3A+XG4gICAgPHA+IC0gSG93IHRvIHVzZSBpZi9lbHNlIHN0YXRlbWVudCB0byBjaGVjayBhIGNvbmRpdGlvbiBhYm91dCBhIHZhcmlhYmxlLiA8L3A+XG4gICAgPHA+IEVhY2ggb2YgdGhlIGZvbGxvd2luZyBjaGFsbGVuZ2VzIHdpbGwgdGVzdCB0aGVzZSBjb25jZXB0cy4gTGV0J3MgZGl2ZSByaWdodCBpbiEgPC9wPlxuICAgIDxwPiBQcmludCBhIGNpcmNsZSBhbmQgcHV0IGl0cyBoZWlnaHQgYW5kIHdpZHRoIGluIG9uZSBvZiB0aGUgYm94ZXMgdG8gdGhlIHNpZGUuIFRoZW4gcHJpbnQgYSByZWN0YW5nbGUgYW5kIHB1dCBpdHMgaGVpZ2h0IGFuZCB3aWR0aCBpbiB0aGUgYm94LiA8L3A+XG4gICAgPHA+IENIQUxMRU5HRTogUHJpbnQgYSBjaXJjbGUgYW5kIHJlY3RhbmdsZS4gUHV0IHRoZWlyIHJlc3BlY3RpdmUgd2lkdGggYW5kIGhlaWdodCBpbiB0aGUgYm94ZXMgcHJvdmlkZWQuIDwvcD5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiBsZWFkaW5nIGludG8gY29uZGl0aW9uYWxzXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvcHJpbnRcXHMqXFwoXFxzKmVsbGlwc2VcXHMqXFwoXFxzKlsxLTldWzAtOV0qXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqXFwpXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqLFxccypbMS05XVswLTldKlxccypcXCk7LztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Gb3VyQ3BPbmUgPSBMZXNzb25Gb3VyQ3BPbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Gb3VyQ3BPbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFbGxpcHNlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9FbGxpcHNlRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uRm91ckNwVHdvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDRjMlwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2w0YzInO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFllcyEgWW91IGdvdCB0aGlzISA8L3A+XG4gICAgPHA+IE5vdyBsZXQncyBwdXQgdGhvc2Ugc2tpbGxzIGluIGlmL2Vsc2Ugc3RhdGVtZW50cyB0byB3b3JrISA8L3A+XG4gICAgPHA+IENyZWF0ZSBhIHBhaXIgb2YgaWYvZWxzZSBzdGF0ZW1lbnRzIHRvIHByaW50IG91dCB0byB0aGUgQ0FOVkFTIGEgY2xhaW0gb2Ygd2hldGhlciB0aGUgY2lyY2xlIGlzIHBvc2l0aW9uZWQgQUJPVkUgb3IgQkVMT1cgdGhlIHJlY3RhbmdsZS4gPC9wPlxuICAgIDxwPiBDSEFMTEVOR0U6IFByaW50IGEgY2xhaW0gdGhhdCBzdGF0ZXMgd2hldGhlciBjaXJjbGUgaXMgQUJPVkUgb3IgQkVMT1cgdGhlIHJlY3RhbmdsZS4gPC9wPlxuICAgIDxwPiBISU5UOiBSZW1lbWJlciB0aGF0IHRoZSBudW1iZXJzIGluIHRoZSBwcmludCgpIHN0YXRlbWVudHMgZGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2hhcGVzIGJlaW5nIHByaW50ZWQuIDwvcD5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiBsZWFkaW5nIGludG8gY29uZGl0aW9uYWxzXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvcHJpbnRcXHMqXFwoXFxzKmVsbGlwc2VcXHMqXFwoXFxzKlsxLTldWzAtOV0qXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqXFwpXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqLFxccypbMS05XVswLTldKlxccypcXCk7LztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Gb3VyQ3BUd28gPSBMZXNzb25Gb3VyQ3BUd287XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Gb3VyQ3BUd28uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3Nvbk9uZUNwRm91ciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwxYzRcIjtcbiAgICAgICAgdGhpcy5fcHJldk1vZHVsZSA9ICdsMWMyJztcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsMmMxJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdjYW52YXMnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IE5vdGUgdGhhdCBjaGFuZ2luZyB0aGUgZmlyc3QgbnVtYmVyIGluIHRoZSBwcmludCBzdGF0ZW1lbnQgbW92ZXMgdGhlIHdvcmRzIGxlZnQgb3IgcmlnaHQsIHdoaWxlIGNoYW5naW5nIHRoZSBzZWNvbmQgbnVtYmVyIG1vdmUgdGhlbSB1cCBvciBkb3duLiA8L3A+XG4gICAgPHA+IE5vdyB0aW1lIGZvciBhIGNoYWxsZW5nZSEgUHJpbnQgdGhlIHdvcmQgXCJtb29cIiBvbiB0aGUgQ0FOVkFTLCBhbmQgcHV0IGl0IHJpZ2h0IGluIHRoZSBjZW50ZXIgb2YgdGhlIGVudGlyZSBDQU5WQVMuIDwvcD5cbiAgICA8cD4gQ0hBTExFTkdFOiBQcmludCB0aGUgd29yZCBcIm1vb1wiIGluIHRoZSBjZW50ZXIgb2YgdGhlIENBTlZBUy4gPC9wPlxuICAgIDxwPiBISU5UOiBXcml0ZSBwcmludChcIm1vb1wiLCA1MCwgNTApIGluIHRoZSBDT0RFIGFyZWEgZmlyc3QsIHRoZW4gY2hhbmdlIHRoZSBudW1iZXJzIGluc2lkZSB0aGF0IHByaW50IHN0YXRlbWVudC4gPC9wPmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudCBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0ICYmIGVmZmVjdC5zdHIgPT09IFwibW9vXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGVmZmVjdC54ID4gMjAwICYmIGVmZmVjdC54IDwgMjQwKSAmJiAoZWZmZWN0LnkgPiAyMzAgJiYgZWZmZWN0LnkgPCAzMDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3Nvbk9uZUNwRm91ciA9IExlc3Nvbk9uZUNwRm91cjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3Nvbk9uZUNwRm91ci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEluc3RydWN0aW9uXzEgPSByZXF1aXJlKFwiLi9JbnN0cnVjdGlvblwiKTtcbmNsYXNzIExlc3Nvbk9uZUNwT25lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDFjMVwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wxYzInO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFRvIGJlZ2luLCBsZXTigJlzIHRlbGwgdGhlIGNvbXB1dGVyIHRvIHdyaXRlIHNvbWV0aGluZyBvbiB0aGUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IEdPQUw6IHdyaXRlIG9uIHRoZSBDQU5WQVMuIDwvcD5cbiAgICA8cD4gSElOVDogdHlwZSBpbiB0aGUgQ09ERSBib3g6IHByaW50KFwiSGVsbG8sIHdvcmxkIVwiKSwgdGhlbiBoaXQgdGhlIFJVTiBidXR0b24uIDwvcD5gO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzID0gW107XG4gICAgICAgIHRoaXMuX2luc3RySW5kZXggPSAwO1xuICAgICAgICBsZXQgY29udGVudCA9IFwiRmlyc3QsIGxldCdzIHRlbGwgdGhlIGNvbXB1dGVyIHRvIHByaW50IHNvbWV0aGluZyBvbiB0aGUgQ0FOVkFTLiBDbGljayBvbiB0aGUgQ09ERSBib3ggaGVyZS5cIjtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlJywgY29udGVudCkpO1xuICAgICAgICBjb250ZW50ID0gJ05vdyB0eXBlIGBwcmludChcIkhlbGxvXCIpYCBpbiB0aGlzIENPREUgYm94Lic7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZScsIGNvbnRlbnQpKTtcbiAgICAgICAgY29udGVudCA9ICdOb3RpY2UgdGhhdCB3aGF0IHlvdSB0eXBlZCBjYXVzZXMgdGhlIGNvbXB1dGVyIHRvIHByaW50IHRoZSB3b3JsZCBcIkhlbGxvXCIgb24gdGhlIENBTlZBUyBoZXJlLiBDb25ncmF0dWxhdGlvbnMhIFlvdSBqdXN0IHdyb3RlIHlvdXIgZmlyc3QgbGluZSBvZiBjb2RlISc7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY2FudmFzJywgY29udGVudCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZW5kZXIgdGhlIGN1cnJlbnQgaW5zdHJ1Y3Rpb24gb2YgdGhpcyBjaGVja3BvaW50XG4gICAgICogQHBhcmFtIGRvY3VtZW50IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICovXG4gICAgcmVuZGVySW5zdHJ1Y3Rpb24oZG9jdW1lbnQpIHtcbiAgICAgICAgbGV0IGluc3RydWN0aW9uID0gdGhpcy5faW5zdHJCb3hlc1t0aGlzLl9pbnN0ckluZGV4XTtcbiAgICAgICAgbGV0IGluc3RyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaW5zdHJEaXYuY2xhc3NOYW1lID0gXCJpbnN0cnVjdGlvblwiO1xuICAgICAgICBpbnN0ckRpdi5pbm5lclRleHQgPSBpbnN0cnVjdGlvbi5fY29udGVudDtcbiAgICAgICAgaW5zdHJEaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgbGV0IHByZXZJbnN0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIHByZXZJbnN0ci5pZCA9ICdwcmV2aW91cy1pbnN0cnVjdGlvbic7XG4gICAgICAgIHByZXZJbnN0ci5pbm5lclRleHQgPSBcIjxcIjtcbiAgICAgICAgaW5zdHJEaXYuYXBwZW5kQ2hpbGQocHJldkluc3RyKTtcbiAgICAgICAgbGV0IG5leHRJbnN0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIG5leHRJbnN0ci5pZCA9ICduZXh0LWluc3RydWN0aW9uJztcbiAgICAgICAgbmV4dEluc3RyLmlubmVyVGV4dCA9IFwiPFwiO1xuICAgICAgICBpbnN0ckRpdi5hcHBlbmRDaGlsZChuZXh0SW5zdHIpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpbnN0cnVjdGlvbi5fbG9jYXRpb24pLmFwcGVuZENoaWxkKGluc3RyRGl2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2Fsczogd3JpdGUgYW55IHN0cmluZyBvbiBDQU5WQVNcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgLypcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0KSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LnN0ciAhPT0gXCJcIikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25PbmVDcE9uZSA9IExlc3Nvbk9uZUNwT25lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uT25lQ3BPbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3Nvbk9uZUNwVGhyZWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMWMzXCI7XG4gICAgICAgIHRoaXMuX3ByZXZNb2R1bGUgPSAnbDFjMic7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDFjNCc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnY2FudmFzJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBZZXAhIE1vdmluZyB0aGUgd29yZHMgYWN0dWFsbHkgY2hhbmdlIHRoZSBudW1iZXJzIGluIHlvdXIgQ09ERS4gPC9wPlxuICAgIDxwPiBOb3cgdGhlIENBTlZBUyBoYXMgYmVlbiBmcm96ZW4hIFRyeSBjaGFuZ2luZyB5b3VyIENPREUgdG8gc2VlIGlmIHlvdSBjYW4gbW92ZSB0aGUgd29yZHMgdG8gdGhlIGJvdHRvbSByaWdodCBjb3JuZXIuIDwvcD5cbiAgICA8cD4gR09BTDogTW92ZSB0aGUgd29yZHMgdG8gdGhlIGJvdHRvbSByaWdodCBvZiB0aGUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IEhJTlQ6IENoYW5nZSBvbmUgb2YgdGhlIDIgbnVtYmVycyBhdCBhIHRpbWUsIHRoZW4gY2xpY2sgUlVOIHRvIHNlZSBob3cgdGhhdCBjaGFuZ2VzIHRoZSBDQU5WQVMuYDtcbiAgICAgICAgdGhpcy54ID0gMTA7XG4gICAgICAgIHRoaXMueSA9IDQzMDtcbiAgICB9XG4gICAgZHJhd0d1aWRlcyhjdHgpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucmVjdCh0aGlzLngsIHRoaXMueSwgMTAwLCAxMDApO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmZvbnQgPSAyMCArIFwicHggQ291cmllciBOZXdcIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgY3R4LmZpbGxUZXh0KFwiUHV0IHRleHRcIiwgdGhpcy54LCAzOTApO1xuICAgICAgICBjdHguZmlsbFRleHQoXCJpbiBoZXJlXCIsIHRoaXMueCwgNDEwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QueCA+IHRoaXMueCAmJiBlZmZlY3QueCA8IHRoaXMueCArIDEwMCAmJiBlZmZlY3QueSA+IHRoaXMueSAmJiBlZmZlY3QueSA8IHRoaXMueSArIDEwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25PbmVDcFRocmVlID0gTGVzc29uT25lQ3BUaHJlZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3Nvbk9uZUNwVGhyZWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3Nvbk9uZUNwVHdvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDFjMlwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wxYzMnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ2NvZGUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFlvdSBqdXN0IHRvbGQgdGhlIGNvbXB1dGVyIHRvIHdyaXRlIHdvcmRzIG9uIHRoZSBDQU5WQVMhIDwvcD5cbiAgICA8cD4gTm93IGxldCdzIGRvIHNvbWV0aGluZyBtb3JlIGludGVyZXN0aW5nOiBjbGljayBvbiB0aGUgd29yZHMgb24gdGhlIENBTlZBUywgdGhlbiBkcmFnIGl0IGluc2lkZSB0aGUgYm94IGF0IHRoZSB0b3AtcmlnaHQgY29ybmVyLiBPYnNlcnZlIHdoYXQgaGFwcGVucyB0byB5b3VyIGNvZGUuIDwvcD5cbiAgICA8cD4gR09BTDogTW92ZSB0aGUgd29yZHMgeW91IGp1c3QgY3JlYXRlZCBpbnNpZGUgdGhlIHRvcC1yaWdodCBib3guIDwvcD5gO1xuICAgICAgICB0aGlzLnggPSAzOTA7XG4gICAgICAgIHRoaXMueSA9IDEwO1xuICAgIH1cbiAgICBkcmF3R3VpZGVzKGN0eCkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5yZWN0KHRoaXMueCwgdGhpcy55LCAxMDAsIDEwMCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguZm9udCA9IDIwICsgXCJweCBDb3VyaWVyIE5ld1wiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICBjdHguZmlsbFRleHQoXCJQdXQgdGV4dFwiLCAzOTAsIDEzMCk7XG4gICAgICAgIGN0eC5maWxsVGV4dChcImluIGhlcmVcIiwgMzkwLCAxNTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC54ID4gdGhpcy54ICYmIGVmZmVjdC54IDwgdGhpcy54ICsgMTAwICYmIGVmZmVjdC55ID4gdGhpcy55ICYmIGVmZmVjdC55IDwgdGhpcy55ICsgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3Nvbk9uZUNwVHdvID0gTGVzc29uT25lQ3BUd287XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25PbmVDcFR3by5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVGhyZWVDcEZpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsM2M1XCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDNjNic7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gU28gd2UgcHJpbnQgYSBtZXNzYWdlIHRvIHRoZSBDQU5WQVMgYW55dGltZSBjIGlzIGV4YWN0bHkgZXF1YWwgdG8gOC4gPC9wPlxuICAgIDxwPiBXaGF0IGlmIHdlIHdhbnQgdG8gcHJpbnQgYW5vdGhlciBtZXNzYWdlLCBcImMgaXMgbm90IGVxdWFsIHRvIDhcIiBhbnkgdGltZSBjIGlzIG5vdCBlcXVhbCB0byA4PyA8L3A+XG4gICAgPHA+IFdlIGRvIHNvIGJ5IHVzaW5nIGFuIGVsc2Ugc3RhdGVtZW50LiBPYnNlcnZlIHRoZSBDT0RFIGFib3ZlLiA8L3A+XG4gICAgPHA+IFdoZW4gdGhlIGNvbmRpdGlvbiBpbnNpZGUgdGhlIGlmKCkgc3RhdGVtZW50IGlzIHNhdGlzZmllZCwgdGhlIGNvZGUgYmxvY2sgaW5zaWRlIHRoZSB7fSByaWdodCBhZnRlciBpdCB3b3VsZCBydW4uIDwvcD5cbiAgICA8cD4gV2hlbiB0aGF0IGNvbmRpdGlvbiBpcyBub3Qgc2F0aXNmaWVkLCB0aGUgY29kZSBibG9jayBpbnNpZGUgdGhlIHt9IGFmdGVyIHRoZSBlbHNlIHN0YXRlbWVudCB3b3VsZCBydW4uIDwvcD5cbiAgICA8cD4gR09BTDogQ2hhbmdlIHRoZSB2YWx1ZSBvZiBjIHNvIHRoYXQgdGhlIGxpbmUgXCJjIGlzIE5PVCBlcXVhbCB0byA4LlwiIGlzIHByaW50ZWQgb24gdGhlIENBTlZBUy4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYGMgPSA4O1xuaWYoYyA9PSA4KSB7XG4gIHByaW50KFwiYyBpcyBlcXVhbCB0byA4LlwiLCAxMDMsIDE0Myk7XG59IGVsc2Uge1xuICBwcmludChcImMgaXMgTk9UIGVxdWFsIHRvIDguXCIsIDEwMywgMTQzKTtcbn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiBsZWFkaW5nIGludG8gY29uZGl0aW9uYWxzXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvY1xccyo9XFxzKlteOF1cXHMqLztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciA9PT0gXCJjIGlzIE5PVCBlcXVhbCB0byA4LlwiKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblRocmVlQ3BGaXZlID0gTGVzc29uVGhyZWVDcEZpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25UaHJlZUNwRml2ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVGhyZWVDcEZvdXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsM2M0XCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDNjNSc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gWW91IGNhbiBwdXQgYW4gaW5lcXVhbGl0eSBjb25kaXRpb24gaW4gdGhlIGlmKCkgY2xhdXNlLCBzdWNoIGFzIFwiYSA8IDVcIiBvciBcImIgPiAyMFwiLiA8L3A+XG4gICAgPHA+IFlvdSBjYW4gYWxzbyB1c2UgYW4gZXF1YWxpdHkgY29uZGl0aW9uLiBPYnNlcnZlIHRoZSBDT0RFIGFib3ZlIHdpdGggXCJjID09IDhcIi4gVGhlIDIgZXF1YWwgc2lnbnMgbWVhbiB0aGF0IHlvdSBhcmUgY2hlY2tpbmcgd2hldGhlciBjIGlzIGV4YWN0bHkgZXF1YWwgdG8gOCBvciBub3QuIDwvcD5cbiAgICA8cD4gQ2hhbmdlIHRoZSB2YWx1ZSBvZiBjIHNvIHRoYXQgdGhlIGxpbmUgXCJjIGlzIGVxdWFsIHRvIDguXCIgaXMgcHJpbnRlZCBvbiB0aGUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IEdPQUw6IENoYW5nZSB0aGUgdmFsdWUgb2YgYyBzbyB0aGF0IHRoZSBsaW5lIFwiYyBpcyBlcXVhbCB0byA4LlwiIGlzIHByaW50ZWQgb24gdGhlIENBTlZBUy4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYGMgPSAxMDA7XG5pZihjID09IDgpIHtcbiAgcHJpbnQoXCJjIGlzIGVxdWFsIHRvIDguXCIsIDEwMywgMTQzKTtcbn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiBsZWFkaW5nIGludG8gY29uZGl0aW9uYWxzXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvY1xccyo9XFxzKjhcXHMqLztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciA9PT0gXCJjIGlzIGVxdWFsIHRvIDguXCIpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVGhyZWVDcEZvdXIgPSBMZXNzb25UaHJlZUNwRm91cjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblRocmVlQ3BGb3VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3RyaW5nRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9TdHJpbmdFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25UaHJlZUNwT25lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDNjMVwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wzYzInO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFdlIGxlYXJuZWQgdG8gdGVsbCB0aGUgY29tcHV0ZXIgdG8gcHJpbnQgYSBsb3Qgb2YgdGhpbmdzLiBVbmZvcnR1bmF0ZWx5LCB0aGUgY29tcHV0ZXIgaXMga2luZGEgYmFkIGF0IG1hdGguIDwvcD5cbiAgICA8cD4gTG9vayBhdCB0aGUgQ09ERSBhYm92ZS4gV2UgbGV0IGEgPSA1LCB0aGVuIHdlIHByaW50IHRoZSB2YWx1ZSBvZiBhIHRvIHRoZSBDQU5WQVMuIFRoZW4gd2UgcHJpbnQgdGhlIGxpbmUgXCJhIGlzIGxlc3MgdGhhbiAxMFwiLiA8L3A+XG4gICAgPHA+IFNpbmNlIGEgPSA1LCBhbmQgNSA8IDEwLCB3ZSBrbm93IHRoYXQgYSBpcyBsZXNzIHRoYW4gMTAuIEJ1dCB3aGF0IHdvdWxkIGhhcHBlbiBpZiB3ZSBjaGFuZ2UgdGhlIHZhbHVlIG9mIGEgdG8sIHNheSwgMTI/IDwvcD5cbiAgICA8cD4gR09BTDogY2hhbmdlIHRoZSB2YWx1ZSBvZiBhIHRvIDEyLiA8L3A+XG4gICAgPHA+IEhJTlQ6IFlvdSBjYW4gZG8gdGhpcyBieSBjaGFuZ2luZyB0aGUgbGluZSBhID0gNSBpbiB0aGUgQ09ERSBhcmVhLCBvciB5b3UgY2FuIGNsaWNrIG9uIHRoZSBudW1iZXIgNSBvbiB0aGUgQ0FOVkFTLiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgYSA9IDU7XG5wcmludChhLCAxMTgsIDYzKTtcbnByaW50KFwiYSBpcyBsZXNzIHRoYW4gMTBcIiwgMTAzLCAxNDMpO2A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIGxlYWRpbmcgaW50byBjb25kaXRpb25hbHNcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRcIikudmFsdWU7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZWdleCA9IC9hXFxzKj1cXHMqMTJcXHMqLztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyID09PSBcImEgaXMgbGVzcyB0aGFuIDEwXCIpIHtcbiAgICAgICAgICAgICAgICAvL2NhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy9icmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblRocmVlQ3BPbmUgPSBMZXNzb25UaHJlZUNwT25lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVGhyZWVDcE9uZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25UaHJlZUNwU2l4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDNjNlwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2w0YzEnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IE5vdyB0aGF0IHlvdSBrbm93IGhvdyB0byB1c2UgaWYvZWxzZSBzdGF0ZW1lbnRzLCBsZXQncyBwdXQgdGhlbSBhbGwgdG9nZXRoZXIhIDwvcD5cbiAgICA8cD4gQWJvdmUgd2UgaGF2ZSB0aGUgQ09ERSB0byBkcmF3IDIgY2lyY2xlczogY2lyY2xlIEEgaGFzIGhlaWdodCBhbmQgd2lkdGggYSwgYW5kIGNpcmNsZSBCIGhhcyBoZWlnaHQgYW5kIHdpZHRoIGIuIDwvcD5cbiAgICA8cD4gSG93ZXZlciwgY3VycmVudGx5IHRoZSBjbGFpbSB0aGF0IFwiQ2lyY2xlIEEgaXMgc21hbGxlciB0aGFuIGNpcmNsZSBCLlwiIHJlZ2FyZGxlc3Mgb2YgdGhlIGNpcmNsZXMnIGFjdHVhbCBzaXplcy4gPC9wPlxuICAgIDxwPiBDcmVhdGUgYW4gaWYvZWxzZSBzdGF0ZW1lbnQgdG8gcHJpbnQgXCJDaXJjbGUgQSBpcyBzbWFsbGVyIHRoYW4gY2lyY2xlIEIuXCIgd2hlbiBpdCBpcyBhY3R1YWxseSBzbywgYW5kIHByaW50IFwiQ2lyY2xlIEEgaXMgYmlnZ2VyIHRoYW4gY2lyY2xlIEJcIiBvdGhlcndpc2UuIDwvcD5cbiAgICA8cD4gQ0hBTExFTkdFOiBDcmVhdGUgYW4gaWYvZWxzZSBzdGF0ZW1lbnQgdG8gcHJpbnQgdGhlIGNvcnJlY3QgY2xhaW0gYWJvdXQgdGhlIHNpemVzIG9mIHRoZSAyIGNpcmNsZXMuIDwvcD5gO1xuICAgICAgICB0aGlzLl9zdGFydGVyQ29kZSA9IGBhID0gMjAwO1xucHJpbnQoYSwgMTExLCAxMDMpO1xucHJpbnQoZWxsaXBzZShhLCBhKSwgMTMyLCAyODcpO1xuYiA9IDEwMDtcbnByaW50KGIsIDMzNywgMTA0KTtcbnByaW50KGVsbGlwc2UoYiwgYiksIDM3MSwgMjQ4KTtcbnByaW50KFwiQ2lyY2xlIEEgaXMgc21hbGxlciB0aGFuIGNpcmNsZSBCLlwiLCA0NSwgNDUzKTtcbmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIGxlYWRpbmcgaW50byBjb25kaXRpb25hbHNcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRcIikudmFsdWU7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZWdleCA9IC9wcmludFxccypcXChcXHMqZWxsaXBzZVxccypcXChcXHMqWzEtOV1bMC05XSpcXHMqLFxccypbMS05XVswLTldKlxccypcXClcXHMqLFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKTsvO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gY29kZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgbGV0IGNhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblRocmVlQ3BTaXggPSBMZXNzb25UaHJlZUNwU2l4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVGhyZWVDcFNpeC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVGhyZWVDcFRocmVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDNjM1wiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wzYzQnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IGlmIHN0YXRlbWVudHMgYWxsb3cgeW91IHRvIHJ1biBhIGJsb2NrIG9mIGNvZGUgaW5zaWRlIHRoZSBjdXJseSBicmFjZXMge30gT05MWSB3aGVuIHRoZSBjb25kaXRpb24gaW5zaWRlIHRoZSBpZigpIGNsYXVzZSBpcyB0cnVlLiA8L3A+XG4gICAgPHA+IExldCdzIGhhdmUgYSBxdWljayBjaGFsbGVuZ2U6IG9ic2VydmUgdGhlIENPREUgYWJvdmUuIE1ha2UgaXQgc28gdGhhdCB0aGUgbGluZSBcImIgaXMgZ3JlYXRlciB0aGFuIDIwXCIgaXMgb25seSBwcmludGVkIG9uIHRoZSBDQU5WQVMgd2hlbiBiIGlzIGFjdHVhbGx5IGdyZWF0ZXIgdGhhbiAyMC4gPC9wPlxuICAgIDxwPiBHT0FMOiBNYWtlIHRoZSBsaW5lIFwiYiBpcyBncmVhdGVyIHRoYW4gMjBcIiBvbmx5IGJlIHByaW50ZWQgb24gdGhlIENBTlZBUyB3aGVuIGIgaXMgYWN0dWFsbHkgZ3JlYXRlciB0aGFuIDIwLiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgYiA9IDg7XG5pZihiIDwgMTApIHtcbiAgcHJpbnQoXCJiIGlzIGdyZWF0ZXIgdGhhbiAyMC5cIiwgMTAzLCAxNDMpO1xufWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIGxlYWRpbmcgaW50byBjb25kaXRpb25hbHNcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRcIikudmFsdWU7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZWdleCA9IC9pZlxccypcXChcXHMqYlxccyo+XFxzKjIwXFxzKlxcKS87XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBjb2RlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSBtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICBsZXQgY2FudmFzSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0ICYmIGVmZmVjdC5zdHIgPT09IFwiYiBpcyBncmVhdGVyIHRoYW4gMjAuXCIpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVGhyZWVDcFRocmVlID0gTGVzc29uVGhyZWVDcFRocmVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVGhyZWVDcFRocmVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3RyaW5nRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9TdHJpbmdFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25UaHJlZUNwVHdvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDNjMlwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wzYzMnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IERpZCB5b3Ugbm90aWNlIHRoZSBjbGFpbSB0aGF0IFwiYSBpcyBsZXNzIHRoYW4gMTBcIiBkaWQgbm90IGNoYW5nZT8gYSBpcyBub3cgMTIgYW5kIGNsZWFybHkgZ3JlYXRlciB0aGFuIDEwISA8L3A+XG4gICAgPHA+IFdoYXQgd2Ugd2FudCBpcyBmb3IgdGhlIGNvbXB1dGVyIHRvIG9ubHkgcHJpbnQgXCJhIGlzIGxlc3MgdGhhbiAxMFwiIE9OTFkgd2hlbiB0aGUgdmFsdWUgb2YgYSBpcyB0cnVseSBsZXNzIHRoYW4gMTAuIDwvcD5cbiAgICA8cD4gVG8gZG8gc28sIHdlIHVzZSBhbiBpZiBzdGF0ZW1lbnQuIE9ic2VydmUgdGhlIENPREUgYWJvdmUuIEFsbCB3ZSBjaGFuZ2VkIHdhcyB0byBwdXQgaW4gYW4gaWYgc3RhdGVtZW50IHRoYXQgY2hlY2tzIHdoZXRoZXIgYSA8IDEwLiBJZiBhIGlzLCB0aGUgY29kZSBpbnNpZGUgdGhlIGN1cmx5IGJyYWNlcyB7fSBhcmUgZXhlY3V0ZWQuIDwvcD5cbiAgICA8cD4gQ2hhbmdlIHRoZSB2YWx1ZSBvZiBhIHRvIDEyLCAxMCwgOCBhbmQgb2JzZXJ2ZSB3aGF0IGhhcHBlbnMuIDwvcD5cbiAgICA8cD4gR09BTDogUlVOIHRoZSBDT0RFIHdpdGggYSA9IDEyIG9yIDEwIG9yIDguIDwvcD5gO1xuICAgICAgICB0aGlzLl9zdGFydGVyQ29kZSA9IGBhID0gMTI7XG5wcmludChhLCAxMTgsIDYzKTtcbmlmKGEgPCAxMCkge1xuICBwcmludChcImEgaXMgbGVzcyB0aGFuIDEwXCIsIDEwMywgMTQzKTtcbn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiBsZWFkaW5nIGludG8gY29uZGl0aW9uYWxzXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvYVxccyo9XFxzKjhcXHMqLztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciA9PT0gXCJhIGlzIGxlc3MgdGhhbiAxMFwiKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblRocmVlQ3BUd28gPSBMZXNzb25UaHJlZUNwVHdvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVGhyZWVDcFR3by5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25Ud29DcEZpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMmM1XCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDJjNic7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gRGlkIHlvdSBzZWUgdGhlIENBTlZBUyBjaGFuZ2VkPyA8L3A+XG4gICAgPHA+IEluIG91ciBjb2RlLCB3ZSBtYWtlIHZhcmlhYmxlIGEgcmVmZXIgdG8gdGhlIHdvcmRzIFwibW9vIG1vb1wiLCBhbmQgdmFyaWFibGUgYiByZWZlciB0byBhbiBlbGxpcHNlKDEwMCwgMTAwKS4gPC9wPlxuICAgIDxwPiBBcyBhIHJlc3VsdCwgd2hlbiB3ZSB0ZWxsIHRoZSBjb21wdXRlciB0byBwcmludCBhLCBpdCB3aWxsIHByaW50IFwibW9vIG1vb1wiLCBhbmQgd2hlbiB3ZSB0ZWxsIHRoZSBjb21wdXRlciB0byBwcmludCBiLCBpdCB3aWxsIHByaW50IGEgY2lyY2xlLiA8L3A+XG4gICAgPHA+IExldCdzIHRha2UgdGhpcyBvbmUgc3RlcCBmdXJ0aGVyOiBDcmVhdGUgYSBuZXcgdmFyaWFibGUgYywgYW5kIG1ha2UgaXQgcmVmZXIgdG8gYW4gZWxsaXBzZSgxMDAsIDEwMCkuIFRoZW4gd3JpdGUgMiBzdGF0ZW1lbnRzIHRvIHByaW50IGMuIFdoYXQgZG8geW91IHRoaW5rIHdvdWxkIGhhcHBlbj8gPC9wPlxuICAgIDxwPiBHT0FMOiBDcmVhdGUgYSB2YXJpYWJsZSBjIHJlZmVycmluZyB0byBhbiBlbGxpcHNlKDEwMCwgMTAwKSwgdGhlbiB3cml0ZSAyIHByaW50IHN0YXRlbWVudHMgdG8gcHJpbnQgYy4gPC9wPmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgYXNzaWdubWVudCA9IC9jXFxzKj1cXHMqZWxsaXBzZVxccypcXChcXHMqWzEtOV1bMC05XSpcXHMqLFxccypbMS05XVswLTldKlxccypcXClcXHMqOy9nO1xuICAgICAgICAgICAgbGV0IG1hdGNoQXNzaWduID0gY29kZS5tYXRjaChhc3NpZ25tZW50KTtcbiAgICAgICAgICAgIGxldCBwcmludCA9IC9wcmludFxccypcXChcXHMqY1xccyosXFxzKlsxLTldWzAtOV0qXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqXFwpOy9nO1xuICAgICAgICAgICAgbGV0IG1hdGNoUHJpbnQgPSBjb2RlLm1hdGNoKHByaW50KTtcbiAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSBtYXRjaEFzc2lnbiAhPSBudWxsICYmIG1hdGNoQXNzaWduLmxlbmd0aCA+IDAgJiYgbWF0Y2hQcmludCAhPSBudWxsICYmIG1hdGNoUHJpbnQubGVuZ3RoID49IDI7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICBsZXQgY2lyY2xlQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgY2lyY2xlQ291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjaXJjbGVDb3VudCA+PSAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Ud29DcEZpdmUgPSBMZXNzb25Ud29DcEZpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Ud29DcEZpdmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFbGxpcHNlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9FbGxpcHNlRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVHdvQ3BGb3VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDJjNFwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wyYzUnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFRoZXJlJ3Mgbm8gbGltaXQgdG8gaG93IG1hbnkgcHJpbnQgc3RhdGVtZW50cyB0aGUgY29tcHV0ZXIgY2FuIHVuZGVyc3RhbmQsIHNvIHlvdSBjYW4gd3JpdGUgMTAwMCBwcmludCBzdGF0ZW1lbnRzLCBhbmQgdGhlIGNvbXB1dGVyIHdpbGwgZHJhdyAxMDAwIHRoaW5ncyBvbiB0aGUgQ0FOVkFTIGZvciB5b3UhIDwvcD5cbiAgICA8cD4gVGltZSB0byB0YWtlIHlvdXIgY29kaW5nIHRvIHRoZSBuZXh0IGxldmVsLiBMZXQncyBsZWFybiBhYm91dCB2YXJpYWJsZXMuIDwvcD5cbiAgICA8cD4gVmFyaWFibGVzIGFyZSBzaW1wbHkgbmFtZXMgeW91IGdpdmUgdG8gdGhlIHRoaW5ncyB0aGF0IHlvdSBkcmF3LiA8L3A+XG4gICAgPHA+IEZvciBleGFtcGxlLCB0YWtlIGEgbG9vayBhdCB0aGUgY29kZSBhYm92ZS4gQ2hhbmdlIHRoZSBhIGluIHRoZSBwcmludCBzdGF0ZW1lbnQgdG8gYiwgYW5kIG9ic2VydmUgd2hhdCBoYXBwZW5lZCBvbiB0aGUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IEdPQUw6IENoYW5nZSBhIHRvIGIgaW4gdGhlIHByaW50IHN0YXRlbWVudC4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYGEgPSBcIm1vbyBtb29cIjtcXG5iID0gZWxsaXBzZSgxMDAsIDEwMCk7XFxucHJpbnQoYSwgNTAsIDcwKTtgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dFwiKS52YWx1ZTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gL3ByaW50XFxzKlxcKFxccypiXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqLFxccypbMS05XVswLTldKlxccypcXCk7LztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKCFjYW52YXNJc0NvcnJlY3QgJiYgZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVHdvQ3BGb3VyID0gTGVzc29uVHdvQ3BGb3VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVHdvQ3BGb3VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwT25lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDJjMVwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wyYzInO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFByaW50aW5nIG9ubHkgd29yZHMgaXMga2luZGEgYm9yaW5nLCBzbyBsZXQncyBsZWFybiB0byBwcmludCBzb21lIHNoYXBlcyBvbiB0aGUgQ0FOVkFTISA8L3A+XG4gICAgPHA+IEluIHRoZSBwcmludCBzdGF0ZW1lbnQsIHJlcGxhY2UgXCJtb29cIiB3aXRoIGVsbGlwc2UoMTAwLDEwMCkuIEhpdCB0aGUgUlVOIGJ1dHRvbiB0byBzZWUgd2hhdCBoYXBwZW5zLiA8L3A+XG4gICAgPHA+IEdPQUw6IHJlcGxhY2UgXCJtb29cIiB3aXRoIGVsbGlwc2UoMTAwLDEwMCkgaW4gdGhlIHByaW50IHN0YXRlbWVudCBhYm92ZS4gPC9wPlxuICAgIDxwPiBISU5UOiBIaWdobGlnaHQgXCJtb29cIiAtIGluY2x1ZGluZyB0aGUgZG91YmxlIHF1b3RlcyBcIiwgYW5kIHJlcGxhY2UgdGhhdCB3aXRoIGVsbGlwc2UoMTAwLCAxMDApLiBLRUVQIEVWRVJZVEhJTkcgRUxTRSBUSEUgU0FNRS4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYFxuICAgIHByaW50KFwibW9vXCIsIDUwLCA3MClgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dFwiKS52YWx1ZTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gL3ByaW50XFxzKlxcKFxccyplbGxpcHNlXFxzKlxcKFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKVxccyosXFxzKlsxLTldWzAtOV0qXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqXFwpOy87XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBjb2RlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSBtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICBsZXQgY2FudmFzSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVHdvQ3BPbmUgPSBMZXNzb25Ud29DcE9uZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblR3b0NwT25lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgTGVzc29uVHdvQ3BTZXZlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwyYzdcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsM2MxJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBDaGFuZ2luZyBvbmUgY2lyY2xlIGNoYW5nZXMgYywgd2hpY2ggd2lsbCB0aGVuIGluIHR1cm4gY2hhbmdlIHRoZSBvdGhlciBjaXJjbGUhIDwvcD5cbiAgICA8cD4gTm93IGxldCdzIHB1dCBhbGwgd2UgaGF2ZSBsZWFybmVkIHRvIHByYWN0aWNlLiA8L3A+XG4gICAgPHA+IENyZWF0ZSBhIGNpcmNsZSwgYW5kIHByaW50IG91dCB0aGUgc2l6ZSBvZiB0aGF0IGNpcmNsZSBpbiB0aGUgZ2l2ZW4gYm94LiA8L3A+XG4gICAgPHA+IElGIHdlIGV2ZXIgY2hhbmdlIHRoZSBjaXJjbGUsIHdlIHdhbnQgdGhlIG51bWJlciBpbiB0aGUgYm94IHRvIGNoYW5nZSwgdG9vISA8L3A+XG4gICAgPHA+IENIQUxMRU5HRTogQ3JlYXRlIGEgY2lyY2xlIGFuZCBwcmludCBpdHMgc2l6ZSBpbiB0aGUgZ2l2ZW4gYm94LiA8L3A+YDtcbiAgICAgICAgdGhpcy54ID0gMTA7XG4gICAgICAgIHRoaXMueSA9IDQzMDtcbiAgICB9XG4gICAgZHJhd0d1aWRlcyhjdHgpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucmVjdCh0aGlzLngsIHRoaXMueSwgMTAwLCAxMDApO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmZvbnQgPSAyMCArIFwicHggQ291cmllciBOZXdcIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgY3R4LmZpbGxUZXh0KFwiUHV0IGNpcmNsZSdzIHNpemVcIiwgdGhpcy54LCAzOTApO1xuICAgICAgICBjdHguZmlsbFRleHQoXCJpbiBoZXJlXCIsIHRoaXMueCwgNDEwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVHdvQ3BTZXZlbiA9IExlc3NvblR3b0NwU2V2ZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Ud29DcFNldmVuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwU2l4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDJjNlwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wyYzcnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ2NvZGUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IE5vdyB0aGF0IHlvdSBoYXZlIGRyYXduIDIgY2lyY2xlcyBib3RoIGFyZSBjYWxsZWQgYywgbGV0J3Mgc2VlIHdoYXQgaGFwcGVucyB3aGVuIHlvdSB0cnkgdG8gbW9kaWZ5IG9uZSBvZiB0aGVtLiA8L3A+XG4gICAgPHA+IENsaWNrIG9uIG9uZSBvZiB0aGUgY2lyY2xlcyBvbiB0aGUgQ0FOVkFTLCBhbmQgdHJ5IG1ha2UgaXQgYmlnZ2VyLiBPYnNlcnZlIHdoYXQgaGFwcGVucyB0byB5b3VyIGRlY2xhcmF0aW9uIG9mIGMuIDwvcD5cbiAgICA8cD4gR09BTDogRW5sYXJnZSBvbmUgb2YgdGhlIGNpcmNsZXMgcmVmZXJyZWQgdG8gYnkgYyBvbiB0aGUgQ0FOVkFTLiA8L3A+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LncgPiAyNTAgJiYgZWZmZWN0LmggPiAyNTApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVHdvQ3BTaXggPSBMZXNzb25Ud29DcFNpeDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblR3b0NwU2l4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVHdvQ3BUaHJlZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwyYzNcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsMmM0JztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBTbyB3ZSBjYW4gZHJhdyBhIGNpcmNsZSBhbmQgY2hhbmdlIGl0LiBCdXQgd2hhdCBpZiB3ZSB3YW50IHRvIGRyYXcgYm90aCBjaXJjbGVzIGFuZCB3b3Jkcz8gPC9wPlxuICAgIDxwPiBXZWxsLCBzaW1wbGUhIEp1c3Qgd3JpdGUgbW9yZSBwcmludCBzdGF0ZW1lbnRzIGluIHRoZSBDT0RFIGFyZWEhIDwvcD5cbiAgICA8cD4gR09BTDogRHJhdyAyIGNpcmNsZXMgYW5kIGEgd29yZCBvbiB0aGUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IEhJTlQ6IFJlbWVtYmVyIHRoYXQgdGhlIG51bWJlcnMgcmlnaHQgaW5zaWRlIHRoZSBlbGxpcHNlKF8sXykgc3RhdGVtZW50IGNoYW5nZSB0aGUgY2lyY2xlJ3Mgc2l6ZXMuYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIGxldCBzdHJpbmdFeGlzdHMgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNpcmNsZUNvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmICghc3RyaW5nRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nRXhpc3RzID0gZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0ICYmIGVmZmVjdC5zdHIgIT09IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBjaXJjbGVDb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdFeGlzdHMgJiYgY2lyY2xlQ291bnQgPj0gMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVHdvQ3BUaHJlZSA9IExlc3NvblR3b0NwVGhyZWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Ud29DcFRocmVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwVHdvIHtcbiAgICAvKlxuICAgIGA8cD4gU28gd2UgY2FuIGRyYXcgYSBjaXJjbGUgYW5kIGNoYW5nZSBpdC4gQnV0IHdoYXQgaWYgd2Ugd2FudCB0byBkcmF3IGJvdGggYSBjaXJjbGUgYW5kIGEgd29yZD8gPC9wPlxuICAgIDxwPiBXZWxsLCBzaW1wbGUhIEp1c3Qgd3JpdGUgYW5vdGhlciBwcmludCBzdGF0ZW1lbnQgaW4gdGhlIENPREUgYXJlYSEgPC9wPlxuICAgIDxwPiBHT0FMOiBEcmF3IDIgY2lyY2xlcyBhbmQgYSB3b3JkIG9uIHRoZSBDQU5WQVMuIDwvcD5cbiAgICA8cD4gSElOVDogUmVtZW1iZXIgdGhhdCB0aGUgbnVtYmVycyByaWdodCBpbnNpZGUgdGhlIGVsbGlwc2UoXyxfKSBzdGF0ZW1lbnQgY2hhbmdlIHRoZSBjaXJjbGUncyBzaXplcy5gO1xuKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDJjMlwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wyYzMnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ2NvZGUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFdlIGNhbiB3cml0ZSBlbGxpcHNlKDEwMCwgMTAwKSBpbiB0aGUgcHJpbnQgc3RhdGVtZW50IHRvIGRyYXcgYSBjaXJjbGUgb24gdGhlIENBTlZBUy4gPC9wPlxuICAgIDxwPiBXaGF0IGFyZSB0aGUgbnVtYmVycyAoMTAwLCAxMDApIGZvcj8gSSdtIGdsYWQgeW91IGFza2VkLi4uIDwvcD5cbiAgICA8cD4gQmVjYXVzZSB0aGUgQ09ERSBhcmVhIGlzIGZyb3plbiBhZ2FpbiEgRHJhZyBvbmUgb2YgdGhlIDkgd2hpdGUgdGlwcyBhcm91bmQgdGhlIGNpcmNsZSBvbiB0aGUgQ0FOVkFTIHRvIHNlZSBob3cgdGhlIG51bWJlciBjaGFuZ2VzISA8L3A+XG4gICAgPHA+IEdPQUw6IE1ha2UgdGhlIGNpcmNsZSB3aWRlciBidXQgc2hvcnRlci4gPC9wPmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudCBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LncgPiAyMDAgJiYgZWZmZWN0LmggPCA4MCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Ud29DcFR3byA9IExlc3NvblR3b0NwVHdvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVHdvQ3BUd28uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwYW50c18xID0gcmVxdWlyZShcInBhbnRzXCIpO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi8uLi9pbmRleFwiKTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xudmFyIFBhcnNlcjtcbihmdW5jdGlvbiAoUGFyc2VyKSB7XG4gICAgLyoqXG4gICAgICogdG8gYmUgbW92ZWQgdG8gUGFudHNcbiAgICAgKiBudW1iZXIgcGFyc2VzIG51bWJlcnMgYnkgcmVwZWF0ZWRseSBhcHBseWluZyB0aGUgZGlnaXQgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG8gPSBwYW50c18xLlByaW1pdGl2ZXMubWFueTEocGFudHNfMS5QcmltaXRpdmVzLmRpZ2l0KCkpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIGxldCBzID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZGlnaXQgb2Ygby5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gZGlnaXQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHBhbnRzXzEuUHJpbWl0aXZlcy5TdWNjZXNzKG8uaW5wdXRzdHJlYW0sIHBhcnNlRmxvYXQocykpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQYXJzZXIubnVtYmVyID0gbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIHRvIGJlIG1vdmVkIHRvIFBhbnRzXG4gICAgICogc3RyaW5nIGlzIGFuIGFyYml0cmFyeSBzdHJpbmcgcGFyc2VyIHRoYXQgcmVwZWF0ZWRseSBhcHBsaWVzIHRoZSBsZXR0ZXIgcHJpbWl0aXZlXG4gICAgICogcmV0dXJucyBhIENoYXJTdHJlYW0gcmVwcmVzZW50aW5nIHRoZSBlbnRpcmUgcGFyc2VkIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmluZygpIHtcbiAgICAgICAgbGV0IHAgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55MShwYW50c18xLlByaW1pdGl2ZXMubGV0dGVyKCkpKTtcbiAgICAgICAgbGV0IGYgPSAoeHMpID0+IHBhbnRzXzEuQ2hhclV0aWwuQ2hhclN0cmVhbS5jb25jYXQoeHMpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwKShmKTtcbiAgICB9XG4gICAgUGFyc2VyLnN0cmluZyA9IHN0cmluZztcbiAgICAvKipcbiAgICAgKiB0byBiZSBtb3ZlZCB0byBQYW50c1xuICAgICAqIHB1bmN0dWF0aW9uIHBhcnNlcyBhbGwgcG9zc2libGUgcHVuY3R1YXRpb24gY2hhcmFjdGVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bmN0dWF0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNhdCh4ID0+IHggPT0gXCIhXCJcbiAgICAgICAgICAgIHx8IHggPT0gXCIuXCJcbiAgICAgICAgICAgIHx8IHggPT0gJywnXG4gICAgICAgICAgICB8fCB4ID09IFwiO1wiXG4gICAgICAgICAgICB8fCB4ID09ICc/J1xuICAgICAgICAgICAgfHwgeCA9PSBcIi1cIlxuICAgICAgICAgICAgfHwgeCA9PSBcIiZcIlxuICAgICAgICAgICAgfHwgeCA9PSAnJCdcbiAgICAgICAgICAgIHx8IHggPT0gJzonXG4gICAgICAgICAgICB8fCB4ID09ICcvJ1xuICAgICAgICAgICAgfHwgeCA9PSAnfCdcbiAgICAgICAgICAgIHx8IHggPT0gJyUnXG4gICAgICAgICAgICB8fCB4ID09ICcjJ1xuICAgICAgICAgICAgfHwgeCA9PSBcIkBcIlxuICAgICAgICAgICAgfHwgeCA9PSBcIn5cIlxuICAgICAgICAgICAgfHwgeCA9PSAnYCdcbiAgICAgICAgICAgIHx8IHggPT0gJyonXG4gICAgICAgICAgICB8fCB4ID09ICdeJ1xuICAgICAgICAgICAgfHwgeCA9PSAneydcbiAgICAgICAgICAgIHx8IHggPT0gJ30nXG4gICAgICAgICAgICB8fCB4ID09IFwiW1wiXG4gICAgICAgICAgICB8fCB4ID09ICddJ1xuICAgICAgICAgICAgfHwgeCA9PSAnKCdcbiAgICAgICAgICAgIHx8IHggPT0gXCIpXCJcbiAgICAgICAgICAgIHx8IHggPT0gXCInXCJcbiAgICAgICAgICAgIHx8IHggPT0gXCJfXCIpO1xuICAgIH1cbiAgICBQYXJzZXIucHVuY3R1YXRpb24gPSBwdW5jdHVhdGlvbjtcbiAgICBsZXQgaWQgPSAoeCkgPT4geDtcbiAgICAvKipcbiAgICAgKiBwYXJzZSBpcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgdGhlIGlucHV0IHRleHQgaW4gYSBDaGFyU3RyZWFtXG4gICAgICogYW5kIHBhc3NlcyBpdCB0byB0aGUgdXBwZXItbGV2ZWwgcGFyc2UgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gcHJvZ3JhbSBhIHN0cmluZyByZXByZXNlbnRpbmcgcHJvZ3JhbSB0ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2UocHJvZ3JhbSkge1xuICAgICAgICBwcm9ncmFtICs9IFwiXFxuXCI7XG4gICAgICAgIGxldCBvID0gUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIobmV3IHBhbnRzXzEuQ2hhclV0aWwuQ2hhclN0cmVhbShwcm9ncmFtKSk7XG4gICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYWNlX2xpZnRfMS5Tb21lKG8ucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYWNlX2xpZnRfMS5Ob25lO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBhcnNlci5wYXJzZSA9IHBhcnNlO1xuICAgIC8qKlxuICAgICAqIEV4cHJlc3Npb24gcGFyc2VyIGZpcnN0IHNlYXJjaGVzIGZvciB0aGUgZmlyc3QgZXhwcmVzc2lvbiBvZiBhIHNlcXVlbmNlIGFuZCBlaXRoZXJcbiAgICAgKiBhbm90aGVyIGV4cHJlc3Npb24gb3IgdGhlIGVuZCBvZiB0aGUgcHJvZ3JhbSAoTk9QKSBhbmQgcmV0dXJucyBhIHNlcXVlbmNlIG5vZGVcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIGJ1ZyBvZiBlYWdlciBwYXJzaW5nXG4gICAgICovXG4gICAgUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIgPSBpID0+IHtcbiAgICAgICAgbGV0IGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuU2VxdWVuY2VOb2RlKHR1cFswXSwgdHVwWzFdKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHAgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9TZXEpKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCc7JykpKHBhbnRzXzEuUHJpbWl0aXZlcy5ubCgpKSkocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyKSkocGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoXyA9PiBuZXcgaW5kZXhfMS5OT1AoKSkpKSkoZik7XG4gICAgICAgIHJldHVybiBwKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhyb3VnaCBhbGwgcG9zc2libGUgZXhwcmVzc2lvbnMgZXhjZXB0IGZvciBzZXF1ZW5jZXNcbiAgICAgKiB1c2VkIHRvIGF2b2lkIGluZmluaXRlIGxvb3BpbmcgaW4gdXBwZXIgbGV2ZWwgcGFyc2VcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIGJ1ZyBvZiBlYWdlciBwYXJzaW5nXG4gICAgICovXG4gICAgUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSA9IGkgPT4ge1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKGxOdW1iZXIoKSkobHN0cmluZzIoKSk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UodmFyTmFtZVBhcnNlKCkpKHAxKTtcbiAgICAgICAgbGV0IHAzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShCb29sUGFyc2UoKSkocDIpO1xuICAgICAgICBsZXQgcDQgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHZhckRlY1BhcnNlKCkpKHAzKTtcbiAgICAgICAgbGV0IHA1ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIudW5PcHNFeHByKShwNCk7XG4gICAgICAgIGxldCBwNiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoRGVjbGFyZSgpKShwNSk7XG4gICAgICAgIGxldCBwNyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmJpbk9wRXhwcikocDYpO1xuICAgICAgICBsZXQgcDggPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKExvZ2ljRXhwcigpKShwNyk7XG4gICAgICAgIGxldCBwOSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLkxpc3RIZWFkKShwOCk7XG4gICAgICAgIGxldCBwMTAgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5mdW5BcHApKHA5KTtcbiAgICAgICAgbGV0IHAxMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLnJldHVyblBhcnNlcikocDEwKTtcbiAgICAgICAgbGV0IHAxMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmNvbmRQYXJzZSkocDExKTtcbiAgICAgICAgbGV0IHAxMyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLldoaWxlTG9vcCkocDEyKTtcbiAgICAgICAgbGV0IHAxNCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLkZvckxvb3ApKHAxMyk7XG4gICAgICAgIGxldCBwMTUgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5mdW5EZWYpKHAxNCk7XG4gICAgICAgIHJldHVybiBwMTUoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aHJvdWdoIGFsbCBwb3NzaWJsZSBleHByZXNzaW9ucyBleGNlcHQgZm9yIGJpbk9wIGV4cHJlc3Npb25zXG4gICAgICogdXNlZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIGluIHRoZSBiaW5hcnkgZXhwcmVzc2lvbiBwYXJzZXJcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIGJ1ZyBvZiBlYWdlciBwYXJzaW5nXG4gICAgICovXG4gICAgUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb0Jpbk9wID0gaSA9PiB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UobE51bWJlcigpKShsc3RyaW5nMigpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZSh2YXJOYW1lUGFyc2UoKSkocDEpO1xuICAgICAgICBsZXQgcDMgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKEJvb2xQYXJzZSgpKShwMik7XG4gICAgICAgIGxldCBwNCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UodmFyRGVjUGFyc2UoKSkocDMpO1xuICAgICAgICBsZXQgcDUgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci51bk9wc0V4cHIpKHA0KTtcbiAgICAgICAgbGV0IHA2ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShEZWNsYXJlKCkpKHA1KTtcbiAgICAgICAgbGV0IHA3ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuTGlzdEhlYWQpKHA2KTtcbiAgICAgICAgbGV0IHA4ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuZnVuQXBwKShwNyk7XG4gICAgICAgIGxldCBwOSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLnJldHVyblBhcnNlcikocDgpO1xuICAgICAgICBsZXQgcDEwID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuY29uZFBhcnNlKShwOSk7XG4gICAgICAgIGxldCBwMTEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5XaGlsZUxvb3ApKHAxMCk7XG4gICAgICAgIGxldCBwMTIgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5Gb3JMb29wKShwMTEpO1xuICAgICAgICBsZXQgcDEzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuZnVuRGVmKShwMTIpO1xuICAgICAgICByZXR1cm4gcDEzKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhyb3VnaCBhbGwgcG9zc2libGUgZXhwcmVzc2lvbnMgZXhjZXB0IGZvciBsb2dpY2FsIGV4cHJlc3Npb25zXG4gICAgICogdXNlZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIGluIHRoZSBsb2dpY2FsIGV4cHJlc3Npb24gcGFyc2VyXG4gICAgICogQHBhcmFtIGkgYSBub25zZW5zZSBwYXJhbWV0ZXIgdXNlZCB0byBhdm9pZCBidWcgb2YgZWFnZXIgcGFyc2luZ1xuICAgICAqL1xuICAgIFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9Mb2dpYyA9IGkgPT4ge1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKGxOdW1iZXIoKSkobHN0cmluZzIoKSk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UodmFyTmFtZVBhcnNlKCkpKHAxKTtcbiAgICAgICAgbGV0IHAzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShCb29sUGFyc2UoKSkocDIpO1xuICAgICAgICBsZXQgcDQgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHZhckRlY1BhcnNlKCkpKHAzKTtcbiAgICAgICAgbGV0IHA1ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIudW5PcHNFeHByKShwNCk7XG4gICAgICAgIGxldCBwNiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoRGVjbGFyZSgpKShwNSk7XG4gICAgICAgIGxldCBwNyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmJpbk9wRXhwcikocDYpO1xuICAgICAgICBsZXQgcDggPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5MaXN0SGVhZCkocDcpO1xuICAgICAgICBsZXQgcDkgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5mdW5BcHApKHA4KTtcbiAgICAgICAgbGV0IHAxMCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLnJldHVyblBhcnNlcikocDkpO1xuICAgICAgICBsZXQgcDExID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuY29uZFBhcnNlKShwMTApO1xuICAgICAgICBsZXQgcDEyID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuV2hpbGVMb29wKShwMTEpO1xuICAgICAgICBsZXQgcDEzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuRm9yTG9vcCkocDEyKTtcbiAgICAgICAgbGV0IHAxNCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmZ1bkRlZikocDEzKTtcbiAgICAgICAgcmV0dXJuIHAxNChpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGxOdW1iZXIgaXMgdXNlZCB0byB3cmFwIHBhcnNlZCBudW1iZXJzIGluIE51bWJlck5vZGVzIGZvciB0aGUgQVNUXG4gICAgICovXG4gICAgZnVuY3Rpb24gbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgbyA9IG51bWJlcigpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGFudHNfMS5QcmltaXRpdmVzLlN1Y2Nlc3Moby5pbnB1dHN0cmVhbSwgbmV3IGluZGV4XzEuTnVtYmVyTm9kZShvLnJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQYXJzZXIubE51bWJlciA9IGxOdW1iZXI7XG4gICAgLyoqXG4gICAgICogYmluT3BzQ2hhciBwYXJzZXMgYWxsIHBvc3NpYmxlIGJpbmFyeSBvcGVyYXRvcnMsIHN1Y2ggYXMgKyBvciAtXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluT3BzQ2hhcigpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuc2F0KHggPT4geCA9PSBcIitcIlxuICAgICAgICAgICAgICAgIHx8IHggPT0gXCItXCJcbiAgICAgICAgICAgICAgICB8fCB4ID09IFwiL1wiXG4gICAgICAgICAgICAgICAgfHwgeCA9PSBcIj1cIlxuICAgICAgICAgICAgICAgIHx8IHggPT0gXCIqXCIpKShpc3RyZWFtKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUGFyc2VyLmJpbk9wc0NoYXIgPSBiaW5PcHNDaGFyO1xuICAgIC8qKlxuICAgICAqIGJpbk9wc1Nob3J0IHJldHVybnMgYSB0dXBsZSB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgYmluYXJ5IG9wZXJhdG9yIChDaGFyU3RyZWFtKVxuICAgICAqIGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgdGhlIGV4cHJlc3Npb24gdG8gdGhlIHJpZ2h0IG9mIHRoZSBvcGVyYXRvciAoRXhwcmVzc2lvbjx7fT4pXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluT3BTaG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEoYmluT3BzQ2hhcigpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKSgoeCkgPT4geCk7XG4gICAgfVxuICAgIFBhcnNlci5iaW5PcFNob3J0ID0gYmluT3BTaG9ydDtcbiAgICAvKipcbiAgICAgKiBiaW5PcEV4cHIgcGFyc2VzIGFsbCBwb3NzaWJsZSBiaW5hcnkgb3BlcmF0aW9uIGV4cHJlc3Npb25zIGFuZCByZXR1cm5zIHRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgQVNUIG5vZGUgY29uc3RydWN0IChhbHNvIHBhcnNlcyBwb3N0Zml4IGluY3JlbWVudHMvZGVjcmVtZW50cyBsaWtlIGkrKylcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIHRoZSBidWcgd2l0aCBlYWdlciBldmFsdWF0aW9uXG4gICAgICovXG4gICAgUGFyc2VyLmJpbk9wRXhwciA9IGkgPT4ge1xuICAgICAgICB2YXIgZiA9ICh0dXApID0+IHtcbiAgICAgICAgICAgIGxldCBsaHMgPSB0dXBbMF07XG4gICAgICAgICAgICBsZXQgb3AgPSB0dXBbMV1bMF07XG4gICAgICAgICAgICBsZXQgcmhzID0gdHVwWzFdWzFdO1xuICAgICAgICAgICAgc3dpdGNoIChvcC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLlBsdXNPcChsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5NaW51c09wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkRpdk9wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLk11bE9wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkFzc2lnbk9wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmluYXJ5IE9wZXJhdGlvbiBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9CaW5PcCkodmFyRGVjUGFyc2UoKSk7XG4gICAgICAgIGxldCBwMiA9IGJpbk9wU2hvcnQoKTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwb3N0UGx1cyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vQmluT3ApKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCcrKycpKSh0dXAgPT4geyByZXR1cm4gbmV3IGluZGV4XzEuSW5jcmVtZW50KHR1cFswXSwgd3MpOyB9KTtcbiAgICAgICAgbGV0IHBvc3RNaW51cyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vQmluT3ApKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCctLScpKSh0dXAgPT4geyByZXR1cm4gbmV3IGluZGV4XzEuRGVjcmVtZW50KHR1cFswXSwgd3MpOyB9KTtcbiAgICAgICAgbGV0IGJpbk9wID0gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHAxKSkocDIpKGYpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShiaW5PcCkocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwb3N0UGx1cykocG9zdE1pbnVzKSkoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB1bk9wc0NoYXIgcGFyc2VzIGFsbCBwb3NzaWJsZSB1bmFyeSBvcGVyYXRvcnNcbiAgICAgKiBPbmx5IG5lZ2F0aW9ucyBhcmUgc3VwcG9ydGVkLCBidXQgbW9yZSBjYW4gYmUgYWRkZWQgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIGkgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIudW5PcHNDaGFyID0gaSA9PiB7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKFwiLVwiKSkoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB1bk9wc0V4cHIgd3JhcHMgYSB1bmFyeSBvcGVyYXRpb24gZXhwcmVzc2lvbiBpbiB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIEFTVCBub2RlIGFuZCByZXR1cm5zIGl0XG4gICAgICogQHBhcmFtIGkgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIudW5PcHNFeHByID0gaSA9PiB7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLk5lZ09wKHR1cFsxXSwgd3MpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgd3MgPSBcIlwiO1xuICAgICAgICBsZXQgcHJlY2VkaW5nV1MgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKSh4ID0+IHdzID0geC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShQYXJzZXIudW5PcHNDaGFyKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSkoZikoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBsc3RyaW5nIHBhcnNlcyB2YWxpZCBzdHJpbmdzIGluIHRoZSBTV0VMTCBsYW5ndWFnZVxuICAgICAqIGEgdmFsaWQgc3RyaW5nIGlzIHN1cnJvdW5kZWQgYnkgcXVvdGF0aW9ucyBhbmQgY29uc2lzdHMgb2YgbGV0dGVycywgbnVtYmVycywgcHVuY3R1YXRpb24sIGFuZC9vciB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbHN0cmluZygpIHtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHBhbnRzXzEuUHJpbWl0aXZlcy5sZXR0ZXIoKSkocGFudHNfMS5QcmltaXRpdmVzLndzMSgpKSkocGFudHNfMS5QcmltaXRpdmVzLmRpZ2l0KCkpO1xuICAgICAgICAvL2xldCBwMSA9IFByaW1pdGl2ZXMuY2hvaWNlKFByaW1pdGl2ZXMubGV0dGVyKCkpKFByaW1pdGl2ZXMud3MxKCkpO1xuICAgICAgICBsZXQgcCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoXCJcXFwiXCIpKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKFwiXFxcIlwiKSkocGFudHNfMS5QcmltaXRpdmVzLm1hbnkocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMSkocHVuY3R1YXRpb24oKSkpKTtcbiAgICAgICAgbGV0IGYgPSAoeHMpID0+IHBhbnRzXzEuQ2hhclV0aWwuQ2hhclN0cmVhbS5jb25jYXQoeHMpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwKShmKTtcbiAgICB9XG4gICAgUGFyc2VyLmxzdHJpbmcgPSBsc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIGxzdHJpbmcyIHdyYXBzIHN0cmluZ3MgcGFyc2VkIGJ5IGxzdHJpbmcgaW4gU3RyaW5Ob2RlIG9iamVjdHMgYW5kIHJldHVybnMgdGhlbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxzdHJpbmcyKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgICAgICBsZXQgcHJlY2VkaW5nV1MgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKSh4ID0+IHdzID0geC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGxldCBvID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShsc3RyaW5nKCkpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGFudHNfMS5QcmltaXRpdmVzLlN1Y2Nlc3Moby5pbnB1dHN0cmVhbSwgbmV3IGluZGV4XzEuU3RyaW5nTm9kZShvLnJlc3VsdC50b1N0cmluZygpLCB3cykpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQYXJzZXIubHN0cmluZzIgPSBsc3RyaW5nMjtcbiAgICAvKipcbiAgICAgKiB2YXJOYW1lUGFyc2UgcGFyc2VzIHZhbGlkIHZhcmlhYmxlIG5hbWVzXG4gICAgICogdmFyaWFibGUgbmFtZXMgaW4gU1dFTEwgYmVnaW4gd2l0aCBhIGxvd2VyY2FzZSBjaGFyIGFuZCBhcmUgZm9sbG93ZWRcbiAgICAgKiBieSBsZXR0ZXJzIG9yIGRpZ2l0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhck5hbWVQYXJzZSgpIHtcbiAgICAgICAgdmFyIGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuVmFyaWFibGVOb2RlKHR1cFswXS50b1N0cmluZygpICsgcGFudHNfMS5DaGFyVXRpbC5DaGFyU3RyZWFtLmNvbmNhdCh0dXBbMV0pLnRvU3RyaW5nKCksIHdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBmaXJzdENoYXIgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5sb3dlcigpKTtcbiAgICAgICAgbGV0IG5leHRDaGFycyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55KHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UocGFudHNfMS5QcmltaXRpdmVzLmRpZ2l0KCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5sZXR0ZXIoKSkpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShmaXJzdENoYXIpKG5leHRDaGFycykoZik7XG4gICAgfVxuICAgIFBhcnNlci52YXJOYW1lUGFyc2UgPSB2YXJOYW1lUGFyc2U7XG4gICAgLyoqXG4gICAgICogdmFyRGVjUGFyc2UgcGFyc2VzIHZhbGlkIHZhcmlhYmxlIGRlY2xhcmF0aW9ucyBpbiB0aGUgZm9ybSBcInZhciB4XCJcbiAgICAgKiB0aGUgcGFyc2VyIHRoZW4gd3JhcHMgdGhlIHBhcnNlZCB2YWx1ZSBpbiBhIHZhcmlhYmxlIG5vZGUgZm9yIHRoZSBBU1RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YXJEZWNQYXJzZSgpIHtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cihcInZhclwiKSk7XG4gICAgICAgIGxldCB2YXJOYW1lID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzMSgpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkodmFyTmFtZVBhcnNlKCkpO1xuICAgICAgICBsZXQgcCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocDEpKHZhck5hbWUpKHR1cCA9PiB0dXBbMV0pO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgUGFyc2VyLnZhckRlY1BhcnNlID0gdmFyRGVjUGFyc2U7XG4gICAgLyoqXG4gICAgICogRGVjbGFyZSBwYXJzZXMgdmFyaWFibGUgZGVjbGFyYXRpb25zIGluIHRoZSBmb3JtIFwidmFyIHggPSAyXCJcbiAgICAgKiBhbmQgcmV0dXJucyBhIERlY2xhcmVPcCBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjbGFyZSgpIHtcbiAgICAgICAgbGV0IGVxID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignPScpKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmxlZnQodmFyRGVjUGFyc2UoKSkoZXEpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwMSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSkodHVwID0+IHsgcmV0dXJuIG5ldyBpbmRleF8xLkRlY2xhcmVPcCh0dXBbMF0sIHR1cFsxXSk7IH0pO1xuICAgIH1cbiAgICBQYXJzZXIuRGVjbGFyZSA9IERlY2xhcmU7XG4gICAgLyoqXG4gICAgICogTGlzdEhlYWQgcGFyc2VzIGFsbCBsaXN0cyBpbiB0aGUgU1dFTEwgbGFuZ3VhZ2UsIGluY2x1ZGluZyBlbXB0eSBsaXN0c1xuICAgICAqIExpc3RzIGFyZSBzdXJyb3VuZGVkIGJ5IHNxdWFyZSBicmFja2V0cyBhbmQgZWFjaCBlbGVtZW50IGlzIHNlcGFyYXRlZCBieSBhIGNvbW1hXG4gICAgICogcmV0dXJucyBhIGxpc3ROb2RlIG9iamVjdFxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIuTGlzdEhlYWQgPSBpID0+IHtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwMCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCdbJykpKShwMCk7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgbGV0IGhkID0gdHVwWzBdO1xuICAgICAgICAgICAgbGV0IHJlcyA9IFtoZF07XG4gICAgICAgICAgICBsZXQgdGFpbCA9IHR1cFsxXTtcbiAgICAgICAgICAgIGZvciAobGV0IGVsZW0gb2YgdGFpbCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkxpc3ROb2RlKHJlcywgd3MpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHAxKShMaXN0VGFpbCgpKShmKTtcbiAgICAgICAgbGV0IHAzID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ1tdJykpKShfID0+IG5ldyBpbmRleF8xLkxpc3ROb2RlKFtdLCB3cykpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMykocDIpKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTGlzdCBUYWlsIHBhcnNlcyBzZWNvbmQgdGhyb3VnaCBsYXN0IGVsZW1lbnRzIG9mIGEgbGlzdCwgZWFjaCBzZXBhcmF0ZWQgYnkgYSBjb21tYVxuICAgICAqIHJldHVybnMgYW4gYXJyYXkgb2YgRXhwcmVzc2lvbnMgdGhhdCB3aWxsIGJlIGFjY2Vzc2VkIGJ5IExpc3RIZWFkXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGlzdFRhaWwoKSB7XG4gICAgICAgIGxldCBwMCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMuY2hhcignLCcpKShwMCk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5sZWZ0KHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55KHAxKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ10nKSk7XG4gICAgICAgIHJldHVybiBwMjtcbiAgICB9XG4gICAgUGFyc2VyLkxpc3RUYWlsID0gTGlzdFRhaWw7XG4gICAgLyoqXG4gICAgICogZnVuRGVmQXJnTGlzdCBwYXJzZXMgYXJndW1lbnQgbGlzdHMgZm9yIGZ1bmN0aW9uIGRlZmluaXRpb25zLFxuICAgICAqIHN1cnJvdW5kZWQgYnkgcGFyZW5zIGFuZCBzZXBhcmF0ZWQgYnkgY29tbWFzXG4gICAgICogcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bkRlZkFyZ0xpc3QoKSB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKCcpKShzdHJpbmcoKSk7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgbGV0IGhkID0gdHVwWzBdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgcmVzID0gW2hkXTtcbiAgICAgICAgICAgIGxldCB0YWlsID0gdHVwWzFdO1xuICAgICAgICAgICAgZm9yIChsZXQgZWxlbSBvZiB0YWlsKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goZWxlbS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocDEpKGZ1bkRlZkFyZ0xpc3RUYWlsKCkpKGYpO1xuICAgICAgICBsZXQgcDMgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJygpJykpKF8gPT4gW10pO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMykocDIpO1xuICAgIH1cbiAgICBQYXJzZXIuZnVuRGVmQXJnTGlzdCA9IGZ1bkRlZkFyZ0xpc3Q7XG4gICAgLyoqXG4gICAgICogZnVuRGVmQXJnTGlzdFRhaWwgcGFyc2VzIHRoZSBzZWNvbmQgdGhyb3VnaCBsYXN0IGVsZW1lbnRzIG9mIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBwYXJhbWV0ZXIgbGlzdFxuICAgICAqIHBhcmFtZXRlcnMgYXJlIHNlcGFyYXRlZCBieSBjb21tYXMgYW5kIGVuZCB3aXRoIGEgY2xvc2luZyBwYXJlbnNcbiAgICAgKiByZXR1cm5zIGFuIGFycmF5IG9mIHBhcmFtZXRlcnMsIHdoaWNoIGlzIGFjY2Vzc2VkIGJ5IGZ1bkRlZkFyZ0xpc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5EZWZBcmdMaXN0VGFpbCgpIHtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcsJykpKHN0cmluZygpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmxlZnQocGFudHNfMS5QcmltaXRpdmVzLm1hbnkocDEpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKScpKTtcbiAgICAgICAgcmV0dXJuIHAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmdW5BcHBBcmdMaXN0IHBhcnNlcyBhcmd1bWVudCBsaXN0cyBmb3IgZnVuY3Rpb24gYXBwbGljYXRpb25zLCBpbmNsdWRpbmcgZW1wdHkgYXJncyBsaXN0c1xuICAgICAqIHRoZSBwYXJzZXIgcmV0dXJucyBhbiBhcnJheSBvZiBFeHByZXNzaW9uIG9iamVjdHMgdGhhdCByZXByZXNlbnQgdGhlIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bkFwcEFyZ0xpc3QoKSB7XG4gICAgICAgIGxldCBleHByID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcoJykpKGV4cHIpO1xuICAgICAgICB2YXIgZiA9ICh0dXApID0+IHtcbiAgICAgICAgICAgIGxldCBoZCA9IHR1cFswXTtcbiAgICAgICAgICAgIGxldCByZXMgPSBbaGRdO1xuICAgICAgICAgICAgbGV0IHRhaWwgPSB0dXBbMV07XG4gICAgICAgICAgICBmb3IgKGxldCBlbGVtIG9mIHRhaWwpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocDEpKGZ1bkFwcEFyZ0xpc3RUYWlsKCkpKGYpO1xuICAgICAgICBsZXQgcDMgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJygpJykpKF8gPT4gW10pO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMykocDIpO1xuICAgIH1cbiAgICBQYXJzZXIuZnVuQXBwQXJnTGlzdCA9IGZ1bkFwcEFyZ0xpc3Q7XG4gICAgLyoqXG4gICAgICogZnVuQXBwQXJnTGlzdFRhaWwgcGFyc2VzIHRoZSBzZWNvbmQgdGhyb3VnaCBsYXN0IGVsZW1lbnRzIG9mIGFuIGFyZ3VtZW50IGxpc3RcbiAgICAgKiBlYWNoIGVsZW1lbnQgaXMgc2VwYXJhdGVkIGJ5IGEgY29tbWFcbiAgICAgKiByZXR1cm5zIGFuIGFycmF5IG9mIEV4cHJlc3Npb24gb2JqZWN0cywgbGF0ZXIgYWNjZXNzZWQgYnkgZnVuQXBwQXJnc0xpc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5BcHBBcmdMaXN0VGFpbCgpIHtcbiAgICAgICAgbGV0IGNvbW1hID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignLCcpKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KGNvbW1hKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmxlZnQocGFudHNfMS5QcmltaXRpdmVzLm1hbnkocDEpKShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcpJykpKTtcbiAgICAgICAgcmV0dXJuIHAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXR1cm5QYXJzZXIgcGFyc2VzIHZhbGlkIHJldHVybiBzdGF0ZW1lbnRzIGluIHRoZSBmb3JtIFwicmV0dXJuIHhcIlxuICAgICAqIHdyYXBzIHRoZSBwYXJzZWQgdmFsdWUgaW4gYSBSZXR1cm4gbm9kZSBmb3IgdGhlIEFTVFxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIucmV0dXJuUGFyc2VyID0gaSA9PiB7XG4gICAgICAgIGxldCBleHByID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cigncmV0dXJuJykpKShleHByKTtcbiAgICAgICAgdmFyIGYgPSAoZSkgPT4geyByZXR1cm4gbmV3IGluZGV4XzEuUmV0dXJuKGUsIHdzKTsgfTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocCkoZikoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBmdW5EZWYgcGFyc2VzIHZhbGlkIGZ1bmN0aW9uIGRlZmluaXRpb25zIGluIHRoZSBmb3JtIFwiZnVuIGZ1bmN0aW9uTmFtZShhcmdMaXN0KXsgYm9keTt9XCJcbiAgICAgKiB0aGUgcGFyc2VyIHJldHVybnMgYSBmdW5EZWYgbm9kZSBmb3IgdGhlIEFTVFxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIuZnVuRGVmID0gaSA9PiB7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cignZnVuJykpKShwYW50c18xLlByaW1pdGl2ZXMuc2VxKFxuICAgICAgICAvKiBmdW5jdGlvbiBuYW1lICovXG4gICAgICAgIHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4oc3RyaW5nKCkpKGNzID0+IGNzLnRvU3RyaW5nKCkpKShwYW50c18xLlByaW1pdGl2ZXMuc2VxKFxuICAgICAgICAvKiBmdW5jdGlvbiBhcmd1bWVudHMgKi9cbiAgICAgICAgZnVuRGVmQXJnTGlzdCgpKShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQoXG4gICAgICAgIC8qIGZ1bmN0aW9uIGJvZHkgKi9cbiAgICAgICAgcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcigneycpKSkocGFudHNfMS5QcmltaXRpdmVzLmxlZnQocGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlcikpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCd9JykpKSkoaWQpKShcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBBU1Qgbm9kZVxuICAgICAgICAodHVwKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm5hbWUgPSB0dXBbMF07XG4gICAgICAgICAgICBsZXQgYXJncyA9IHR1cFsxXVswXTtcbiAgICAgICAgICAgIGxldCBib2R5ID0gdHVwWzFdWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkZ1bkRlZihmbmFtZSwgYm9keSwgYXJncywgd3MpO1xuICAgICAgICB9KSkoaSk7XG4gICAgfTtcbiAgICBsZXQgcHJpbnRPZmZzZXQgPSAtMTtcbiAgICAvKipcbiAgICAgKiBmdW5BcHAgcGFyc2VzIHZhbGlkIGZ1bmN0aW9uIGFwcGxpY2F0aW9ucyBpbiB0aGUgZm9ybSBcImZ1bmN0aW9uTmFtZShhcmdzTGlzdClcIiBhbmQgcmV0dXJucyBhIGZ1bkFwcCBub2RlXG4gICAgICogcGFyc2VyIGNoZWNrcyBmb3IgYnVpbHQtaW4gZnVuY3Rpb25zLCBsaWtlIHByaW50LCBlbGxpcHNlLCBhbmQgcmVjdDsgYW5kIHJldHVybnMgdGhlIHZhbGlkIEFTVCBub2RlXG4gICAgICogQHBhcmFtIGkgYSBub25zZW5zZSBwYXJhbWV0ZXIgdXNlZCB0byBhdm9pZCB0aGUgYnVnIHdpdGggZWFnZXIgZXZhbHVhdGlvblxuICAgICAqL1xuICAgIFBhcnNlci5mdW5BcHAgPSBpID0+IHtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykoc3RyaW5nKCkpKShmdW5BcHBBcmdMaXN0KCkpKHR1cCA9PiB7XG4gICAgICAgICAgICBsZXQgZm5hbWUgPSB0dXBbMF0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicHJpbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1cFsxXS5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLlByaW50Tm9kZSh0dXBbMV1bMF0sIG5ldyBpbmRleF8xLkRpbWVuc2lvbnModHVwWzFdWzFdLCB0dXBbMV1bMl0sIG5ldyBpbmRleF8xLk51bWJlck5vZGUoMSkpLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJpbnRPZmZzZXQgPSAocHJpbnRPZmZzZXQgKyAxKSAlIDEyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuUHJpbnROb2RlKHR1cFsxXVswXSwgbmV3IGluZGV4XzEuRGltZW5zaW9ucyhuZXcgaW5kZXhfMS5OdW1iZXJOb2RlKDEwMCArIDEwMCAqIChwcmludE9mZnNldCAlIDMpKSwgbmV3IGluZGV4XzEuTnVtYmVyTm9kZSgxMDAgKyAxMDAgKiAocHJpbnRPZmZzZXQgLyA0KSksIG5ldyBpbmRleF8xLk51bWJlck5vZGUoMSkpLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVsbGlwc2VcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1cFsxXS5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkVsbGlwc2VOb2RlKHR1cFsxXVswXSwgdHVwWzFdWzFdLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwicmVjdFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHVwWzFdLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuUmVjdGFuZ2xlTm9kZSh0dXBbMV1bMF0sIHR1cFsxXVsxXSwgd3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1cFsxXS5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkxpbmVOb2RlKHR1cFsxXVswXSwgdHVwWzFdWzFdLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiY3VydmVcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1cFsxXS5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkN1cnZlTm9kZSh0dXBbMV1bMF0sIHR1cFsxXVsxXSwgdHVwWzFdWzJdLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZXBoXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0dXBbMV0ubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5FcGhOb2RlKHR1cFsxXVswXSwgdHVwWzFdWzFdLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhcmdzID0gdHVwWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkZ1bkFwcChmbmFtZSwgYXJncywgd3MpO1xuICAgICAgICB9KShpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJvb2xQYXJzZSBwYXJzZXMgdmFsaWQgYm9vbGVhbnMsIHRydWUgYW5kIGZhbHNlLCBhbmQgcmV0dXJucyBhIEJvb2xlYW5Ob2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gQm9vbFBhcnNlKCkge1xuICAgICAgICBsZXQgd3MgPSBcIlwiO1xuICAgICAgICBsZXQgcHJlY2VkaW5nV1MgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKSh4ID0+IHdzID0geC50b1N0cmluZygpKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ3RydWUnKSkpKF8gPT4gbmV3IGluZGV4XzEuQm9vbGVhbk5vZGUodHJ1ZSwgd3MpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ2ZhbHNlJykpKShfID0+IG5ldyBpbmRleF8xLkJvb2xlYW5Ob2RlKGZhbHNlLCB3cykpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMSkocDIpO1xuICAgIH1cbiAgICBQYXJzZXIuQm9vbFBhcnNlID0gQm9vbFBhcnNlO1xuICAgIC8qKlxuICAgICAqIGxvZ2ljQ2hhciBwYXJzZXMgYWxsIGxvZ2ljYWwgb3BlcmF0b3JzIGluIHRoZSBTV0VMTCBsYW5ndWFnZSBhbmQgcmV0dXJucyB0aGUgY29uc3VtZWQgb3BlcmF0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2dpY0NoYXIoKSB7XG4gICAgICAgIHZhciBsb2dpY0NoYXIgPSBbXCJlcXVhbHNcIiwgJz09JywgJ2FuZCcsICc+JywgJzwnLCAnbm90IGVxdWFscycsICdvciddO1xuICAgICAgICB2YXIgbG9naWNDaGFyMiA9IFsnPj0nLCAnPD0nXTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuc3RyU2F0KGxvZ2ljQ2hhcikpO1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHJTYXQobG9naWNDaGFyMikpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMikocDEpO1xuICAgIH1cbiAgICBQYXJzZXIubG9naWNDaGFyID0gbG9naWNDaGFyO1xuICAgIC8qKlxuICAgICAqIGxvZ2ljU2hvcnQgcmV0dXJucyBhIHR1cGxlLCB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCByZXByZXNlbnRzIHRoZSBsb2dpY2FsIG9wZXJhdG9yIGFuZFxuICAgICAqIHRoZSBzZWNvbmQgZWxlbWVudCBpcyB0aGUgZXhwcmVzc2lvbiB0byB0aGUgcmlnaHQgb2YgdGhlIG9wZXJhdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9naWNTaG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEobG9naWNDaGFyKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9TZXEpKCh4KSA9PiB4KTtcbiAgICB9XG4gICAgUGFyc2VyLmxvZ2ljU2hvcnQgPSBsb2dpY1Nob3J0O1xuICAgIC8qKlxuICAgICAqIGxvZ2ljRXhwciBwYXJzZXMgbG9naWNhbCBleHByZXNzaW9ucyBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBBU1Qgbm9kZVxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2dpY0V4cHIoKSB7XG4gICAgICAgIC8vIFRPRE86IERhbiAoMjAxOC0xMS0xOSksIHNob3VsZG4ndCBwYXJhbWV0ZXJpemVkIHR5cGUgYmUgQm9vbGVhbk5vZGU/XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxocyA9IHR1cFswXTtcbiAgICAgICAgICAgIGxldCBvcCA9IHR1cFsxXVswXTtcbiAgICAgICAgICAgIGxldCByaHMgPSB0dXBbMV1bMV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXF1YWxzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5FcXVhbHMobGhzLCByaHMsIHdzKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiPT1cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkVxdWFscyhsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkFuZChsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5HcmVhdGVyVGhhbihsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5MZXNzVGhhbihsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuR3JlYXRlclRoYW5FcShsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuTGVzc1RoYW5FcShsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvclwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuT3IobGhzLCByaHMsIHdzKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwibm90IGVxdWFsc1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuTm90RXF1YWwobGhzLCByaHMsIHdzKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2dpY2FsIGV4cHJlc3Npb24gbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBub3QgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ25vdCcpKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KG5vdCkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBub3RFeHByID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwMSkoeCA9PiBuZXcgaW5kZXhfMS5Ob3QoeCwgd3MpKTtcbiAgICAgICAgbGV0IGxvZ2ljRXhwciA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vTG9naWMpKShsb2dpY1Nob3J0KCkpKGYpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShub3RFeHByKShsb2dpY0V4cHIpO1xuICAgIH1cbiAgICBQYXJzZXIuTG9naWNFeHByID0gTG9naWNFeHByO1xuICAgIC8qKlxuICAgICAqIElmUGFyc2UgcGFyc2VzIHZhbGlkIGlmIHN0YXRlbWVudHMgaW4gdGhlIGZvcm0gXCJpZihjb25kaXRpb24peyBib2R5OyB9XCJcbiAgICAgKiByZXR1cm5zIGFuIGFycmF5IHdoZXJlIHRoZSBmaXJzdCBlbGVtIGlzIHRoZSBjb25kaXRpb24gYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGJvZHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJZlBhcnNlKCkge1xuICAgICAgICBsZXQgZXhwciA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBib2R5UGFyc2UgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCdpZicpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKCcpKSh4ID0+IHgpO1xuICAgICAgICBsZXQgY29uZCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHAxKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKScpKShleHByKTtcbiAgICAgICAgbGV0IGN1cmx5ID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcigneycpKTtcbiAgICAgICAgbGV0IGJvZHkgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihjdXJseSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ30nKSkoYm9keVBhcnNlKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEoY29uZCkoYm9keSkoeCA9PiB4KTtcbiAgICB9XG4gICAgUGFyc2VyLklmUGFyc2UgPSBJZlBhcnNlO1xuICAgIC8qKlxuICAgICAgKiBJZkVsc2VQYXJzZSBwYXJzZXMgdmFsaWQgaWYgZWxzZSBzdGF0ZW1lbnRzIGluIHRoZSBmb3JtIFwiaWYoY29uZGl0aW9uKXsgYm9keTsgfSBlbHNleyBib2R5Mjt9XCJcbiAgICAgICogcmV0dXJucyBhbiBhcnJheSB3aGVyZSB0aGUgZmlyc3QgZWxlbSBpcyB0aGUgY29uZGl0aW9uIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSBmaXJzdCBib2R5IGFuZCB0aGUgdGhpcmQgaXMgYm9keTJcbiAgICAgICovXG4gICAgZnVuY3Rpb24gSWZFbHNlUGFyc2UoKSB7XG4gICAgICAgIGxldCBlID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCdlbHNlJykpO1xuICAgICAgICBsZXQgYm9keSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIpO1xuICAgICAgICBsZXQgYm9keTIgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMuc3RyKCd7JykpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ30nKSkoYm9keSk7XG4gICAgICAgIGxldCBlbHNlUGFyc2UgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQoZSkoYm9keTIpO1xuICAgICAgICB2YXIgZiA9ICh0dXApID0+IHtcbiAgICAgICAgICAgIHR1cFswXS5wdXNoKHR1cFsxXSk7XG4gICAgICAgICAgICByZXR1cm4gdHVwWzBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShJZlBhcnNlKCkpKGVsc2VQYXJzZSkoZik7XG4gICAgfVxuICAgIFBhcnNlci5JZkVsc2VQYXJzZSA9IElmRWxzZVBhcnNlO1xuICAgIC8qKlxuICAgICAqIGNvbmRQYXJzZSBwYXJzZXMgcG9zc2libGUgY29uZGl0aW9uYWwgc3RhdGVtZW50cywgaW5jbHVkaW5nIGlmIGFuZCBpZi9lbHNlIHN0YXRlbWVudHNcbiAgICAgKiByZXR1cm5zIGEgQ29uZGl0aW9uYWwgbm9kZVxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIuY29uZFBhcnNlID0gaSA9PiB7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR1cC5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5Db25kaXRpb25hbCh0dXBbMF0sIHR1cFsxXSwgdHVwWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5Db25kaXRpb25hbCh0dXBbMF0sIHR1cFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoSWZFbHNlUGFyc2UoKSkoSWZQYXJzZSgpKSkoZikoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGlsZUxvb3AgcGFyc2VzIHZhbGlkIHdoaWxlIGxvb3BzIGluIHRoZSBmb3JtIFwid2hpbGUoY29uZGl0aW9uKSB7IGJvZHk7fVwiXG4gICAgICogcmV0dXJucyBhIFdoaWxlTm9kZSBmb3IgdGhlIEFTVFxuICAgICAqL1xuICAgIFBhcnNlci5XaGlsZUxvb3AgPSBpID0+IHtcbiAgICAgICAgbGV0IGV4cHIgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9TZXEpO1xuICAgICAgICBsZXQgYm9keVBhcnNlID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlcik7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cihcIndoaWxlXCIpKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJygnKSkoeCA9PiB4KTtcbiAgICAgICAgbGV0IGNvbmQgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwMSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJyknKSkoZXhwcik7XG4gICAgICAgIGxldCBjdXJseSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ3snKSk7XG4gICAgICAgIGxldCBib2R5ID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4oY3VybHkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCd9JykpKGJvZHlQYXJzZSk7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4geyByZXR1cm4gbmV3IGluZGV4XzEuV2hpbGVOb2RlKHR1cFswXSwgdHVwWzFdLCB3cyk7IH07XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuc2VxKGNvbmQpKGJvZHkpKGYpKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9yTG9vcCBwYXJzZXMgdmFsaWQgZm9yIGxvb3BzIGluIHRoZSBmb3JtIFwiZm9yKGluaXRpYWwsIGNvbmRpdGlvbiwgcG9zdCkgeyBib2R5O31cIiBhbmQgcmV0dXJucyBhIEZvck5vZGVcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIHRoZSBidWcgd2l0aCBlYWdlciBldmFsdWF0aW9uXG4gICAgICovXG4gICAgUGFyc2VyLkZvckxvb3AgPSBpID0+IHtcbiAgICAgICAgbGV0IGFyZ3MgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKGZ1bkFwcEFyZ0xpc3QoKSk7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCdmb3InKSkpKGFyZ3MpO1xuICAgICAgICBsZXQgY3VybHkgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCd7JykpO1xuICAgICAgICBsZXQgZXhwciA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5ubCgpKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyKTtcbiAgICAgICAgbGV0IGJvZHkgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihjdXJseSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ30nKSkoZXhwcik7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgbGV0IGluaXQgPSB0dXBbMF1bMF07XG4gICAgICAgICAgICBsZXQgY29uZCA9IHR1cFswXVsxXTtcbiAgICAgICAgICAgIGxldCBwb3N0ID0gdHVwWzBdWzJdO1xuICAgICAgICAgICAgbGV0IGJvZHkgPSB0dXBbMV07XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuRm9yTm9kZShpbml0LCBjb25kLCBwb3N0LCBib2R5LCB3cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHAxKShib2R5KShmKShpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHNpbmdsZUNvbW1lbnQoKSB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55MShwYW50c18xLlByaW1pdGl2ZXMuaXRlbSgpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwMSkoeHMgPT4gcGFudHNfMS5DaGFyVXRpbC5DaGFyU3RyZWFtLmNvbmNhdCh4cykpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLnN0cignLy8nKSkocGFudHNfMS5QcmltaXRpdmVzLm5sKCkpKHAyKTtcbiAgICAgICAgLy9yZXR1cm4gUHJpbWl0aXZlcy5zZXE8Q2hhclV0aWwuQ2hhclN0cmVhbSwgQ2hhclV0aWwuQ2hhclN0cmVhbSwgQ2hhclV0aWwuQ2hhclN0cmVhbVtdPihQcmltaXRpdmVzLnN0cignLy8nKSkoUHJpbWl0aXZlcy5ubCgpKSh4PT54KTtcbiAgICB9XG4gICAgUGFyc2VyLnNpbmdsZUNvbW1lbnQgPSBzaW5nbGVDb21tZW50O1xuICAgIGZ1bmN0aW9uIG11bHRpTGluZUNvbW1lbnQoKSB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55MShwYW50c18xLlByaW1pdGl2ZXMuaXRlbSgpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwMSkoeHMgPT4gcGFudHNfMS5DaGFyVXRpbC5DaGFyU3RyZWFtLmNvbmNhdCh4cykpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLnN0cignXFwvKionKSkocGFudHNfMS5QcmltaXRpdmVzLnN0cignKlxcLycpKShwMik7XG4gICAgfVxuICAgIFBhcnNlci5tdWx0aUxpbmVDb21tZW50ID0gbXVsdGlMaW5lQ29tbWVudDtcbn0pKFBhcnNlciA9IGV4cG9ydHMuUGFyc2VyIHx8IChleHBvcnRzLlBhcnNlciA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBCb29sZWFuTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIEJvb2xlYW5Ob2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgYm9vbGVhblxuICAgICAqIEBwYXJhbSB2YWwgVGhlIGJvb2xlYW4gdmFsdWUgb2YgdGhlIEJvb2xlYW5Ob2RlXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZSBzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl92YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQm9vbGVhbk5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJvb2xlYW5Ob2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgQm9vbGVhbk5vZGUgZXF1YWxzIGFub3RoZXJcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIEJvb2xlYW5Ob2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWwgPT09IHJpZ2h0LnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEJvb2xlYW5Ob2RlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX3ZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYm9vbGVhbiB2YWx1ZVxuICAgICAqL1xuICAgIGdldCB2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvb2xlYW4gdmFsdWVcbiAgICAgKi9cbiAgICBzZXQgdmFsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5Cb29sZWFuTm9kZSA9IEJvb2xlYW5Ob2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm9vbGVhbk5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBOT1Age1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKiBBIE5PUCBpcyBhIHBsYWNlaG9sZGVyIG9wZXJhdGlvbiB0aGF0IGV2YWx1YXRlcyB0byBub3RoaW5nICovXG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBOT1BcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTk9QcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5PUHMgY2Fubm90IGJlIGRyYXduLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgTk9QXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBOT1AgZXF1YWxzIGFub3RoZXIgKHNwb2lsZXI6IGl0IGRvZXNuJ3QpXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuTk9QID0gTk9QO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tk9QLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9OdW1iZXJFZmZlY3RcIik7XG4vLyBOb2RlcyByZXByZXNlbnRpbmcgbnVtYmVyc1xuLy8gU2hvdWxkIGFic3RyYWN0IE5vZGUgY2xhc3MgaW1wbGVtZW50IEV4cHJlc3Npb24/XG5jbGFzcyBOdW1iZXJOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBOdW1iZXJOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgbnVtYmVyXG4gICAgICogQHBhcmFtIHZhbCBUaGUgbnVtYmVyIHZhbHVlXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFsLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTnVtYmVyTm9kZXMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBsZXQgZSA9IG5ldyBOdW1iZXJFZmZlY3RfMS5OdW1iZXJFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBOdW1iZXJOb2RlIGVxdWFscyBhbm90aGVyIE51bWJlck5vZGVcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5IChtdXN0IGJlIGEgTnVtYmVyTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgTnVtYmVyTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsID09PSByaWdodC52YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBOdW1iZXJOb2RlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX3ZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIHN0b3JlZCBpbiB0aGUgbm9kZVxuICAgICAqL1xuICAgIGdldCB2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBudW1iZXIgc3RvcmVkIGluIHRoZSBub2RlXG4gICAgICovXG4gICAgc2V0IHZhbCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWwgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuTnVtYmVyTm9kZSA9IE51bWJlck5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OdW1iZXJOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3RyaW5nRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9TdHJpbmdFZmZlY3RcIik7XG5jbGFzcyBTdHJpbmdOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBTdHJpbmdOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHN0b3JlZCBpbiB0aGUgbm9kZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0ciwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdHIgPSBzdHI7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgU3RyaW5nTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIFN0cmluZyB1c2luZyBTdHJpbmdFZmZlY3RcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgc3RyaW5nIHRvIGJlIGRyYXduXG4gICAgICogQHBhcmFtIGFzdCBUaGUgcHJvZ3JhbSBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBsZXQgZSA9IG5ldyBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBTdHJpbmdOb2RlIGVxdWFscyBhbm90aGVyIFN0cmluZ05vZGVcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5LCBtdXN0IGJlIGEgU3RyaW5nTm9kZVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBTdHJpbmdOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWwgPT09IHJpZ2h0LnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFN0cmluZ05vZGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgJ1xcXCInICsgdGhpcy5fc3RyICsgJ1xcXCInO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJpbmcgc3RvcmVkIGluIHRoZSBub2RlXG4gICAgICovXG4gICAgc2V0IHN0cih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zdHIgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nIHN0b3JlZCBpbiB0aGUgbm9kZVxuICAgICAqL1xuICAgIGdldCB2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLlN0cmluZ05vZGUgPSBTdHJpbmdOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RyaW5nTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIENvbG9yTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgQ29sb3JOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGFuIFJHQiBjb2xvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZWQgPSByZWQ7XG4gICAgICAgIHRoaXMuX2dyZWVuID0gZ3JlZW47XG4gICAgICAgIHRoaXMuX2JsdWUgPSBibHVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIGludG8gYSBzdHJpbmcgUkdCIHZhbHVlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWQgKyBcIiBcIiArIHRoaXMuX2dyZWVuICsgXCIgXCIgKyB0aGlzLl9ibHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb2xvck5vZGVzIGNhbm5vdCBjdXJyZW50bHkgYmUgZHJhd25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgQ29sb3JOb2RlIGVxdWFscyBhbm90aGVyIENvbG9yTm9kZVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHkgKG11c3QgYmUgYSBCb29sZWFuTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgQ29sb3JOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucmVkID09PSByaWdodC5yZWQgJiYgdGhpcy5ncmVlbiA9PT0gcmlnaHQuZ3JlZW4gJiYgdGhpcy5ibHVlID09PSByaWdodC5ibHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIENvbG9yTm9kZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVkIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IHJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmVkIHZhbHVlXG4gICAgICovXG4gICAgc2V0IHJlZChyZWQpIHtcbiAgICAgICAgdGhpcy5fcmVkID0gcmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBncmVlbiB2YWx1ZVxuICAgICAqL1xuICAgIGdldCBncmVlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyZWVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBncmVlbiB2YWx1ZVxuICAgICAqL1xuICAgIHNldCBncmVlbihncmVlbikge1xuICAgICAgICB0aGlzLl9ncmVlbiA9IGdyZWVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBibHVlIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IGJsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBibHVlIHZhbHVlXG4gICAgICovXG4gICAgc2V0IGJsdWUoYmx1ZSkge1xuICAgICAgICB0aGlzLl9ibHVlID0gYmx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29sb3JOb2RlID0gQ29sb3JOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sb3JOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBDdXJ2ZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvQ3VydmVFZmZlY3RcIik7XG5jbGFzcyBDdXJ2ZU5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIEN1cnZlTm9kZSwgYSBub2RlIHJlcHJlc2VudGluZyBhIGN1cnZlXG4gICAgICogQHBhcmFtIGR4IHRoZSBydW4gb2YgdGhlIGN1cnZlXG4gICAgICogQHBhcmFtIGR5IHRoZSByaXNlIG9mIHRoZSBjdXJ2ZVxuICAgICAqIEBwYXJhbSBjdXJ2YXR1cmUgaG93IG11Y2ggdGhlIGN1cnZlLCB1bW0sIGN1cnZlc1xuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGR4LCBkeSwgY3VydmF0dXJlLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2R4ID0gZHg7XG4gICAgICAgIHRoaXMuX2R5ID0gZHk7XG4gICAgICAgIHRoaXMuX2N1cnZhdHVyZSA9IGN1cnZhdHVyZTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBDdXJ2ZU5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBjdXJ2ZSB1c2luZyBDdXJ2ZUVmZmVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBsaW5lIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGRpbXMud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5fZHguZXZhbChjb250ZXh0KS52YWwsIFwiXCIpO1xuICAgICAgICBkaW1zLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl9keS5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGRpbXMuY3VydmF0dXJlID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMuX2N1cnZhdHVyZS5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGxldCBlID0gbmV3IEN1cnZlRWZmZWN0XzEuQ3VydmVFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBDdXJ2ZU5vZGUgZXF1YWxzIGFub3RoZXIgKGlmIHRoZWlyIGR4LCBkeSwgYW5kIGN1cnZhdHVyZSBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhIEN1cnZlTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgQ3VydmVOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZHguZXF1YWxzVmFsKHJpZ2h0LmR4KSAmJiB0aGlzLmR5LmVxdWFsc1ZhbChyaWdodC5keSkgJiYgdGhpcy5jdXJ2YXR1cmUuZXF1YWxzVmFsKHJpZ2h0LmN1cnZhdHVyZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW92ZSgpIHsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnZlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwiY3VydmUoXCIgKyB0aGlzLl9keC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5fZHkudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuX2N1cnZhdHVyZS50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJ1biBvZiB0aGUgY3VydmVcbiAgICAgKi9cbiAgICBnZXQgZHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9keDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcnVuIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIHNldCBkeChkeCkge1xuICAgICAgICB0aGlzLl9keCA9IGR4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByaXNlIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIGdldCBkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByaXNlIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIHNldCBkeShkeSkge1xuICAgICAgICB0aGlzLl9keSA9IGR5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJ2YXR1cmUgb2YgdGhlIGN1cnZlXG4gICAgICovXG4gICAgZ2V0IGN1cnZhdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnZhdHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VydmF0dXJlIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIHNldCBjdXJ2YXR1cmUoY3VydmF0dXJlKSB7XG4gICAgICAgIHRoaXMuX2N1cnZhdHVyZSA9IGN1cnZhdHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuQ3VydmVOb2RlID0gQ3VydmVOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3VydmVOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIEVsbGlwc2VOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYW4gRWxsaXBzZU5vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYW4gZWxsaXBzZVxuICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIGVsbGlwc2VcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGVsbGlwc2VcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBFbGxpcHNlTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGVsbGlwc2Ugb24gdGhlIGNhbnZhcyB1c2luZyBFbGxpcHNlRWZmZWN0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXMgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGVsbGlwc2VcbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGRpbXMud2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgZGltcy5oZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIGxldCBlID0gbmV3IEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KHRoaXMpO1xuICAgICAgICBlLmRyYXcoY29udGV4dCwgZGltcywgYXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgRWxsaXBzZU5vZGUgZXF1YWxzIGFub3RoZXIgRWxsaXBzZU5vZGUgKGlmIHRoZWlyIHdpZHRocyBhbmQgaGVpZ2h0cyBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhbiBFbGxpcHNlTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgRWxsaXBzZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy53aWR0aC5lcXVhbHNWYWwocmlnaHQud2lkdGgpICYmIHRoaXMuaGVpZ2h0LmVxdWFsc1ZhbChyaWdodC5oZWlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVsbGlwc2VcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJlbGxpcHNlKFwiICsgdGhpcy5fd2lkdGgudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuX2hlaWdodC50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIG1vdmUoKSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGxpcHNlIHdpZHRoXG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGVsbGlwc2Ugd2lkdGhcbiAgICAgKi9cbiAgICBzZXQgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBlbGxpcHNlIGhlaWdodFxuICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZWxsaXBzZSBoZWlnaHRcbiAgICAgKi9cbiAgICBzZXQgaGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkVsbGlwc2VOb2RlID0gRWxsaXBzZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbGxpcHNlTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgRXBoRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9FcGhFZmZlY3RcIik7XG5jbGFzcyBFcGhOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYW4gRXBoTm9kZSwgYSBub2RlIHJlcHJlc2VudGluZyBzb21ldGhpbmcgdmVyeSBzcGVjaWFsXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgRXBoTm9kZVxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgRXBoTm9kZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgLy90aGlzLl9pbWFnZSA9IGltYWdlO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgRXBoTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIHJlY3RhbmdsZSB1c2luZyBFcGhFZmZlY3RcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgcmVjdGFuZ2xlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGRpbXMud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5fd2lkdGguZXZhbChjb250ZXh0KS52YWwsIFwiXCIpO1xuICAgICAgICBkaW1zLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl9oZWlnaHQuZXZhbChjb250ZXh0KS52YWwsIFwiXCIpO1xuICAgICAgICBsZXQgZSA9IG5ldyBFcGhFZmZlY3RfMS5FcGhFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBFcGhOb2RlIGVxdWFscyBhbm90aGVyIChpZiB0aGVpciB3aWR0aHMgYW5kIGhlaWdodHMgYXJlIGVxdWFsKVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHkgKG11c3QgYmUgYW4gRXBoTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgRXBoTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoLmVxdWFsc1ZhbChyaWdodC53aWR0aCkgJiYgdGhpcy5oZWlnaHQuZXF1YWxzVmFsKHJpZ2h0LmhlaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW92ZSgpIHsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEVwaE5vZGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJlcGgoXCIgKyB0aGlzLl93aWR0aC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5faGVpZ2h0LnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIEVwaE5vZGVcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd2lkdGggb2YgdGhlIEVwaE5vZGVcbiAgICAgKi9cbiAgICBzZXQgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBFcGhOb2RlXG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBFcGhOb2RlXG4gICAgICovXG4gICAgc2V0IGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5FcGhOb2RlID0gRXBoTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVwaE5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IExpbmVFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0xpbmVFZmZlY3RcIik7XG5jbGFzcyBMaW5lTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgTGluZU5vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYSBsaW5lXG4gICAgICogQHBhcmFtIGR4IHRoZSBydW4gb2YgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0gZHkgdGhlIHJpc2Ugb2YgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkeCwgZHksIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZHggPSBkeDtcbiAgICAgICAgdGhpcy5fZHkgPSBkeTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMaW5lTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGxpbmUgdXNpbmcgTGluZUVmZmVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBsaW5lIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGRpbXMud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5fZHguZXZhbChjb250ZXh0KS52YWwsIFwiXCIpO1xuICAgICAgICBkaW1zLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl9keS5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGxldCBlID0gbmV3IExpbmVFZmZlY3RfMS5MaW5lRWZmZWN0KHRoaXMpO1xuICAgICAgICBlLmRyYXcoY29udGV4dCwgZGltcywgYXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgTGluZU5vZGUgZXF1YWxzIGFub3RoZXIgKGlmIHRoZWlyIGR4IGFuZCBkeSBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhIExpbmVOb2RlKVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBMaW5lTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmR4LmVxdWFsc1ZhbChyaWdodC5keCkgJiYgdGhpcy5keS5lcXVhbHNWYWwocmlnaHQuZHkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vdmUoKSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsaW5lXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwibGluZShcIiArIHRoaXMuX2R4LnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLl9keS50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJ1biBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIGdldCBkeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBydW4gb2YgdGhlIGxpbmVcbiAgICAgKi9cbiAgICBzZXQgZHgoZHgpIHtcbiAgICAgICAgdGhpcy5fZHggPSBkeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmlzZSBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIGdldCBkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByaXNlIG9mIHRoZSBsaW5lXG4gICAgICovXG4gICAgc2V0IGR5KGR5KSB7XG4gICAgICAgIHRoaXMuX2R5ID0gZHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkxpbmVOb2RlID0gTGluZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgUmVjdGFuZ2xlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9SZWN0YW5nbGVFZmZlY3RcIik7XG5jbGFzcyBSZWN0YW5nbGVOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBSZWN0YW5nbGVOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBSZWN0YW5nbGVOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgcmVjdGFuZ2xlIHVzaW5nIFJlY3RhbmdsZUVmZmVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSByZWN0YW5nbGUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSBhc3QgVGhlIHByb2dyYW0gQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgZGltcy53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl93aWR0aC5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGRpbXMuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMuX2hlaWdodC5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGxldCBlID0gbmV3IFJlY3RhbmdsZUVmZmVjdF8xLlJlY3RhbmdsZUVmZmVjdCh0aGlzKTtcbiAgICAgICAgZS5kcmF3KGNvbnRleHQsIGRpbXMsIGFzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIFJlY3RhbmdsZU5vZGUgZXF1YWxzIGFub3RoZXIgKGlmIHRoZWlyIHdpZHRocyBhbmQgaGVpZ2h0cyBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhIFJlY3RhbmdsZU5vZGUpXG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIFJlY3RhbmdsZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy53aWR0aC5lcXVhbHNWYWwocmlnaHQud2lkdGgpICYmIHRoaXMuaGVpZ2h0LmVxdWFsc1ZhbChyaWdodC5oZWlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vdmUoKSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJyZWN0KFwiICsgdGhpcy5fd2lkdGgudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuX2hlaWdodC50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIHNldCB3aWR0aCh3aWR0aCkge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICovXG4gICAgc2V0IGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5SZWN0YW5nbGVOb2RlID0gUmVjdGFuZ2xlTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlY3RhbmdsZU5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIERpbWVuc2lvbnMge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBEaW1lbnNpb25zLCB3aGljaCBzdG9yZXMgb2JqZWN0IGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0geCBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0geSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gc2NhbGUgVGhlIHNjYWxlIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gcmFkaXVzIFRoZSByYWRpdXMgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHNjYWxlLCByYWRpdXMpIHtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICB0aGlzLl9zY2FsZSA9IHNjYWxlO1xuICAgICAgICB0aGlzLl9yYWRpdXMgPSByYWRpdXMgfHwgbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDMwLCBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGltZW5zaW9uc1xuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy54LnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLnkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgc2V0IHgodmFsKSB7XG4gICAgICAgIHRoaXMuX3ggPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIHNldCB5KHZhbCkge1xuICAgICAgICB0aGlzLl95ID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByYWRpdXMgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGdldCByYWRpdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJhZGl1cyBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgc2V0IHJhZGl1cyh2YWwpIHtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzY2FsZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IHNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjYWxlIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgc2NhbGUodmFsKSB7XG4gICAgICAgIHRoaXMuX3NjYWxlID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHdpZHRoIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgd2lkdGgodmFsKSB7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgc2V0IGhlaWdodCh2YWwpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJ2YXR1cmUgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBjdXJ2YXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJ2YXR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnZhdHVyZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgc2V0IGN1cnZhdHVyZSh2YWwpIHtcbiAgICAgICAgdGhpcy5fY3VydmF0dXJlID0gdmFsO1xuICAgIH1cbn1cbmV4cG9ydHMuRGltZW5zaW9ucyA9IERpbWVuc2lvbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaW1lbnNpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgUHJpbnROb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBQcmludE5vZGUsIHJlcHJlc2VudGluZyBhbiBvYmplY3QgdG8gYmUgcHJpbnRlZFxuICAgICAqIEBwYXJhbSB0b1ByaW50IFRoZSBvYmplY3QgdG8gYmUgcHJpbnRlZFxuICAgICAqIEBwYXJhbSBkaW1lbnNpb25zIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3QgdG8gYmUgcHJpbnRlZFxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRvUHJpbnQsIGRpbWVuc2lvbnMsIHdzKSB7XG4gICAgICAgIHRoaXMuX3NjYWxlID0gMTtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90b1ByaW50ID0gdG9QcmludDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RpbXMgPSBkaW1lbnNpb25zIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCB0byBiZSBwcmludGVkXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwicHJpbnQoXCIgKyB0aGlzLnRvUHJpbnQudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuZGltcy50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgUHJpbnROb2RlXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBQcmludE5vZGVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW50Tm9kZXMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3KCkgb24gcHJpbnRPcFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBvYmplY3QgdG8gYmUgcHJpbnRlZCBhbmQgZHJhd3MgaXRcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5fdG9QcmludC5ldmFsKGNvbnRleHQpO1xuICAgICAgICByZXMuZHJhdyhjb250ZXh0LCB0aGlzLl9kaW1zLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb2JqZWN0IHRvIGJlIHByaW50ZWRcbiAgICAgKi9cbiAgICBnZXQgdG9QcmludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvUHJpbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9iamVjdCB0byBiZSBwcmludGVkXG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5QcmludE5vZGUgPSBQcmludE5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QcmludE5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBSZXR1cm5FcnJvcl8xID0gcmVxdWlyZShcIi4vUmV0dXJuRXJyb3JcIik7XG5jbGFzcyBSZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIFJldHVybiBvYmplY3QsIHJlcHJlc2VudGluZyBzb21ldGhpbmcgdG8gYmUgcmV0dXJuZWQgaW4gYSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBleHByIFRoZSBleHByZXNzaW9uIHRvIGJlIHJldHVybmVkXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZXhwciwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9leHByID0gZXhwcjtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyB0aGUgZXhwcmVzc2lvbiB0byBiZSByZXR1cm5lZCBhbmQgcmV0dXJucyB2aWEgYSBSZXR1cm5FcnJvXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIC8vIElmIHJldHVybiB2YWwgaXMgYSB2YXIsIHJldHVybnMgdGhhdCB2YXIncyB2YWx1ZVxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fZXhwci5ldmFsKGNvbnRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgUmV0dXJuRXJyb3JfMS5SZXR1cm5FcnJvcihyZXN1bHQsIGNvbnRleHQucmV0SURMb29rdXAoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIFJldHVybiBub2Rlc1xuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gUmV0dXJuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBSZXR1cm4gbm9kZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyBcInJldHVybiBcIiArIHRoaXMuX2V4cHIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbm9kZXMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIFJldHVyblwiKTtcbiAgICB9XG59XG5leHBvcnRzLlJldHVybiA9IFJldHVybjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJldHVybi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFJldHVybkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBSZXR1cm5FcnJvciwgYSBjdXN0b20gZXJyb3IgY2xhc3MgdGhhdCB3ZSBhYnVzZSB0byByZXR1cm4gdmFsdWVzXG4gICAgICogQHBhcmFtIHJldFZhbCBUaGUgdmFsdWUgdG8gYmUgcmV0dXJuZWRcbiAgICAgKiBAcGFyYW0gSUQgVGhlIElEIG9mIHRoZSB2YWx1ZSB0byBiZSByZXR1cm5lZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJldFZhbCwgSUQpIHtcbiAgICAgICAgc3VwZXIoSUQpO1xuICAgICAgICB0aGlzLnJldFZhbCA9IHJldFZhbDtcbiAgICAgICAgdGhpcy5JRCA9IElEO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUmV0dXJuRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLlJldHVybkVycm9yID0gUmV0dXJuRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXR1cm5FcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xuY2xhc3MgU2NvcGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBTY29wZSwgYW4gb2JqZWN0IGtlZXBpbmcgdHJhY2sgb2Ygb2JqZWN0cyB3aXRoaW4gYSBwYXJ0aWN1bGFyIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gcGFyZW50IFRoZSBwYXJlbnQgU2NvcGVcbiAgICAgKiBAcGFyYW0gZWZmZWN0cyBFZmZlY3RzIHdpdGhpbiB0aGlzIFNjb3BlXG4gICAgICogQHBhcmFtIG15U3RhdGUgVGhlIHNjb3BlIHN0YXRlXG4gICAgICogQHBhcmFtIGV2ZW50TG9nIFRoZSBsb2cgb2YgZXZlbnRzIHRoYXQgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGVmZmVjdHMsIGV2ZW50TG9nKSB7XG4gICAgICAgIHRoaXMuX3JldFZhbElEID0gc3BhY2VfbGlmdF8xLk5vbmU7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IHNwYWNlX2xpZnRfMS5Ob25lO1xuICAgICAgICB0aGlzLl9ldmVudExvZyA9IFtdOyAvLyBUaGUgZXZlbnQgbG9nXG4gICAgICAgIHRoaXMuX2hhZEZ1bkV2YWwgPSBmYWxzZTsgLy8gV2FzIHRoaXMgY3JlYXRlZCBpbiBhIGZ1bmN0aW9uP1xuICAgICAgICAvL3B1YmxpYyBnbG9iYWxGdW5JRCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHRoaXMuZ2xvYmFsRnVuSUQgPSAxMDAwMDAwMDsgLy8gVGhlIGdsb2JhbCBJRCBmb3IgZnVuY3Rpb25zIGluIHRoaXMgY29udGV4dFxuICAgICAgICB0aGlzLl92YXJCaW5kaW5ncyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLl9lZmZlY3RzID0gZWZmZWN0cyB8fCBudWxsO1xuICAgICAgICB0aGlzLl9ldmVudExvZyA9IGV2ZW50TG9nO1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50ICE9IG51bGwgJiYgdGhpcy5fcGFyZW50Ll9oYWRGdW5FdmFsKVxuICAgICAgICAgICAgdGhpcy5faGFkRnVuRXZhbCA9IHRydWU7IC8vIGNvcHkgZnVuY3Rpb24gZXZhbCBmbGFnIGZyb20gcGFyZW50XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyBpbmZvcm1hdGlvbiBmcm9tIHRoaXMgU2NvcGUgaW50byBhbm90aGVyIFNjb3BlIGFuZCByZXR1cm5zIHRoZSBuZXcgU2NvcGVcbiAgICAgKi9cbiAgICBjb3B5KCkge1xuICAgICAgICBsZXQgcyA9IG5ldyBTY29wZSh0aGlzLl9wYXJlbnQsIHRoaXMuX2VmZmVjdHMsIHRoaXMuX2V2ZW50TG9nKTtcbiAgICAgICAgcy52YXJCaW5kaW5ncyA9IG5ldyBNYXAodGhpcy5fdmFyQmluZGluZ3MpO1xuICAgICAgICBzLmNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgICBzLmV2ZW50TG9nID0gdGhpcy5ldmVudExvZztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY2xhcmVzIGEgbmV3IHZhcmlhYmxlXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGJlIGRlY2xhcmVkXG4gICAgICovXG4gICAgZGVjbGFyZShuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl92YXJCaW5kaW5ncy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjb3BlIGFscmVhZHkgaGFzIHZhciB3aXRoIG5hbWUgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92YXJCaW5kaW5ncy5zZXQobmFtZSwgc3BhY2VfbGlmdF8xLk5vbmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIGEgdmFsdWUgdG8gYSB2YXJpYWJsZSBpbiB0aGlzIENvbnRleHRcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGVcbiAgICAgKi9cbiAgICBhc3NpZ24obmFtZSwgdmFsKSB7XG4gICAgICAgIHRoaXMuX3ZhckJpbmRpbmdzLnNldChuYW1lLCBzcGFjZV9saWZ0XzEuU29tZSh2YWwpKTsgLy9Tb21lKHZhbCk/XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIGEgdmFsdWUgd2l0aGluIHRoZSBTY29wZSBhbmQgYWxsIGl0cyBhbmNlc3RvciBTY29wZXNcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB0byBzZWFyY2ggd2l0aGluXG4gICAgICovXG4gICAgbG9va3VwKG5hbWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQudmFyQmluZGluZ3MuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC52YXJCaW5kaW5ncy5nZXQobmFtZSkuaXNEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNvbnRleHQudmFyQmluZGluZ3MuZ2V0KG5hbWUpLmdldCgpKTsgLy9leHRyYSBnZXQgdG8gbWFuYWdlIFNvbWUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghKGNvbnRleHQucGFyZW50ID09IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb29rdXAobmFtZSwgY29udGV4dC5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhcmlhYmxlIGNvdWxkIG5vdCBiZSBmb3VuZC5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIGFuZCByZXR1cm5zIHRoZSByZXR1cm4gSUQgdmFsdWVcbiAgICAgKi9cbiAgICByZXRJRExvb2t1cCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JldFZhbElELmlzRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0VmFsSUQuZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudC5yZXRJRExvb2t1cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjYWxsZXIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE1hcCBvZiB2YXJpYWJsZSBiaW5kaW5nc1xuICAgICAqL1xuICAgIGdldCB2YXJCaW5kaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhckJpbmRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBNYXAgb2YgdmFyaWFibGUgYmluZGluZ3NcbiAgICAgKi9cbiAgICBzZXQgdmFyQmluZGluZ3MobSkge1xuICAgICAgICB0aGlzLl92YXJCaW5kaW5ncyA9IG07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhcmVudCBTY29wZVxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJldHVybiB2YWx1ZSBJRFxuICAgICAqL1xuICAgIGdldCByZXRWYWxJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldFZhbElEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByZXR1cm4gdmFsdWUgSURcbiAgICAgKi9cbiAgICBzZXQgcmV0VmFsSUQodmFsKSB7XG4gICAgICAgIHRoaXMuX3JldFZhbElEID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBIVE1MIGNhbnZhc1xuICAgICAqL1xuICAgIGdldCBjYW52YXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIEhUTUwgY2FudmFzXG4gICAgICovXG4gICAgc2V0IGNhbnZhcyh2YWwpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlZmZlY3RzIGFycmF5XG4gICAgICovXG4gICAgZ2V0IGVmZmVjdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lZmZlY3RzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBlZmZlY3RzIGFycmF5XG4gICAgICovXG4gICAgc2V0IGVmZmVjdHMoYXJyKSB7XG4gICAgICAgIHRoaXMuX2VmZmVjdHMgPSBhcnI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV2ZW50IGxvZ1xuICAgICAqL1xuICAgIGdldCBldmVudExvZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50TG9nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBldmVudCBsb2dcbiAgICAgKi9cbiAgICBzZXQgZXZlbnRMb2codXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50TG9nID0gdXBkYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBlZmZlY3RzXG4gICAgICovXG4gICAgZ2V0IG11bFNlbEFycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbXVsU2VsQXJyYXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFycmF5IG9mIGVmZmVjdHNcbiAgICAgKi9cbiAgICBzZXQgbXVsU2VsQXJyYXkodXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX211bFNlbEFycmF5ID0gdXBkYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBTY29wZSB3YXMgY3JlYXRlZCBpbiBhIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZ2V0IGhhZEZ1bkV2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYWRGdW5FdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhpcyBTY29wZSB3YXMgY3JlYXRlZCBpbiBhIGZ1bmN0aW9uXG4gICAgICovXG4gICAgc2V0IGhhZEZ1bkV2YWwodmFsKSB7XG4gICAgICAgIHRoaXMuX2hhZEZ1bkV2YWwgPSB2YWw7XG4gICAgfVxufVxuZXhwb3J0cy5TY29wZSA9IFNjb3BlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2NvcGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTY29wZV8xID0gcmVxdWlyZShcIi4vU2NvcGVcIik7XG5jb25zdCBzcGFjZV9saWZ0XzEgPSByZXF1aXJlKFwic3BhY2UtbGlmdFwiKTtcbmNsYXNzIFNlcXVlbmNlTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgU2VxdWVuY2VOb2RlLCB0aGUgYnVpbGRpbmcgYmxvY2sgb2YgdGhlIEFTVFxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IHNpZGUgb2YgdGhlIFNlcXVlbmNlXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBTZXF1ZW5jZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBjaGlsZHJlbiBpbiBwb3N0b3JkZXIgKGxlZnQsIHJpZ2h0LCBwYXJlbnQpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsZWZ0U2NvcGUgPSBuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0LCBjb250ZXh0LmVmZmVjdHMsIGNvbnRleHQuZXZlbnRMb2cpO1xuICAgICAgICBsZWZ0U2NvcGUuY2FudmFzID0gc3BhY2VfbGlmdF8xLlNvbWUoY29udGV4dC5jYW52YXMuZ2V0KCkpO1xuICAgICAgICAvL3Rocm93aW5nIGF3YXkgYWZ0ZXIgZXZhbGluZ1xuICAgICAgICB0aGlzLl9sZWZ0VmFsID0gdGhpcy5fbGVmdC5ldmFsKGxlZnRTY29wZSk7XG4gICAgICAgIHRoaXMuX3JpZ2h0VmFsID0gdGhpcy5fcmlnaHQuZXZhbChsZWZ0U2NvcGUpOyAvLyBsZWZ0U2NvcGUgbWF5IGJlIG1vZGlmaWVkIG5vd1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXF1ZW5jZU5vZGVzIGNhbm5vdCBiZSBkaXJlY3RseSBkcmF3blxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdygpIG9uIFNlcXVlbmNlTm9kZXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgZGlyZWN0bHkgY2FsbGVkIG9uIFNlcXVlbmNlTm9kZXNcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIFNlcXVlbmNlTm9kZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQVNUXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9sZWZ0LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLl9sZWZ0Lm5ld0xpbmUoKSA9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCI7XFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JpZ2h0Lm5ld0xpbmUoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCkgKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLl9yaWdodC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxlZnQgY2hpbGRcbiAgICAgKi9cbiAgICBzZXQgbGVmdChsZWZ0KSB7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsZWZ0IGNoaWxkXG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByaWdodCBjaGlsZFxuICAgICAqL1xuICAgIHNldCByaWdodChyaWdodCkge1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByaWdodCBjaGlsZFxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbGVmdCBjaGlsZVxuICAgICAqL1xuICAgIGdldCBsZWZ0VmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdFZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHJpZ2h0IGNoaWxlXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0VmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHRWYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLlNlcXVlbmNlTm9kZSA9IFNlcXVlbmNlTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlcXVlbmNlTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi4vLi4vaW5kZXhcIik7XG5jb25zdCBpbmRleF8yID0gcmVxdWlyZShcIi4uLy4uL2luZGV4XCIpO1xuY29uc3QgaW5kZXhfMyA9IHJlcXVpcmUoXCIuLi8uLi9pbmRleFwiKTtcbmNvbnN0IGluZGV4XzQgPSByZXF1aXJlKFwiLi4vLi4vaW5kZXhcIik7XG5jb25zdCBpbmRleF81ID0gcmVxdWlyZShcIi4uLy4uL2luZGV4XCIpO1xuY29uc3QgaW5kZXhfNiA9IHJlcXVpcmUoXCIuLi8uLi9pbmRleFwiKTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xubGV0IGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xubGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5sZXQgaW5wdXRCb3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5wdXQnKTtcbmxldCBsYXN0V29ya2luZ0lucHV0VGV4dCA9IFwiXCI7XG5sZXQgc3RhckNvdW50ID0gMDtcbi8vdGhlIGVmZmVjdHMgYXJyYXkgdGhhdCBob2xkcyBhbGwgdGhlIHRleHQsIGVsbGlwc2VzLCBhbmQgcmVjdGFuZ2xlc1xubGV0IGVmZmVjdHMgPSBbXTtcbmxldCBhc3Q7XG5sZXQgY29udGV4dDtcbmxldCBzaG93RGVidWcgPSB0cnVlOyAvLyBmbGFnIHRvIHNob3cgb3IgaGlkZSBkZWJ1ZyBidXR0b25cbmxldCBtYXN0ZXJMb2cgPSBbXTtcbmxldCBzZWxlY3RlZEVsZW1zID0gW107XG5sZXQgdGV4dEJveFNlbGVjdGVkOyAvL3NlZXMgaWYgdGhlIHRleHQgYm94IGlzIHNlbGVjdGVkXG5sZXQgaXNQYWludGluZzsgLy90ZXN0cyB0byBzZWUgaWYgeW91J3JlIHBhaW50aW5nIHRvIHRoZSBjYW52YXNcbmxldCBjaGVja3BvaW50SXNBY3RpdmUgPSBmYWxzZTtcbmxldCBjaGVja3BvaW50ID0gbnVsbDtcbmxldCBjYW52YXNJc0Rpc2FibGVkID0gZmFsc2U7XG5sZXQgc2VsZWN0ZWQgPSAwOyAvL3RoZSBudW1iZXIgb2Ygc2VsZWN0ZWQgZWZmZWN0cyBpZiBtdWx0aXBseSBzZWxlY3RpbmdcbmxldCBhbHJlYWR5TG9nZ2VkID0gZmFsc2U7XG5sZXQgbnVtTG9nZ2VkID0gMDtcbmxldCBnbG9iYWxJRCA9IDE7XG5sZXQgZXBoO1xuLypcbmxldCBidWdCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGVidWcnKTtcbmlmKCFzaG93RGVidWcpe1xuICAgIGJ1Z0J1dHRvbi5zdHlsZS52aXNpYmlsaXR5PSdoaWRkZW4nO1xufVxuXG5idWdCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uKCl7XG4gICAgcHJpbnRMb2coKTtcbn1cbiovXG4vKipcbiAqIDxkaXYgY2xhc3M9XCJjb2wtaXRlbVwiPlxuICogIDxidXR0b24gaWQ9J3BhaW50JyBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6I0RGQjUzNFwiPiBSdW4gPC9idXR0b24+XG4gKiA8L2Rpdj5cbiAqXG4gKiBQdXQgdGhpcyBpbiBodG1sIGZpbGUgZm9yIFJ1biBidXR0b24ncyBzdHlsaW5nXG4gKi9cbi8vbGV0IHBhaW50QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhaW50Jyk7XG4vKipcbiAqIG1ha2VzIHRoZSBwYWludCBidXR0b24gcGFpbnQgdGV4dCBmcm9tIHRoZSB0ZXh0YXJlYSB0byB0aGUgY2FudmFzIVxuICovXG4vKlxucGFpbnRCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICBlZmZlY3RzLmxlbmd0aCA9IDA7IC8vIHNsaWdodGx5IHNrZXRjaCBjbGVhcmluZyBtZXRob2QgdG8gbWFpbnRhaW4gcmVmZXJlbmNlIHRvIG9yaWdpbmFsIGFycmF5XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgaXNQYWludGluZyA9IHRydWU7XG4gICAgbGV0IGlucHV0VGV4dCA9IGlucHV0Qm94LnZhbHVlO1xuXG4gICAgbGV0IGFzdE9wdCA9IFBhcnNlci5wYXJzZShpbnB1dFRleHQpO1xuICAgIGlmKGFzdE9wdC5pc0RlZmluZWQoKSl7XG4gICAgICAgIGFzdCA9IGFzdE9wdC5nZXQoKTtcbiAgICAgICAgY29udGV4dCA9IG5ldyBTY29wZShudWxsLCBlZmZlY3RzLCBtYXN0ZXJMb2cpO1xuICAgICAgICBjb250ZXh0LmNhbnZhcyA9IFNvbWUoY2FudmFzKTtcbiAgICAgICAgYXN0LmV2YWwoY29udGV4dCk7IC8vdGhpcyBpcyB3aGVyZSB3ZSBkcmF3IHRoZSBvYmplY3RzIHRvIHRoZSBzY3JlZW5cbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZXJyb3IgPSBcImVycm9yIHRleHRcIjtcbiAgICAgICAgYWxlcnQoXCJRdWFuOiBzbyBzb21ldGhpbmcgd2l0aCB0aGlzIHN5bnRheCBlcnJvcjogXCIgKyBlcnJvcik7XG4gICAgfVxuXG4gICAgLy9sZXQgcGFpbnRFdnQgPSBuZXcgUGFpbnRFdmVudChpbnB1dFRleHQpOyAvLyB3aWxsIG5lZWQgdG8gZ2V0IGZyb20gYXN0IHdoZW4gdGhhdCdzIGltcGxlbWVudGVkXG5cbiAgICAvLyBBZGRpbmcgY29udGV4dCBsb2cgdG8gbWFzdGVyIGxvZ1xuICAgIC8vbG9nRXZlbnQucHVzaChwYWludEV2dC5hc3NlbWJsZUxvZygpKTtcbiAgICBwcmludExvZygpO1xuICAgIC8vZXZlbnQxLmxvZ0l0ZW0oKTtcbiAgICAvLyB9XG59O1xuKi9cbi8vY2xlYXJzIHRoZSBjYW52YXMhXG5sZXQgcmVzZXRCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzZXQnKTtcbnJlc2V0QnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNoZWNrcG9pbnQuX3N0YXJ0ZXJDb2RlICE9IG51bGwpIHtcbiAgICAgICAgdGV4dEJveFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaW5wdXRCb3gudmFsdWUgPSBjaGVja3BvaW50Ll9zdGFydGVyQ29kZTtcbiAgICB9XG4gICAgY29udGV4dC5ldmVudExvZy5wdXNoKG5ldyBpbmRleF8yLkNsZWFyRXZlbnQoKSk7XG4gICAgbWFzdGVyTG9nLnB1c2goY29udGV4dC5ldmVudExvZ1tjb250ZXh0LmV2ZW50TG9nLmxlbmd0aCAtIDFdKTsgLy8gRG9lcyB0aGlzIGFjdHVhbGx5IHdvcms/XG4gICAgcHJpbnRMb2coKTtcbiAgICAvL2xldCBjbGVhckV2dCA9IG5ldyBDbGVhckV2ZW50KCk7XG4gICAgLy9sb2dFdmVudC5wdXNoKGNsZWFyRXZ0LmFzc2VtYmxlTG9nKCkpO1xuICAgIC8vY29uc29sZS5sb2coXCJMb2c6IFwiICsgbG9nRXZlbnQpO1xufTtcbi8qKlxuICogVGhlIGFuaW1hdGlvbiBmdW5jdGlvbiB0aGF0IGJhc2ljYWxseSByZWN1cnNpdmVseSBjYWxscyBpdHNlbGYsIGNsZWFyaW5nIGFuZFxuICogcmVkcmF3aW5nIHRvIHRoZSBjYW52YXMgYXQgNjBmcHMuXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsgLy9jbGVhcnMgY2FudmFzXG4gICAgc2VsZWN0ZWQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWZmZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlZmZlY3RzW2ldLnVwZGF0ZSgpO1xuICAgICAgICBpZiAoZWZmZWN0c1tpXS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRFbGVtcy5wdXNoKGVmZmVjdHNbaV0pO1xuICAgICAgICAgICAgc2VsZWN0ZWQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0c1tpXS5nZXRKdXN0RHJhZ2dlZCgpKSB7IC8vIExvZ3MgZHJhZyBldmVudFxuICAgICAgICAgICAgY29udGV4dC5ldmVudExvZy5wdXNoKG5ldyBpbmRleF8yLkRyYWdFdmVudChlZmZlY3RzW2ldKSk7XG4gICAgICAgICAgICBtYXN0ZXJMb2cucHVzaChjb250ZXh0LmV2ZW50TG9nW2NvbnRleHQuZXZlbnRMb2cubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgZWZmZWN0c1tpXS5zZXRKdXN0RHJhZ2dlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdHNbaV0uaWRPYmogPT0gdW5kZWZpbmVkKSB7IC8vIEdpdmVzIG9iamVjdCBhbiBJRCBpZiBpdCBkb2Vzbid0IGhhdmUgb25lXG4gICAgICAgICAgICBlZmZlY3RzW2ldLmluaXRJRChnbG9iYWxJRCk7XG4gICAgICAgICAgICBjb250ZXh0LmV2ZW50TG9nLnB1c2gobmV3IGluZGV4XzIuSURFdmVudChlZmZlY3RzW2ldKSk7IC8vIExvZ3MgSURcbiAgICAgICAgICAgIGdsb2JhbElEKys7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVmZmVjdHNbaV0uZ2V0SUQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYoKChlZmZlY3RzW2ldIGFzIEVsbGlwc2VFZmZlY3QpLmp1c3REcmFnZ2VkKSl7XG4gICAgICAgIC8vICAgICAvL2NvbnRleHQuZXZlbnRMb2cucHVzaChuZXcgRHJhZ0V2ZW50KGVmZmVjdHNbaV0pKTtcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBoYXZlIGl0ZXJhdGVkIHRocm91Z2ggYWxsIGVmZmVjdHMgYW5kIGhhdmUgY29tcGxldGUgbGlzdCB0byBsb2dcbiAgICBpZiAoc2VsZWN0ZWQgIT0gbnVtTG9nZ2VkKSB7IC8vIGlmIHNlbGVjdGlvbnMgaGF2ZSBjaGFuZ2VkLCBzaG91bGQgbG9nIGFnYWluXG4gICAgICAgIGFscmVhZHlMb2dnZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFhbHJlYWR5TG9nZ2VkICYmIHNlbGVjdGVkID49IDIpIHsgLy8gbG9ncyBpZiBoYXNuJ3QgYWxyZWFkeVxuICAgICAgICBudW1Mb2dnZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgY29udGV4dC5ldmVudExvZy5wdXNoKG5ldyBpbmRleF8yLlNlbGVjdEV2ZW50KHNlbGVjdGVkRWxlbXMpKTtcbiAgICAgICAgbWFzdGVyTG9nLnB1c2goY29udGV4dC5ldmVudExvZ1tjb250ZXh0LmV2ZW50TG9nLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgYWxyZWFkeUxvZ2dlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vVGhpcyBkb2VzIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uLCBwYXNzaW5nIHRoZSBuZXcgc3RyaW5ncyB0byB0aGUgdGV4dCBib3hcbiAgICBsZXQgaW5wdXRUZXh0ID0gaW5wdXRCb3gudmFsdWU7XG4gICAgaWYgKHRleHRCb3hTZWxlY3RlZCAmJiBpbnB1dFRleHQgIT09IGxhc3RXb3JraW5nSW5wdXRUZXh0KSB7XG4gICAgICAgIGVmZmVjdHMubGVuZ3RoID0gMDsgLy8gc2xpZ2h0bHkgc2tldGNoIGNsZWFyaW5nIG1ldGhvZCB0byBtYWludGFpbiByZWZlcmVuY2UgdG8gb3JpZ2luYWwgYXJyYXlcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAvL2lzUGFpbnRpbmcgPSB0cnVlO1xuICAgICAgICAvL2xldCBpbnB1dFRleHQgPSBpbnB1dEJveC52YWx1ZTtcbiAgICAgICAgbGV0IGFzdE9wdCA9IGluZGV4XzEuUGFyc2VyLnBhcnNlKGlucHV0VGV4dCk7XG4gICAgICAgIGlmIChhc3RPcHQuaXNEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIGFzdCA9IGFzdE9wdC5nZXQoKTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBuZXcgaW5kZXhfMi5TY29wZShudWxsLCBlZmZlY3RzLCBtYXN0ZXJMb2cpO1xuICAgICAgICAgICAgY29udGV4dC5jYW52YXMgPSBzcGFjZV9saWZ0XzEuU29tZShjYW52YXMpO1xuICAgICAgICAgICAgYXN0LmV2YWwoY29udGV4dCk7IC8vdGhpcyBpcyB3aGVyZSB3ZSBkcmF3IHRoZSBvYmplY3RzIHRvIHRoZSBzY3JlZW5cbiAgICAgICAgICAgIGxhc3RXb3JraW5nSW5wdXRUZXh0ID0gaW5wdXRUZXh0O1xuICAgICAgICB9IC8qZWxzZSB7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBcImVycm9yIHRleHRcIjtcbiAgICAgICAgICAgIGFsZXJ0KFwiUXVhbjogc28gc29tZXRoaW5nIHdpdGggdGhpcyBzeW50YXggZXJyb3I6IFwiICsgZXJyb3IpO1xuICAgICAgICB9Ki9cbiAgICAgICAgLy9sZXQgcGFpbnRFdnQgPSBuZXcgUGFpbnRFdmVudChpbnB1dFRleHQpOyAvLyB3aWxsIG5lZWQgdG8gZ2V0IGZyb20gYXN0IHdoZW4gdGhhdCdzIGltcGxlbWVudGVkXG4gICAgICAgIC8vIEFkZGluZyBjb250ZXh0IGxvZyB0byBtYXN0ZXIgbG9nXG4gICAgICAgIC8vbG9nRXZlbnQucHVzaChwYWludEV2dC5hc3NlbWJsZUxvZygpKTtcbiAgICAgICAgcHJpbnRMb2coKTtcbiAgICAgICAgLy9ldmVudDEubG9nSXRlbSgpO1xuICAgICAgICAvLyB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdCAhPSB1bmRlZmluZWQgJiYgIXRleHRCb3hTZWxlY3RlZCAvKiAmJiAhaXNQYWludGluZyAqLykge1xuICAgICAgICBsZXQgbmV3SW5wdXQgPSBhc3QudG9TdHJpbmcoKTtcbiAgICAgICAgaW5wdXRCb3gudmFsdWUgPSBuZXdJbnB1dDtcbiAgICB9XG4gICAgaWYgKGNoZWNrcG9pbnRJc0FjdGl2ZSkge1xuICAgICAgICBjaGVja3BvaW50Q2hlY2tzR29hbCgpO1xuICAgIH1cbiAgICBpZiAoY2hlY2twb2ludCAhPSBudWxsICYmIGNoZWNrcG9pbnQuZHJhd0d1aWRlcyAhPSBudWxsKSB7XG4gICAgICAgIGNoZWNrcG9pbnQuZHJhd0d1aWRlcyhjdHgpO1xuICAgICAgICAvKlxuICAgICAgICAgICAgICBpZiAoY2hlY2twb2ludC5fbmFtZSA9PSBcImwxYzNcIikge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVjdCgxMCwgNDMwLCAxMDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSAyMCArIFwicHggQ291cmllciBOZXdcIjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChcIlB1dCB0ZXh0XCIsIDEwLCAzOTApO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChcImluIGhlcmVcIiwgMTAsIDQxMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgKi9cbiAgICB9XG4gICAgc2VsZWN0ZWRFbGVtcyA9IFtdO1xufVxuLy9jaGVja3MgdG8gc2VlIHdoZXRoZXIgdGhlIHRleHQgYm94IGlzIHNlbGVjdGVkXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaXNJbnB1dEJveFNlbGVjdGVkKTtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBtYW5hZ2VzIHRoZSBzdGF0ZSBvZiB0aGUgVUkgd2hlbiB0aGUgdGV4dCBib3ggaXMgc2VsZWN0ZWQgYW5kIHdoZW4gaXQgaXNuJ3QuXG4gKiBJZiBpdCBpcyBpbnNpZGUgdGhlIHRleHQgYm94LCBpc1BhaW50aW5nIGlzIGZhbHNlIGFuZCB0ZXh0Qm94U2VsZWN0ZWQgaXMgdHJ1ZS5cbiAqIElmIGl0J3Mgbm90LCBpZiBpdCdzIGluc2lkZSB0aGUgcGFpbnQgYnV0dG9uLCB0aGVuIGlzUGFpbnRpbmcgPSB0cnVlLlxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZSBkb3duIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGlzSW5wdXRCb3hTZWxlY3RlZChldmVudCkge1xuICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgIGxldCByZWN0ID0gaW5wdXRCb3guZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKG1vdXNlWCA+IHJlY3QubGVmdCAmJiBtb3VzZVggPCByZWN0LnJpZ2h0ICYmIG1vdXNlWSA+IHJlY3QudG9wICYmIG1vdXNlWSA8IHJlY3QuYm90dG9tKSB7XG4gICAgICAgIC8vaXNQYWludGluZyA9IGZhbHNlO1xuICAgICAgICB0ZXh0Qm94U2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLypcbiAgICAgICAgICBsZXQgcGFpbnRCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFpbnQnKTtcbiAgICAgICAgICByZWN0ID0gcGFpbnRCdXR0b24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgaWYobW91c2VYID4gcmVjdC5sZWZ0ICYmIG1vdXNlWCA8IHJlY3QucmlnaHQgJiYgbW91c2VZID4gcmVjdC50b3AgJiYgbW91c2VZIDwgcmVjdC5ib3R0b20pIHtcbiAgICAgICAgICAgICAgaXNQYWludGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpc1BhaW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgICovXG4gICAgICAgIHRleHRCb3hTZWxlY3RlZCA9IGZhbHNlO1xuICAgIH1cbn1cbi8vY2hlY2tzIHRvIHNlZSB3aGV0aGVyIHRoZSB0ZXh0IGJveCBpcyBzZWxlY3RlZFxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGRpc2FibGVkQ2FudmFzSXNTZWxlY3RlZCk7XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyB0aGUgY2FzZSB3aGVuIGEgZGlzYWJsZWQgY2FudmFzIGlzIHNlbGVjdGVkLlxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZSBkb3duIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVkQ2FudmFzSXNTZWxlY3RlZChldmVudCkge1xuICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBwb3BVcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwb3B1cCcpO1xuICAgIGlmIChjYW52YXNJc0Rpc2FibGVkICYmIG1vdXNlWCA+IHJlY3QubGVmdCAmJiBtb3VzZVggPCByZWN0LnJpZ2h0ICYmIG1vdXNlWSA+IHJlY3QudG9wICYmIG1vdXNlWSA8IHJlY3QuYm90dG9tKSB7XG4gICAgICAgIHBvcFVwLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9wVXAuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG59XG5mdW5jdGlvbiBwcmludExvZygpIHtcbiAgICBjb25zb2xlLmxvZyhcIkxvZzogXCIpO1xuICAgIGZvciAobGV0IGVsZW0gb2YgbWFzdGVyTG9nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVsZW0uYXNzZW1ibGVMb2coKSk7XG4gICAgfVxufVxubGV0IHBhbGV0dGVCdXR0b25zID0gW1xuICAgIFwiZWxsaXBzZVwiLCBcInJlY3RcIiwgXCJzdHJpbmdcIiwgXCJudW1iZXJcIixcbiAgICBcImxpbmVcIiwgXCJjdXJ2ZVwiXG5dO1xuZm9yIChsZXQgYnV0dG9uTmFtZSBvZiBwYWxldHRlQnV0dG9ucykge1xuICAgIGxldCBwYWxldHRlQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYnV0dG9uTmFtZSk7XG4gICAgcGFsZXR0ZUJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0ZXh0Qm94U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBwcmludE5ld05vZGUoYnV0dG9uTmFtZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHByaW50TmV3Tm9kZShidXR0b25OYW1lKSB7XG4gICAgbGV0IHByaW50TGluZSA9IFwiXCI7XG4gICAgc3dpdGNoIChidXR0b25OYW1lKSB7XG4gICAgICAgIGNhc2UgXCJlbGxpcHNlXCI6XG4gICAgICAgICAgICBwcmludExpbmUgPSBcInByaW50KGVsbGlwc2UoMTAwLDEwMCkpO1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWN0XCI6XG4gICAgICAgICAgICBwcmludExpbmUgPSBcInByaW50KHJlY3QoMTAwLDEwMCkpO1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHByaW50TGluZSA9ICdwcmludChcIm5ld1dvcmRcIik7JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBwcmludExpbmUgPSBcInByaW50KDEwKTtcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICAgICAgcHJpbnRMaW5lID0gXCJwcmludChsaW5lKDEwMCwxMDApKTtcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY3VydmVcIjpcbiAgICAgICAgICAgIHByaW50TGluZSA9IFwicHJpbnQoY3VydmUoMTAwLDEwMCwxMDApKTtcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQcm9ibGVtIHdpdGggXCIgKyBidXR0b25OYW1lKTtcbiAgICB9XG4gICAgaW5wdXRCb3gudmFsdWUgKz0gcHJpbnRMaW5lO1xufVxubGV0IGluc3RydWN0aW9ucyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnb2FsJyk7XG5sZXQgcmV3YXJkQm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jld2FyZC1jb250YWluZXInKTtcbmxldCBpbnN0ckxhYmVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luc3RyLWxhYmVsJyk7XG4vL01hcCBtYWludGFpbmluZyBjb2RlIGxhc3QgdXNlZCBhdCBhIGNoZWNrcG9pbnRcbmxldCBjcENvZGUgPSBuZXcgTWFwKFtcbiAgICBbJ2wxYzEnLCBcIlwiXSxcbiAgICBbJ2wxYzInLCBcIlwiXSxcbiAgICBbJ2wxYzMnLCBcIlwiXSxcbiAgICBbJ2wxYzQnLCBcIlwiXSxcbiAgICBbJ2wyYzEnLCBcIlwiXSxcbiAgICBbJ2wyYzInLCBcIlwiXSxcbiAgICBbJ2wyYzMnLCBcIlwiXSxcbiAgICBbJ2wyYzQnLCBcIlwiXSxcbiAgICBbJ2wyYzUnLCBcIlwiXSxcbiAgICBbJ2wyYzYnLCBcIlwiXSxcbiAgICBbJ2wyYzcnLCBcIlwiXSxcbiAgICBbJ2wzYzEnLCBcIlwiXSxcbiAgICBbJ2wzYzInLCBcIlwiXSxcbiAgICBbJ2wzYzMnLCBcIlwiXSxcbiAgICBbJ2wzYzQnLCBcIlwiXSxcbiAgICBbJ2wzYzUnLCBcIlwiXSxcbiAgICBbJ2wzYzYnLCBcIlwiXSxcbiAgICBbJ2w0YzEnLCBcIlwiXSxcbiAgICBbJ2w0YzInLCBcIlwiXVxuXSk7XG4vL01hcCBtYWludGFpbmluZyB3aGV0aGVyIGEgY2hlY2twb2ludCBoYXMgYmVlbiBjb21wbGV0ZWRcbmxldCBjcENvbXBsZXRpb24gPSBuZXcgTWFwKFtcbiAgICBbJ2wxYzEnLCBmYWxzZV0sXG4gICAgWydsMWMyJywgZmFsc2VdLFxuICAgIFsnbDFjMycsIGZhbHNlXSxcbiAgICBbJ2wxYzQnLCBmYWxzZV0sXG4gICAgWydsMmMxJywgZmFsc2VdLFxuICAgIFsnbDJjMicsIGZhbHNlXSxcbiAgICBbJ2wyYzMnLCBmYWxzZV0sXG4gICAgWydsMmM0JywgZmFsc2VdLFxuICAgIFsnbDJjNScsIGZhbHNlXSxcbiAgICBbJ2wyYzYnLCBmYWxzZV0sXG4gICAgWydsMmM3JywgZmFsc2VdLFxuICAgIFsnbDNjMScsIGZhbHNlXSxcbiAgICBbJ2wzYzInLCBmYWxzZV0sXG4gICAgWydsM2MzJywgZmFsc2VdLFxuICAgIFsnbDNjNCcsIGZhbHNlXSxcbiAgICBbJ2wzYzUnLCBmYWxzZV0sXG4gICAgWydsM2M2JywgZmFsc2VdLFxuICAgIFsnbDRjMScsIGZhbHNlXSxcbiAgICBbJ2w0YzInLCBmYWxzZV1cbl0pO1xubGV0IGNoZWNrcG9pbnRzID0gbmV3IE1hcChbXG4gICAgWydsMWMxJywgKCkgPT4gbmV3IGluZGV4XzMuTGVzc29uT25lQ3BPbmUoKV0sXG4gICAgWydsMWMyJywgKCkgPT4gbmV3IGluZGV4XzMuTGVzc29uT25lQ3BUd28oKV0sXG4gICAgWydsMWMzJywgKCkgPT4gbmV3IGluZGV4XzMuTGVzc29uT25lQ3BUaHJlZSgpXSxcbiAgICBbJ2wxYzQnLCAoKSA9PiBuZXcgaW5kZXhfMy5MZXNzb25PbmVDcEZvdXIoKV0sXG4gICAgWydsMmMxJywgKCkgPT4gbmV3IGluZGV4XzQuTGVzc29uVHdvQ3BPbmUoKV0sXG4gICAgWydsMmMyJywgKCkgPT4gbmV3IGluZGV4XzQuTGVzc29uVHdvQ3BUd28oKV0sXG4gICAgWydsMmMzJywgKCkgPT4gbmV3IGluZGV4XzQuTGVzc29uVHdvQ3BUaHJlZSgpXSxcbiAgICBbJ2wyYzQnLCAoKSA9PiBuZXcgaW5kZXhfNC5MZXNzb25Ud29DcEZvdXIoKV0sXG4gICAgWydsMmM1JywgKCkgPT4gbmV3IGluZGV4XzQuTGVzc29uVHdvQ3BGaXZlKCldLFxuICAgIFsnbDJjNicsICgpID0+IG5ldyBpbmRleF80Lkxlc3NvblR3b0NwU2l4KCldLFxuICAgIFsnbDJjNycsICgpID0+IG5ldyBpbmRleF80Lkxlc3NvblR3b0NwU2V2ZW4oKV0sXG4gICAgWydsM2MxJywgKCkgPT4gbmV3IGluZGV4XzUuTGVzc29uVGhyZWVDcE9uZSgpXSxcbiAgICBbJ2wzYzInLCAoKSA9PiBuZXcgaW5kZXhfNS5MZXNzb25UaHJlZUNwVHdvKCldLFxuICAgIFsnbDNjMycsICgpID0+IG5ldyBpbmRleF81Lkxlc3NvblRocmVlQ3BUaHJlZSgpXSxcbiAgICBbJ2wzYzQnLCAoKSA9PiBuZXcgaW5kZXhfNS5MZXNzb25UaHJlZUNwRm91cigpXSxcbiAgICBbJ2wzYzUnLCAoKSA9PiBuZXcgaW5kZXhfNS5MZXNzb25UaHJlZUNwRml2ZSgpXSxcbiAgICBbJ2wzYzYnLCAoKSA9PiBuZXcgaW5kZXhfNS5MZXNzb25UaHJlZUNwU2l4KCldLFxuICAgIFsnbDRjMScsICgpID0+IG5ldyBpbmRleF82Lkxlc3NvbkZvdXJDcE9uZSgpXSxcbiAgICBbJ2w0YzInLCAoKSA9PiBuZXcgaW5kZXhfNi5MZXNzb25Gb3VyQ3BUd28oKV1cbl0pO1xuZm9yIChsZXQgY3Agb2YgY2hlY2twb2ludHMua2V5cygpKSB7XG4gICAgbGV0IGNwQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY3ApO1xuICAgIGNwQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluaXRDaGVja3BvaW50KGNwKTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbW9kdWxlIGNvcnJlc3BvbmRpbmcgdG8gYSBjaGVja3BvaW50IHBhc3NlZCBpbi5cbiAqIFNldHMgdXAgdGhlIGluc3RydWN0aW9uLCBDT0RFIGFyZWEsIGFuZCBnb2FsIGJveCBhY2NvcmRpbmdseS5cbiAqIEBwYXJhbSBjcDogdGhlIG5hbWUgb2YgdGhlIGNoZWNrcG9pbnRcbiAqL1xuZnVuY3Rpb24gaW5pdENoZWNrcG9pbnQoY3ApIHtcbiAgICBpZiAoY2hlY2twb2ludHMuaGFzKGNwKSkge1xuICAgICAgICBpZiAoY2hlY2twb2ludCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjcENvZGUuc2V0KGNoZWNrcG9pbnQuX25hbWUsIGlucHV0Qm94LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhcIkluaXRpYXRpbmcgY2hlY2twb2ludCBcIiArIGNwKTtcbiAgICAgICAgY2hlY2twb2ludCA9IGNoZWNrcG9pbnRzLmdldChjcCkoKTtcbiAgICAgICAgaW5zdHJMYWJlbC5pbm5lckhUTUwgPSBjcCArIFwiIC0gSU5TVFJVQ1RJT05TXCI7XG4gICAgICAgIGluc3RydWN0aW9ucy5pbm5lckhUTUwgPSBjaGVja3BvaW50Ll9pbnN0cnVjdGlvbnM7XG4gICAgICAgIC8vc2V0IHVwIHRoZSBDT0RFIGFuZCBDQU5WQVMgYXJlYXNcbiAgICAgICAgaWYgKGNoZWNrcG9pbnQuX2NvbnN0cmFpbnQgPT0gJ2NvZGUnKSB7XG4gICAgICAgICAgICBpbnB1dEJveC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICBpbnB1dEJveC5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSAnI0VCRUJFQic7XG4gICAgICAgICAgICBjYW52YXNJc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hlY2twb2ludC5fY29uc3RyYWludCA9PSAnY2FudmFzJykge1xuICAgICAgICAgICAgaW5wdXRCb3gucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgaW5wdXRCb3guc3R5bGUub3BhY2l0eSA9ICcxLjAnO1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kID0gJyNDMEMwQzAnO1xuICAgICAgICAgICAgY2FudmFzSXNEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnB1dEJveC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICBpbnB1dEJveC5zdHlsZS5vcGFjaXR5ID0gJzEuMCc7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSAnI0VCRUJFQic7XG4gICAgICAgICAgICBjYW52YXNJc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBvcFVwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BvcHVwJyk7XG4gICAgICAgIHBvcFVwLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGlmIChjcENvZGUuZ2V0KGNoZWNrcG9pbnQuX25hbWUpICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB0ZXh0Qm94U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaW5wdXRCb3gudmFsdWUgPSBjcENvZGUuZ2V0KGNoZWNrcG9pbnQuX25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vc2V0IHVwIHRoZSBpbnN0cnVjdGlvbiBhbmQgZ29hbCBib3hlc1xuICAgICAgICBpZiAoY3BDb21wbGV0aW9uLmdldChjcCkpIHtcbiAgICAgICAgICAgIHVwZGF0ZVJld2FyZEJveCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoZWNrcG9pbnQuX3N0YXJ0ZXJDb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZXh0Qm94U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlucHV0Qm94LnZhbHVlID0gY2hlY2twb2ludC5fc3RhcnRlckNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hlY2twb2ludC5fbmFtZSA9PT0gXCJsMWMxXCIpIHtcbiAgICAgICAgICAgICAgICBjaGVja3BvaW50LnJlbmRlckluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJld2FyZEJveC5zdHlsZS5iYWNrZ3JvdW5kID0gJyNDMEMwQzAnO1xuICAgICAgICAgICAgbGV0IHJld2FyZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXdhcmQtdGV4dCcpO1xuICAgICAgICAgICAgcmV3YXJkLnN0eWxlLmNvbG9yID0gJ2JsYWNrJztcbiAgICAgICAgICAgIHJld2FyZC5pbm5lckhUTUwgPSAnQ29tcGxldGUgZ29hbCB0byBlYXJuIGEgc3RhciEnO1xuICAgICAgICAgICAgbGV0IHJld2FyZEltZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXdhcmQtaW1hZ2UnKTtcbiAgICAgICAgICAgIHJld2FyZEltZy5zcmMgPSAncGljcy9ncmV5c3Rhci5zdmcnO1xuICAgICAgICAgICAgcmV3YXJkSW1nLmFsdCA9ICdhIHN0YXIgdG8gYmUgZWFybmVkJztcbiAgICAgICAgICAgIGxldCBuZXh0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25leHQnKTtcbiAgICAgICAgICAgIG5leHRCdG4uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGluc3RydWN0aW9ucy5zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgY2hlY2twb2ludElzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrcG9pbnRDaGVja3NHb2FsKCkge1xuICAgIGlmIChjaGVja3BvaW50LmNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykpIHtcbiAgICAgICAgdXBkYXRlUmV3YXJkQm94KCk7XG4gICAgICAgIGNwQ29tcGxldGlvbi5zZXQoY2hlY2twb2ludC5fbmFtZSwgdHJ1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlUmV3YXJkQm94KCkge1xuICAgIHJld2FyZEJveC5zdHlsZS5iYWNrZ3JvdW5kID0gJyM2NzNBQjcnO1xuICAgIGNvbnNvbGUubG9nKGRvY3VtZW50KTtcbiAgICBsZXQgcmV3YXJkVGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXdhcmQtdGV4dCcpO1xuICAgIHJld2FyZFRleHQuc3R5bGUuY29sb3IgPSAnI0Q4RDhEOCc7XG4gICAgcmV3YXJkVGV4dC5pbm5lckhUTUwgPSAnR29hbCBtZXQhJztcbiAgICBsZXQgcmV3YXJkSW1nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jld2FyZC1pbWFnZScpO1xuICAgIHJld2FyZEltZy5zcmMgPSAncGljcy9zdGFyLnN2Zyc7XG4gICAgcmV3YXJkSW1nLmFsdCA9ICdzdGFyIGVhcm5lZCc7XG4gICAgbGV0IG5leHRCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmV4dCcpO1xuICAgIG5leHRCdG4uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgaW5zdHJ1Y3Rpb25zLmlubmVySFRNTCArPSBcIlxcbkhvb3JheSEgR29hbCBtZXQhIENsaWNrICdOZXh0JyB0byBwcm9jZWVkIHRvIG5leHQgY2hlY2twb2ludCFcIjtcbiAgICBpbnN0cnVjdGlvbnMuc2Nyb2xsVG9wID0gaW5zdHJ1Y3Rpb25zLnNjcm9sbEhlaWdodDtcbiAgICBjaGVja3BvaW50SXNBY3RpdmUgPSBmYWxzZTtcbn1cbmxldCBuZXh0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25leHQnKTtcbm5leHRCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgbmV4dE1vZHVsZSA9IGNoZWNrcG9pbnQuX25leHRNb2R1bGU7XG4gICAgaWYgKG5leHRNb2R1bGUgIT0gJycpIHtcbiAgICAgICAgaW5pdENoZWNrcG9pbnQobmV4dE1vZHVsZSk7XG4gICAgfVxufTtcbmxldCBwcmV2QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ByZXYnKTtcbnByZXZCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcHJldk1vZHVsZSA9IGNoZWNrcG9pbnQuX3ByZXZNb2R1bGU7XG4gICAgaWYgKHByZXZNb2R1bGUgIT0gJycpIHtcbiAgICAgICAgaW5pdENoZWNrcG9pbnQocHJldk1vZHVsZSk7XG4gICAgfVxufTtcbi8vY2FsbCB0byBhbmltYXRlXG5hbmltYXRlKCk7XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiB0ZXN0IGxpbmVzIG9mIFMuVy5FLkwuTC4gY29kZVxuXG5wcmludChcImhlbGxvIHdvcmxkXCIsIDE4MCwgNDIxKTtcbnByaW50KGVsbGlwc2UoNzUsIDUwKSwgMTAwLCAxMDApO1xucHJpbnQocmVjdCg2MCwgNzApLCAyNTAsIDI1MCk7XG5cbnByaW50KFwiaGVsbG9cIik7XG5wcmludChcIndvcmxkXCIpO1xuXG5PdXIgc2FtcGxlIHByb2dyYW1cbnByaW50KFwiaGVsbG8gd29ybGRcIik7XG5wcmludChlbGxpcHNlKDEzMCwgMTAwKSk7XG4qL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBVbmFyeU9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vVW5hcnlPcGVyYXRpb25cIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIE5lZ09wIGV4dGVuZHMgVW5hcnlPcGVyYXRpb25fMS5VbmFyeU9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgTmVnYXRpb25PcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSB0byBiZSBuZWdhdGVkIChtdXN0IGJlIGEgTnVtYmVyTm9kZSlcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2YWwsIHdzKSB7XG4gICAgICAgIHN1cGVyKHZhbCk7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgdGhlIHZhbHVlIGludG8gdGhlIG5lZ2F0aXZlIHZlcnNpb25cbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHYgPSB0aGlzLnZhbC5ldmFsKGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKC12LnZhbCwgXCJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5lZ09wcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5lZ2F0aW9uIG9wcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgTmVnT3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIE5lZ09wXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBOZWdPcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyBcIi1cIiArIHRoaXMudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuTmVnT3AgPSBOZWdPcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5lZ09wLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IGNsYXNzIGNvbnN0cnVjdG9yIGZvciBVbmFyeSBPcGVyYXRpb25zXG4gICAgICogQHBhcmFtIF92YWwgVGhlIG9iamVjdCB0byBiZSBvcGVyYXRlZCBvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF92YWwpIHtcbiAgICAgICAgdGhpcy5fdmFsID0gX3ZhbDtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWJzdHJhY3QgZHJhdyBtZXRob2QgZm9yIHVuZHJhd2FibGUgVW5hcnlPcHNcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYXJ5IE9wZXJhdGlvbnMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBVbmFyeU9wc1xuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gVW5hcnlPcFwiKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVW5hcnlPcCB2YWx1ZVxuICAgICAqL1xuICAgIGdldCB2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFVuYXJ5T3AgdmFsdWVcbiAgICAgKi9cbiAgICBzZXQgdmFsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbCA9IHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5hcnlPcGVyYXRpb24gPSBVbmFyeU9wZXJhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuYXJ5T3BlcmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVmFyaWFibGVOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBWYXJpYWJsZU5vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYSB2YXJpYWJsZVxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSB2YXJpYWJsZSBuYW1lXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgaW4gdGhlIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQubG9va3VwKHRoaXMuX25hbWUsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYXJpYWJsZU5vZGVzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdyBvbiB2YXJpYWJsZSBub2Rlc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gVmFyaWFibGVOb2Rlc1xuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGlyZWN0bHkgY29tcGFyZSB2YXJzLCBldmFsIGZpcnN0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBWYXJpYWJsZU5vZGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLlZhcmlhYmxlTm9kZSA9IFZhcmlhYmxlTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhcmlhYmxlTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICBTaGFsbG93IHVwZGF0ZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbi8qKiBQZXJmb3JtcyBhIHNoYWxsb3cgdXBkYXRlIG9mIGFuIG9iamVjdCB1c2luZyBhIHBhcnRpYWwgb2JqZWN0IG9mIHRoZSBzYW1lIHNoYXBlLiBBIG5ldyBvYmplY3QgaXMgcmV0dXJuZWQuICovXG5mdW5jdGlvbiB1cGRhdGUoaG9zdCwgc3BlYykge1xuICAgIHZhciByZXN1bHQgPSBjbG9uZShob3N0KTtcbiAgICBmb3IgKHZhciBrZXkgaW4gc3BlYykge1xuICAgICAgICB2YXIgc3BlY1ZhbHVlID0gc3BlY1trZXldO1xuICAgICAgICBpZiAoc3BlY1ZhbHVlID09PSBleHBvcnRzLkRFTEVURSkge1xuICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBzcGVjVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudXBkYXRlID0gdXBkYXRlO1xuLy8gV2UgbGllIGFib3V0IHRoZSBwdWJsaWMgdHlwZSBzbyB0aGF0IG9ubHkgYSBwcm9wZXJ0eSB0aGF0IGlzIG9wdGlvbmFsIG9yIHRoYXQgY2FuIGJlIGFzc2lnbmVkIHRvIHVuZGVmaW5lZCBjYW4gYmUgREVMRVRFJ2Rcbi8qKiBNYXJrZXIgdXNlZCB0byBkZWxldGUgYSBrZXkgKi9cbmV4cG9ydHMuREVMRVRFID0ge307XG52YXIgX1VwZGF0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX1VwZGF0ZXIoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBfVXBkYXRlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoa2V5T3JJbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IF9VcGRhdGVyKHsgdHlwZTogJ2F0JywgcGFyZW50OiB0aGlzLCBmaWVsZDoga2V5T3JJbmRleCB9KTtcbiAgICB9O1xuICAgIF9VcGRhdGVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRvU2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLmNsb25lRm9yVXBkYXRlKHRhcmdldCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lm5hbWUgPT09ICdhYm9ydGVkJylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGNsb25lZFRhcmdldCA9IHJlc3VsdC5jbG9uZWRUYXJnZXQsIGxlYWZIb3N0ID0gcmVzdWx0LmxlYWZIb3N0LCBmaWVsZCA9IHJlc3VsdC5maWVsZDtcbiAgICAgICAgICAgIHZhbHVlID09PSBleHBvcnRzLkRFTEVURSA/IGRlbGV0ZSBsZWFmSG9zdFtmaWVsZF0gOiBsZWFmSG9zdFtmaWVsZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZWRUYXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBib3VuZFRhcmdldCA9IHRoaXMuZmluZEJvdW5kVGFyZ2V0KCk7XG4gICAgICAgIHJldHVybiBib3VuZFRhcmdldFxuICAgICAgICAgICAgPyBkb1NldChib3VuZFRhcmdldClcbiAgICAgICAgICAgIDogZG9TZXQ7XG4gICAgfTtcbiAgICBfVXBkYXRlci5wcm90b3R5cGUubW9kaWZ5ID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkb01vZGlmeSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5jbG9uZUZvclVwZGF0ZSh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5uYW1lID09PSAnYWJvcnRlZCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIHZhciBjbG9uZWRUYXJnZXQgPSByZXN1bHQuY2xvbmVkVGFyZ2V0LCBsZWFmSG9zdCA9IHJlc3VsdC5sZWFmSG9zdCwgZmllbGQgPSByZXN1bHQuZmllbGQ7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBtb2RpZmllcihsZWFmSG9zdFtmaWVsZF0pO1xuICAgICAgICAgICAgdmFsdWUgPT09IGV4cG9ydHMuREVMRVRFID8gZGVsZXRlIGxlYWZIb3N0W2ZpZWxkXSA6IGxlYWZIb3N0W2ZpZWxkXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lZFRhcmdldDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJvdW5kVGFyZ2V0ID0gdGhpcy5maW5kQm91bmRUYXJnZXQoKTtcbiAgICAgICAgcmV0dXJuIGJvdW5kVGFyZ2V0XG4gICAgICAgICAgICA/IGRvTW9kaWZ5KGJvdW5kVGFyZ2V0KVxuICAgICAgICAgICAgOiBkb01vZGlmeTtcbiAgICB9O1xuICAgIF9VcGRhdGVyLnByb3RvdHlwZS53aXRoRGVmYXVsdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IF9VcGRhdGVyKHsgdHlwZTogJ3dpdGhEZWZhdWx0JywgcGFyZW50OiB0aGlzLCBkZWZhdWx0VmFsdWU6IHZhbHVlIH0pO1xuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLmFib3J0SWZVbmRlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfVXBkYXRlcih7IHR5cGU6ICdhYm9ydElmVW5kZWYnLCBwYXJlbnQ6IHRoaXMgfSk7XG4gICAgfTtcbiAgICBfVXBkYXRlci5wcm90b3R5cGUuZmluZEJvdW5kVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5kYXRhLnR5cGUgPT09ICdyb290JylcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudC5kYXRhLmJvdW5kVGFyZ2V0O1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuZGF0YS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9VcGRhdGVyLnByb3RvdHlwZS5wYXJlbnRVcGRhdGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVwZGF0ZXJzID0gW3RoaXNdO1xuICAgICAgICB2YXIgcGFyZW50VXBkYXRlciA9IHRoaXMuZGF0YS5wYXJlbnQ7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgcm9vdCB1cGRhdGVyXG4gICAgICAgIHdoaWxlIChwYXJlbnRVcGRhdGVyICYmIHBhcmVudFVwZGF0ZXIuZGF0YS5wYXJlbnQpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJzLnVuc2hpZnQocGFyZW50VXBkYXRlcik7XG4gICAgICAgICAgICBwYXJlbnRVcGRhdGVyID0gcGFyZW50VXBkYXRlci5kYXRhLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBkYXRlcnM7XG4gICAgfTtcbiAgICBfVXBkYXRlci5wcm90b3R5cGUuZ2V0TmV4dFZhbHVlID0gZnVuY3Rpb24gKHByZXZpb3VzSG9zdCwgaG9zdCwgZmllbGQsIGlzTGFzdCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhLnR5cGUgPT09ICdhdCcpIHtcbiAgICAgICAgICAgIHZhciBuZXdGaWVsZCA9IHRoaXMuZGF0YS5maWVsZDtcbiAgICAgICAgICAgIHZhciB2YWx1ZV8xID0gaG9zdFtuZXdGaWVsZF07XG4gICAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gaXNPYmplY3RPckFycmF5KHZhbHVlXzEpID8gY2xvbmUodmFsdWVfMSkgOiB2YWx1ZV8xO1xuICAgICAgICAgICAgdmFyIG5ld0hvc3RfMSA9IGlzTGFzdCA/IGhvc3QgOiBuZXh0VmFsdWU7XG4gICAgICAgICAgICBob3N0W3RoaXMuZGF0YS5maWVsZF0gPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4geyBob3N0OiBuZXdIb3N0XzEsIGZpZWxkOiBuZXdGaWVsZCB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IHByZXZpb3VzSG9zdFtmaWVsZF07XG4gICAgICAgIGlmICh0aGlzLmRhdGEudHlwZSA9PT0gJ2Fib3J0SWZVbmRlZicgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaG9zdDogaG9zdCwgZmllbGQ6IGZpZWxkLCBhYm9ydGVkOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF0YS50eXBlID09PSAnd2l0aERlZmF1bHQnICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBuZXh0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgdmFyIG5ld0hvc3RfMiA9IGlzTGFzdCA/IHByZXZpb3VzSG9zdCA6IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIHByZXZpb3VzSG9zdFtmaWVsZF0gPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4geyBob3N0OiBuZXdIb3N0XzIsIGZpZWxkOiBmaWVsZCB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdIb3N0ID0gaXNMYXN0ID8gcHJldmlvdXNIb3N0IDogaG9zdDtcbiAgICAgICAgcmV0dXJuIHsgaG9zdDogbmV3SG9zdCwgZmllbGQ6IGZpZWxkIH07XG4gICAgfTtcbiAgICBfVXBkYXRlci5wcm90b3R5cGUuY2xvbmVGb3JVcGRhdGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciB1cGRhdGVycyA9IHRoaXMucGFyZW50VXBkYXRlcnMoKTtcbiAgICAgICAgdmFyIG9iaiA9IGNsb25lKHRhcmdldCk7XG4gICAgICAgIHZhciBwcmV2aW91c0hvc3QgPSBvYmo7XG4gICAgICAgIHZhciBob3N0ID0gb2JqO1xuICAgICAgICB2YXIgZmllbGQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHVwZGF0ZXJzW2ldLmdldE5leHRWYWx1ZShwcmV2aW91c0hvc3QsIGhvc3QsIGZpZWxkLCBpID09PSB1cGRhdGVycy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuYWJvcnRlZClcbiAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lOiAnYWJvcnRlZCcgfTtcbiAgICAgICAgICAgIHByZXZpb3VzSG9zdCA9IGhvc3Q7XG4gICAgICAgICAgICBob3N0ID0gcmVzdWx0Lmhvc3Q7XG4gICAgICAgICAgICBmaWVsZCA9IHJlc3VsdC5maWVsZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ3Jlc3VsdCcsXG4gICAgICAgICAgICBjbG9uZWRUYXJnZXQ6IG9iaixcbiAgICAgICAgICAgIGxlYWZIb3N0OiBob3N0LFxuICAgICAgICAgICAgZmllbGQ6IGZpZWxkXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gX1VwZGF0ZXI7XG59KCkpO1xuZnVuY3Rpb24gaXNPYmplY3RPckFycmF5KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59XG5mdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKVxuICAgICAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gICAgdmFyIGNsb25lZCA9IHt9O1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGNsb25lZFtrZXldID0gb2JqW2tleV07IH0pO1xuICAgIHJldHVybiBjbG9uZWQ7XG59XG5mdW5jdGlvbiBkZWVwVXBkYXRlKHRhcmdldCkge1xuICAgIHJldHVybiBuZXcgX1VwZGF0ZXIoeyB0eXBlOiAncm9vdCcsIGJvdW5kVGFyZ2V0OiB0YXJnZXQgfSk7XG59XG5leHBvcnRzLmRlZXBVcGRhdGUgPSBkZWVwVXBkYXRlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2hhclV0aWw7XG4oZnVuY3Rpb24gKENoYXJVdGlsKSB7XG4gICAgY2xhc3MgQ2hhclN0cmVhbSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHMsIHN0YXJ0cG9zLCBlbmRwb3MsIGhhc0VPRikge1xuICAgICAgICAgICAgdGhpcy5oYXNFT0YgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IHM7XG4gICAgICAgICAgICBpZiAoaGFzRU9GICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzRU9GID0gaGFzRU9GO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0cG9zID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRwb3MgPSAwOyAvLyBub3Qgc3BlY2lmaWVkOyBzZXQgZGVmYXVsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRwb3MgPiBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRwb3MgPSBzLmxlbmd0aDsgLy8gc2VlayB0b28gZmFyOyBzZXQgRU9GXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0cG9zID0gc3RhcnRwb3M7IC8vIHNwZWNpZmllZCBhbmQgaW4gYm91bmRzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kcG9zID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9zID0gcy5sZW5ndGg7IC8vIG5vdCBzcGVjaWZpZWQ7IHNldCBkZWZhdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmRwb3MgPiBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9zID0gcy5sZW5ndGg7IC8vIHNlZWsgdG9vIGZhcjsgc2V0IEVPRlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRwb3MgPSBlbmRwb3M7IC8vIHNwZWNpZmllZCBhbmQgaW4gYm91bmRzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydHBvcyA+IHRoaXMuZW5kcG9zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydHBvcyA9IHRoaXMuZW5kcG9zOyAvLyBpZiB0aGUgdXNlciBmbGlwcGVkIHBvc2l0aW9uc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgb2YgdGhlIGVuZCBvZiB0aGUgaW5wdXQgaGFzIGJlZW4gcmVhY2hlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlzRU9GKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzRU9GICYmIHRoaXMuc3RhcnRwb3MgPT0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBKYXZzY3JpcHQgcHJpbWl0aXZlIHN0cmluZyBvZiB0aGUgc2xpY2Ugb2YgaW5wdXRcbiAgICAgICAgICogcmVwcmVzZW50ZWQgYnkgdGhpcyBDaGFyU3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5zdWJzdHJpbmcodGhpcy5zdGFydHBvcywgdGhpcy5lbmRwb3MpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IENoYXJTdHJlYW0gcmVwcmVzZW50aW5nIHRoZSBpbnB1dCBmcm9tIHRoZVxuICAgICAgICAgKiBjdXJyZW50IHN0YXJ0IHBvc2l0aW9uIHRvIGFuIGVuZCBwb3NpdGlvbiBudW0gY2hhcnMgZnJvbVxuICAgICAgICAgKiB0aGUgY3VycmVudCBzdGFydCBwb3NpdGlvbi4gIElmIHN0YXJ0cG9zICsgbnVtID4gZW5kcG9zLFxuICAgICAgICAgKiB0aGUgY3VycmVudCBDaGFyU3RyZWFtIGlzIHJldHVybmVkLlxuICAgICAgICAgKiBAcGFyYW0gbnVtXG4gICAgICAgICAqL1xuICAgICAgICBwZWVrKG51bSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRwb3MgKyBudW0gPiB0aGlzLmVuZHBvcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0hhc0VPRiA9IHRoaXMuc3RhcnRwb3MgKyBudW0gPT0gdGhpcy5lbmRwb3MgJiYgdGhpcy5oYXNFT0Y7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFyU3RyZWFtKHRoaXMuaW5wdXQsIHRoaXMuc3RhcnRwb3MsIHRoaXMuc3RhcnRwb3MgKyBudW0sIG5ld0hhc0VPRik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgQ2hhclN0cmVhbSByZXByZXNlbnRpbmcgdGhlIHN0cmluZyBhZnRlclxuICAgICAgICAgKiBzZWVraW5nIG51bSBjaGFyYWN0ZXJzIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAqIEBwYXJhbSBudW1cbiAgICAgICAgICovXG4gICAgICAgIHNlZWsobnVtKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydHBvcyArIG51bSA+IHRoaXMuZW5kcG9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFyU3RyZWFtKHRoaXMuaW5wdXQsIHRoaXMuZW5kcG9zLCB0aGlzLmVuZHBvcywgdGhpcy5oYXNFT0YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFyU3RyZWFtKHRoaXMuaW5wdXQsIHRoaXMuc3RhcnRwb3MgKyBudW0sIHRoaXMuZW5kcG9zLCB0aGlzLmhhc0VPRik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgQ2hhclN0cmVhbSByZXByZXNlbnRpbmcgdGhlIGhlYWQgb2YgdGhlIGlucHV0IGF0XG4gICAgICAgICAqIHRoZSBjdXJyZW50IHBvc2l0aW9uLiAgVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgQ2hhclN0cmVhbSBpc1xuICAgICAgICAgKiBlbXB0eS5cbiAgICAgICAgICovXG4gICAgICAgIGhlYWQoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SGFzRU9GID0gdGhpcy5zdGFydHBvcyArIDEgPT0gdGhpcy5lbmRwb3MgJiYgdGhpcy5oYXNFT0Y7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFyU3RyZWFtKHRoaXMuaW5wdXQsIHRoaXMuc3RhcnRwb3MsIHRoaXMuc3RhcnRwb3MgKyAxLCBuZXdIYXNFT0YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgaGVhZCBvZiBhbiBlbXB0eSBzdHJpbmcuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IENoYXJTdHJlYW0gcmVwcmVzZW50aW5nIHRoZSB0YWlsIG9mIHRoZSBpbnB1dCBhdFxuICAgICAgICAgKiB0aGUgY3VycmVudCBwb3NpdGlvbi4gIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIENoYXJTdHJlYW0gaXNcbiAgICAgICAgICogZW1wdHkuXG4gICAgICAgICAqL1xuICAgICAgICB0YWlsKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbSh0aGlzLmlucHV0LCB0aGlzLnN0YXJ0cG9zICsgMSwgdGhpcy5lbmRwb3MsIHRoaXMuaGFzRU9GKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHRhaWwgb2YgYW4gZW1wdHkgc3RyaW5nLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBpbnB1dCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyBlbXB0eS4gTm90ZVxuICAgICAgICAgKiB0aGF0IGEgQ2hhclN0cmVhbSBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBjb250YWlucyBhbiBlbXB0eVxuICAgICAgICAgKiBzdHJpbmcgYnV0IHRoYXQgYW4gZW1wdHkgc3RyaW5nIG1heSBub3QgYmUgdGhlIGVuZC1vZi1maWxlIChpLmUuLFxuICAgICAgICAgKiBpc0VPRiBpcyBmYWxzZSkuXG4gICAgICAgICAqL1xuICAgICAgICBpc0VtcHR5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRwb3MgPT0gdGhpcy5lbmRwb3M7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHJlbWFpbmluZyBhdFxuICAgICAgICAgKiB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGxlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZHBvcyAtIHRoaXMuc3RhcnRwb3M7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHN1YnN0cmluZyBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgYXQgdGhlXG4gICAgICAgICAqIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAqIEBwYXJhbSBzdGFydCB0aGUgc3RhcnQgaW5kZXggb2YgdGhlIHN1YnN0cmluZywgaW5jbHVzaXZlXG4gICAgICAgICAqIEBwYXJhbSBlbmQgdGhlIGVuZCBpbmRleCBvZiB0aGUgc3Vic3RyaW5nLCBleGNsdXNpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN1YnN0cmluZyhzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydDIgPSB0aGlzLnN0YXJ0cG9zICsgc3RhcnQ7XG4gICAgICAgICAgICBjb25zdCBlbmQyID0gdGhpcy5zdGFydHBvcyArIGVuZDtcbiAgICAgICAgICAgIGNvbnN0IG5ld0hhc0VPRiA9IHRoaXMuZW5kcG9zID09IGVuZDIgJiYgdGhpcy5oYXNFT0Y7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYXJTdHJlYW0odGhpcy5pbnB1dCwgc3RhcnQyLCBlbmQyLCBuZXdIYXNFT0YpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSBjdXJyZW50IENoYXJTdHJlYW0gd2l0aFxuICAgICAgICAgKiB0aGUgZ2l2ZW4gQ2hhclN0cmVhbS4gTm90ZTogcmV0dXJuZWQgb2JqZWN0IGRvZXMgbm90XG4gICAgICAgICAqIHJldXNlIG9yaWdpbmFsIGlucHV0IHN0cmluZywgYW5kIHN0YXJ0cG9zIGFuZCBlbmRwb3NcbiAgICAgICAgICogYXJlIHJlc2V0LiBJZiB0aGUgZ2l2ZW4gQ2hhclN0cmVhbSBjb250YWlucyBFT0YsIHRoZVxuICAgICAgICAgKiBjb25jYXRlbmF0ZWQgQ2hhclN0cmVhbSB3aWxsIGFsc28gY29udGFpbiBFT0YuXG4gICAgICAgICAqIEBwYXJhbSBjcyB0aGUgQ2hhclN0cmVhbSB0byBjb25jYXQgdG8gdGhpcyBDaGFyU3RyZWFtXG4gICAgICAgICAqL1xuICAgICAgICBjb25jYXQoY3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLnRvU3RyaW5nKCkgKyBjcy50b1N0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFyU3RyZWFtKHMsIDAsIHMubGVuZ3RoLCBjcy5oYXNFT0YpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25jYXRlbmF0ZSBhbiBhcnJheSBvZiBDaGFyU3RyZWFtIG9iamVjdHMgaW50byBhIHNpbmdsZVxuICAgICAgICAgKiBDaGFyU3RyZWFtIG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIGNzcyBhIENoYXJTdHJlYW1bXVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNvbmNhdChjc3MpIHtcbiAgICAgICAgICAgIGlmIChjc3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENoYXJTdHJlYW0oXCJcIiwgMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNzID0gY3NzWzBdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY3NzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzID0gY3MuY29uY2F0KGNzc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBDaGFyVXRpbC5DaGFyU3RyZWFtID0gQ2hhclN0cmVhbTtcbn0pKENoYXJVdGlsID0gZXhwb3J0cy5DaGFyVXRpbCB8fCAoZXhwb3J0cy5DaGFyVXRpbCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFyc3RyZWFtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHByaW1pdGl2ZXNfMSA9IHJlcXVpcmUoXCIuL3ByaW1pdGl2ZXNcIik7XG5leHBvcnRzLlByaW1pdGl2ZXMgPSBwcmltaXRpdmVzXzEuUHJpbWl0aXZlcztcbnZhciBjaGFyc3RyZWFtXzEgPSByZXF1aXJlKFwiLi9jaGFyc3RyZWFtXCIpO1xuZXhwb3J0cy5DaGFyVXRpbCA9IGNoYXJzdHJlYW1fMS5DaGFyVXRpbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY2hhcnN0cmVhbV8xID0gcmVxdWlyZShcIi4vY2hhcnN0cmVhbVwiKTtcbnZhciBQcmltaXRpdmVzO1xuKGZ1bmN0aW9uIChQcmltaXRpdmVzKSB7XG4gICAgY2xhc3MgRU9GTWFyayB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgICAgIHN0YXRpYyBnZXQgSW5zdGFuY2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2UgfHwgKHRoaXMuX2luc3RhbmNlID0gbmV3IHRoaXMoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUHJpbWl0aXZlcy5FT0ZNYXJrID0gRU9GTWFyaztcbiAgICBQcmltaXRpdmVzLkVPRiA9IEVPRk1hcmsuSW5zdGFuY2U7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN1Y2Nlc3NmdWwgcGFyc2UuXG4gICAgICovXG4gICAgY2xhc3MgU3VjY2VzcyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBzdWNjZXNzZnVsIHBhcnNlLlxuICAgICAgICAgKiBAcGFyYW0gaXN0cmVhbSBUaGUgcmVtYWluaW5nIHN0cmluZy5cbiAgICAgICAgICogQHBhcmFtIHJlcyBUaGUgcmVzdWx0IG9mIHRoZSBwYXJzZVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoaXN0cmVhbSwgcmVzKSB7XG4gICAgICAgICAgICB0aGlzLnRhZyA9IFwic3VjY2Vzc1wiO1xuICAgICAgICAgICAgdGhpcy5pbnB1dHN0cmVhbSA9IGlzdHJlYW07XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHJlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBQcmltaXRpdmVzLlN1Y2Nlc3MgPSBTdWNjZXNzO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBmYWlsZWQgcGFyc2UuXG4gICAgICovXG4gICAgY2xhc3MgRmFpbHVyZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBmYWlsZWQgcGFyc2UuXG4gICAgICAgICAqIEBwYXJhbSBpc3RyZWFtIFRoZSBzdHJpbmcsIHVubW9kaWZpZWQsIHRoYXQgd2FzIGdpdmVuIHRvIHRoZSBwYXJzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcihpc3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLnRhZyA9IFwiZmFpbHVyZVwiO1xuICAgICAgICAgICAgdGhpcy5pbnB1dHN0cmVhbSA9IGlzdHJlYW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgUHJpbWl0aXZlcy5GYWlsdXJlID0gRmFpbHVyZTtcbiAgICAvKipcbiAgICAgKiByZXN1bHQgc3VjY2VlZHMgd2l0aG91dCBjb25zdW1pbmcgYW55IGlucHV0LCBhbmQgcmV0dXJucyB2LlxuICAgICAqIEBwYXJhbSB2IFRoZSByZXN1bHQgb2YgdGhlIHBhcnNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdCh2KSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4gbmV3IFN1Y2Nlc3MoaXN0cmVhbSwgdik7XG4gICAgfVxuICAgIFByaW1pdGl2ZXMucmVzdWx0ID0gcmVzdWx0O1xuICAgIC8qKlxuICAgICAqIHplcm8gZmFpbHMgd2l0aG91dCBjb25zdW1pbmcgYW55IGlucHV0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHplcm8oKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4gbmV3IEZhaWx1cmUoaXN0cmVhbSk7XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuemVybyA9IHplcm87XG4gICAgLyoqXG4gICAgICogaXRlbSBzdWNjZXNzZnVsbHkgY29uc3VtZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpZiB0aGUgaW5wdXRcbiAgICAgKiBzdHJpbmcgaXMgbm9uLWVtcHR5LCBvdGhlcndpc2UgaXQgZmFpbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXN0cmVhbS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhaWx1cmUoaXN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN1Y2Nlc3MoaXN0cmVhbS50YWlsKCksIGlzdHJlYW0uaGVhZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5pdGVtID0gaXRlbTtcbiAgICAvKipcbiAgICAgKiBiaW5kIGlzIGEgY3VycmllZCBmdW5jdGlvbiB0aGF0IHRha2VzIGEgcGFyc2VyIHAgYW5kIHJldHVybnNcbiAgICAgKiBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBwYXJzZXIgZiB3aGljaCByZXR1cm5zIHRoZSBjb21wb3NpdGlvblxuICAgICAqIG9mIHAgYW5kIGYuICBJZiBfYW55XyBvZiB0aGUgcGFyc2VycyBmYWlsLCB0aGUgb3JpZ2luYWwgaW5wdXRzdHJlYW1cbiAgICAgKiBpcyByZXR1cm5lZCBpbiB0aGUgRmFpbHVyZSBvYmplY3QgKGkuZS4sIGJpbmQgYmFja3RyYWNrcykuXG4gICAgICogQHBhcmFtIHAgQSBwYXJzZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kKHApIHtcbiAgICAgICAgcmV0dXJuIChmKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgciA9IHAoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChyLnRhZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG8gPSBmKHIucmVzdWx0KShyLmlucHV0c3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOiByZXR1cm4gbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiBiYWNrdHJhY2tzLCByZXR1cm5pbmcgb3JpZ2luYWwgaXN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhaWx1cmUoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6IHJldHVybiBuZXcgRmFpbHVyZShpc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmJpbmQgPSBiaW5kO1xuICAgIGZ1bmN0aW9uIGRlbGF5KHApIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHA7XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuZGVsYXkgPSBkZWxheTtcbiAgICAvKipcbiAgICAgKiBzZXEgaXMgYSBjdXJyaWVkIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBwYXJzZXIgcCwgYSBwYXJzZXIgcSxcbiAgICAgKiBhbmQgYSBmdW5jdGlvbiBmLiBJdCBhcHBsaWVzIHAgdG8gdGhlIGlucHV0LCBwYXNzaW5nIHRoZVxuICAgICAqIHJlbWFpbmluZyBpbnB1dCBzdHJlYW0gdG8gcTsgcSBpcyB0aGVuIGFwcGxpZWQuICBUaGUgZnVuY3Rpb25cbiAgICAgKiBmIHRha2VzIHRoZSByZXN1bHQgb2YgcCBhbmQgcSwgYXMgYSB0dXBsZSwgYW5kIHJldHVybnNcbiAgICAgKiBhIHNpbmdsZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHAgQSBwYXJzZXJcbiAgICAgKi9cbiAgICAvLyBleHBvcnQgbGV0IHNlcSA9IGZ1bmN0aW9uPFQsVSxWPihwOiBJUGFyc2VyPFQ+KSB7XG4gICAgLy8gICAgIHJldHVybiAocTogSVBhcnNlcjxVPikgPT4ge1xuICAgIC8vICAgICAgICAgcmV0dXJuIChmOiAoZTogW1QsVV0pID0+IFYpID0+IHtcbiAgICAvLyAgICAgICAgICAgICByZXR1cm4gYmluZDxULFY+KHApKCh4KSA9PiB7XG4gICAgLy8gICAgICAgICAgICAgICAgIHJldHVybiBiaW5kPFUsVj4ocSkoKHkpID0+IHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGxldCB0dXAgOiBbVCxVXSA9IFt4LHldO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDxWPihmKHR1cCkpO1xuICAgIC8vICAgICAgICAgICAgICAgICB9KTtcbiAgICAvLyAgICAgICAgICAgICB9KTtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfTtcbiAgICAvLyB9XG4gICAgZnVuY3Rpb24gc2VxKHApIHtcbiAgICAgICAgcmV0dXJuIChxKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGYpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluZChwKSgoeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmluZChxKSgoeSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR1cCA9IFt4LCB5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQoZih0dXApKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnNlcSA9IHNlcTtcbiAgICAvKipcbiAgICAgKiBzYXQgdGFrZXMgYSBwcmVkaWNhdGUgYW5kIHlpZWxkcyBhIHBhcnNlciB0aGF0IGNvbnN1bWVzIGFcbiAgICAgKiBzaW5nbGUgY2hhcmFjdGVyIGlmIHRoZSBjaGFyYWN0ZXIgc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGUsXG4gICAgICogb3RoZXJ3aXNlIGl0IGZhaWxzLlxuICAgICAqIEBwYXJhbSBwcmVkIGEgY2hhcmFjdGVyIHByZWRpY2F0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhdChwcmVkKSB7XG4gICAgICAgIGxldCBwcmVkMiA9IChjcykgPT4gcHJlZChjcy50b1N0cmluZygpKTtcbiAgICAgICAgbGV0IGEgPSBpdGVtKCk7XG4gICAgICAgIGxldCBiID0gKHgpID0+IHtcbiAgICAgICAgICAgIGlmIChwcmVkMih4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gemVybygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYmluZChhKShiKTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5zYXQgPSBzYXQ7XG4gICAgLyoqXG4gICAgICogY2hhciB0YWtlcyBhIGNoYXJhY3RlciBhbmQgeWllbGRzIGEgcGFyc2VyIHRoYXQgY29uc3VtZVxuICAgICAqIHRoYXQgY2hhcmFjdGVyLiBUaGUgcmV0dXJuZWQgcGFyc2VyIHN1Y2NlZWRzIGlmIHRoZSBuZXh0XG4gICAgICogY2hhcmFjdGVyIGluIHRoZSBpbnB1dCBzdHJlYW0gaXMgYywgb3RoZXJ3aXNlIGl0IGZhaWxzLlxuICAgICAqIEBwYXJhbSBjXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhcihjKSB7XG4gICAgICAgIGlmIChjLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGFyIHBhcnNlciB0YWtlcyBhIHN0cmluZyBvZiBsZW5ndGggMSAoaS5lLiwgYSBjaGFyKVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2F0KHggPT4geCA9PSBjKTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5jaGFyID0gY2hhcjtcbiAgICAvKipcbiAgICAgKiBsZXR0ZXIgcmV0dXJucyBhIHBhcnNlciB0aGF0IGNvbnN1bWVzIGEgc2luZ2xlIGFscGhhYmV0aWNcbiAgICAgKiBjaGFyYWN0ZXIsIGZyb20gYS16LCByZWdhcmRsZXNzIG9mIGNhc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGV0dGVyKCkge1xuICAgICAgICBsZXQgY29udGFpbnNfbGV0dGVyID0gKHgpID0+IHtcbiAgICAgICAgICAgIGxldCBhX2xldHRlciA9IC9bQS1aYS16XS87XG4gICAgICAgICAgICByZXR1cm4geC5tYXRjaChhX2xldHRlcikgIT0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc2F0KGNvbnRhaW5zX2xldHRlcik7XG4gICAgfVxuICAgIFByaW1pdGl2ZXMubGV0dGVyID0gbGV0dGVyO1xuICAgIC8qKlxuICAgICAqIGRpZ2l0IHJldHVybnMgYSBwYXJzZXIgdGhhdCBjb25zdW1lcyBhIHNpbmdsZSBudW1lcmljXG4gICAgICogY2hhcmFjdGVyLCBmcm9tIDAtOS4gIE5vdGUgdGhhdCB0aGUgdHlwZSBvZiB0aGUgcmVzdWx0XG4gICAgICogaXMgYSBzdHJpbmcsIG5vdCBhIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaWdpdCgpIHtcbiAgICAgICAgcmV0dXJuIHNhdCh4ID0+IHggPT0gXCIwXCJcbiAgICAgICAgICAgIHx8IHggPT0gXCIxXCJcbiAgICAgICAgICAgIHx8IHggPT0gXCIyXCJcbiAgICAgICAgICAgIHx8IHggPT0gXCIzXCJcbiAgICAgICAgICAgIHx8IHggPT0gXCI0XCJcbiAgICAgICAgICAgIHx8IHggPT0gXCI1XCJcbiAgICAgICAgICAgIHx8IHggPT0gXCI2XCJcbiAgICAgICAgICAgIHx8IHggPT0gXCI3XCJcbiAgICAgICAgICAgIHx8IHggPT0gXCI4XCJcbiAgICAgICAgICAgIHx8IHggPT0gXCI5XCIpO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmRpZ2l0ID0gZGlnaXQ7XG4gICAgLyoqXG4gICAgICogdXBwZXIgcmV0dXJucyBhIHBhcnNlciB0aGF0IGNvbnN1bWVzIGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAqIGlmIHRoYXQgY2hhcmFjdGVyIGlzIHVwcGVyY2FzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cHBlcigpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgbzEgPSBsZXR0ZXIoKShpc3RyZWFtKTtcbiAgICAgICAgICAgIHN3aXRjaCAobzEudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgbGV0IG8yID0gc2F0KHggPT4geCA9PSB4LnRvVXBwZXJDYXNlKCkpKG8xLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobzIudGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5ldmVyIGhhcHBlbnNcIik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMudXBwZXIgPSB1cHBlcjtcbiAgICAvKipcbiAgICAgKiBsb3dlciByZXR1cm5zIGEgcGFyc2VyIHRoYXQgY29uc3VtZXMgYSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgICogaWYgdGhhdCBjaGFyYWN0ZXIgaXMgbG93ZXJjYXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvd2VyKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGxldCBvMSA9IGxldHRlcigpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvMS50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICBsZXQgbzIgPSBzYXQoeCA9PiB4ID09IHgudG9Mb3dlckNhc2UoKSkobzEucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvMi50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhaWx1cmUoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmV2ZXIgaGFwcGVuc1wiKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5sb3dlciA9IGxvd2VyO1xuICAgIC8qKlxuICAgICAqIGNob2ljZSBzcGVjaWZpZXMgYW4gb3JkZXJlZCBjaG9pY2UgYmV0d2VlbiB0d28gcGFyc2VycyxcbiAgICAgKiBwMSBhbmQgcDIuIFRoZSByZXR1cm5lZCBwYXJzZXIgd2lsbCBmaXJzdCBhcHBseVxuICAgICAqIHBhcnNlciBwMS4gIElmIHAxIHN1Y2NlZWRzLCBwMSdzIE91dGNvbWUgaXMgcmV0dXJuZWQuXG4gICAgICogSWYgcDEgZmFpbHMsIHAyIGlzIGFwcGxpZWQgYW5kIHRoZSBPdXRjb21lIG9mIHAyIGlzIHJldHVybmVkLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGdpdmVuIHRvIHAxIGFuZCBwMiBpcyBleGFjdGx5XG4gICAgICogdGhlIHNhbWUgaW5wdXQgc3RyZWFtLlxuICAgICAqIEBwYXJhbSBwMSBBIHBhcnNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaG9pY2UocDEpIHtcbiAgICAgICAgcmV0dXJuIChwMikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG8gPSBwMShpc3RyZWFtKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG8udGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwMihpc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmNob2ljZSA9IGNob2ljZTtcbiAgICAvKipcbiAgICAgKiBhcHBmdW4gYWxsb3dzIHRoZSB1c2VyIHRvIGFwcGx5IGEgZnVuY3Rpb24gZiB0b1xuICAgICAqIHRoZSByZXN1bHQgb2YgYSBwYXJzZXIgcCwgYXNzdW1pbmcgdGhhdCBwIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICogQHBhcmFtIHAgQSBwYXJzZXIuICBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSB8Pj5cbiAgICAgKiBmdW5jdGlvbiBmcm9tIEZQYXJzZWMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwZnVuKHApIHtcbiAgICAgICAgcmV0dXJuIChmKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbyA9IHAoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKG8uaW5wdXRzdHJlYW0sIGYoby5yZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuYXBwZnVuID0gYXBwZnVuO1xuICAgIC8qKlxuICAgICAqIG1hbnkgcmVwZWF0ZWRseSBhcHBsaWVzIHRoZSBwYXJzZXIgcCB1bnRpbCBwIGZhaWxzLiBtYW55IGFsd2F5c1xuICAgICAqIHN1Y2NlZWRzLCBldmVuIGlmIGl0IG1hdGNoZXMgbm90aGluZy4gIG1hbnkgdHJpZXMgdG8gZ3VhcmRcbiAgICAgKiBhZ2FpbnN0IGFuIGluZmluaXRlIGxvb3AgYnkgcmFpc2luZyBhbiBleGNlcHRpb24gaWYgcCBzdWNjZWVkc1xuICAgICAqIHdpdGhvdXQgY2hhbmdpbmcgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gcFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hbnkocCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGxldCBpc3RyZWFtMiA9IGlzdHJlYW07XG4gICAgICAgICAgICBsZXQgb3V0cHV0cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHN1Y2NlZWRzID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlICghaXN0cmVhbTIuaXNFbXB0eSgpICYmIHN1Y2NlZWRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG8gPSBwKGlzdHJlYW0yKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG8udGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXN0cmVhbTIgPT0gby5pbnB1dHN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcnNlciBsb29wcyBpbmZpbml0ZWx5LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzdHJlYW0yID0gby5pbnB1dHN0cmVhbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaChvLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2NlZWRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1Y2Nlc3MoaXN0cmVhbTIsIG91dHB1dHMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLm1hbnkgPSBtYW55O1xuICAgIC8qKlxuICAgICAqIG1hbnkxIHJlcGVhdGVkbHkgYXBwbGllcyB0aGUgcGFyc2VyIHAgdW50aWwgcCBmYWlscy4gbWFueTEgbXVzdFxuICAgICAqIHN1Y2NlZWQgYXQgbGVhc3Qgb25jZS4gIG1hbnkxIHRyaWVzIHRvIGd1YXJkIGFnYWluc3QgYW4gaW5maW5pdGVcbiAgICAgKiBsb29wIGJ5IHJhaXNpbmcgYW4gZXhjZXB0aW9uIGlmIHAgc3VjY2VlZHMgd2l0aG91dCBjaGFuZ2luZyB0aGVcbiAgICAgKiBwYXJzZXIgc3RhdGUuXG4gICAgICogQHBhcmFtIHBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYW55MShwKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHNlcShwKShtYW55KHApKSh0dXAgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBoZCA9IHR1cFtcIjBcIl07XG4gICAgICAgICAgICAgICAgbGV0IHRsID0gdHVwW1wiMVwiXTtcbiAgICAgICAgICAgICAgICB0bC51bnNoaWZ0KGhkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGw7XG4gICAgICAgICAgICB9KShpc3RyZWFtKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5tYW55MSA9IG1hbnkxO1xuICAgIC8qKlxuICAgICAqIHN0ciB5aWVsZHMgYSBwYXJzZXIgZm9yIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgICogQHBhcmFtIHMgQSBzdHJpbmdcbiAgICAgKi9cbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBhY3R1YWxseSBiZSBhIHNlcXVlbmNlIG9mIHBhcnNlcnMgY29uc3RydWN0ZWRcbiAgICAvLyBmcm9tIHRoZSBzdHJpbmcgc1xuICAgIGZ1bmN0aW9uIHN0cihzKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgLy8gZXNjYXBlIHJlZ2V4IG1ldGFjaGFyYWN0ZXJzXG4gICAgICAgICAgICAvLyAodGhpcyBsaWtlbHkgbmVlZHMgd29yaylcbiAgICAgICAgICAgIGxldCBzMiA9IHMucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbiAgICAgICAgICAgIGxldCByZSA9IG5ldyBSZWdFeHAoXCJeXCIgKyBzMik7XG4gICAgICAgICAgICBpZiAoaXN0cmVhbS50b1N0cmluZygpLm1hdGNoKHJlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbSA9IGlzdHJlYW0uc3Vic3RyaW5nKHMubGVuZ3RoLCBpc3RyZWFtLmxlbmd0aCgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBpc3RyZWFtLnN1YnN0cmluZygwLCBzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKHJlbSwgcmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFpbHVyZShpc3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5zdHIgPSBzdHI7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBhcnNlciB0aGF0IHN1Y2NlZWRzIG9ubHkgaWYgdGhlIGVuZCBvZiB0aGVcbiAgICAgKiBpbnB1dCBoYXMgYmVlbiByZWFjaGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVvZigpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXN0cmVhbS5pc0VPRigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKGlzdHJlYW0sIFByaW1pdGl2ZXMuRU9GKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFpbHVyZShpc3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5lb2YgPSBlb2Y7XG4gICAgLyoqXG4gICAgICogZnJlc3VsdCByZXR1cm5zIGEgcGFyc2VyIHRoYXQgYXBwbGllcyB0aGUgcGFyc2VyIHAsXG4gICAgICogYW5kIGlmIHAgc3VjY2VlZHMsIHJldHVybnMgdGhlIHZhbHVlIHguXG4gICAgICogQHBhcmFtIHAgYSBwYXJzZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcmVzdWx0KHApIHtcbiAgICAgICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluZChwKSgodCkgPT4gcmVzdWx0KHgpKShpc3RyZWFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuZnJlc3VsdCA9IGZyZXN1bHQ7XG4gICAgLyoqXG4gICAgICogbGVmdCByZXR1cm5zIGEgcGFyc2VyIHRoYXQgYXBwbGllcyB0aGUgcGFyc2VyIHAsXG4gICAgICogdGhlbiB0aGUgcGFyc2VyIHEsIGFuZCBpZiBib3RoIGFyZSBzdWNjZXNzZnVsLFxuICAgICAqIHJldHVybnMgdGhlIHJlc3VsdCBvZiBwLlxuICAgICAqIEBwYXJhbSBwIGEgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVmdChwKSB7XG4gICAgICAgIHJldHVybiAocSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQocCkoKHQpID0+IGZyZXN1bHQocSkodCkpKGlzdHJlYW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5sZWZ0ID0gbGVmdDtcbiAgICAvKipcbiAgICAgKiByaWdodCByZXR1cm5zIGEgcGFyc2VyIHRoYXQgYXBwbGllcyB0aGUgcGFyc2VyIHAsXG4gICAgICogdGhlbiB0aGUgcGFyc2VyIHEsIGFuZCBpZiBib3RoIGFyZSBzdWNjZXNzZnVsLFxuICAgICAqIHJldHVybnMgdGhlIHJlc3VsdCBvZiBxLlxuICAgICAqIEBwYXJhbSBwIGEgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmlnaHQocCkge1xuICAgICAgICByZXR1cm4gKHEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiaW5kKHApKF8gPT4gcSkoaXN0cmVhbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgLyoqXG4gICAgICogYmV0d2VlbiByZXR1cm5zIGEgcGFyc2VyIHRoYXQgYXBwbGllcyB0aGUgcGFyc2VyXG4gICAgICogcG9wZW4sIHAsIGFuZCBwY2xvc2UgaW4gc2VxdWVuY2UsIGFuZCBpZiBhbGwgYXJlXG4gICAgICogc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHAuXG4gICAgICogQHBhcmFtIHBvcGVuIHRoZSBmaXJzdCBwYXJzZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZXR3ZWVuKHBvcGVuKSB7XG4gICAgICAgIHJldHVybiAocGNsb3NlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHApID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbCA9IGxlZnQocCkocGNsb3NlKTtcbiAgICAgICAgICAgICAgICBsZXQgciA9IHJpZ2h0KHBvcGVuKShsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuYmV0d2VlbiA9IGJldHdlZW47XG4gICAgLyoqXG4gICAgICogVGhlIGRlYnVnIHBhcnNlciB0YWtlcyBhIHBhcnNlciBwIGFuZCBhIGRlYnVnIHN0cmluZyxcbiAgICAgKiBwcmludGluZyB0aGUgZGVidWcgc3RyaW5nIGFzIGEgc2lkZS1lZmZlY3QgYmVmb3JlXG4gICAgICogYXBwbHlpbmcgcCB0byB0aGUgaW5wdXQuXG4gICAgICogQHBhcmFtIHAgYSBwYXJzZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJ1ZyhwKSB7XG4gICAgICAgIHJldHVybiAobGFiZWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYXBwbHk6IFwiICsgbGFiZWwpO1xuICAgICAgICAgICAgICAgIGxldCBvID0gcChpc3RyZWFtKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG8udGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInN1Y2Nlc3M6IFwiICsgbGFiZWwgKyBcIiwgc3RhcnRwb3M6IFwiICsgaXN0cmVhbS5zdGFydHBvcyArIFwiLCBlbmRwb3M6IFwiICsgaXN0cmVhbS5lbmRwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImZhaWx1cmU6IFwiICsgbGFiZWwgKyBcIiwgc3RhcnRwb3M6IFwiICsgaXN0cmVhbS5zdGFydHBvcyArIFwiLCBlbmRwb3M6IFwiICsgaXN0cmVhbS5lbmRwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5kZWJ1ZyA9IGRlYnVnO1xuICAgIGxldCB3c2NoYXJzID0gY2hvaWNlKHNhdChjID0+IGMgPT0gJyAnIHx8IGMgPT0gJ1xcdCcpKShubCgpKTtcbiAgICAvKipcbiAgICAgKiB3cyBtYXRjaGVzIHplcm8gb3IgbW9yZSBvZiB0aGUgZm9sbG93aW5nIHdoaXRlc3BhY2UgY2hhcmFjdGVyczpcbiAgICAgKiAnICcsICdcXHQnLCAnXFxuJywgb3IgJ1xcclxcbidcbiAgICAgKiB3cyByZXR1cm5zIG1hdGNoZWQgd2hpdGVzcGFjZSBpbiBhIHNpbmdsZSBDaGFyU3RyZWFtIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cygpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgbyA9IG1hbnkod3NjaGFycykoaXN0cmVhbSk7XG4gICAgICAgICAgICBzd2l0Y2ggKG8udGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKG8uaW5wdXRzdHJlYW0sIGNoYXJzdHJlYW1fMS5DaGFyVXRpbC5DaGFyU3RyZWFtLmNvbmNhdChvLnJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIC8vIHdzIG5ldmVyIGZhaWxzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMud3MgPSB3cztcbiAgICAvKipcbiAgICAgKiB3czEgbWF0Y2hlcyBvbmUgb3IgbW9yZSBvZiB0aGUgZm9sbG93aW5nIHdoaXRlc3BhY2UgY2hhcmFjdGVyczpcbiAgICAgKiAnICcsICdcXHQnLCAnXFxuJywgb3IgJ1xcclxcbidcbiAgICAgKiB3czEgcmV0dXJucyBtYXRjaGVkIHdoaXRlc3BhY2UgaW4gYSBzaW5nbGUgQ2hhclN0cmVhbSByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3MxKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGxldCBvID0gbWFueTEod3NjaGFycykoaXN0cmVhbSk7XG4gICAgICAgICAgICBzd2l0Y2ggKG8udGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKG8uaW5wdXRzdHJlYW0sIGNoYXJzdHJlYW1fMS5DaGFyVXRpbC5DaGFyU3RyZWFtLmNvbmNhdChvLnJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLndzMSA9IHdzMTtcbiAgICAvKipcbiAgICAgKiBubCBtYXRjaGVzIGFuZCByZXR1cm5zIGEgbmV3bGluZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBubCgpIHtcbiAgICAgICAgcmV0dXJuIFByaW1pdGl2ZXMuY2hvaWNlKFByaW1pdGl2ZXMuc3RyKFwiXFxuXCIpKShQcmltaXRpdmVzLnN0cihcIlxcclxcblwiKSk7XG4gICAgfVxuICAgIFByaW1pdGl2ZXMubmwgPSBubDtcbiAgICBmdW5jdGlvbiBncm91cEJ5KGxpc3QsIGtleUdldHRlcikge1xuICAgICAgICBsZXQgbSA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlHZXR0ZXIoaXRlbSk7XG4gICAgICAgICAgICBpZiAoIW0uaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBtLnNldChrZXksIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb2xsZWN0aW9uID0gbS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJTYXQoc3Rycykge1xuICAgICAgICAvLyBzb3J0IHN0cmluZ3MgZmlyc3QgYnkgbGVuZ3RoLCBhbmQgdGhlbiBsZXhpY29ncmFwaWNhbGx5O1xuICAgICAgICAvLyBzbGljZSgpIGNhbGxlZCBoZXJlIHNvIGFzIG5vdCB0byBtb2RpZnkgb3JpZ2luYWwgYXJyYXlcbiAgICAgICAgbGV0IHNtYXAgPSBncm91cEJ5KHN0cnMsIHMgPT4gcy5sZW5ndGgpO1xuICAgICAgICBsZXQgc2l6ZXMgPSBbXTtcbiAgICAgICAgLy8gZmluZCBzaXplIGNsYXNzZXM7XG4gICAgICAgIC8vIGFsc28gc29ydCBlYWNoIHNldCBvZiBlcXVpdmFsZW50LWxlbmd0aCB2YWx1ZXNcbiAgICAgICAgc21hcC5mb3JFYWNoKCh2YWxzLCBrZXksIG0pID0+IHtcbiAgICAgICAgICAgIHNpemVzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHZhbHMuc29ydCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2l6ZXMuc29ydCgpO1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHdpdGggdGhlIHNtYWxsZXN0IHNpemUgY2xhc3MgICAgICAgXG4gICAgICAgICAgICBmb3IgKGxldCBwZWVrSW5kZXggPSAwOyBwZWVrSW5kZXggPCBzaXplcy5sZW5ndGg7IHBlZWtJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggc2l6ZSBjbGFzcywgdHJ5IG1hdGNoaW5nIGFsbCBvZlxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdHJpbmdzOyBpZiBvbmUgaXMgZm91bmQsIHJldHVybiB0aGVcbiAgICAgICAgICAgICAgICAvLyBhcHByb3ByaWF0ZSBDaGFyU3RyZWFtOyBpZiBub3QsIGZhaWwuXG4gICAgICAgICAgICAgICAgbGV0IHBlZWsgPSBpc3RyZWFtLnBlZWsoc2l6ZXNbcGVla0luZGV4XSk7XG4gICAgICAgICAgICAgICAgbGV0IHRhaWwgPSBpc3RyZWFtLnNlZWsoc2l6ZXNbcGVla0luZGV4XSk7XG4gICAgICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZXMgPSBzbWFwLmdldChzaXplc1twZWVrSW5kZXhdKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjSW5kZXggPSAwOyBjSW5kZXggPCBjYW5kaWRhdGVzLmxlbmd0aDsgY0luZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZXNbY0luZGV4XSA9PT0gcGVlay50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN1Y2Nlc3ModGFpbCwgcGVlayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhaWx1cmUoaXN0cmVhbSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuc3RyU2F0ID0gc3RyU2F0O1xufSkoUHJpbWl0aXZlcyA9IGV4cG9ydHMuUHJpbWl0aXZlcyB8fCAoZXhwb3J0cy5QcmltaXRpdmVzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByaW1pdGl2ZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGxpZnRfMSA9IHJlcXVpcmUoXCIuLi9saWZ0XCIpO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBBcnJheS1saWtlIG9iamVjdCAoc3VjaCBhcyBhbiBhcmd1bWVudHMgb3IgTm9kZUxpc3QgaW5zdGFuY2UpIHRvIGEgcmVndWxhciBBcnJheVxuICovXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlKGFycmF5TGlrZSkge1xuICAgIHJldHVybiBuZXcgbGlmdF8xLkFycmF5T3BzKFtdLnNsaWNlLmNhbGwoYXJyYXlMaWtlKSk7XG59XG5leHBvcnRzLmZyb21BcnJheUxpa2UgPSBmcm9tQXJyYXlMaWtlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGxpZnRfMSA9IHJlcXVpcmUoXCIuLi9saWZ0XCIpO1xuLypcbiogUmV0dXJucyBhIG51bWJlcltdIHdyYXBwZXIgd2l0aCBhbGwgbnVtYmVycyBmcm9tIHN0YXJ0IHRvIHN0b3AgKGluY2x1c2l2ZSksXG4qIGluY3JlbWVudGVkIG9yIGRlY3JlbWVudGVkIGJ5IHN0ZXAuXG4qL1xuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdG9wID0gYXJndW1lbnRzWzBdIC0gMTtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCB8fCAxO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgaW5jcmVhc2luZyA9IHN0ZXAgPiAwO1xuICAgIHZhciBuZXh0ID0gc3RhcnQ7XG4gICAgd2hpbGUgKChpbmNyZWFzaW5nICYmIG5leHQgPD0gc3RvcCkgfHwgKCFpbmNyZWFzaW5nICYmIG5leHQgPj0gc3RvcCkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV4dCk7XG4gICAgICAgIG5leHQgPSBuZXh0ICsgc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBsaWZ0XzEuQXJyYXlPcHMocmVzdWx0KTtcbn1cbmV4cG9ydHMucmFuZ2UgPSByYW5nZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmZ1bmN0aW9uIHR1cGxlKGFycikge1xuICAgIHJldHVybiBhcnI7XG59XG5leHBvcnRzLnR1cGxlID0gdHVwbGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgaXNfMSA9IHJlcXVpcmUoXCIuLi9vYmplY3QvaXNcIik7XG52YXIgY3VycmVudE1lbW9JZCA9IDA7XG4vKipcbiAqIE1lbW9pemVzIGEgZnVuY3Rpb24gb2YgYXJiaXRyYXJ5IGFyaXR5LlxuICogVGhpcyBoYXMgdHdvIG1haW4gdXNlczpcbiAqICAgMSkgUmVkdWNpbmcgdGhlIENQVSB0aW1lIHRha2VuIGJ5IGV4cGVuc2l2ZSBjYWxjdWxhdGlvbnMgYXQgdGhlIGNvc3Qgb2Ygc29tZSBtZW1vcnkgb3ZlcmhlYWRcbiAqICAgMikgUHJvZHVjaW5nIHN0YWJsZSByZWZlcmVuY2VzIGZvciBhIGdpdmVuIHNldCBvZiBhcmd1bWVudHMuIFVzZWZ1bCB3aGVuIHJlbHlpbmcgb24gcmVmZXJlbmNlIGVxdWFsaXR5LlxuICpcbiAqIE1lbW9pemVkIGZ1bmN0aW9ucyBrZWVwIGludGVybmFsIHN0YXRlLiBJZiB5b3Ugd2lzaCB0byBjbGVhciB0aGF0IHN0YXRlIGVudGlyZWx5LCB5b3UgY2FuIHJlY3JlYXRlIHRoZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW4sIG9wdGlvbnMpIHtcbiAgICAvLyBUaGUgdW5pcXVlIHByb3BlcnR5IG5hbWUgdXNlZCBieSB0aGlzIG1lbW9pemUgZnVuY3Rpb24gaW5zdGFuY2UuXG4gICAgLy8gVGhpcyBpcyB1c2VkIHRvIHN0b3JlIHRoZSBpZC9yZWZlcmVuY2Ugb2Ygb2JqZWN0IGFyZ3VtZW50cywgYXMgV2VhayBtYXBzL3NldHMgYXJlIHZlcnkgbGltaXRlZC5cbiAgICB2YXIgbWVtb0tleSA9IFwiX19tZW1vX19cIiArIGN1cnJlbnRNZW1vSWQrKztcbiAgICB2YXIgbGFzdEFyZ0tleXMgPSBbXTtcbiAgICB2YXIgY2FjaGVTaXplID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5jYWNoZVNpemUpIHx8IDMwO1xuICAgIHZhciBrZXlGdW5jdGlvbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5rZXk7XG4gICAgLy8gVGhlIHVuaXF1ZSBpZHMvcmVmZXJlbmNlcyBvZiBvYmplY3RzIGluc2lkZSB0aGUgYXJpdHlOQ2FjaGUgY2FjaGVcbiAgICB2YXIgb2JqSWQgPSAwO1xuICAgIHZhciBhcml0eTBDYWNoZTtcbiAgICB2YXIgYXJpdHlOQ2FjaGU7XG4gICAgdmFyIGtleUNhY2hlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gMCBhcmd1bWVudHMgZWRnZS1jYXNlXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKCFhcml0eTBDYWNoZSlcbiAgICAgICAgICAgICAgICBhcml0eTBDYWNoZSA9IGZ1bigpO1xuICAgICAgICAgICAgcmV0dXJuIGFyaXR5MENhY2hlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGN1c3RvbSBrZXkgZnVuY3Rpb25cbiAgICAgICAgZWxzZSBpZiAoa2V5RnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGtleUNhY2hlID0ga2V5Q2FjaGUgfHwge307XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5RnVuY3Rpb24uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ga2V5Q2FjaGVba2V5XTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgbGFzdEFyZ0tleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIGxpbWl0Q2FjaGVTaXplKGtleUNhY2hlLCBsYXN0QXJnS2V5cywgY2FjaGVTaXplKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBrZXlDYWNoZVtrZXldID0gZnVuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOIGFyZ3VtZW50c1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFyaXR5TkNhY2hlID0gYXJpdHlOQ2FjaGUgfHwge307XG4gICAgICAgICAgICB2YXIga2V5ID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgYXJnS2V5ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChpc18xLm9iamVjdChhcmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ0tleSA9IGFyZ1ttZW1vS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmdLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vbiBlbnVtZXJhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJnLCBtZW1vS2V5LCB7IHZhbHVlOiBcIm9ialwiICsgb2JqSWQrKyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ0tleSA9IGFyZ1ttZW1vS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnS2V5ID0gYXJnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZXkgKz0gKGFyZ0tleSArICdfJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gYXJpdHlOQ2FjaGVba2V5XTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgbGFzdEFyZ0tleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIGxpbWl0Q2FjaGVTaXplKGFyaXR5TkNhY2hlLCBsYXN0QXJnS2V5cywgY2FjaGVTaXplKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhcml0eU5DYWNoZVtrZXldID0gZnVuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLm1lbW9pemUgPSBtZW1vaXplO1xuZnVuY3Rpb24gbGltaXRDYWNoZVNpemUoY2FjaGUsIGxhc3RBcmdLZXlzLCBzaXplKSB7XG4gICAgaWYgKGxhc3RBcmdLZXlzLmxlbmd0aCA9PT0gc2l6ZSArIDEpIHtcbiAgICAgICAgdmFyIGtleSA9IGxhc3RBcmdLZXlzLnNoaWZ0KCk7XG4gICAgICAgIGRlbGV0ZSBjYWNoZVtrZXldO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0XzEgPSByZXF1aXJlKFwiLi9saWZ0XCIpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBsaWZ0XzFbXCJkZWZhdWx0XCJdO1xudmFyIGxpZnRfMiA9IHJlcXVpcmUoXCIuL2xpZnRcIik7XG5leHBvcnRzLkFycmF5T3BzID0gbGlmdF8yLkFycmF5T3BzO1xuZXhwb3J0cy5PYmplY3RPcHMgPSBsaWZ0XzIuT2JqZWN0T3BzO1xuZXhwb3J0cy5OdW1iZXJPcHMgPSBsaWZ0XzIuTnVtYmVyT3BzO1xuZXhwb3J0cy5TdHJpbmdPcHMgPSBsaWZ0XzIuU3RyaW5nT3BzO1xuZXhwb3J0cy5EYXRlT3BzID0gbGlmdF8yLkRhdGVPcHM7XG5leHBvcnRzLmdldFZhbHVlID0gbGlmdF8yLmdldFZhbHVlO1xudmFyIGltbXVwZGF0ZV8xID0gcmVxdWlyZShcImltbXVwZGF0ZVwiKTtcbmV4cG9ydHMudXBkYXRlID0gaW1tdXBkYXRlXzEudXBkYXRlO1xuZXhwb3J0cy5kZWVwVXBkYXRlID0gaW1tdXBkYXRlXzEuZGVlcFVwZGF0ZTtcbmV4cG9ydHMuREVMRVRFID0gaW1tdXBkYXRlXzEuREVMRVRFO1xudmFyIG9wdGlvbl8xID0gcmVxdWlyZShcIi4vb3B0aW9uXCIpO1xuZXhwb3J0cy5PcHRpb24gPSBvcHRpb25fMS5PcHRpb247XG5leHBvcnRzLk5vbmUgPSBvcHRpb25fMS5Ob25lO1xuZXhwb3J0cy5Tb21lID0gb3B0aW9uXzEuU29tZTtcbnZhciByZXN1bHRfMSA9IHJlcXVpcmUoXCIuL3Jlc3VsdFwiKTtcbmV4cG9ydHMuUmVzdWx0ID0gcmVzdWx0XzEuUmVzdWx0O1xuZXhwb3J0cy5PayA9IHJlc3VsdF8xLk9rO1xuZXhwb3J0cy5FcnIgPSByZXN1bHRfMS5FcnI7XG52YXIgcmFuZ2VfMSA9IHJlcXVpcmUoXCIuL2FycmF5L3JhbmdlXCIpO1xuZXhwb3J0cy5yYW5nZSA9IHJhbmdlXzEucmFuZ2U7XG52YXIgZnJvbUFycmF5TGlrZV8xID0gcmVxdWlyZShcIi4vYXJyYXkvZnJvbUFycmF5TGlrZVwiKTtcbmV4cG9ydHMuZnJvbUFycmF5TGlrZSA9IGZyb21BcnJheUxpa2VfMS5mcm9tQXJyYXlMaWtlO1xudmFyIHR1cGxlXzEgPSByZXF1aXJlKFwiLi9hcnJheS90dXBsZVwiKTtcbmV4cG9ydHMudHVwbGUgPSB0dXBsZV8xLnR1cGxlO1xudmFyIHNldF8xID0gcmVxdWlyZShcIi4vb2JqZWN0L3NldFwiKTtcbmV4cG9ydHMuU2V0ID0gc2V0XzEuU2V0O1xudmFyIG1lbW9pemVfMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uL21lbW9pemVcIik7XG5leHBvcnRzLm1lbW9pemUgPSBtZW1vaXplXzEubWVtb2l6ZTtcbnZhciBpc1R5cGUgPSByZXF1aXJlKFwiLi9vYmplY3QvaXNcIik7XG5leHBvcnRzLmlzID0gaXNUeXBlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGxpZnQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuQXJyYXlPcHMob2JqKTtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGVPcHMob2JqKTtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBuZXcgZXhwb3J0cy5TdHJpbmdPcHMob2JqKTtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBuZXcgZXhwb3J0cy5OdW1iZXJPcHMob2JqKTtcbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuT2JqZWN0T3BzKG9iaik7XG59O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBsaWZ0O1xuZnVuY3Rpb24gZ2V0VmFsdWUoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgJiYgaW5wdXRbJ19pc0xpZnRXcmFwcGVyJ11cbiAgICAgICAgPyBpbnB1dC52YWx1ZSgpXG4gICAgICAgIDogaW5wdXQ7XG59XG5leHBvcnRzLmdldFZhbHVlID0gZ2V0VmFsdWU7XG5mdW5jdGlvbiBtYWtlT3BzKCkge1xuICAgIHZhciBPcHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE9wcyhfdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5faXNMaWZ0V3JhcHBlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgT3BzLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9O1xuICAgICAgICByZXR1cm4gT3BzO1xuICAgIH0oKSk7XG4gICAgcmV0dXJuIE9wcztcbn1cbmV4cG9ydHMuQXJyYXlPcHMgPSBtYWtlT3BzKCk7XG5leHBvcnRzLk9iamVjdE9wcyA9IG1ha2VPcHMoKTtcbmV4cG9ydHMuTnVtYmVyT3BzID0gbWFrZU9wcygpO1xuZXhwb3J0cy5TdHJpbmdPcHMgPSBtYWtlT3BzKCk7XG5leHBvcnRzLkRhdGVPcHMgPSBtYWtlT3BzKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4vKiogUmV0dXJucyB3aGV0aGVyIGFuIG9iamVjdCBpcyBhbiBBcnJheSAqL1xuZXhwb3J0cy5hcnJheSA9IEFycmF5LmlzQXJyYXk7XG4vKiogUmV0dXJucyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIGEgZnVuY3Rpb24gKi9cbmZ1bmN0aW9uIGZ1bmMob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKTtcbn1cbmV4cG9ydHMuZnVuYyA9IGZ1bmM7XG4vKiogUmV0dXJucyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIGEgc3RyaW5nICovXG5mdW5jdGlvbiBzdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyk7XG59XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbi8qKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvYmplY3QgaXMgYSBudW1iZXIgKi9cbmZ1bmN0aW9uIG51bWJlcihvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdudW1iZXInKTtcbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuLyoqIFJldHVybnMgd2hldGhlciB0aGlzIG9iamVjdCBpcyBhIGJvb2xlYW4gKi9cbmZ1bmN0aW9uIGJvb2xlYW4ob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAnYm9vbGVhbicpO1xufVxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbi8qKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyB2YWx1ZSBpcyBhbiBvYmplY3QgKGUuZyBub3QgYSBwcmltaXRpdmU6IGRhdGVzLCBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpKSAqL1xuZnVuY3Rpb24gb2JqZWN0KG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cbmV4cG9ydHMub2JqZWN0ID0gb2JqZWN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGxpZnRfMSA9IHJlcXVpcmUoXCIuLi9saWZ0XCIpO1xuLyoqXG4gKiBDcmVhdGVzIGEgU2V0LWxpa2Ugb2JqZWN0IChzdHJpbmcga2V5cywgdHJ1ZSB2YWx1ZXMpIGZyb20gYSBsaXN0IG9mIGtleXNcbiAqL1xuZnVuY3Rpb24gU2V0KCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAga2V5c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHJlc3VsdFtrZXldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIG5ldyBsaWZ0XzEuT2JqZWN0T3BzKHJlc3VsdCk7XG59XG5leHBvcnRzLlNldCA9IFNldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0XzEgPSByZXF1aXJlKFwiLi4vbGlmdFwiKTtcbi8vIFRoZSBPcHRpb24gZmFjdG9yeSAvIHN0YXRpYyBvYmplY3RcbnZhciBPcHRpb25PYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gaXNEZWYodmFsdWUpID8gU29tZSh2YWx1ZSkgOiBleHBvcnRzLk5vbmU7XG59O1xuT3B0aW9uT2JqZWN0LmFsbCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyW2ldO1xuICAgICAgICBpZiAoZXhwb3J0cy5PcHRpb24uaXNPcHRpb24odmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5nZXQoKTtcbiAgICAgICAgaWYgKCFpc0RlZih2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Ob25lO1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBTb21lKHZhbHVlcyk7XG59O1xuT3B0aW9uT2JqZWN0LmlzT3B0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgKHZhbHVlLnR5cGUgPT09ICdzb21lJyB8fCB2YWx1ZS50eXBlID09PSAnbm9uZScpO1xufTtcbmZ1bmN0aW9uIG1ha2VOb25lKCkge1xuICAgIHZhciBzZWxmID0ge307XG4gICAgZnVuY3Rpb24gcmV0dXJuTm9uZSgpIHsgcmV0dXJuIGV4cG9ydHMuTm9uZTsgfVxuICAgIHNlbGYudHlwZSA9ICdub25lJztcbiAgICBzZWxmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfTtcbiAgICBzZWxmLmlzRGVmaW5lZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIHNlbGYuZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBzZWxmLm1hcCA9IHJldHVybk5vbmU7XG4gICAgc2VsZi5mbGF0TWFwID0gcmV0dXJuTm9uZTtcbiAgICBzZWxmLmZpbHRlciA9IHJldHVybk5vbmU7XG4gICAgc2VsZi5mb2xkID0gZnVuY3Rpb24gKGlmRW1wdHkpIHsgcmV0dXJuIGlmRW1wdHkoKTsgfTtcbiAgICBzZWxmLm9yRWxzZSA9IGZ1bmN0aW9uIChhbHQpIHsgcmV0dXJuIGFsdCgpOyB9O1xuICAgIHNlbGYuZ2V0T3JFbHNlID0gZnVuY3Rpb24gKGFsdCkgeyByZXR1cm4gYWx0OyB9O1xuICAgIHNlbGYudG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpZnRfMVtcImRlZmF1bHRcIl0oW10pOyB9O1xuICAgIHNlbGYudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnTm9uZSc7IH07XG4gICAgc2VsZi50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gX1NvbWUodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG59XG5fU29tZS5wcm90b3R5cGUgPSB7XG4gICAgdHlwZTogJ3NvbWUnLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9LFxuICAgIGlzRGVmaW5lZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBmbih0aGlzLnZhbHVlKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk9wdGlvbihsaWZ0XzEuZ2V0VmFsdWUoZm4odGhpcy52YWx1ZSkpKTtcbiAgICB9LFxuICAgIGZsYXRNYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4odGhpcy52YWx1ZSk7XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4odGhpcy52YWx1ZSkgPyB0aGlzIDogZXhwb3J0cy5Ob25lO1xuICAgIH0sXG4gICAgZm9sZDogZnVuY3Rpb24gKGlmRW1wdHksIGlmRGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaWZEZWZpbmVkKHRoaXMudmFsdWUpO1xuICAgIH0sXG4gICAgb3JFbHNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ2V0T3JFbHNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH0sXG4gICAgdG9BcnJheTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbGlmdF8xW1wiZGVmYXVsdFwiXShbdGhpcy52YWx1ZV0pO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiU29tZShcIiArIHRoaXMudmFsdWUgKyBcIilcIjtcbiAgICB9LFxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG59O1xuZnVuY3Rpb24gaXNEZWYodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuT3B0aW9uID0gT3B0aW9uT2JqZWN0O1xuLyoqIENyZWF0ZXMgYSBuZXcgU29tZSBpbnN0YW5jZSB1c2luZyBhIG5vbiBudWxsYWJsZSB2YWx1ZSAqL1xuLy8gZXh0ZW5kcyB7fSB0byBwcmV2ZW50IG51bGwgYW5kIHVuZGVmaW5lZCBiZWluZyBwYXNzZWRcbmZ1bmN0aW9uIFNvbWUodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9Tb21lKHZhbHVlKTtcbn1cbmV4cG9ydHMuU29tZSA9IFNvbWU7XG5leHBvcnRzLk5vbmUgPSBtYWtlTm9uZSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGxpZnRfMSA9IHJlcXVpcmUoXCIuLi9saWZ0XCIpO1xudmFyIFJlc3VsdE9iamVjdCA9IHt9O1xuUmVzdWx0T2JqZWN0LmFsbCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICB2YXIgb2tWYWx1ZXMgPSBbXTtcbiAgICB2YXIgY3VycmVudFJlc3VsdDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudFJlc3VsdF8xID0gYXJyW2ldO1xuICAgICAgICBpZiAoIWN1cnJlbnRSZXN1bHRfMS5pc09rKCkpXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFJlc3VsdF8xO1xuICAgICAgICBva1ZhbHVlcy5wdXNoKGN1cnJlbnRSZXN1bHRfMS5nZXQoKSk7XG4gICAgfVxuICAgIHJldHVybiBPayhva1ZhbHVlcyk7XG59O1xuUmVzdWx0T2JqZWN0LmlzUmVzdWx0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgKHZhbHVlLnR5cGUgPT09ICdvaycgfHwgdmFsdWUudHlwZSA9PT0gJ2VycicpO1xufTtcbmZ1bmN0aW9uIF9Payh2YWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG59XG5fT2sucHJvdG90eXBlID0ge1xuICAgIHR5cGU6ICdvaycsXG4gICAgaXNPazogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBPayhsaWZ0XzEuZ2V0VmFsdWUoZm4odGhpcy5fdmFsdWUpKSk7XG4gICAgfSxcbiAgICBtYXBFcnJvcjogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZmxhdE1hcDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbih0aGlzLl92YWx1ZSk7XG4gICAgfSxcbiAgICBmb2xkOiBmdW5jdGlvbiAoaWZFcnIsIGlmT2spIHtcbiAgICAgICAgcmV0dXJuIGlmT2sodGhpcy5fdmFsdWUpO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiT2soXCIgKyB0aGlzLl92YWx1ZSArIFwiKVwiO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG59O1xuZnVuY3Rpb24gX0VycihlcnJvcikge1xuICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG59XG5fRXJyLnByb3RvdHlwZSA9IHtcbiAgICB0eXBlOiAnZXJyJyxcbiAgICBpc09rOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbWFwRXJyb3I6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gRXJyKGZuKHRoaXMuX2Vycm9yKSk7XG4gICAgfSxcbiAgICBmbGF0TWFwOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBmb2xkOiBmdW5jdGlvbiAoaWZFcnIsIGlmT2spIHtcbiAgICAgICAgcmV0dXJuIGlmRXJyKHRoaXMuX2Vycm9yKTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkVycihcIiArIHRoaXMuX2Vycm9yICsgXCIpXCI7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgIH1cbn07XG5leHBvcnRzLlJlc3VsdCA9IFJlc3VsdE9iamVjdDtcbmZ1bmN0aW9uIE9rKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfT2sodmFsdWUpO1xufVxuZXhwb3J0cy5PayA9IE9rO1xuZnVuY3Rpb24gRXJyKGVycm9yKSB7XG4gICAgcmV0dXJuIG5ldyBfRXJyKGVycm9yKTtcbn1cbmV4cG9ydHMuRXJyID0gRXJyO1xuIl19
