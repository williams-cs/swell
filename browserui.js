(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Scope_1 = require("./lib/structural/Scope");
exports.Scope = Scope_1.Scope;
/* BINARY OPS */
var AssignOp_1 = require("./lib/binops/AssignOp");
exports.AssignOp = AssignOp_1.AssignOp;
var BinaryOperation_1 = require("./lib/binops/BinaryOperation");
exports.BinaryOperation = BinaryOperation_1.BinaryOperation;
var DivOp_1 = require("./lib/binops/DivOp");
exports.DivOp = DivOp_1.DivOp;
var MinusOp_1 = require("./lib/binops/MinusOp");
exports.MinusOp = MinusOp_1.MinusOp;
var MulOp_1 = require("./lib/binops/MulOp");
exports.MulOp = MulOp_1.MulOp;
var PlusOp_1 = require("./lib/binops/PlusOp");
exports.PlusOp = PlusOp_1.PlusOp;
var GreaterThan_1 = require("./lib/logic/GreaterThan");
exports.GreaterThan = GreaterThan_1.GreaterThan;
var GreaterThanEq_1 = require("./lib/logic/GreaterThanEq");
exports.GreaterThanEq = GreaterThanEq_1.GreaterThanEq;
var LessThan_1 = require("./lib/logic/LessThan");
exports.LessThan = LessThan_1.LessThan;
var LessThanEq_1 = require("./lib/logic/LessThanEq");
exports.LessThanEq = LessThanEq_1.LessThanEq;
var DeclareOp_1 = require("./lib/binops/DeclareOp");
exports.DeclareOp = DeclareOp_1.DeclareOp;
var And_1 = require("./lib/logic/And");
exports.And = And_1.And;
var Or_1 = require("./lib/logic/Or");
exports.Or = Or_1.Or;
var Equals_1 = require("./lib/logic/Equals");
exports.Equals = Equals_1.Equals;
var NotEqual_1 = require("./lib/logic/NotEqual");
exports.NotEqual = NotEqual_1.NotEqual;
var Increment_1 = require("./lib/binops/Increment");
exports.Increment = Increment_1.Increment;
var Decrement_1 = require("./lib/binops/Decrement");
exports.Decrement = Decrement_1.Decrement;
/* UNARY OPS */
var UnaryOperation_1 = require("./lib/unops/UnaryOperation");
exports.UnaryOperation = UnaryOperation_1.UnaryOperation;
var NegOp_1 = require("./lib/unops/NegOp");
exports.NegOp = NegOp_1.NegOp;
var Not_1 = require("./lib/logic/Not");
exports.Not = Not_1.Not;
/* DATA TYPES */
var ListNode_1 = require("./lib/lists/ListNode");
exports.ListNode = ListNode_1.ListNode;
var NumberNode_1 = require("./lib/prims/NumberNode");
exports.NumberNode = NumberNode_1.NumberNode;
var StringNode_1 = require("./lib/prims/StringNode");
exports.StringNode = StringNode_1.StringNode;
var BooleanNode_1 = require("./lib/prims/BooleanNode");
exports.BooleanNode = BooleanNode_1.BooleanNode;
var NOP_1 = require("./lib/prims/NOP");
exports.NOP = NOP_1.NOP;
/* VARIABLES */
var VariableNode_1 = require("./lib/vars/VariableNode");
exports.VariableNode = VariableNode_1.VariableNode;
/* CONTROL CONSTRUCTS */
var Conditional_1 = require("./lib/conditionals/Conditional");
exports.Conditional = Conditional_1.Conditional;
var FunApp_1 = require("./lib/funhouse/FunApp");
exports.FunApp = FunApp_1.FunApp;
var FunDef_1 = require("./lib/funhouse/FunDef");
exports.FunDef = FunDef_1.FunDef;
var SequenceNode_1 = require("./lib/structural/SequenceNode");
exports.SequenceNode = SequenceNode_1.SequenceNode;
var WhileNode_1 = require("./lib/loops/WhileNode");
exports.WhileNode = WhileNode_1.WhileNode;
var ForNode_1 = require("./lib/loops/ForNode");
exports.ForNode = ForNode_1.ForNode;
/* BUILTIN FUNCTIONS */
var ColorNode_1 = require("./lib/shapes/ColorNode");
exports.ColorNode = ColorNode_1.ColorNode;
var EllipseNode_1 = require("./lib/shapes/EllipseNode");
exports.EllipseNode = EllipseNode_1.EllipseNode;
var RectangleNode_1 = require("./lib/shapes/RectangleNode");
exports.RectangleNode = RectangleNode_1.RectangleNode;
var LineNode_1 = require("./lib/shapes/LineNode");
exports.LineNode = LineNode_1.LineNode;
var CurveNode_1 = require("./lib/shapes/CurveNode");
exports.CurveNode = CurveNode_1.CurveNode;
var EphNode_1 = require("./lib/shapes/EphNode");
exports.EphNode = EphNode_1.EphNode;
var PrintNode_1 = require("./lib/structural/PrintNode");
exports.PrintNode = PrintNode_1.PrintNode;
var Return_1 = require("./lib/structural/Return");
exports.Return = Return_1.Return;
var ReturnError_1 = require("./lib/structural/ReturnError");
exports.ReturnError = ReturnError_1.ReturnError;
var EllipseEffect_1 = require("./lib/effects/EllipseEffect");
exports.EllipseEffect = EllipseEffect_1.EllipseEffect;
var NumberEffect_1 = require("./lib/effects/NumberEffect");
exports.NumberEffect = NumberEffect_1.NumberEffect;
var StringEffect_1 = require("./lib/effects/StringEffect");
exports.StringEffect = StringEffect_1.StringEffect;
var Dimensions_1 = require("./lib/structural/Dimensions");
exports.Dimensions = Dimensions_1.Dimensions;
var RectangleEffect_1 = require("./lib/effects/RectangleEffect");
exports.RectangleEffect = RectangleEffect_1.RectangleEffect;
var LineEffect_1 = require("./lib/effects/LineEffect");
exports.LineEffect = LineEffect_1.LineEffect;
var CurveEffect_1 = require("./lib/effects/CurveEffect");
exports.CurveEffect = CurveEffect_1.CurveEffect;
var EphEffect_1 = require("./lib/effects/EphEffect");
exports.EphEffect = EphEffect_1.EphEffect;
/* EVENTS */
var LogEvent_1 = require("./lib/logging/LogEvent");
exports.LogEvent = LogEvent_1.LogEvent;
var ClearEvent_1 = require("./lib/logging/ClearEvent");
exports.ClearEvent = ClearEvent_1.ClearEvent;
var DragEvent_1 = require("./lib/logging/DragEvent");
exports.DragEvent = DragEvent_1.DragEvent;
var PaintEvent_1 = require("./lib/logging/PaintEvent");
exports.PaintEvent = PaintEvent_1.PaintEvent;
var ResizeEvent_1 = require("./lib/logging/ResizeEvent");
exports.ResizeEvent = ResizeEvent_1.ResizeEvent;
var SelectEvent_1 = require("./lib/logging/SelectEvent");
exports.SelectEvent = SelectEvent_1.SelectEvent;
var IDEvent_1 = require("./lib/logging/IDEvent");
exports.IDEvent = IDEvent_1.IDEvent;
var ModuleGenerator_1 = require("./lib/modules/ModuleGenerator");
exports.ModuleGenerator = ModuleGenerator_1.ModuleGenerator;
var LessonOneCpOne_1 = require("./lib/modules/LessonOneCpOne");
exports.LessonOneCpOne = LessonOneCpOne_1.LessonOneCpOne;
var LessonOneCpTwo_1 = require("./lib/modules/LessonOneCpTwo");
exports.LessonOneCpTwo = LessonOneCpTwo_1.LessonOneCpTwo;
var LessonOneCpThree_1 = require("./lib/modules/LessonOneCpThree");
exports.LessonOneCpThree = LessonOneCpThree_1.LessonOneCpThree;
var LessonOneCpFour_1 = require("./lib/modules/LessonOneCpFour");
exports.LessonOneCpFour = LessonOneCpFour_1.LessonOneCpFour;
var LessonTwoCpOne_1 = require("./lib/modules/LessonTwoCpOne");
exports.LessonTwoCpOne = LessonTwoCpOne_1.LessonTwoCpOne;
var LessonTwoCpTwo_1 = require("./lib/modules/LessonTwoCpTwo");
exports.LessonTwoCpTwo = LessonTwoCpTwo_1.LessonTwoCpTwo;
var LessonTwoCpThree_1 = require("./lib/modules/LessonTwoCpThree");
exports.LessonTwoCpThree = LessonTwoCpThree_1.LessonTwoCpThree;
var LessonTwoCpFour_1 = require("./lib/modules/LessonTwoCpFour");
exports.LessonTwoCpFour = LessonTwoCpFour_1.LessonTwoCpFour;
var LessonTwoCpFive_1 = require("./lib/modules/LessonTwoCpFive");
exports.LessonTwoCpFive = LessonTwoCpFive_1.LessonTwoCpFive;
var LessonTwoCpSix_1 = require("./lib/modules/LessonTwoCpSix");
exports.LessonTwoCpSix = LessonTwoCpSix_1.LessonTwoCpSix;
var LessonTwoCpSeven_1 = require("./lib/modules/LessonTwoCpSeven");
exports.LessonTwoCpSeven = LessonTwoCpSeven_1.LessonTwoCpSeven;
var LessonThreeCpOne_1 = require("./lib/modules/LessonThreeCpOne");
exports.LessonThreeCpOne = LessonThreeCpOne_1.LessonThreeCpOne;
var LessonThreeCpTwo_1 = require("./lib/modules/LessonThreeCpTwo");
exports.LessonThreeCpTwo = LessonThreeCpTwo_1.LessonThreeCpTwo;
var LessonThreeCpThree_1 = require("./lib/modules/LessonThreeCpThree");
exports.LessonThreeCpThree = LessonThreeCpThree_1.LessonThreeCpThree;
var LessonThreeCpFour_1 = require("./lib/modules/LessonThreeCpFour");
exports.LessonThreeCpFour = LessonThreeCpFour_1.LessonThreeCpFour;
var LessonThreeCpFive_1 = require("./lib/modules/LessonThreeCpFive");
exports.LessonThreeCpFive = LessonThreeCpFive_1.LessonThreeCpFive;
var LessonThreeCpSix_1 = require("./lib/modules/LessonThreeCpSix");
exports.LessonThreeCpSix = LessonThreeCpSix_1.LessonThreeCpSix;
var LessonFourCpOne_1 = require("./lib/modules/LessonFourCpOne");
exports.LessonFourCpOne = LessonFourCpOne_1.LessonFourCpOne;
var LessonFourCpTwo_1 = require("./lib/modules/LessonFourCpTwo");
exports.LessonFourCpTwo = LessonFourCpTwo_1.LessonFourCpTwo;
/* PARSER */
var parser_1 = require("./lib/parser/parser");
exports.Parser = parser_1.Parser;

},{"./lib/binops/AssignOp":2,"./lib/binops/BinaryOperation":3,"./lib/binops/DeclareOp":4,"./lib/binops/Decrement":5,"./lib/binops/DivOp":6,"./lib/binops/Increment":7,"./lib/binops/MinusOp":8,"./lib/binops/MulOp":9,"./lib/binops/PlusOp":10,"./lib/conditionals/Conditional":11,"./lib/effects/CurveEffect":12,"./lib/effects/EllipseEffect":13,"./lib/effects/EphEffect":14,"./lib/effects/LineEffect":15,"./lib/effects/NumberEffect":16,"./lib/effects/RectangleEffect":17,"./lib/effects/StringEffect":18,"./lib/funhouse/FunApp":19,"./lib/funhouse/FunDef":20,"./lib/lists/ListNode":21,"./lib/logging/ClearEvent":22,"./lib/logging/DragEvent":24,"./lib/logging/IDEvent":25,"./lib/logging/LogEvent":26,"./lib/logging/PaintEvent":27,"./lib/logging/ResizeEvent":28,"./lib/logging/SelectEvent":29,"./lib/logic/And":30,"./lib/logic/Equals":31,"./lib/logic/GreaterThan":32,"./lib/logic/GreaterThanEq":33,"./lib/logic/LessThan":34,"./lib/logic/LessThanEq":35,"./lib/logic/Not":36,"./lib/logic/NotEqual":37,"./lib/logic/Or":38,"./lib/loops/ForNode":39,"./lib/loops/WhileNode":40,"./lib/modules/LessonFourCpOne":42,"./lib/modules/LessonFourCpTwo":43,"./lib/modules/LessonOneCpFour":44,"./lib/modules/LessonOneCpOne":45,"./lib/modules/LessonOneCpThree":46,"./lib/modules/LessonOneCpTwo":47,"./lib/modules/LessonThreeCpFive":48,"./lib/modules/LessonThreeCpFour":49,"./lib/modules/LessonThreeCpOne":50,"./lib/modules/LessonThreeCpSix":51,"./lib/modules/LessonThreeCpThree":52,"./lib/modules/LessonThreeCpTwo":53,"./lib/modules/LessonTwoCpFive":54,"./lib/modules/LessonTwoCpFour":55,"./lib/modules/LessonTwoCpOne":56,"./lib/modules/LessonTwoCpSeven":57,"./lib/modules/LessonTwoCpSix":58,"./lib/modules/LessonTwoCpThree":59,"./lib/modules/LessonTwoCpTwo":60,"./lib/modules/ModuleGenerator":61,"./lib/parser/parser":62,"./lib/prims/BooleanNode":63,"./lib/prims/NOP":64,"./lib/prims/NumberNode":65,"./lib/prims/StringNode":66,"./lib/shapes/ColorNode":67,"./lib/shapes/CurveNode":68,"./lib/shapes/EllipseNode":69,"./lib/shapes/EphNode":70,"./lib/shapes/LineNode":71,"./lib/shapes/RectangleNode":72,"./lib/structural/Dimensions":73,"./lib/structural/PrintNode":74,"./lib/structural/Return":75,"./lib/structural/ReturnError":76,"./lib/structural/Scope":77,"./lib/structural/SequenceNode":78,"./lib/unops/NegOp":80,"./lib/unops/UnaryOperation":81,"./lib/vars/VariableNode":82}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const VariableNode_1 = require("../vars/VariableNode");
// left side is variable, right side is val
// Reassign new value to var
class AssignOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for an assignment operation
     * @param left The left side of the assignment (the var)
     * @param right The right side of the assignment (the value)
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        if (!(left instanceof VariableNode_1.VariableNode)) {
            throw new Error("The left hand side of the assignment must be a variable.");
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates assign op by assigning value to var
     * @param context The current context
     */
    eval(context) {
        if (this.left instanceof VariableNode_1.VariableNode) {
            let r = this.right.eval(context);
            context.assign(this.left.name, r);
            return r;
        }
        throw new Error("HALP (in AssignOp)");
    }
    /**
     * Returns a string representation of the AssignOp
     */
    toString() {
        return this._ws + this.left.toString() + ' = ' + this.right.toString();
    }
    /**
     * AssignOps can't be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on AssignOp
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.AssignOp = AssignOp;

},{"../vars/VariableNode":82,"./BinaryOperation":3}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BinaryOperation {
    /**
     * Constructor for the BinOp abstract class
     * @param _left The left side of the binary operation
     * @param _right The right side of the binary operation
     */
    constructor(_left, _right) {
        this._left = _left;
        this._right = _right;
        this._newLine = false;
    }
    ;
    /**
     * Draws the binary operation, if applicable
     * @param context The current program context
     * @param dims The dimensions
     * @param ast The AST
     */
    draw(context, dims, ast) { }
    /**
     * Checks if equal to another expression
     * @param right The right side of the equality
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on BinOp");
    }
    /**
     * Returns a string representation of the binary operation
     */
    toString() { return ""; }
    ;
    /**
     * Gets left side of the binary operation
     */
    get left() {
        return this._left;
    }
    /**
     * Sets left side of the binary operation
     */
    set left(left) {
        this._left = left;
    }
    /**
     * Gets right side of the binary operation
     */
    get right() {
        return this._right;
    }
    /**
     * Sets right side of the binary operation
     */
    set right(right) {
        this._right = right;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.BinaryOperation = BinaryOperation;

},{}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const VariableNode_1 = require("../vars/VariableNode");
// left side is variable, right side is val
// Declares new val
class DeclareOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the declare operation, which declares a variable for the first time
     * @param left The left side of the declare op (the variable)
     * @param right The right side of the op (the value)
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        if (!(left instanceof VariableNode_1.VariableNode)) {
            throw new Error("The left hand side of the assignment must be a variable.");
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the declaration by declaring the variable in the context and assigning the value
     * @param context The current program context
     */
    eval(context) {
        if (this.left instanceof VariableNode_1.VariableNode) {
            context.declare(this.left.name);
            let r = this.right.eval(context);
            context.assign(this.left.name, r);
            return r;
        }
        throw new Error("HALP (in DeclareOp)");
    }
    /**
     * Returns a string representation of the declare op
     */
    toString() {
        return this._ws + "var " + this.left.toString() + ' = ' + this.right.toString();
    }
    /**
     * DeclareOps cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called direcly on a DeclareOp
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.DeclareOp = DeclareOp;

},{"../vars/VariableNode":82,"./BinaryOperation":3}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const MinusOp_1 = require("./MinusOp");
const AssignOp_1 = require("./AssignOp");
const VariableNode_1 = require("../vars/VariableNode");
class Decrement {
    /**
     * Constructor for the decrement operation
     * @param variable The expression to be decremented
     * @param ws Preceding whitespace
     */
    constructor(variable, ws) {
        this.expr = variable;
        if (variable instanceof VariableNode_1.VariableNode) {
            this.innerRep = new AssignOp_1.AssignOp(variable, new MinusOp_1.MinusOp(variable, new NumberNode_1.NumberNode(1)));
        }
        else {
            this.innerRep = new MinusOp_1.MinusOp(variable, new NumberNode_1.NumberNode(1));
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the decrement op to a NumberNode
     * @param context The current program context
     */
    eval(context) {
        return this.innerRep.eval(context);
    }
    /**
     * Returns a string representation of the decrement op
     */
    toString() {
        return this._ws + this.expr.toString() + "--";
    }
    /**
     * Decrement ops can't be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on decrement
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.Decrement = Decrement;

},{"../prims/NumberNode":65,"../vars/VariableNode":82,"./AssignOp":2,"./MinusOp":8}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
class DivOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the division operation
     * @param left The dividend
     * @param right The divisor
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the division and evaluates into a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val / this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Division ops can't be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on a division op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the division
     */
    toString() {
        return this._ws + this.left.toString() + ' / ' + this.right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.DivOp = DivOp;

},{"../prims/NumberNode":65,"../structural/Scope":77,"./BinaryOperation":3}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PlusOp_1 = require("./PlusOp");
const AssignOp_1 = require("./AssignOp");
const VariableNode_1 = require("../vars/VariableNode");
class Increment {
    /**
     * Constructor for Increment
     * @param variable The expression to increment
     * @param ws Tracks preceding whitespace
     */
    constructor(variable, ws) {
        this.expr = variable;
        if (variable instanceof VariableNode_1.VariableNode) {
            this.innerRep = new AssignOp_1.AssignOp(variable, new PlusOp_1.PlusOp(variable, new NumberNode_1.NumberNode(1)));
        }
        else {
            this.innerRep = new PlusOp_1.PlusOp(variable, new NumberNode_1.NumberNode(1, ""));
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates increment into a number node
     * @param context The function scope
     */
    eval(context) {
        return this.innerRep.eval(context);
    }
    /**
     * Increments cannot be drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Cannot call equals directly on binops
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the increment expression
     */
    toString() {
        return this._ws + this.expr.toString() + "++";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.Increment = Increment;

},{"../prims/NumberNode":65,"../vars/VariableNode":82,"./AssignOp":2,"./PlusOp":10}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
class MinusOp extends BinaryOperation_1.BinaryOperation {
    /**
     * The constructor for the subtraction operation
     * @param left The minuend
     * @param right The subrahend
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the subtraction and evaluates to a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val - this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Subtraction ops can't be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on subtraction
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the subtraction op
     */
    toString() {
        return this._ws + this.left.toString() + ' - ' + this.right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.MinusOp = MinusOp;

},{"../prims/NumberNode":65,"../structural/Scope":77,"./BinaryOperation":3}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
class MulOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the multiplication operation
     * @param left The multiplicand
     * @param right The multiplier
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the multiplication and returns a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val * this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Returns a string representation of the multiplication op
     */
    toString() {
        return this._ws + this.left.toString() + ' * ' + this.right.toString();
    }
    /**
     * Multiplication ops cannot be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a multiplicaiton operation
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.MulOp = MulOp;

},{"../prims/NumberNode":65,"../structural/Scope":77,"./BinaryOperation":3}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
// left and right are both expressions
class PlusOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the addition operation
     * @param left The first addend
     * @param right The second addend
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the addition and returns a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val + this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Addition ops cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on an addition op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the addition op
     */
    toString() {
        return this._ws + this.left.toString() + ' + ' + this.right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.PlusOp = PlusOp;

},{"../prims/NumberNode":65,"../structural/Scope":77,"./BinaryOperation":3}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const BooleanNode_1 = require("../prims/BooleanNode");
const space_lift_1 = require("space-lift");
class Conditional {
    /**
     * The constructor for conditionals (if, else if, and else statements)
     * @param test The condition of the statement
     * @param trueBranch The branch to follow if the condition evaluates to true
     * @param falseBranch The branch to follow if the condition evaluates to false
     */
    constructor(test, trueBranch, falseBranch) {
        this._newLine = true;
        this._test = test;
        this._trueBranch = trueBranch;
        this._falseBranch = falseBranch;
    }
    /**
     * Checks the test result and returns the result of the true or false branch, depending on the test
     * @param context The current program context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        let res = this._test.eval(childCtx);
        if (!(res instanceof BooleanNode_1.BooleanNode)) {
            throw new Error("The condition must be a boolean expression.");
        }
        if (res.val) {
            return this._trueBranch.eval(childCtx);
        }
        else if (this._falseBranch != null) { // check if else/else if is null or undefined
            return this._falseBranch.eval(childCtx); // possibly a bad idea
        }
    }
    /**
     * Returns a string representation of the conditional statement
     */
    toString() {
        let res = 'if(' + this._test.toString() + ") {\n " + this._trueBranch.toString() + "}";
        if (this._falseBranch !== undefined) {
            res += '\nelse {\n ' + this._falseBranch.toString() + '}';
        }
        return res;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the true branch of the conditional
     */
    get trueBranch() {
        return this._trueBranch;
    }
    /**
     * Returns the false branch of the conditional
     */
    get falseBranch() {
        return this._falseBranch;
    }
    /**
     * Conditionals cannot be drawn directly
     */
    draw() {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a conditional
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on conditionals");
    }
}
exports.Conditional = Conditional;

},{"../prims/BooleanNode":63,"../structural/Scope":77,"space-lift":91}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class CurveEffect {
    constructor(curve) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._curve = curve;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        let curvature = this.curvature;
        this._ctx.beginPath();
        this._ctx.moveTo(x, y);
        let v = this.perpendicularVector(width, height);
        this._ctx.quadraticCurveTo((x + width / 2) + curvature * v[0], (y + height / 2) + curvature * v[1], x + width, y + height);
        this._ctx.strokeStyle = "#673AB7";
        this._ctx.stroke();
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    //a * w + b * h = 0
    perpendicularVector(w, h) {
        if (w == 0 && h == 0) {
            return [0, 0];
        }
        else if (w == 0) {
            return [1, 0];
        }
        else if (h == 0) {
            return [0, 1];
        }
        return [1, (-w) / h];
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) { // a corner guide is selected
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) { // a middle guide is selected
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else { //if no guides are selected, colors everything white
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._curve.dx = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._curve.dy = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._curve.dy = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._curve.dx = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._curve.dx = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._curve.dy = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._curve.dx = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._curve.dy = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.h > 10) { //as long as the height is > 10
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10) { // as long as width is > 10
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) { // sets the offsets depending on which corner is selected
                case 1: // top left
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w; // offset is bottom right
                    this._dragoffy = y + h;
                    break;
                case 2: // top right
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h; // offset is bottom left, etc
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) { // sets the offsets depending on which middle guide is selected
                case 5: // top middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2; // offset is bottom middle
                    this._dragoffy = y + h;
                    break;
                case 6: //right middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2; // offset is left middle etc
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) { // dragging
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) { // not selected
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isChangingDims = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a rectangle paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("rectangle", this.x, this.y);
    }
    /**
     * Logs a rectangle resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("rectangle with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs a rectangle click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("rectangle with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the rect
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the rect
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the rect
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the rect
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the curvature of the curve
     */
    get curvature() {
        return this._dims.curvature.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the rect is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the rect
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the rect has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the rect has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the rect is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " rectangle with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("rectangle with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to rectangle at " + this.x + ", " + this.y);
    }
}
exports.CurveEffect = CurveEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":65}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const NumberNode_1 = require("../prims/NumberNode");
const ClickEvent_1 = require("../logging/ClickEvent");
class EllipseEffect {
    constructor(circle) {
        this._corner = 0;
        this._isSelected = false; // Private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false; // Has this object just been dragged?
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._circle = circle;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        // logging
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        this._ctx.beginPath();
        this._ctx.ellipse(x, y, w / 2, h / 2, 0, 0, Math.PI * 2, false);
        //this._ctx.strokeStyle = "black";
        //this._ctx.stroke();
        this._ctx.fillStyle = "#D5B8FF";
        this._ctx.shadowColor = "#6C6C6C";
        this._ctx.shadowBlur = 15;
        //this._ctx.shadowOffsetX = 2;
        //this._ctx.shadowOffsetY = 2;
        this._ctx.fill();
        if (this._isSelected) {
            this.drawGuides(x - w / 2, y - h / 2, w, h, this._corner);
        }
    }
    /*
        private mouseMove = this.onMouseMove.bind(this);
        private mouseDown = this.onMouseDown.bind(this);
        private mouseUp = this.onMouseUp.bind(this);
        private shiftDown = this.onShiftDown.bind(this);
        private shiftUp = this.onShiftUp.bind(this);
        private mouseOutside = this.isMouseOutside.bind(this);
        private selectStart = function(e:any) { e.preventDefault(); return false; };
    */
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    removeEventListeners() {
        /*
        console.log("removing EventListners");
          this._canvas.removeEventListener('mousemove', this.mouseMove); // bind in order to maintain the meaning of 'this'
          this._canvas.removeEventListener('mousedown', this.mouseDown);
          this._canvas.removeEventListener('mouseup', this.mouseUp);
          window.removeEventListener('keydown', this.shiftDown);
          window.removeEventListener('keyup', this.shiftUp);
          window.removeEventListener('mousedown', this.mouseOutside);
          //makes it so that double clicking doesn't select text on the page
          this._canvas.removeEventListener('selectstart', this.selectStart, false);
          */
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        return Math.pow(mx - x, 2) / Math.pow(w / 2, 2) + Math.pow(my - y, 2) / Math.pow(h / 2, 2) <= 1;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - (x - w / 2);
        let ydif = my - (y - h / 2);
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - (x - w / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - x;
        ydif = my - (y - h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - (x - w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) {
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0 && corner > 4) {
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else {
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 14, this.h < 14);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 14, this.h < 14);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        //console.log("I'm an ellipse!");
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //console.log("ellipse dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 14 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     * @param widthTooSmall true if the width dimension is < 14
     * @param heightTooSmall true if the height dimension is < 14
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 14;
            this._circle.width = new NumberNode_1.NumberNode(14); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 14 / this._ratio;
            this._circle.height = new NumberNode_1.NumberNode(Math.round(14 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._initDistance = newDistance;
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 14;
            this._circle.height = new NumberNode_1.NumberNode(14); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 14 * this._ratio;
            this._circle.width = new NumberNode_1.NumberNode(Math.round(14 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._initDistance = newDistance;
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
            this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
            this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
            this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
            this._initDistance = newDistance;
        }
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (this._corner == 5 || this._corner == 7) { // if modifying height
            if (!heightTooSmall) {
                this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._initDistance = newDistance;
                this._ratio = this.w / this.h; // setting width/height ratio = to the new ratio
            }
            else {
                this._dims.height.eval(this._context).val = 14;
                this._circle.height = new NumberNode_1.NumberNode(14);
                this._ratio = this.w / this.h;
                if (newDistance - this._initDistance > 0) {
                    this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                    this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                    this._initDistance = newDistance;
                    this._ratio = this.w / this.h;
                }
            }
        }
        else { // modifying width
            if (!widthTooSmall) {
                this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._initDistance = newDistance;
                this._ratio = this.w / this.h;
            }
            else {
                this._dims.width.eval(this._context).val = 14;
                this._circle.width = new NumberNode_1.NumberNode(14);
                this._ratio = this.w / this.h;
                if (newDistance - this._initDistance > 0) {
                    this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                    this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                    this._initDistance = newDistance;
                    this._ratio = this.w / this.h;
                }
            }
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
            else {
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = guideContains;
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
            this._width1 = this.w;
            this._height1 = this.h;
            //this._size1 = Math.sqrt(Math.pow(this.w,2) + Math.pow(this.h,2)); // saving old size
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
        }
        else if (contains) { //simply selecting the shape or dragging
            this._x1 = this.x; // Saving original x and y
            this._y1 = this.y;
            this._isSelected = true;
            this._isDragging = true;
            this._context.eventLog.push(this.logClick());
            this._dragoffx = this._mouse.x - this.x;
            this._dragoffy = this._mouse.y - this.y;
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) { // probs only need dragging but oh well | isSel || selMul?
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
                //this._context.eventLog.push(this.logMove());
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            //console.log("resizing ellipse");
            this._isResizing = false;
            //let size2 = Math.sqrt(Math.pow(this.w,2) + Math.pow(this.h,2));
            //console.log("Size diff: " + Math.abs(this._size1 - size2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        // if(this._isSelectingMultiple){
        //     if(Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
        //         this._context.eventLog.push(this.logMove());
        //     }
        // }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("ellipse", this.x, this.y);
    }
    /**
     * Logs a resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("ellipse with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
        //Math.round(this._size1*100)/100, Math.round((Math.sqrt(Math.pow(this.w,2) + Math.pow(this.h,2))*100))/100);
    }
    /**
     * Logs a click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("ellipse with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the ellipse
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the ellipse
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the ellipse
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the ellipse
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the ellipse is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the ellipse
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the ellipse has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the ellipse has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the ellipse is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return (" ellipse with ID " + this.getID().toString() + " at " + this.x + ", " + this.y);
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("ellipse with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to ellipse at " + this.x + ", " + this.y);
    }
}
exports.EllipseEffect = EllipseEffect;
/**
 * Get's the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":65}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class EphEffect {
    constructor(eph) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._eph = eph;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ephImg = new Image();
            this._ephImg.src = './pics/demoncow.png';
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        //var imgObj = new Image();
        //let ctx = this._canvas.getContext('2d');
        // this._ephImg = new Image();
        // this._ephImg.src = './pics/demoncow.png';
        //imgObj.onload = function(){
        //this._ephImg.onload = function(){
        this._ctx.drawImage(this._ephImg, this.x, this.y, width, height);
        //this._ephImg.onload = function(){
        // this._ephImg.width = width;
        // this._ephImg.height = height;
        //}
        //}
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) {
            switch (corner) { //colors the coreph guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) {
            switch (corner) { //colors the coreph guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else {
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * @param event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //console.log("ephangle dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._eph.width = new NumberNode_1.NumberNode(10);
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._eph.height = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._eph.height = new NumberNode_1.NumberNode(10);
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._eph.width = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._eph.width = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._eph.height = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._eph.width = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._eph.height = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.w > 10 && this.h > 10) {
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._eph.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._eph.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._eph.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10 && this.h > 10) {
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._eph.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) {
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) {
                case 1:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h;
                    break;
                case 2:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h;
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
            //this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h / 2);
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) {
                case 5:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y + h;
                    break;
                case 6:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2;
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) {
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let eph = this._canvas.getBoundingClientRect();
        if (mouseX < eph.left || mouseX > eph.right || mouseY < eph.top || mouseY > eph.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs an eph paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("eph", this.x, this.y);
    }
    /**
     * Logs an eph resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("eph with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs an eph click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("eph with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Not implemented");
    }
    updateAST() {
        throw new Error("Not implemented");
    }
    /**
     * Returns the x position of the eph
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the eph
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the eph
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the eph
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the eph is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the image
     */
    get image() {
        return this._ephImg;
    }
    /**
     * Returns the ID of the eph
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the eph has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the eph has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the eph is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " eph with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("eph with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to eph at " + this.x + ", " + this.y);
    }
}
exports.EphEffect = EphEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let eph = canvas.getBoundingClientRect();
    return {
        x: event.clientX - eph.left,
        y: event.clientY - eph.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":65}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class LineEffect {
    constructor(line) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._line = line;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        this._ctx.moveTo(x, y);
        this._ctx.lineTo(x + width, y + height);
        this._ctx.strokeStyle = "#673AB7";
        this._ctx.stroke();
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) { // a corner guide is selected
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) { // a middle guide is selected
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else { //if no guides are selected, colors everything white
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._line.dx = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._line.dy = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._line.dy = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._line.dx = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._line.dx = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._line.dy = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._line.dx = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._line.dy = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.h > 10) { //as long as the height is > 10
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._line.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._line.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._line.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10) { // as long as width is > 10
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._line.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) { // sets the offsets depending on which corner is selected
                case 1: // top left
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w; // offset is bottom right
                    this._dragoffy = y + h;
                    break;
                case 2: // top right
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h; // offset is bottom left, etc
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) { // sets the offsets depending on which middle guide is selected
                case 5: // top middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2; // offset is bottom middle
                    this._dragoffy = y + h;
                    break;
                case 6: //right middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2; // offset is left middle etc
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) { // dragging
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) { // not selected
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isChangingDims = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a rectangle paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("rectangle", this.x, this.y);
    }
    /**
     * Logs a rectangle resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("rectangle with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs a rectangle click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("rectangle with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the rect
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the rect
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the rect
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the rect
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the rect is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the rect
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the rect has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the rect has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the rect is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " rectangle with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("rectangle with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to rectangle at " + this.x + ", " + this.y);
    }
}
exports.LineEffect = LineEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":65}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class NumberEffect {
    constructor(num) {
        this._fontSize = 20;
        this._corner = 0;
        this._isEditing = false;
        this._isListening = false;
        this._isDragging = false;
        this._isResizing = false;
        this._isSelectingMultiple = false;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._numberMetrics = {
            width: 0,
            height: 0,
            interval: 0,
            str: "",
            initMousePos: 0,
            cursorPos: 0
        };
        this._num = num;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas != undefined) {
            this._context = context;
            this._canvas = context.canvas.get();
            this._dims = dims;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this.update();
            // logging
            this._context.eventLog.push(this.logPaint()); // this.context or context?
            context.effects.push(this);
            this.addEventListeners();
        }
        else {
            console.log("canvas is NOT defined");
        }
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let fontDeets = this._fontSize + "px Courier New";
        this._ctx.font = fontDeets;
        this._ctx.fillStyle = "#673AB7";
        let str = this._num.toString();
        this._ctx.fillText(str, this.x, this.y);
        let numberDims = this._ctx.measureText(str);
        this._numberMetrics.width = numberDims.width;
        this._numberMetrics.height = this._fontSize;
        this._numberMetrics.str = str;
        this._numberMetrics.interval = this._numberMetrics.width / this._numberMetrics.str.length;
        if (this._isSelected) {
            this.drawTextGuides(this.x, this.y - this._fontSize, this._numberMetrics.width, this._numberMetrics.height, this._corner);
        }
        if (this._isEditing) {
            this.modifyTextCursor();
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        return (this.x <= mx) && (this.x + this._numberMetrics.width >= mx) &&
            (this.y - this._fontSize <= my) && (this.y >= my);
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let xdif = mx - (this.x + this._numberMetrics.width);
        let ydif = my - (this.y - this._fontSize);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) {
            this._isEditing = false;
            return 2;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawTextGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0) {
            switch (corner) { //colors the guide blue if selected
                case 2:
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue');
                    break;
            }
        }
        else {
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white');
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /* Event listener functions */
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isSelected && this._isDragging) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this._fontSize < 15);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        if (!this._isSelectingMultiple && this._isSelected && this.contains(this._mouse.x, this._mouse.y)) { //text editing
            if (!this._isListening) {
                window.addEventListener('keydown', this.modifyText.bind(this));
            }
            this._isListening = true;
            this._isEditing = true;
            this._isDragging = false;
            this._numberMetrics.initMousePos = this._mouse.x;
            this.modifyTextCursor();
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isEditing = false;
        }
        else {
            this._isEditing = false;
        }
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y) > 0, this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //("string dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Creates and moves the text edit cursor based on where the mouse is clicked
     */
    modifyTextCursor() {
        let leftWall = this.x; // the x position of the left most side of the bounding rectangle
        let xDif = this._numberMetrics.initMousePos - leftWall; // difference between mouse x and left wall
        let interval = this._numberMetrics.interval; // the text width divided by the length of the string
        let moveFactor = 0;
        if (xDif >= interval / 2 && xDif <= interval) {
            moveFactor = leftWall + interval;
            this._numberMetrics.cursorPos = interval;
        }
        else if (xDif <= interval / 2) {
            moveFactor = leftWall;
            this._numberMetrics.cursorPos = 0;
        }
        else if (xDif % interval >= interval / 2) {
            moveFactor = leftWall + interval * Math.ceil(xDif / interval);
            this._numberMetrics.cursorPos = interval * Math.ceil(xDif / interval);
        }
        else if (xDif % interval < interval / 2) {
            moveFactor = leftWall + interval * Math.floor(xDif / interval);
            this._numberMetrics.cursorPos = interval * Math.floor(xDif / interval);
        }
        this._ctx.moveTo(moveFactor, this.y - this._fontSize);
        this._ctx.lineTo(moveFactor, this.y);
        this._ctx.strokeStyle = "grey";
        this._ctx.stroke();
    }
    /**
     * This edits the string when editing text
     * @param event keydown event
     */
    modifyText(event) {
        if (this._isEditing) {
            let firstHalf;
            let secondHalf;
            let str = this._num.toString();
            let breakPoint = this._numberMetrics.cursorPos / this._numberMetrics.interval;
            firstHalf = str.substring(0, breakPoint);
            secondHalf = str.substring(breakPoint);
            if (event.keyCode == 37 && this._numberMetrics.initMousePos > this.x + this._numberMetrics.interval / 2) {
                this._numberMetrics.initMousePos -= this._numberMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 39 && this._numberMetrics.initMousePos < this.x + this._numberMetrics.width) {
                this._numberMetrics.initMousePos += this._numberMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 8 && str.length > 0) {
                firstHalf = firstHalf.substring(0, firstHalf.length - 1);
                str = firstHalf + secondHalf;
                this._num.val = Number(str);
                this._numberMetrics.initMousePos -= this._numberMetrics.interval;
                this.modifyTextCursor();
            }
            else {
                let keyName = event.key;
                if (keyName.length == 1) {
                    firstHalf += keyName;
                    str = firstHalf + secondHalf;
                    this._num.val = Number(str);
                    this._numberMetrics.initMousePos += this._numberMetrics.interval;
                    this.modifyTextCursor();
                }
            }
        }
    }
    /**
     * Modifies the font size of the text
     * If the text font is smaller than 15pt, it set's it equal to 15pt
     * @param isTooSmall true if the font size is < 15
     */
    modifyResize(isTooSmall) {
        if (isTooSmall) {
            this._fontSize = 15;
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._fontSize += (newDistance - this._initDistance) * 0.2;
                this._initDistance = newDistance;
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this._fontSize += (newDistance - this._initDistance) * 0.2;
            this._initDistance = newDistance;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x = this.x;
                this._y = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
            else {
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
                this._isDragging = true;
            }
            // if(this._context.mulSelected.mulSel){
            //     console.log("string effect mulSelected: " + this._context.mulSelected.mulSel);
            //     //if(this._context.mulSelected.val){
            //     this._context.eventLog.push(this.logSelected());
            //     //this.logSelected();
            // }
        }
        else if (guideContains) { //if the corner guides contain the mouse we are resizing
            this._isSelected = true;
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._context.eventLog.push(this.logClick());
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
            this._isResizing = true;
            this._size1 = this._fontSize; // saving old font size
        }
        else if (contains) {
            this._x = this.x; // Saving original x and y
            this._y = this.y;
            this._isSelected = true;
            this._context.eventLog.push(this.logClick());
            this._dragoffx = this._mouse.x - this.x;
            this._dragoffy = this._mouse.y - this.y;
            if (!this._isEditing) {
                this._isDragging = true;
            }
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
            this._isEditing = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x - this.x) > 1 || Math.abs(this._y - this.y) > 1) {
                this._justDragged = true;
                //this._context.eventLog.push(this.logMove());
            }
        }
        else if (this._isResizing && this._isSelected) {
            this._isResizing = false;
            if (Math.abs(this._size1 - this._fontSize) > 0) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._corner = 0;
        // console.log("string effect mulSelected: " + this._context.mulSelected.val);
        // if(this._context.mulSelected.val){
        //     this.logSelected();
        // }
        // if(this.isMultipleSelected){
        //     context.eventLog.push(new SelectEvent(selectedElems));
        //     masterLog.push(context.eventLog[context.eventLog.length - 1]);
        //     //console.log("multiple selected");
        // }
        // //this._context.eventLog.push(this.logMove());
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._isEditing = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent(this._num.toString(), this.x, this.y);
    }
    /**
     * Logs a resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent(this._num.toString() + " with ID " + this.getID().toString(), Math.round(this._size1 * 100) / 100, Math.round(this._fontSize * 100) / 100);
    }
    /**
     * Logs a click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent(this._num.toString() + " with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id, };
    }
    /**
     * Returns the canvas
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Sets the canvas
     * @param canvas The canvas to be assigned
     */
    set canvas(canvas) {
        this._canvas = canvas;
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the number
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the number
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
    * Returns whether or not the ellipse has just been dragged
    */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the ellipse has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the ellipse is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Returns whether or not this is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the number
     */
    get num() {
        return this._num.val;
    }
    /**
     * Returns the object ID
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " " + this._num.toString() + " with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return (this._num.toString() + " with ID " + this.getID().toString() + " from " + this._x + ", " + this._y + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to " + this._num.toString() + " at " + this.x + ", " + this.y);
    }
}
exports.NumberEffect = NumberEffect;
/**
 * Get's the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class RectangleEffect {
    constructor(rect) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._rect = rect;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        this._ctx.rect(x, y, width, height);
        //this._ctx.strokeStyle = "black";
        //this._ctx.stroke();
        this._ctx.fillStyle = "#d5b8ff";
        this._ctx.shadowColor = "#6C6C6C";
        this._ctx.shadowBlur = 15;
        //this._ctx.shadowOffsetX = 2;
        //this._ctx.shadowOffsetY = 2;
        this._ctx.fill();
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) { // a corner guide is selected
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) { // a middle guide is selected
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else { //if no guides are selected, colors everything white
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._rect.width = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._rect.height = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._rect.height = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._rect.width = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._rect.width = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._rect.height = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._rect.width = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._rect.height = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.h > 10) { //as long as the height is > 10
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._rect.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._rect.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._rect.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10) { // as long as width is > 10
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._rect.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) { // sets the offsets depending on which corner is selected
                case 1: // top left
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w; // offset is bottom right
                    this._dragoffy = y + h;
                    break;
                case 2: // top right
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h; // offset is bottom left, etc
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) { // sets the offsets depending on which middle guide is selected
                case 5: // top middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2; // offset is bottom middle
                    this._dragoffy = y + h;
                    break;
                case 6: //right middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2; // offset is left middle etc
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) { // dragging
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) { // not selected
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isChangingDims = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a rectangle paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("rectangle", this.x, this.y);
    }
    /**
     * Logs a rectangle resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("rectangle with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs a rectangle click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("rectangle with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the rect
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the rect
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the rect
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the rect
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the rect is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the rect
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the rect has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the rect has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the rect is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " rectangle with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("rectangle with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to rectangle at " + this.x + ", " + this.y);
    }
}
exports.RectangleEffect = RectangleEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":65}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class StringEffect {
    constructor(str) {
        this._fontSize = 20;
        //private _size2: number;
        this._corner = 0;
        this._isSelected = false; // Private bools
        this._isEditing = false;
        this._isListening = false;
        this._isDragging = false;
        this._isResizing = false;
        this._isSelectingMultiple = false;
        this._justDragged = false; // Has this object just been dragged?
        //private _log: string[];
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._textMetrics = {
            width: 0,
            height: 0,
            interval: 0,
            str: "",
            initMousePos: 0,
            cursorPos: 0
        };
        this._str = str;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas != undefined) {
            this._context = context;
            this._canvas = context.canvas.get();
            this._dims = dims;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this.update();
            // logging
            this._context.eventLog.push(this.logPaint()); // this.context or context?
            context.effects.push(this);
            this.addEventListeners();
        }
        else {
            console.log("canvas is NOT defined");
        }
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let fontDeets = this._fontSize + "px Courier New";
        this._ctx.font = fontDeets;
        this._ctx.fillStyle = "#673AB7";
        this._ctx.fillText(this._str.val, this.x, this.y);
        let textDims = this._ctx.measureText(this._str.val);
        this._textMetrics.width = textDims.width;
        this._textMetrics.height = this._fontSize;
        this._textMetrics.str = this._str.val;
        this._textMetrics.interval = this._textMetrics.width / this._textMetrics.str.length;
        if (this._isSelected) {
            this.drawTextGuides(this.x, this.y - this._fontSize, this._textMetrics.width, this._textMetrics.height, this._corner);
        }
        if (this._isEditing) {
            this.modifyTextCursor();
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        return (this.x <= mx) && (this.x + this._textMetrics.width >= mx) &&
            (this.y - this._fontSize <= my) && (this.y >= my);
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let xdif = mx - (this.x + this._textMetrics.width);
        let ydif = my - (this.y - this._fontSize);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) {
            this._isEditing = false;
            return 2;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawTextGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0) {
            switch (corner) { //colors the guide blue if selected
                case 2:
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue');
                    break;
            }
        }
        else {
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white');
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /* Event listener functions */
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isSelected && this._isDragging) {
            //console.log(this._str.val + " is being dragged.");
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this._fontSize < 15);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        if (!this._isSelectingMultiple && this._isSelected && this.contains(this._mouse.x, this._mouse.y)) { //text editing
            if (!this._isListening) {
                window.addEventListener('keydown', this.modifyText.bind(this));
            }
            this._isListening = true;
            this._isEditing = true;
            this._isDragging = false;
            //console.log(this._str.val + " is setting dragging to false");
            this._textMetrics.initMousePos = this._mouse.x;
            this.modifyTextCursor();
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isEditing = false;
        }
        else {
            this._isEditing = false;
        }
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y) > 0, this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //("string dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Creates and moves the text edit cursor based on where the mouse is clicked
     */
    modifyTextCursor() {
        let leftWall = this.x; // the x position of the left most side of the bounding rectangle
        let xDif = this._textMetrics.initMousePos - leftWall; // difference between mouse x and left wall
        let interval = this._textMetrics.interval; // the text width divided by the length of the string
        let moveFactor = 0;
        if (xDif >= interval / 2 && xDif <= interval) {
            moveFactor = leftWall + interval;
            this._textMetrics.cursorPos = interval;
        }
        else if (xDif <= interval / 2) {
            moveFactor = leftWall;
            this._textMetrics.cursorPos = 0;
        }
        else if (xDif % interval >= interval / 2) {
            moveFactor = leftWall + interval * Math.ceil(xDif / interval);
            this._textMetrics.cursorPos = interval * Math.ceil(xDif / interval);
        }
        else if (xDif % interval < interval / 2) {
            moveFactor = leftWall + interval * Math.floor(xDif / interval);
            this._textMetrics.cursorPos = interval * Math.floor(xDif / interval);
        }
        this._ctx.moveTo(moveFactor, this.y - this._fontSize);
        this._ctx.lineTo(moveFactor, this.y);
        this._ctx.strokeStyle = "grey";
        this._ctx.stroke();
    }
    /**
     * This edits the string when editing text
     * @param event keydown event
     */
    modifyText(event) {
        if (this._isEditing) {
            let firstHalf;
            let secondHalf;
            let breakPoint = this._textMetrics.cursorPos / this._textMetrics.interval;
            firstHalf = this._str.val.substring(0, breakPoint);
            secondHalf = this._str.val.substring(breakPoint);
            if (event.keyCode == 37 && this._textMetrics.initMousePos > this.x + this._textMetrics.interval / 2) {
                this._textMetrics.initMousePos -= this._textMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 39 && this._textMetrics.initMousePos < this.x + this._textMetrics.width) {
                this._textMetrics.initMousePos += this._textMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 8 && this._str.val.length > 0) {
                firstHalf = firstHalf.substring(0, firstHalf.length - 1);
                this._str.str = firstHalf + secondHalf;
                this._textMetrics.initMousePos -= this._textMetrics.interval;
                this.modifyTextCursor();
            }
            else {
                let keyName = event.key;
                if (keyName.length == 1) {
                    firstHalf += keyName;
                    this._str.str = firstHalf + secondHalf;
                    this._textMetrics.initMousePos += this._textMetrics.interval;
                    this.modifyTextCursor();
                }
            }
        }
    }
    /**
     * Modifies the font size of the text
     * If the text font is smaller than 15pt, it set's it equal to 15pt
     * @param isTooSmall true if the font size is < 15
     */
    modifyResize(isTooSmall) {
        if (isTooSmall) {
            this._fontSize = 15;
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._fontSize += (newDistance - this._initDistance) * 0.2;
                this._initDistance = newDistance;
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this._fontSize += (newDistance - this._initDistance) * 0.2;
            this._initDistance = newDistance;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
            else {
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
                this._isDragging = true;
            }
            // if(this._context.mulSelected.mulSel){
            //     console.log("string effect mulSelected: " + this._context.mulSelected.mulSel);
            //     //if(this._context.mulSelected.val){
            //     this._context.eventLog.push(this.logSelected());
            //     //this.logSelected();
            // }
        }
        else if (guideContains) { //if the corner guides contain the mouse we are resizing
            this._isSelected = true;
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._context.eventLog.push(this.logClick());
            //console.log(this._str.val + "is selected?" + this._selected);
            //console.log("state selection is " + this._str.val);
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
            this._isResizing = true;
            this._size1 = this._fontSize; // saving old font size
        }
        else if (contains) {
            this._x1 = this.x; // Saving original x and y
            this._y1 = this.y;
            this._isSelected = true;
            this._context.eventLog.push(this.logClick());
            //console.log(this._str.val + "is selected?" + this._selected);
            //console.log("state selection is " + this._str.val);
            this._dragoffx = this._mouse.x - this.x;
            this._dragoffy = this._mouse.y - this.y;
            if (!this._isEditing) {
                this._isDragging = true;
                //console.log(this._str.val + " is dragging? " + this._isDragging);
            }
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
            this._isEditing = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            //console.log(this._str.val + " logging drag");
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
                //this._context.eventLog.push(this.logMove());
            }
        }
        else if (this._isResizing && this._isSelected) {
            //console.log(this._str.val + " logging resize");
            this._isResizing = false;
            if (Math.abs(this._size1 - this._fontSize) > 0) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._corner = 0;
        // console.log("string effect mulSelected: " + this._context.mulSelected.val);
        // if(this._context.mulSelected.val){
        //     this.logSelected();
        // }
        // if(this.isMultipleSelected){
        //     context.eventLog.push(new SelectEvent(selectedElems));
        //     masterLog.push(context.eventLog[context.eventLog.length - 1]);
        //     //console.log("multiple selected");
        // }
        // //this._context.eventLog.push(this.logMove());
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._isEditing = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent(this._str.val, this.x, this.y);
    }
    /**
     * Logs a resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent(this._str.val + " with ID " + this.getID().toString(), Math.round(this._size1 * 100) / 100, Math.round(this._fontSize * 100) / 100);
    }
    /**
     * Logs a click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent(this._str.val + " with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id, };
    }
    /**
     * Returns the canvas
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Sets the canvas
     * @param canvas The canvas to be assigned
     */
    set canvas(canvas) {
        this._canvas = canvas;
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the ellipse
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the ellipse
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
    * Returns whether or not the ellipse has just been dragged
    */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the ellipse has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the ellipse is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Returns whether or not this is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the string
     */
    get str() {
        return this._str.val;
    }
    /**
     * Returns the object ID
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " " + this._str.val + " with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return (this._str.val + " with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to " + this._str.val + " at " + this.x + ", " + this.y);
    }
}
exports.StringEffect = StringEffect;
/**
 * Get's the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ReturnError_1 = require("../structural/ReturnError");
const space_lift_1 = require("space-lift");
// Application of a function. Assumes arg values passed in same order as FunDef args
class FunApp {
    /**
     * The constructor for a function application
     * @param name The name of the function
     * @param args Function arguments, if applicable
     * @param ws Preceding whitespace
     * @param defaultValue The default return value of the function, if any
     */
    constructor(name, args, ws, defaultValue) {
        this._defaultValue = undefined;
        this._newLine = false;
        this._name = name;
        this._args = args;
        this._defaultValue = defaultValue;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the function application
     * @param context
     */
    eval(context) {
        let fundef = context.lookup(this._name, context); // looking up function
        //let child = new Scope(fundef.scope); // avoiding overwrite; need to toss after returning
        let child = fundef.scope.copy(); // Copying definition scope
        // Assigns arg values to definition arguments
        if (this._args != null) {
            for (let i = 0; i < this._args.length; i++) { //lookups?
                //child.declare(this._funct.args[i]); // redeclare?
                child.assign(fundef.args[i], this._args[i]);
            }
        }
        let id = context.globalFunID; // Assigns an ID to the function
        context.globalFunID++;
        child.retValID = space_lift_1.Some(id); // new method
        // we only return a value with function application
        // if it is explicitly returned using a return statement;
        // we abuse JS exceptions for this purpose
        try {
            child.hadFunEval = true;
            fundef.body.eval(child);
            return this._defaultValue;
        }
        catch (e) {
            // make sure that we catch only the error intended for us
            if (e instanceof ReturnError_1.ReturnError && parseInt(e.ID) == id) {
                return e.retVal;
            }
            // error was not intended for us; rethrow
            throw e;
        }
        //return fundef.body.eval(child);
    }
    /**
     * Returns a string representation of the function application
     */
    toString() {
        let argsList = '';
        if (this._args.length > 0) {
            for (let i = 0; i < this._args.length - 1; i++) {
                argsList += this._args[i].toString() + ", ";
            }
            argsList += this._args[this._args.length - 1].toString();
        }
        return this._ws + this.name + '(' + argsList + ")";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Function applications cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a function application
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on functions");
    }
    /**
     * Returns the name of the function
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the arguments of the function
     */
    get args() {
        return this._args;
    }
}
exports.FunApp = FunApp;

},{"../structural/ReturnError":76,"space-lift":91}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
class FunDef {
    constructor(name, body, args, ws) {
        this._newLine = true;
        this._name = name;
        this._body = body;
        this._args = args;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    ;
    // Binds args in context of definition; no values
    // Binds name to parent context (cur context is new context)
    eval(context) {
        this._funScope = new Scope_1.Scope(context); // ************* copy????
        this._funScope.canvas = context.canvas;
        this._funScope.eventLog = context.eventLog;
        this._funScope.effects = context.effects;
        /*
        if(this._args != null){
            for(let entry of this._args){
                this._funScope.declare(entry);
            }
        }
        */
        context.declare(this._name); // assign with val function
        context.assign(this._name, this); // parent or current?
        return null;
    }
    newLine() {
        return this._newLine;
    }
    toString() {
        let argsList = '';
        if (this._args.length > 0) {
            for (let i = 0; i < this._args.length - 1; i++) {
                argsList += this._args[i] + ", ";
            }
            argsList += this._args[this._args.length - 1];
        }
        return this._ws + "fun " + this._name + "(" + argsList + ')' + ' {\n ' + this._body.toString() + '}';
    }
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    equalsVal(right) {
        throw new Error("Cannot call equals directly on functions");
    }
    // Get methods
    get name() {
        return this._name;
    }
    get body() {
        return this._body;
    }
    get args() {
        return this._args;
    }
    get scope() {
        return this._funScope;
    }
}
exports.FunDef = FunDef;

},{"../structural/Scope":77}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ListNode {
    /**
     * Constructor for an array-like list
     * @param list The list, stored in a TS array
     * @param ws Preceding whitespace
     */
    constructor(list, ws) {
        this._newLine = false;
        this._list = list;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates each element of the list and pushes it onto the internal representation
     * @param context
     */
    eval(context) {
        let evalList = [];
        for (let expr of this._list) {
            evalList.push(expr.eval(context));
        }
        return new ListNode(evalList);
    }
    /**
     * Returns a string representation of the list
     */
    toString() {
        let list = '';
        for (let i = 0; i < this._list.length - 1; i++) {
            list += this._list[i].toString() + ", ";
        }
        list += this._list[this._list.length - 1].toString();
        return this._ws + '[' + list + ']';
    }
    /**
     * Returns whether the list equals another list
     * @param right The right side of the equality (must be a ListNode)
     */
    equalsVal(right) {
        if (right instanceof ListNode) {
            for (let i = 0; i < this.list.length; i++) {
                if (!(this.list[i].equalsVal(right.list[i]))) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Draw cannot be called directly on a list
     */
    draw() {
        throw new Error("Cannot draw a ListNode");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the internal representation of the list
     */
    get list() {
        return this._list;
    }
}
exports.ListNode = ListNode;

},{}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class ClearEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for the Clear Event, which logs when the canvas is cleared
     * @param toLog What to log (spoiler: nothing)
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "clear";
    }
    /**
     * Assembles and returns message "Console cleared" with date and time attached
     */
    assembleLog() {
        let toPrint = "Console cleared";
        return this.logItem(toPrint);
    }
}
exports.ClearEvent = ClearEvent;

},{"./LogEvent":26}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class ClickEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Click Event, which logs when an object on the canvas is clicked
     * @param toLog The string representation of the object to log
     * @param x1 The x coordinate of the object to log
     * @param y1 The y coordinate of the object to log
     */
    constructor(toLog, x1, y1) {
        super(toLog, x1, y1);
        this.tag = "click";
    }
    /**
     * Assembles and returns message of form "Clicked on obj at x, y" with date and time attached
     */
    assembleLog() {
        let toPrint = "Clicked on " + this.toLog + " at " + this.x1.toString() + ", " + this.y1.toString();
        return this.logItem(toPrint);
    }
}
exports.ClickEvent = ClickEvent;

},{"./LogEvent":26}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class DragEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Drag Event, which logs when an object on the canvas is dragged
     * @param toLog The effect to log
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "drag";
        this._toPrint = this.assembleString();
    }
    /**
     * Assembles a log string using the Effect's toDragString() method
     */
    assembleString() {
        this._toPrint = this.toLog.toDragString();
        return this._toPrint;
    }
    /**
     * Assembles and returns final log message of form "Dragged obj from x1, y1 to x2, y2"
     * with date and time attached
     */
    assembleLog() {
        let print = "Dragged " + this._toPrint;
        return this.logItem(print);
    }
}
exports.DragEvent = DragEvent;

},{"./LogEvent":26}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class IDEvent extends LogEvent_1.LogEvent {
    /**
     * A constructor for an ID event, used when an object gets assigned an ID
     * @param toLog The effect to log
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "ID";
        this._toPrint = this.assembleString();
    }
    /**
     * Assembles string using the effect's toIDString() method
     */
    assembleString() {
        this._toPrint = this.toLog.toIDString();
        return this._toPrint;
    }
    /**
     * Assembles message of form "Assigned ID # to obj at x, y" with date and time attached
     */
    assembleLog() {
        let print = "Assigned ID " + this._toPrint;
        return this.logItem(print);
    }
}
exports.IDEvent = IDEvent;

},{"./LogEvent":26}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class LogEvent {
    /**
     * Abstract class constructor for a Log Event. Registers event time.
     * @param toLog The string, object, or array of objects to be logged
     * @param x1 Initial x position, if applicable
     * @param y1 Initial y position, if applicable
     * @param x2 Final x position, if applicable
     * @param y2 Final y position, if applicable
     */
    constructor(toLog, x1, y1, x2, y2) {
        let today = new Date();
        this._date = today.getFullYear() + '-' + (today.getMonth() + 1) + '-' + today.getDate();
        this._time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds();
        this._dateTime = this._date + ' ' + this._time;
        this._toLog = toLog;
        //this._toLogArray = toLogArray;
        this._x1 = x1;
        this._y1 = y1;
        this._x2 = x2;
        this._y2 = y2;
    }
    /**
     * Attaches date and time to log message
     * @param toLog The log message
     */
    logItem(toLog) {
        return " " + this._dateTime + ": " + toLog;
    }
    /**
     * Returns date-time string
     */
    get dateTime() {
        return this._dateTime;
    }
    /**
     * Returns string or effect(s) to be logged
     */
    get toLog() {
        return this._toLog;
    }
    /**
     * Returns event tag
     */
    get tag() {
        return this._tag;
    }
    /**
     * Sets tag string
     */
    set tag(tag) {
        this._tag = tag;
    }
    /**
     * Returns x1
     */
    get x1() {
        return this._x1;
    }
    /**
     * Returns y1
     */
    get y1() {
        return this._y1;
    }
    /**
     * Returns x2
     */
    get x2() {
        return this._x2;
    }
    /**
     * Returns y2
     */
    get y2() {
        return this._y2;
    }
}
exports.LogEvent = LogEvent;

},{}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class PaintEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Paint Event, used when an object is painted on the canvas
     * @param toLog The string representation of the object to be logged
     * @param x1 The x position of the object
     * @param y1 The y position of the object
     */
    constructor(toLog, x1, y1) {
        super(toLog, x1, y1);
        this.tag = "paint";
    }
    /**
     * Assembles and returns message of form "Painted obj at x, y" with date and time attached
     */
    assembleLog() {
        let toPrint = "Painted " + this.toLog + " at " + this.x1.toString() + ", " + this.y1.toString();
        return this.logItem(toPrint);
    }
}
exports.PaintEvent = PaintEvent;

},{"./LogEvent":26}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class ResizeEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for Resize Event, used when an object on the canvas is resized
     * @param toLog String representation of the object to be logged
     * @param x1 Initial x dimension of the object, or initial font size
     * @param y1 Initial y dimension of the object, or final font size
     * @param x2 Final x dimension of the object
     * @param y2 Final y dimension of the object
     */
    constructor(toLog, x1, y1, x2, y2) {
        super(toLog, x1, y1, x2, y2);
        this.tag = "resize";
    }
    /**
     * Assembles log message of form "Resized obj from size x1, y1 to size x1, y2" for rects and ellipses
     * or of form "Resized obj from size x1 to size y1" for strings
     * Has date and time attached
     */
    assembleLog() {
        if (this.x2 != undefined && this.y2 != undefined) {
            this.toPrint = "Resized " + this.toLog + " from size " + this.x1.toString() + " by " + this.y1.toString()
                + " to size " + this.x2.toString() + " by " + this.y2.toString();
        }
        else {
            this.toPrint = "Resized " + this.toLog + " from size " + this.x1.toString() + " to size " + this.y1.toString();
        }
        return this.logItem(this.toPrint);
    }
}
exports.ResizeEvent = ResizeEvent;

},{"./LogEvent":26}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class SelectEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Selection Event, used when multiple objects on the canvas are selected
     * @param toLog The array of objects selected
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "select";
        this._toPrint = this.assembleStrings();
    }
    /**
     * Assembles and returns a string representation of all the objects selected
     */
    assembleStrings() {
        let logStrings = [];
        for (let elem of this.toLog) {
            logStrings.push(elem.toSelString());
        }
        return "Selected" + logStrings;
    }
    /**
     * Returns the message with date and time attached
     */
    assembleLog() {
        return this.logItem(this._toPrint);
    }
}
exports.SelectEvent = SelectEvent;

},{"./LogEvent":26}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class And {
    /**
     * Constructor for logical 'and' (&&) operation
     * @param left The left side of the operation
     * @param right The right side of the operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the operation and returns a boolean of the result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof BooleanNode_1.BooleanNode && rhs instanceof BooleanNode_1.BooleanNode) {
            return new BooleanNode_1.BooleanNode(lhs.val && rhs.val);
        }
        else {
            throw new Error("The arguments to the 'and' operator must be booleans.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + ' and ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on the 'and' op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * The 'and' operation cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns the left side of the op
     */
    get left() {
        return this._left;
    }
    /**
     * Returns the right side of the op
     */
    get right() {
        return this._right;
    }
}
exports.And = And;

},{"../prims/BooleanNode":63}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class Equals {
    /**
     * Constructor for equality (==) operation
     * @param left The left side of the equality
     * @param right The right side of the equality
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the comparison and evaluates to a BooleanNode
     * @param context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        return new BooleanNode_1.BooleanNode(lhs.equalsVal(rhs));
    }
    /**
     * Returns a string representation of the equality op
     */
    toString() {
        return this._ws + this._left.toString() + ' equals ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals can't be called directly on an equality op
     * @param right
     */
    equalsVal(right) {
        throw new Error("well this is meta");
    }
    /**
     * Equality ops can't be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.Equals = Equals;

},{"../prims/BooleanNode":63}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class GreaterThan {
    /**
     * Constructor for GreaterThan (>) op
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs GreaterThan comparison and returns BooleanNode representation of result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val > rhs.val));
        }
        else {
            throw new Error("The arguments to the > operator must be numeric.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + " > " + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on GreaterThan op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * GreaterThan op cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.GreaterThan = GreaterThan;

},{"../prims/BooleanNode":63,"../prims/NumberNode":65}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class GreaterThanEq {
    /**
     * Constructor for GreaterThanEq (greater than or equal to, >=) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs GreaterThanEq operation and returns BooleanNode with result
     * @param context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val >= rhs.val));
        }
        else {
            throw new Error("The arguments to the >= operator must be numeric.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + ' >= ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on GreaterThanEq op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * GreaterThanEq op cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.GreaterThanEq = GreaterThanEq;

},{"../prims/BooleanNode":63,"../prims/NumberNode":65}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class LessThan {
    /**
     * Constructor for LessThan (<) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the LessThan comparison and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        //console.log(this._left.eval(context) + " is less than " + this._right.eval(context));
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            //console.log("They're both number nodes");
            //console.log(lhs.val + "<" + rhs.val);
            //let bool: boolean = lhs.val < rhs.val;
            //console.log("bool: " + bool);
            return (new BooleanNode_1.BooleanNode(lhs.val < rhs.val));
        }
        else {
            throw new Error("Arguments to less than must produce numeric values.");
        }
    }
    /**
     * Returns string representation of operation
     */
    toString() {
        return this._left.toString() + ' < ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on LessThan op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * LessThan op cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.LessThan = LessThan;

},{"../prims/BooleanNode":63,"../prims/NumberNode":65}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class LessThanEq {
    /**
     * Constructor for LessThanEq (less than or equal to, <=) operation
     * @param left The left side of the operation
     * @param right The right side of the operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the LessThanEq comparison and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val <= rhs.val));
        }
        else {
            throw new Error("The arguments to the <= operator must be numeric.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + " <= " + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on LessThanEq op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * LessThanEq ops cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.LessThanEq = LessThanEq;

},{"../prims/BooleanNode":63,"../prims/NumberNode":65}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class Not {
    /**
     * Constructor for the logical Not (!) operation
     * @param expr The expression to be operated on (must be a BooleanNode)
     * @param ws Preceding whitespace
     */
    constructor(expr, ws) {
        this._newLine = false;
        this._expr = expr;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the Not operation and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        let e = this._expr.eval(context);
        if (e instanceof BooleanNode_1.BooleanNode) {
            return new BooleanNode_1.BooleanNode(!e.val);
        }
        else {
            throw new Error("The argument to the ! operator must be boolean.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + "not " + this._expr.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on a Not op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * Not operations cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns expression to be operated on
     */
    get expr() {
        return this._expr;
    }
}
exports.Not = Not;

},{"../prims/BooleanNode":63}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class NotEqual {
    /**
     * Constructor for NotEqual (!=) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs NotEqual operation and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val !== rhs.val));
        }
        else {
            throw new Error("The arguments to the != operator must be numeric.");
        }
    }
    /**
     * Returns string representation of operation
     */
    toString() {
        return this._ws + this._left.toString() + " not equals " + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on a NotEqual op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * NotEqual ops cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.NotEqual = NotEqual;

},{"../prims/BooleanNode":63,"../prims/NumberNode":65}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class Or {
    /**
     * Constructor for logical 'or' (||) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs Or operation and returns BooleanNode with result
     * @param context Current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof BooleanNode_1.BooleanNode && rhs instanceof BooleanNode_1.BooleanNode) {
            return new BooleanNode_1.BooleanNode(lhs.val || rhs.val);
        }
        else {
            throw new Error("The arguments to the 'or' operator must be booleans.");
        }
    }
    /**
     * Returns string representation of operation
     */
    toString() {
        return this._ws + this._left.toString() + ' or ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on Or operation
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * Or operations cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.Or = Or;

},{"../prims/BooleanNode":63}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const BooleanNode_1 = require("../prims/BooleanNode");
const space_lift_1 = require("space-lift");
class ForNode {
    /**
     * Constructor for a For loop
     * @param init Initializes the variable used in the condition
     * @param cond The condition (must evaluate to BooleanNode)
     * @param post The postevaluation condition
     * @param body The body of the loop
     * @param ws Preceding whitespace
     */
    constructor(init, cond, post, body, ws) {
        this._newLine = true;
        this._init = init;
        this._cond = cond;
        this._post = post;
        this._body = body;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the For loop
     * @param context The current program context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        this._init.eval(childCtx); // initialize var
        let res = this._cond.eval(childCtx);
        if (!(res instanceof BooleanNode_1.BooleanNode)) {
            throw new Error("The condition must be a boolean expression.");
        }
        let ret;
        while (res.val) {
            ret = this._body.eval(childCtx);
            this._post.eval(childCtx);
            res = this._cond.eval(childCtx);
        }
        return ret;
    }
    /**
     * Equals cannot be called directly on ForNode
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on For loop");
    }
    /**
     * ForNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        return "Cannot call draw on For loop";
    }
    /**
     * Returns a string representation of the for loop
     */
    toString() {
        return this._ws + 'for(' + this._init.toString() + ", " + this._cond.toString() + ", " + this._post.toString() + ") {\n "
            + this._body.toString() + "}";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.ForNode = ForNode;

},{"../prims/BooleanNode":63,"../structural/Scope":77,"space-lift":91}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const BooleanNode_1 = require("../prims/BooleanNode");
const space_lift_1 = require("space-lift");
class WhileNode {
    /**
     * Constructor for a While loop
     * @param cond The While loop condition
     * @param body The body of the loop
     * @param ws Preceding whitespace
     */
    constructor(cond, body, ws) {
        this._newLine = true;
        this._cond = cond;
        this._body = body;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the body of the loop while the condition is true
     * @param context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        let res = this._cond.eval(childCtx);
        if (!(res instanceof BooleanNode_1.BooleanNode)) {
            throw new Error("The condition must be a boolean expression.");
        }
        let ret;
        while (res.val) {
            ret = this._body.eval(childCtx);
            res = this._cond.eval(childCtx);
        }
        return ret;
    }
    /**
     * Equals cannot be called directly on WhileNodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on While loop");
    }
    /**
     * WhileNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        return "Cannot call draw on While loop";
    }
    /**
     * Returns a string representation of the While loop
     */
    toString() {
        return this._ws + "while(" + this._cond.toString() + ") {\n " + this._body.toString() + "}";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.WhileNode = WhileNode;

},{"../prims/BooleanNode":63,"../structural/Scope":77,"space-lift":91}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Instruction {
    constructor(location, content, top, left) {
        this._location = location;
        this._content = content;
        this._top = top;
        this._left = left;
    }
}
exports.Instruction = Instruction;

},{}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonFourCpOne {
    constructor() {
        this._name = "l4c1";
        this._nextModule = 'l4c2';
        this._constraint = 'none';
        this._instructions = `<p> You've made it to the FINAL CHALLENGES! Complete these challenges to earn ETERNAL GLORY! </p>
    <p> Throughout this Hour of Code, you have learned: </p>
    <p> - How to print a word, circle, rectangle, and curve. </p>
    <p> - How to store any of the value above in a variable. </p>
    <p> - How to use if/else statement to check a condition about a variable. </p>
    <p> Each of the following challenges will test these concepts. Let's dive right in! </p>
    <p> Print a circle and put its height and width in one of the boxes to the side. Then print a rectangle and put its height and width in the box. </p>
    <p> CHALLENGE: Print a circle and rectangle. Put their respective width and height in the boxes provided. </p>`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonFourCpOne = LessonFourCpOne;

},{"../effects/EllipseEffect":13}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonFourCpTwo {
    constructor() {
        this._name = "l4c2";
        this._nextModule = 'l4c2';
        this._constraint = 'none';
        this._instructions = `<p> Yes! You got this! </p>
    <p> Now let's put those skills in if/else statements to work! </p>
    <p> Create a pair of if/else statements to print out to the CANVAS a claim of whether the circle is positioned ABOVE or BELOW the rectangle. </p>
    <p> CHALLENGE: Print a claim that states whether circle is ABOVE or BELOW the rectangle. </p>
    <p> HINT: Remember that the numbers in the print() statements determine the position of the shapes being printed. </p>`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonFourCpTwo = LessonFourCpTwo;

},{"../effects/EllipseEffect":13}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpFour {
    constructor() {
        this._name = "l1c4";
        this._prevModule = 'l1c2';
        this._nextModule = 'l2c1';
        this._constraint = 'canvas';
        this._instructions = `<p> Note that changing the first number in the print statement moves the words left or right, while changing the second number move them up or down. </p>
    <p> Now time for a challenge! Print the word "moo" on the CANVAS, and put it right in the center of the entire CANVAS. </p>
    <p> CHALLENGE: Print the word "moo" in the center of the CANVAS. </p>
    <p> HINT: Write print("moo", 50, 50) in the CODE area first, then change the numbers inside that print statement. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "moo") {
                if ((effect.x > 200 && effect.x < 300) && (effect.y > 200 && effect.y < 300)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpFour = LessonOneCpFour;

},{"../effects/StringEffect":18}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Instruction_1 = require("./Instruction");
class LessonOneCpOne {
    constructor() {
        this._name = "l1c1";
        this._nextModule = 'l1c2';
        this._constraint = 'none';
        this._instructions = `<p> Computers can do wonderful things, but they unfortunately don't understand English. </p>
    <p> However, they understand computer code, so let's learn how to write code that instruct the computer to do things! </p>
    <p> On the CODE area above, write print("Hello") </p>
    <p> GOAL: Write 'Hello' on the CANVAS. </p>`;
        this._instrBoxes = [];
        this._instrIndex = 0;
        this._latestInstrIndex = 0;
        let content = "First, let's tell the computer to print something on the CANVAS. Click on the CODE box.";
        this._instrBoxes.push(new Instruction_1.Instruction('code', content, "30%", "10%"));
        content = 'Now type `print("Hello")` in this CODE box.';
        this._instrBoxes.push(new Instruction_1.Instruction('code', content, "30%", "10%"));
        content = 'Notice that what you typed causes the computer to print the word "Hello" on the CANVAS here. Congratulations! You just wrote your first line of code!';
        this._instrBoxes.push(new Instruction_1.Instruction('canvas', content, "65%", "10%"));
    }
    /**
     * A lesson to print a string
     * goals: write any string on CANVAS
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        let input = document.getElementById('input');
        let regex = /print\s*\(\s*\"Hello\"\s*\)/;
        let match = input.value.match(regex);
        if (match != null && match.length > 0) {
            return true;
        }
        return false;
        /*
        console.log("instrIndex in checkGoal: " + this._instrIndex);
        switch(this._instrIndex) {

          case 0:
            if (document.activeElement === input && this._latestInstrIndex == 0) {
              this._latestInstrIndex++;
              this.nextInstruction(document);
            }
            return false;
            break;

          case 1:
            let regex: RegExp = /print\s*\(\s*\"Hello\"\s*\)/;
            let match = input.value.match(regex);
            if (match != null && match.length > 0 && this._latestInstrIndex == 1) {
              this._latestInstrIndex++;
              this.nextInstruction(document);
            }
            return false;
            break;

          default:
            return true;
            break;
        }

        return false;
        */
    }
    nextInstruction(document) {
        this._instrIndex = (this._instrIndex + 1 < this._instrBoxes.length) ? this._instrIndex + 1 : this._instrIndex;
        this.renderInstruction(document);
    }
    prevInstruction(document) {
        this._instrIndex = (this._instrIndex - 1 >= 0) ? this._instrIndex - 1 : this._instrIndex;
        this.renderInstruction(document);
    }
    /**
     * render the current instruction of this checkpoint
     * @param document The HTML document
     */
    renderInstruction(document) {
        let curInstruction = document.getElementById("instruction");
        if (curInstruction != null) {
            curInstruction.remove();
        }
        let instruction = this._instrBoxes[this._instrIndex];
        let instrDiv = document.createElement("div");
        instrDiv.className = "instruction";
        instrDiv.id = 'instruction';
        instrDiv.innerText = instruction._content;
        instrDiv.style.top = instruction._top;
        instrDiv.style.left = instruction._left;
        instrDiv.style.display = "block";
        let prevInstr = document.createElement("button");
        prevInstr.id = 'previous-instruction';
        prevInstr.innerText = "<";
        let thisModule = this;
        prevInstr.onclick = function () {
            console.log("instrIndex " + thisModule._instrIndex);
            thisModule.prevInstruction(document);
        };
        if (this._instrIndex == 0) {
            prevInstr.style.background = "#D8D8D8";
            prevInstr.disabled = true;
        }
        instrDiv.appendChild(prevInstr);
        let nextInstr = document.createElement("button");
        nextInstr.id = 'next-instruction';
        nextInstr.innerText = ">";
        nextInstr.onclick = function () {
            console.log("instrIndex " + thisModule._instrIndex);
            thisModule.nextInstruction(document);
        };
        if (this._instrIndex == this._instrBoxes.length || this._instrIndex == this._latestInstrIndex) {
            nextInstr.style.background = "#D8D8D8";
            nextInstr.disabled = true;
        }
        instrDiv.appendChild(nextInstr);
        document.getElementById(instruction._location).appendChild(instrDiv);
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpOne = LessonOneCpOne;

},{"./Instruction":41}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpThree {
    constructor() {
        this._name = "l1c3";
        this._prevModule = 'l1c2';
        this._nextModule = 'l1c4';
        this._constraint = 'canvas';
        this._instructions = `<p> Yep! Moving the words actually change the numbers in your CODE. </p>
    <p> Now the CANVAS has been frozen! Try changing your CODE to see if you can move the words to the bottom right corner. </p>
    <p> GOAL: Move the words to the bottom right of the CANVAS. </p>
    <p> HINT: Change one of the 2 numbers at a time, then click RUN to see how that changes the CANVAS.`;
        this.x = 10;
        this.y = 430;
    }
    drawGuides(ctx) {
        ctx.beginPath();
        ctx.rect(this.x, this.y, 100, 100);
        ctx.strokeStyle = '#6C6C6C';
        ctx.stroke();
        ctx.font = 20 + "px Courier New";
        ctx.fillStyle = '#6C6C6C';
        ctx.fillText("Put text", this.x, 390);
        ctx.fillText("in here", this.x, 410);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str !== "") {
                if (effect.x > this.x && effect.x < this.x + 100 && effect.y > this.y && effect.y < this.y + 100) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpThree = LessonOneCpThree;

},{"../effects/StringEffect":18}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpTwo {
    constructor() {
        this._name = "l1c2";
        this._nextModule = 'l1c3';
        this._constraint = 'code';
        this._instructions = `<p> You just told the computer to write words on the CANVAS! </p>
    <p> Now let's do something more interesting: click on the words on the CANVAS, then drag it inside the box at the top-right corner. Observe what happens to your code. </p>
    <p> GOAL: Move the words you just created inside the top-right box. </p>`;
        this.x = 390;
        this.y = 10;
    }
    drawGuides(ctx) {
        ctx.beginPath();
        ctx.rect(this.x, this.y, 100, 100);
        ctx.strokeStyle = '#6C6C6C';
        ctx.stroke();
        ctx.font = 20 + "px Courier New";
        ctx.fillStyle = '#6C6C6C';
        ctx.fillText("Put text", 390, 130);
        ctx.fillText("in here", 390, 150);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str !== "") {
                if (effect.x > this.x && effect.x < this.x + 100 && effect.y > this.y && effect.y < this.y + 100) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpTwo = LessonOneCpTwo;

},{"../effects/StringEffect":18}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpFive {
    constructor() {
        this._name = "l3c5";
        this._nextModule = 'l3c6';
        this._constraint = 'none';
        this._instructions = `<p> So we print a message to the CANVAS anytime c is exactly equal to 8. </p>
    <p> What if we want to print another message, "c is not equal to 8" any time c is not equal to 8? </p>
    <p> We do so by using an else statement. Observe the CODE above. </p>
    <p> When the condition inside the if() statement is satisfied, the code block inside the {} right after it would run. </p>
    <p> When that condition is not satisfied, the code block inside the {} after the else statement would run. </p>
    <p> GOAL: Change the value of c so that the line "c is NOT equal to 8." is printed on the CANVAS. </p>`;
        this._starterCode = `c = 8;
if(c == 8) {
  print("c is equal to 8.", 103, 143);
} else {
  print("c is NOT equal to 8.", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /c\s*=\s*[^8]\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "c is NOT equal to 8.") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpFive = LessonThreeCpFive;

},{"../effects/StringEffect":18}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpFour {
    constructor() {
        this._name = "l3c4";
        this._nextModule = 'l3c5';
        this._constraint = 'none';
        this._instructions = `<p> You can put an inequality condition in the if() clause, such as "a < 5" or "b > 20". </p>
    <p> You can also use an equality condition. Observe the CODE above with "c == 8". The 2 equal signs mean that you are checking whether c is exactly equal to 8 or not. </p>
    <p> Change the value of c so that the line "c is equal to 8." is printed on the CANVAS. </p>
    <p> GOAL: Change the value of c so that the line "c is equal to 8." is printed on the CANVAS. </p>`;
        this._starterCode = `c = 100;
if(c == 8) {
  print("c is equal to 8.", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /c\s*=\s*8\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "c is equal to 8.") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpFour = LessonThreeCpFour;

},{"../effects/StringEffect":18}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpOne {
    constructor() {
        this._name = "l3c1";
        this._nextModule = 'l3c2';
        this._constraint = 'none';
        this._instructions = `<p> We learned to tell the computer to print a lot of things. Unfortunately, the computer is kinda bad at math. </p>
    <p> Look at the CODE above. We let a = 5, then we print the value of a to the CANVAS. Then we print the line "a is less than 10". </p>
    <p> Since a = 5, and 5 < 10, we know that a is less than 10. But what would happen if we change the value of a to, say, 12? </p>
    <p> GOAL: change the value of a to 12. </p>
    <p> HINT: You can do this by changing the line a = 5 in the CODE area, or you can click on the number 5 on the CANVAS. </p>`;
        this._starterCode = `a = 5;
print(a, 118, 63);
print("a is less than 10", 103, 143);`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /a\s*=\s*12\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "a is less than 10") {
                //canvasIsCorrect = true;
                //break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpOne = LessonThreeCpOne;

},{"../effects/StringEffect":18}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpSix {
    constructor() {
        this._name = "l3c6";
        this._nextModule = 'l4c1';
        this._constraint = 'none';
        this._instructions = `<p> Now that you know how to use if/else statements, let's put them all together! </p>
    <p> Above we have the CODE to draw 2 circles: circle A has height and width a, and circle B has height and width b. </p>
    <p> However, currently the claim that "Circle A is smaller than circle B." regardless of the circles' actual sizes. </p>
    <p> Create an if/else statement to print "Circle A is smaller than circle B." when it is actually so, and print "Circle A is bigger than circle B" otherwise. </p>
    <p> CHALLENGE: Create an if/else statement to print the correct claim about the sizes of the 2 circles. </p>`;
        this._starterCode = `a = 200;
print(a, 111, 103);
print(ellipse(a, a), 131, 263);
b = 100;
print(b, 337, 104);
print(ellipse(b, b), 371, 248);
print("Circle A is smaller than circle B.", 45, 453);
`;
        this.xA = 20;
        this.yA = 150;
        this.xB = this.xA + 225 + 10;
        this.yB = 150;
    }
    drawGuides(ctx) {
        ctx.beginPath();
        ctx.rect(this.xA, this.yA, 225, 225);
        ctx.strokeStyle = '#6C6C6C';
        ctx.stroke();
        ctx.font = 20 + "px Courier New";
        ctx.fillStyle = '#6C6C6C';
        ctx.fillText("Circle A", this.xA, this.yA - 20);
        ctx.beginPath();
        ctx.rect(this.xB, this.yB, 225, 225);
        ctx.stroke();
        ctx.fillText("Circle B", this.xB, this.yB - 20);
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            /*
            if(a < b) {
              print("Circle A is smaller than circle B.", 45, 453);
            } else {
              print("Circle A is bigger than circle B.", 45, 453);
            }*/
            let regex1 = /if\s*\(\s*a\s*[<>]\s*b\s*\)/;
            let regex2 = /if\s*\(\s*b\s*[<>]\s*a\s*\)/;
            let match1 = code.match(regex1);
            let match2 = code.match(regex2);
            codeIsCorrect = (match1 != null && match1.length > 0) || (match2 != null && match2.length > 0);
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        let circleA = null;
        let circleB = null;
        //look for circles A and B
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                if (effect.x > this.xA && effect.x < this.xA + 225 && effect.y > this.yA && effect.y < this.yA + 225) {
                    circleA = effect;
                }
                else if (effect.x > this.xB && effect.x < this.xB + 225 && effect.y > this.yB && effect.y < this.yB + 225) {
                    circleB = effect;
                }
            }
        }
        if (circleA != null && circleB != null) {
            for (let effect of effects) {
                if (effect instanceof StringEffect_1.StringEffect) {
                    let str = effect.str;
                    if ((str === "Circle A is smaller than circle B." && circleA.w < circleB.w && circleA.h < circleB.h)
                        || (str === "Circle A is bigger than circle B." && circleA.w > circleB.w && circleA.h > circleB.h)) {
                        canvasIsCorrect = true;
                        break;
                    }
                }
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpSix = LessonThreeCpSix;

},{"../effects/EllipseEffect":13,"../effects/StringEffect":18}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpThree {
    constructor() {
        this._name = "l3c3";
        this._nextModule = 'l3c4';
        this._constraint = 'none';
        this._instructions = `<p> if statements allow you to run a block of code inside the curly braces {} ONLY when the condition inside the if() clause is true. </p>
    <p> Let's have a quick challenge: observe the CODE above. Make it so that the line "b is greater than 20" is only printed on the CANVAS when b is actually greater than 20. </p>
    <p> GOAL: Make the line "b is greater than 20" only be printed on the CANVAS when b is actually greater than 20. Change b to test the if() statement. </p>`;
        this._starterCode = `b = 8;
if(b < 10) {
  print("b is greater than 20.", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /if\s*\(\s*b\s*>\s*20\s*\)/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "b is greater than 20.") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpThree = LessonThreeCpThree;

},{"../effects/StringEffect":18}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpTwo {
    constructor() {
        this._name = "l3c2";
        this._nextModule = 'l3c3';
        this._constraint = 'none';
        this._instructions = `<p> Did you notice the claim that "a is less than 10" did not change? a is now 12 and clearly greater than 10! </p>
    <p> What we want is for the computer to only print "a is less than 10" ONLY when the value of a is truly less than 10. </p>
    <p> To do so, we use an if statement. Observe the CODE above. All we changed was to put in an if statement that checks whether a < 10. If a is, the code inside the curly braces {} are executed. </p>
    <p> Change the value of a to 12, 10, 8 and observe what happens. </p>
    <p> GOAL: RUN the CODE with a = 12 or 10 or 8. </p>`;
        this._starterCode = `a = 12;
print(a, 118, 63);
if(a < 10) {
  print("a is less than 10", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /a\s*=\s*8\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "a is less than 10") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpTwo = LessonThreeCpTwo;

},{"../effects/StringEffect":18}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpFive {
    constructor() {
        this._name = "l2c5";
        this._nextModule = 'l2c6';
        this._constraint = 'none';
        this._instructions = `<p> Did you see the CANVAS changed? </p>
    <p> In our code, we make variable a refer to the words "moo moo", and variable b refer to an ellipse(100, 100). </p>
    <p> As a result, when we tell the computer to print a, it will print "moo moo", and when we tell the computer to print b, it will print a circle. </p>
    <p> Let's take this one step further: Create a new variable c, and make it refer to an ellipse(100, 100). Then write 2 statements to print c. What do you think would happen? </p>
    <p> GOAL: Create a variable c referring to an ellipse(100, 100), then write 2 print statements to print c. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let assignment = /c\s*=\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*/g;
            let matchAssign = code.match(assignment);
            let print = /print\s*\(\s*c\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)/g;
            let matchPrint = code.match(print);
            codeIsCorrect = matchAssign != null && matchAssign.length > 0 && matchPrint != null && matchPrint.length >= 2;
        }
        //check for correct CANVAS effects
        let circleCount = 0;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                circleCount += 1;
            }
        }
        return codeIsCorrect && circleCount >= 2;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpFive = LessonTwoCpFive;

},{"../effects/EllipseEffect":13}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpFour {
    constructor() {
        this._name = "l2c4";
        this._nextModule = 'l2c5';
        this._constraint = 'none';
        this._instructions = `<p> There's no limit to how many print statements the computer can understand, so you can write 1000 print statements, and the computer will draw 1000 things on the CANVAS for you! </p>
    <p> Time to take your coding to the next level. Let's learn about variables. </p>
    <p> Variables are simply names you give to the things that you draw. </p>
    <p> For example, take a look at the code above. Change the a in the print statement to b, and observe what happened on the CANVAS. </p>
    <p> GOAL: Change a to b in the print statement. </p>`;
        this._starterCode = `a = "moo moo";\nb = ellipse(100, 100);\nprint(a, 50, 70);`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*b\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (!canvasIsCorrect && effect instanceof EllipseEffect_1.EllipseEffect) {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpFour = LessonTwoCpFour;

},{"../effects/EllipseEffect":13}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpOne {
    constructor() {
        this._name = "l2c1";
        this._nextModule = 'l2c2';
        this._constraint = 'none';
        this._instructions = `<p> Printing only words is kinda boring, so let's learn to print some shapes on the CANVAS! </p>
    <p> In the print statement, replace "moo" with ellipse(100,100). Hit the RUN button to see what happens. </p>
    <p> GOAL: replace "moo" with ellipse(100,100) in the print statement above. </p>
    <p> HINT: Highlight "moo" - including the double quotes ", and replace that with ellipse(100, 100). KEEP EVERYTHING ELSE THE SAME. </p>`;
        this._starterCode = `
    print("moo", 50, 70)`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpOne = LessonTwoCpOne;

},{"../effects/EllipseEffect":13}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberEffect_1 = require("../effects/NumberEffect");
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpSeven {
    constructor() {
        this._name = "l2c7";
        this._nextModule = 'l3c1';
        this._constraint = 'none';
        this._instructions = `<p> Changing one circle changes c, which will then in turn change the other circle! </p>
    <p> Now let's put all we have learned to practice. </p>
    <p> Create a circle, and print out the size of that circle in the given box. </p>
    <p> IF we ever change the circle, we want the number in the box to change, too! </p>
    <p> CHALLENGE: Create a circle and print its size in the given box. </p>`;
        this.x = 10;
        this.y = 430;
    }
    drawGuides(ctx) {
        ctx.beginPath();
        ctx.rect(this.x, this.y, 100, 100);
        ctx.strokeStyle = '#6C6C6C';
        ctx.stroke();
        ctx.font = 20 + "px Courier New";
        ctx.fillStyle = '#6C6C6C';
        ctx.fillText("Put circle's size", this.x, 390);
        ctx.fillText("in here", this.x, 410);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof NumberEffect_1.NumberEffect && effect.num != null) {
                if (effect.x > this.x && effect.x < this.x + 100 && effect.y > this.y && effect.y < this.y + 100) {
                    let val = effect.num;
                    for (let effect2 of effects) {
                        if (effect2 instanceof EllipseEffect_1.EllipseEffect && (val == effect2.w || val == effect2.h)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpSeven = LessonTwoCpSeven;

},{"../effects/EllipseEffect":13,"../effects/NumberEffect":16}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpSix {
    constructor() {
        this._name = "l2c6";
        this._nextModule = 'l2c7';
        this._constraint = 'code';
        this._instructions = `<p> Now that you have drawn 2 circles both are called c, let's see what happens when you try to modify one of them. </p>
    <p> Click on one of the circles on the CANVAS, and try make it bigger. Observe what happens to your declaration of c. </p>
    <p> GOAL: Enlarge one of the circles referred to by c on the CANVAS. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                if (effect.w > 250 && effect.h > 250) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpSix = LessonTwoCpSix;

},{"../effects/EllipseEffect":13}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
const StringEffect_1 = require("../effects/StringEffect");
class LessonTwoCpThree {
    constructor() {
        this._name = "l2c3";
        this._nextModule = 'l2c4';
        this._constraint = 'none';
        this._instructions = `<p> So we can draw a circle and change it. But what if we want to draw both circles and words? </p>
    <p> Well, simple! Just write more print statements in the CODE area! </p>
    <p> GOAL: Draw 2 circles and a word on the CANVAS. </p>
    <p> HINT: Remember that the numbers right inside the ellipse(_,_) statement change the circle's sizes.`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        let stringExists = false;
        let circleCount = 0;
        for (let effect of effects) {
            if (!stringExists) {
                stringExists = effect instanceof StringEffect_1.StringEffect && effect.str !== "";
            }
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                circleCount += 1;
            }
        }
        return stringExists && circleCount >= 2;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpThree = LessonTwoCpThree;

},{"../effects/EllipseEffect":13,"../effects/StringEffect":18}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpTwo {
    /*
    `<p> So we can draw a circle and change it. But what if we want to draw both a circle and a word? </p>
    <p> Well, simple! Just write another print statement in the CODE area! </p>
    <p> GOAL: Draw 2 circles and a word on the CANVAS. </p>
    <p> HINT: Remember that the numbers right inside the ellipse(_,_) statement change the circle's sizes.`;
*/
    constructor() {
        this._name = "l2c2";
        this._nextModule = 'l2c3';
        this._constraint = 'code';
        this._instructions = `<p> We can write ellipse(100, 100) in the print statement to draw a circle on the CANVAS. </p>
    <p> What are the numbers (100, 100) for? I'm glad you asked... </p>
    <p> Because the CODE area is frozen again! Drag one of the 9 white tips around the circle on the CANVAS to see how the number changes! </p>
    <p> GOAL: Make the circle wider but shorter. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                if (effect.w > 200 && effect.h < 80) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpTwo = LessonTwoCpTwo;

},{"../effects/EllipseEffect":13}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../../index");
const index_2 = require("../../index");
const index_3 = require("../../index");
const index_4 = require("../../index");
class ModuleGenerator {
    constructor(isDM) {
        this.dmConstructors = new Map([
            ['l1c1', () => new index_1.LessonOneCpOne()],
            ['l1c2', () => new index_1.LessonOneCpTwo()],
            ['l1c3', () => new index_1.LessonOneCpThree()],
            ['l1c4', () => new index_1.LessonOneCpFour()],
            ['l2c1', () => new index_2.LessonTwoCpOne()],
            ['l2c2', () => new index_2.LessonTwoCpTwo()],
            ['l2c3', () => new index_2.LessonTwoCpThree()],
            ['l2c4', () => new index_2.LessonTwoCpFour()],
            ['l2c5', () => new index_2.LessonTwoCpFive()],
            ['l2c6', () => new index_2.LessonTwoCpSix()],
            ['l2c7', () => new index_2.LessonTwoCpSeven()],
            ['l3c1', () => new index_3.LessonThreeCpOne()],
            ['l3c2', () => new index_3.LessonThreeCpTwo()],
            ['l3c3', () => new index_3.LessonThreeCpThree()],
            ['l3c4', () => new index_3.LessonThreeCpFour()],
            ['l3c5', () => new index_3.LessonThreeCpFive()],
            ['l3c6', () => new index_3.LessonThreeCpSix()],
            ['l4c1', () => new index_4.LessonFourCpOne()],
            ['l4c2', () => new index_4.LessonFourCpTwo()]
        ]);
        this.nonDmConstructors = new Map([
            ['l1c1', () => new index_1.LessonOneCpOne()],
            ['l1c2', () => new index_1.LessonOneCpThree()],
            ['l1c3', () => new index_1.LessonOneCpFour()],
            ['l2c1', () => new index_2.LessonTwoCpOne()],
            ['l2c2', () => new index_2.LessonTwoCpThree()],
            ['l2c3', () => new index_2.LessonTwoCpFour()],
            ['l2c4', () => new index_2.LessonTwoCpFive()],
            ['l2c5', () => new index_2.LessonTwoCpSeven()],
            ['l3c1', () => new index_3.LessonThreeCpOne()],
            ['l3c2', () => new index_3.LessonThreeCpTwo()],
            ['l3c3', () => new index_3.LessonThreeCpThree()],
            ['l3c4', () => new index_3.LessonThreeCpFour()],
            ['l3c5', () => new index_3.LessonThreeCpFive()],
            ['l3c6', () => new index_3.LessonThreeCpSix()],
            ['l4c1', () => new index_4.LessonFourCpOne()],
            ['l4c2', () => new index_4.LessonFourCpTwo()]
        ]);
        this.checkpoints = new Map([
            ['l1c1', null],
            ['l1c2', null],
            ['l1c3', null],
            ['l1c4', null],
            ['l2c1', null],
            ['l2c2', null],
            ['l2c3', null],
            ['l2c4', null],
            ['l2c5', null],
            ['l2c6', null],
            ['l2c7', null],
            ['l3c1', null],
            ['l3c2', null],
            ['l3c3', null],
            ['l3c4', null],
            ['l3c5', null],
            ['l3c6', null],
            ['l4c1', null],
            ['l4c2', null]
        ]);
        if (isDM) {
            this.curConstructors = this.dmConstructors;
        }
        else {
            this.curConstructors = this.nonDmConstructors;
        }
    }
    generateCheckpoint(cp) {
        let checkpoint = this.checkpoints.get(cp);
        if (checkpoint != null) {
            return checkpoint;
        }
        checkpoint = this.curConstructors.get(cp)();
        this.checkpoints.set(cp, checkpoint);
        return checkpoint;
    }
}
exports.ModuleGenerator = ModuleGenerator;

},{"../../index":1}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pants_1 = require("pants");
const index_1 = require("../../index");
const space_lift_1 = require("space-lift");
var Parser;
(function (Parser) {
    /**
     * to be moved to Pants
     * number parses numbers by repeatedly applying the digit parser
     */
    function number() {
        return (istream) => {
            const o = pants_1.Primitives.many1(pants_1.Primitives.digit())(istream);
            switch (o.tag) {
                case "success":
                    let s = "";
                    for (let digit of o.result) {
                        s += digit.toString();
                    }
                    return new pants_1.Primitives.Success(o.inputstream, parseFloat(s));
                case "failure":
                    return o;
            }
        };
    }
    Parser.number = number;
    /**
     * to be moved to Pants
     * string is an arbitrary string parser that repeatedly applies the letter primitive
     * returns a CharStream representing the entire parsed string
     */
    function string() {
        let p = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.many1(pants_1.Primitives.letter()));
        let f = (xs) => pants_1.CharUtil.CharStream.concat(xs);
        return pants_1.Primitives.appfun(p)(f);
    }
    Parser.string = string;
    /**
     * to be moved to Pants
     * punctuation parses all possible punctuation characters
     */
    function punctuation() {
        return pants_1.Primitives.sat(x => x == "!"
            || x == "."
            || x == ','
            || x == ";"
            || x == '?'
            || x == "-"
            || x == "&"
            || x == '$'
            || x == ':'
            || x == '/'
            || x == '|'
            || x == '%'
            || x == '#'
            || x == "@"
            || x == "~"
            || x == '`'
            || x == '*'
            || x == '^'
            || x == '{'
            || x == '}'
            || x == "["
            || x == ']'
            || x == '('
            || x == ")"
            || x == "'"
            || x == "_");
    }
    Parser.punctuation = punctuation;
    let id = (x) => x;
    //let effects: Effect<any>[] = [];
    /**
     * parse is a function that wraps the input text in a CharStream
     * and passes it to the upper-level parse function
     * @param program a string representing program text
     */
    function parse(program) {
        program += "\n";
        //printOffset = -1;
        //this.effects = effects;
        let o = Parser.ExpressionParser(new pants_1.CharUtil.CharStream(program));
        switch (o.tag) {
            case "success":
                return space_lift_1.Some(o.result);
            case "failure":
                return space_lift_1.None;
        }
    }
    Parser.parse = parse;
    /**
     * Expression parser first searches for the first expression of a sequence and either
     * another expression or the end of the program (NOP) and returns a sequence node
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParser = i => {
        let f = (tup) => {
            return new index_1.SequenceNode(tup[0], tup[1]);
        };
        let p = pants_1.Primitives.seq(Parser.ExpressionParserNoSeq)(pants_1.Primitives.right(pants_1.Primitives.choice(pants_1.Primitives.char(';'))(pants_1.Primitives.nl()))(pants_1.Primitives.choice(pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser))(pants_1.Primitives.appfun(pants_1.Primitives.ws())(_ => new index_1.NOP()))))(f);
        return p(i);
    };
    /**
     * Searches through all possible expressions except for sequences
     * used to avoid infinite looping in upper level parse
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParserNoSeq = i => {
        let p1 = pants_1.Primitives.choice(lNumber())(lstring2());
        let p2 = pants_1.Primitives.choice(varNameParse())(p1);
        let p3 = pants_1.Primitives.choice(BoolParse())(p2);
        let p4 = pants_1.Primitives.choice(varDecParse())(p3);
        let p5 = pants_1.Primitives.choice(Parser.unOpsExpr)(p4);
        let p6 = pants_1.Primitives.choice(Declare())(p5);
        let p7 = pants_1.Primitives.choice(Parser.binOpExpr)(p6);
        let p8 = pants_1.Primitives.choice(LogicExpr())(p7);
        let p9 = pants_1.Primitives.choice(Parser.ListHead)(p8);
        let p10 = pants_1.Primitives.choice(Parser.funApp)(p9);
        let p11 = pants_1.Primitives.choice(Parser.returnParser)(p10);
        let p12 = pants_1.Primitives.choice(Parser.condParse)(p11);
        let p13 = pants_1.Primitives.choice(Parser.WhileLoop)(p12);
        let p14 = pants_1.Primitives.choice(Parser.ForLoop)(p13);
        let p15 = pants_1.Primitives.choice(Parser.funDef)(p14);
        return p15(i);
    };
    /**
     * Searches through all possible expressions except for binOp expressions
     * used to avoid infinite looping in the binary expression parser
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParserNoBinOp = i => {
        let p1 = pants_1.Primitives.choice(lNumber())(lstring2());
        let p2 = pants_1.Primitives.choice(varNameParse())(p1);
        let p3 = pants_1.Primitives.choice(BoolParse())(p2);
        let p4 = pants_1.Primitives.choice(varDecParse())(p3);
        let p5 = pants_1.Primitives.choice(Parser.unOpsExpr)(p4);
        let p6 = pants_1.Primitives.choice(Declare())(p5);
        let p7 = pants_1.Primitives.choice(Parser.ListHead)(p6);
        let p8 = pants_1.Primitives.choice(Parser.funApp)(p7);
        let p9 = pants_1.Primitives.choice(Parser.returnParser)(p8);
        let p10 = pants_1.Primitives.choice(Parser.condParse)(p9);
        let p11 = pants_1.Primitives.choice(Parser.WhileLoop)(p10);
        let p12 = pants_1.Primitives.choice(Parser.ForLoop)(p11);
        let p13 = pants_1.Primitives.choice(Parser.funDef)(p12);
        return p13(i);
    };
    /**
     * Searches through all possible expressions except for logical expressions
     * used to avoid infinite looping in the logical expression parser
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParserNoLogic = i => {
        let p1 = pants_1.Primitives.choice(lNumber())(lstring2());
        let p2 = pants_1.Primitives.choice(varNameParse())(p1);
        let p3 = pants_1.Primitives.choice(BoolParse())(p2);
        let p4 = pants_1.Primitives.choice(varDecParse())(p3);
        let p5 = pants_1.Primitives.choice(Parser.unOpsExpr)(p4);
        let p6 = pants_1.Primitives.choice(Declare())(p5);
        let p7 = pants_1.Primitives.choice(Parser.binOpExpr)(p6);
        let p8 = pants_1.Primitives.choice(Parser.ListHead)(p7);
        let p9 = pants_1.Primitives.choice(Parser.funApp)(p8);
        let p10 = pants_1.Primitives.choice(Parser.returnParser)(p9);
        let p11 = pants_1.Primitives.choice(Parser.condParse)(p10);
        let p12 = pants_1.Primitives.choice(Parser.WhileLoop)(p11);
        let p13 = pants_1.Primitives.choice(Parser.ForLoop)(p12);
        let p14 = pants_1.Primitives.choice(Parser.funDef)(p13);
        return p14(i);
    };
    /**
     * lNumber is used to wrap parsed numbers in NumberNodes for the AST
     */
    function lNumber() {
        return (istream) => {
            let o = number()(istream);
            switch (o.tag) {
                case "success":
                    return new pants_1.Primitives.Success(o.inputstream, new index_1.NumberNode(o.result));
                case "failure":
                    return o;
            }
        };
    }
    Parser.lNumber = lNumber;
    /**
     * binOpsChar parses all possible binary operators, such as + or -
     */
    function binOpsChar() {
        return (istream) => {
            return pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.sat(x => x == "+"
                || x == "-"
                || x == "/"
                || x == "="
                || x == "*"))(istream);
        };
    }
    Parser.binOpsChar = binOpsChar;
    /**
     * binOpsShort returns a tuple where the first element is the binary operator (CharStream)
     * and the second element is the expression to the right of the operator (Expression<{}>)
     */
    function binOpShort() {
        return pants_1.Primitives.seq(binOpsChar())(Parser.ExpressionParserNoSeq)((x) => x);
    }
    Parser.binOpShort = binOpShort;
    /**
     * binOpExpr parses all possible binary operation expressions and returns the
     * corresponding AST node construct (also parses postfix increments/decrements like i++)
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.binOpExpr = i => {
        var f = (tup) => {
            let lhs = tup[0];
            let op = tup[1][0];
            let rhs = tup[1][1];
            switch (op.toString()) {
                case "+":
                    return new index_1.PlusOp(lhs, rhs, ws);
                case "-":
                    return new index_1.MinusOp(lhs, rhs, ws);
                case "/":
                    return new index_1.DivOp(lhs, rhs, ws);
                case "*":
                    return new index_1.MulOp(lhs, rhs, ws);
                case "=":
                    return new index_1.AssignOp(lhs, rhs, ws);
                default:
                    throw new Error("Binary Operation not supported");
            }
        };
        let p1 = pants_1.Primitives.choice(Parser.ExpressionParserNoBinOp)(varDecParse());
        let p2 = binOpShort();
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let postPlus = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.ExpressionParserNoBinOp))(pants_1.Primitives.str('++'))(tup => { return new index_1.Increment(tup[0], ws); });
        let postMinus = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.ExpressionParserNoBinOp))(pants_1.Primitives.str('--'))(tup => { return new index_1.Decrement(tup[0], ws); });
        let binOp = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(p1))(p2)(f);
        return pants_1.Primitives.choice(binOp)(pants_1.Primitives.choice(postPlus)(postMinus))(i);
    };
    /**
     * unOpsChar parses all possible unary operators
     * Only negations are supported, but more can be added as needed
     * @param i nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.unOpsChar = i => {
        return pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char("-"))(i);
    };
    /**
     * unOpsExpr wraps a unary operation expression in the corresponding
     * AST node and returns it
     * @param i nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.unOpsExpr = i => {
        var f = (tup) => {
            return new index_1.NegOp(tup[1], ws);
        };
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        return pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.unOpsChar))(Parser.ExpressionParserNoSeq)(f)(i);
    };
    /**
     * lstring parses valid strings in the SWELL language
     * a valid string is surrounded by quotations and consists of letters, numbers, punctuation, and/or whitespace
     */
    function lstring() {
        let p1 = pants_1.Primitives.choice(pants_1.Primitives.choice(pants_1.Primitives.letter())(pants_1.Primitives.ws1()))(pants_1.Primitives.digit());
        //let p1 = Primitives.choice(Primitives.letter())(Primitives.ws1());
        let p = pants_1.Primitives.between(pants_1.Primitives.str("\""))(pants_1.Primitives.str("\""))(pants_1.Primitives.many(pants_1.Primitives.choice(p1)(punctuation())));
        let f = (xs) => pants_1.CharUtil.CharStream.concat(xs);
        return pants_1.Primitives.appfun(p)(f);
    }
    Parser.lstring = lstring;
    /**
     * lstring2 wraps strings parsed by lstring in StrinNode objects and returns them
     */
    function lstring2() {
        return (istream) => {
            let ws = "";
            let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
            let o = pants_1.Primitives.right(precedingWS)(lstring())(istream);
            switch (o.tag) {
                case "success":
                    return new pants_1.Primitives.Success(o.inputstream, new index_1.StringNode(o.result.toString(), ws));
                case "failure":
                    return o;
            }
        };
    }
    Parser.lstring2 = lstring2;
    /**
     * varNameParse parses valid variable names
     * variable names in SWELL begin with a lowercase char and are followed
     * by letters or digits
     */
    function varNameParse() {
        var f = (tup) => {
            return new index_1.VariableNode(tup[0].toString() + pants_1.CharUtil.CharStream.concat(tup[1]).toString(), ws);
        };
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let firstChar = pants_1.Primitives.right(precedingWS)(pants_1.Primitives.lower());
        let nextChars = pants_1.Primitives.many(pants_1.Primitives.choice(pants_1.Primitives.digit())(pants_1.Primitives.letter()));
        return pants_1.Primitives.seq(firstChar)(nextChars)(f);
    }
    Parser.varNameParse = varNameParse;
    /**
     * varDecParse parses valid variable declarations in the form "var x"
     * the parser then wraps the parsed value in a variable node for the AST
     */
    function varDecParse() {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str("var"));
        let varName = pants_1.Primitives.between(pants_1.Primitives.ws1())(pants_1.Primitives.ws())(varNameParse());
        let p = pants_1.Primitives.seq(p1)(varName)(tup => tup[1]);
        return p;
    }
    Parser.varDecParse = varDecParse;
    /**
     * Declare parses variable declarations in the form "var x = 2"
     * and returns a DeclareOp node
     */
    function Declare() {
        let eq = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('='));
        let p1 = pants_1.Primitives.left(varDecParse())(eq);
        return pants_1.Primitives.seq(p1)(Parser.ExpressionParserNoSeq)(tup => { return new index_1.DeclareOp(tup[0], tup[1]); });
    }
    Parser.Declare = Declare;
    /**
     * ListHead parses all lists in the SWELL language, including empty lists
     * Lists are surrounded by square brackets and each element is separated by a comma
     * returns a listNode object
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.ListHead = i => {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p0 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let p1 = pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.char('[')))(p0);
        var f = (tup) => {
            let hd = tup[0];
            let res = [hd];
            let tail = tup[1];
            for (let elem of tail) {
                res.push(elem);
            }
            return new index_1.ListNode(res, ws);
        };
        let p2 = pants_1.Primitives.seq(p1)(ListTail())(f);
        let p3 = pants_1.Primitives.appfun(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('[]')))(_ => new index_1.ListNode([], ws));
        return pants_1.Primitives.choice(p3)(p2)(i);
    };
    /**
     * List Tail parses second through last elements of a list, each separated by a comma
     * returns an array of Expressions that will be accessed by ListHead
     */
    function ListTail() {
        let p0 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char(','))(p0);
        let p2 = pants_1.Primitives.left(pants_1.Primitives.many(p1))(pants_1.Primitives.char(']'));
        return p2;
    }
    Parser.ListTail = ListTail;
    /**
     * funDefArgList parses argument lists for function definitions,
     * surrounded by parens and separated by commas
     * returns an array of the parameters
     */
    function funDefArgList() {
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char('('))(string());
        var f = (tup) => {
            let hd = tup[0].toString();
            let res = [hd];
            let tail = tup[1];
            for (let elem of tail) {
                res.push(elem.toString());
            }
            return res;
        };
        let p2 = pants_1.Primitives.seq(p1)(funDefArgListTail())(f);
        let p3 = pants_1.Primitives.appfun(pants_1.Primitives.str('()'))(_ => []);
        return pants_1.Primitives.choice(p3)(p2);
    }
    Parser.funDefArgList = funDefArgList;
    /**
     * funDefArgListTail parses the second through last elements of a function definition parameter list
     * parameters are separated by commas and end with a closing parens
     * returns an array of parameters, which is accessed by funDefArgList
     */
    function funDefArgListTail() {
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char(','))(string());
        let p2 = pants_1.Primitives.left(pants_1.Primitives.many(p1))(pants_1.Primitives.char(')'));
        return p2;
    }
    /**
     * funAppArgList parses argument lists for function applications, including empty args lists
     * the parser returns an array of Expression objects that represent the arguments
     */
    function funAppArgList() {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char('('))(expr);
        var f = (tup) => {
            let hd = tup[0];
            let res = [hd];
            let tail = tup[1];
            for (let elem of tail) {
                res.push(elem);
            }
            return res;
        };
        let p2 = pants_1.Primitives.seq(p1)(funAppArgListTail())(f);
        let p3 = pants_1.Primitives.appfun(pants_1.Primitives.str('()'))(_ => []);
        return pants_1.Primitives.choice(p3)(p2);
    }
    Parser.funAppArgList = funAppArgList;
    /**
     * funAppArgListTail parses the second through last elements of an argument list
     * each element is separated by a comma
     * returns an array of Expression objects, later accessed by funAppArgsList
     */
    function funAppArgListTail() {
        let comma = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char(','));
        let p1 = pants_1.Primitives.right(comma)(Parser.ExpressionParserNoSeq);
        let p2 = pants_1.Primitives.left(pants_1.Primitives.many(p1))(pants_1.Primitives.right(pants_1.Primitives.ws())(pants_1.Primitives.char(')')));
        return p2;
    }
    /**
     * returnParser parses valid return statements in the form "return x"
     * wraps the parsed value in a Return node for the AST
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.returnParser = i => {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p = pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('return')))(expr);
        var f = (e) => { return new index_1.Return(e, ws); };
        return pants_1.Primitives.appfun(p)(f)(i);
    };
    /**
     * funDef parses valid function definitions in the form "fun functionName(argList){ body;}"
     * the parser returns a funDef node for the AST
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.funDef = i => {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        return pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('fun')))(pants_1.Primitives.seq(
        /* function name */
        pants_1.Primitives.appfun(string())(cs => cs.toString()))(pants_1.Primitives.seq(
        /* function arguments */
        funDefArgList())(pants_1.Primitives.right(
        /* function body */
        pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{')))(pants_1.Primitives.left(pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser))(pants_1.Primitives.char('}'))))(id))(
        // create the AST node
        (tup) => {
            let fname = tup[0];
            let args = tup[1][0];
            let body = tup[1][1];
            return new index_1.FunDef(fname, body, args, ws);
        }))(i);
    };
    let printOffset = -1;
    let boundingRects = [];
    //TODO
    function getNonOverlappingCoords() {
        return [0, 0];
    }
    Parser.getNonOverlappingCoords = getNonOverlappingCoords;
    /**
     * funApp parses valid function applications in the form "functionName(argsList)" and returns a funApp node
     * parser checks for built-in functions, like print, ellipse, and rect; and returns the valid AST node
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.funApp = i => {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        return pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(string()))(funAppArgList())(tup => {
            let fname = tup[0].toString();
            switch (fname) {
                case "print":
                    if (tup[1].length == 3) {
                        //boundingRects.push([tup[1][0].width, tup[1][0].height, tup[1][1], tup[1][2]]);
                        return new index_1.PrintNode(tup[1][0], new index_1.Dimensions(tup[1][1], tup[1][2], new index_1.NumberNode(1)), ws);
                    }
                    printOffset = (printOffset + 1) % 12;
                    console.log("printOffset: " + printOffset);
                    return new index_1.PrintNode(tup[1][0], new index_1.Dimensions(new index_1.NumberNode(100 + 100 * (printOffset % 3)), new index_1.NumberNode(100 + 100 * (printOffset / 4)), new index_1.NumberNode(1)), ws);
                case "ellipse":
                    if (tup[1].length == 2) {
                        return new index_1.EllipseNode(tup[1][0], tup[1][1], ws);
                    }
                case "rect":
                    if (tup[1].length == 2) {
                        return new index_1.RectangleNode(tup[1][0], tup[1][1], ws);
                    }
                case "line":
                    if (tup[1].length == 2) {
                        return new index_1.LineNode(tup[1][0], tup[1][1], ws);
                    }
                case "curve":
                    if (tup[1].length == 3) {
                        return new index_1.CurveNode(tup[1][0], tup[1][1], tup[1][2], ws);
                    }
                case "eph":
                    if (tup[1].length == 2) {
                        return new index_1.EphNode(tup[1][0], tup[1][1], ws);
                    }
            }
            let args = tup[1];
            return new index_1.FunApp(fname, args, ws);
        })(i);
    };
    /**
     * BoolParse parses valid booleans, true and false, and returns a BooleanNode
     */
    function BoolParse() {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.appfun(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('true')))(_ => new index_1.BooleanNode(true, ws));
        let p2 = pants_1.Primitives.appfun(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('false')))(_ => new index_1.BooleanNode(false, ws));
        return pants_1.Primitives.choice(p1)(p2);
    }
    Parser.BoolParse = BoolParse;
    /**
     * logicChar parses all logical operators in the SWELL language and returns the consumed operator
     */
    function logicChar() {
        var logicChar = ["equals", '==', 'and', '>', '<', 'not equals', 'or'];
        var logicChar2 = ['>=', '<='];
        let p1 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.strSat(logicChar));
        let p2 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.strSat(logicChar2));
        return pants_1.Primitives.choice(p2)(p1);
    }
    Parser.logicChar = logicChar;
    /**
     * logicShort returns a tuple, where the first element represents the logical operator and
     * the second element is the expression to the right of the operator
     */
    function logicShort() {
        return pants_1.Primitives.seq(logicChar())(Parser.ExpressionParserNoSeq)((x) => x);
    }
    Parser.logicShort = logicShort;
    /**
     * logicExpr parses logical expressions and returns the corresponding AST node
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    function LogicExpr() {
        // TODO: Dan (2018-11-19), shouldn't parameterized type be BooleanNode?
        var f = (tup) => {
            let lhs = tup[0];
            let op = tup[1][0];
            let rhs = tup[1][1];
            switch (op.toString()) {
                case "equals":
                    return new index_1.Equals(lhs, rhs, ws);
                case "==":
                    return new index_1.Equals(lhs, rhs, ws);
                case "and":
                    return new index_1.And(lhs, rhs, ws);
                case ">":
                    return new index_1.GreaterThan(lhs, rhs, ws);
                case "<":
                    return new index_1.LessThan(lhs, rhs, ws);
                case ">=":
                    return new index_1.GreaterThanEq(lhs, rhs, ws);
                case "<=":
                    return new index_1.LessThanEq(lhs, rhs, ws);
                case "or":
                    return new index_1.Or(lhs, rhs, ws);
                case "not equals":
                    return new index_1.NotEqual(lhs, rhs, ws);
                default:
                    throw new Error("Logical expression not supported");
            }
        };
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let not = pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('not'));
        let p1 = pants_1.Primitives.right(not)(Parser.ExpressionParserNoSeq);
        let notExpr = pants_1.Primitives.appfun(p1)(x => new index_1.Not(x, ws));
        let logicExpr = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.ExpressionParserNoLogic))(logicShort())(f);
        return pants_1.Primitives.choice(notExpr)(logicExpr);
    }
    Parser.LogicExpr = LogicExpr;
    /**
     * IfParse parses valid if statements in the form "if(condition){ body; }"
     * returns an array where the first elem is the condition and the second is the body
     */
    function IfParse() {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let bodyParse = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let p1 = pants_1.Primitives.seq(pants_1.Primitives.str('if'))(pants_1.Primitives.char('('))(x => x);
        let cond = pants_1.Primitives.between(p1)(pants_1.Primitives.char(')'))(expr);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(bodyParse);
        return pants_1.Primitives.seq(cond)(body)(x => x);
    }
    Parser.IfParse = IfParse;
    /**
      * IfElseParse parses valid if else statements in the form "if(condition){ body; } else{ body2;}"
      * returns an array where the first elem is the condition and the second is the first body and the third is body2
      */
    function IfElseParse() {
        let e = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.str('else'));
        let body = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let body2 = pants_1.Primitives.between(pants_1.Primitives.str('{'))(pants_1.Primitives.str('}'))(body);
        let elseParse = pants_1.Primitives.right(e)(body2);
        var f = (tup) => {
            tup[0].push(tup[1]);
            return tup[0];
        };
        return pants_1.Primitives.seq(IfParse())(elseParse)(f);
    }
    Parser.IfElseParse = IfElseParse;
    /**
     * condParse parses possible conditional statements, including if and if/else statements
     * returns a Conditional node
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.condParse = i => {
        var f = (tup) => {
            if (tup.length == 3) {
                return new index_1.Conditional(tup[0], tup[1], tup[2]);
            }
            else {
                return new index_1.Conditional(tup[0], tup[1]);
            }
        };
        return pants_1.Primitives.appfun(pants_1.Primitives.choice(IfElseParse())(IfParse()))(f)(i);
    };
    /**
     * WhileLoop parses valid while loops in the form "while(condition) { body;}"
     * returns a WhileNode for the AST
     */
    Parser.WhileLoop = i => {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let bodyParse = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str("while")))(pants_1.Primitives.char('('))(x => x);
        let cond = pants_1.Primitives.between(p1)(pants_1.Primitives.char(')'))(expr);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(bodyParse);
        var f = (tup) => { return new index_1.WhileNode(tup[0], tup[1], ws); };
        return pants_1.Primitives.seq(cond)(body)(f)(i);
    };
    /**
     * ForLoop parses valid for loops in the form "for(initial, condition, post) { body;}" and returns a ForNode
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.ForLoop = i => {
        let args = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(funAppArgList());
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('for')))(args);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let expr = pants_1.Primitives.between(pants_1.Primitives.choice(pants_1.Primitives.ws())(pants_1.Primitives.nl()))(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(expr);
        var f = (tup) => {
            let init = tup[0][0];
            let cond = tup[0][1];
            let post = tup[0][2];
            let body = tup[1];
            return new index_1.ForNode(init, cond, post, body, ws);
        };
        return pants_1.Primitives.seq(p1)(body)(f)(i);
    };
    function singleComment() {
        let p1 = pants_1.Primitives.many1(pants_1.Primitives.item());
        let p2 = pants_1.Primitives.appfun(p1)(xs => pants_1.CharUtil.CharStream.concat(xs));
        return pants_1.Primitives.between(pants_1.Primitives.str('//'))(pants_1.Primitives.nl())(p2);
        //return Primitives.seq<CharUtil.CharStream, CharUtil.CharStream, CharUtil.CharStream[]>(Primitives.str('//'))(Primitives.nl())(x=>x);
    }
    Parser.singleComment = singleComment;
    function multiLineComment() {
        let p1 = pants_1.Primitives.many1(pants_1.Primitives.item());
        let p2 = pants_1.Primitives.appfun(p1)(xs => pants_1.CharUtil.CharStream.concat(xs));
        return pants_1.Primitives.between(pants_1.Primitives.str('\/**'))(pants_1.Primitives.str('*\/'))(p2);
    }
    Parser.multiLineComment = multiLineComment;
})(Parser = exports.Parser || (exports.Parser = {}));

},{"../../index":1,"pants":85,"space-lift":91}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BooleanNode {
    /**
     * Constructor for BooleanNode, a node representing a boolean
     * @param val The boolean value of the BooleanNode
     * @param ws Preceding white space
     */
    constructor(val, ws) {
        this._newLine = false;
        this._val = val;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    ;
    /**
     * Returns the BooleanNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * BooleanNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Returns whether this BooleanNode equals another
     * @param right The right side of the equality
     */
    equalsVal(right) {
        if (right instanceof BooleanNode) {
            return this.val === right.val;
        }
        return false;
    }
    /**
     * Returns a string representation of the BooleanNode
     */
    toString() {
        return this._ws + this._val;
    }
    /**
     * Returns the boolean value
     */
    get val() {
        return this._val;
    }
    /**
     * Sets the boolean value
     */
    set val(value) {
        this._val = value;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.BooleanNode = BooleanNode;

},{}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class NOP {
    constructor() {
        /* A NOP is a placeholder operation that evaluates to nothing */
        this._newLine = true;
    }
    /**
     * Returns the NOP
     * @param context
     */
    eval(context) {
        return this;
    }
    /**
     * NOPs cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("NOPs cannot be drawn.");
    }
    /**
     * Returns a string representation of the NOP
     */
    toString() {
        return "";
    }
    /**
     * Returns whether this NOP equals another (spoiler: it doesn't)
     * @param right
     */
    equalsVal(right) {
        return false;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.NOP = NOP;

},{}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberEffect_1 = require("../effects/NumberEffect");
// Nodes representing numbers
// Should abstract Node class implement Expression?
class NumberNode {
    /**
     * Constructor for a NumberNode, a node representing a number
     * @param val The number value
     * @param ws Preceding whitespace
     */
    constructor(val, ws) {
        this._newLine = false;
        this._val = val;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    ;
    /**
     * Returns this NumberNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * NumberNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        let e = new NumberEffect_1.NumberEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this NumberNode equals another NumberNode
     * @param right The right side of the equality (must be a NumberNode)
     */
    equalsVal(right) {
        if (right instanceof NumberNode) {
            return this.val === right.val;
        }
        return false;
    }
    /**
     * Returns a string representation of the NumberNode
     */
    toString() {
        return this._ws + this._val;
    }
    /**
     * Returns the number stored in the node
     */
    get val() {
        return this._val;
    }
    /**
     * Sets the value of the number stored in the node
     */
    set val(value) {
        this._val = value;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.NumberNode = NumberNode;

},{"../effects/NumberEffect":16}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class StringNode {
    /**
     * Constructor for a StringNode, a node representing a string
     * @param str The string stored in the node
     * @param ws Preceding whitespace
     */
    constructor(str, ws) {
        this._newLine = false;
        this._str = str;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this StringNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the String using StringEffect
     * @param context The current program context
     * @param dims The dimensions of the string to be drawn
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        let e = new StringEffect_1.StringEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this StringNode equals another StringNode
     * @param right The right side of the equality, must be a StringNode
     */
    equalsVal(right) {
        if (right instanceof StringNode) {
            return this.val === right.val;
        }
        return false;
    }
    /**
     * Returns a string representation of the StringNode
     */
    toString() {
        return this._ws + '\"' + this._str + '\"';
    }
    /**
     * Sets the string stored in the node
     */
    set str(value) {
        this._str = value;
    }
    /**
     * Returns the string stored in the node
     */
    get val() {
        return this._str;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.StringNode = StringNode;

},{"../effects/StringEffect":18}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ColorNode {
    /**
     * Constructor for a ColorNode, a node representing an RGB color
     */
    constructor(red, green, blue) {
        this._newLine = false;
        this._red = red;
        this._green = green;
        this._blue = blue;
    }
    ;
    /**
     * Evaluates into a string RGB value
     * @param context The current program context
     */
    eval(context) {
        return this._red + " " + this._green + " " + this._blue;
    }
    /**
     * ColorNodes cannot currently be drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Returns whether this ColorNode equals another ColorNode
     * @param right The right side of the equality (must be a BooleanNode)
     */
    equalsVal(right) {
        if (right instanceof ColorNode) {
            return (this.red === right.red && this.green === right.green && this.blue === right.blue);
        }
        return false;
    }
    /**
     * Returns a string representation of the ColorNode
     */
    toString() {
        return "";
    }
    /**
     * Returns the red value
     */
    get red() {
        return this._red;
    }
    /**
     * Sets the red value
     */
    set red(red) {
        this._red = red;
    }
    /**
     * Returns the green value
     */
    get green() {
        return this._green;
    }
    /**
     * Sets the green value
     */
    set green(green) {
        this._green = green;
    }
    /**
     * Returns the blue value
     */
    get blue() {
        return this._blue;
    }
    /**
     * Sets the blue value
     */
    set blue(blue) {
        this._blue = blue;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.ColorNode = ColorNode;

},{}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const CurveEffect_1 = require("../effects/CurveEffect");
class CurveNode {
    /**
     * Constructor for a CurveNode, a node representing a curve
     * @param dx the run of the curve
     * @param dy the rise of the curve
     * @param curvature how much the curve, umm, curves
     * @param ws Preceding whitespace
     */
    constructor(dx, dy, curvature, ws) {
        this._newLine = false;
        this._dx = dx;
        this._dy = dy;
        this._curvature = curvature;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this CurveNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the curve using CurveEffect
     * @param context The current program context
     * @param dims The line dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._dx.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._dy.eval(context).val, "");
        dims.curvature = new NumberNode_1.NumberNode(this._curvature.eval(context).val, "");
        let e = new CurveEffect_1.CurveEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this CurveNode equals another (if their dx, dy, and curvature are equal)
     * @param right The right side of the equality (must be a CurveNode)
     */
    equalsVal(right) {
        if (right instanceof CurveNode) {
            return (this.dx.equalsVal(right.dx) && this.dy.equalsVal(right.dy) && this.curvature.equalsVal(right.curvature));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the curve
     */
    toString() {
        return this._ws + "curve(" + this._dx.toString() + ", " + this._dy.toString() + ", " + this._curvature.toString() + ")";
    }
    /**
     * Returns the run of the curve
     */
    get dx() {
        return this._dx;
    }
    /**
     * Sets the run of the curve
     */
    set dx(dx) {
        this._dx = dx;
    }
    /**
     * Returns the rise of the curve
     */
    get dy() {
        return this._dy;
    }
    /**
     * Sets the rise of the curve
     */
    set dy(dy) {
        this._dy = dy;
    }
    /**
     * Returns the curvature of the curve
     */
    get curvature() {
        return this._curvature;
    }
    /**
     * Sets the curvature of the curve
     */
    set curvature(curvature) {
        this._curvature = curvature;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.CurveNode = CurveNode;

},{"../effects/CurveEffect":12,"../prims/NumberNode":65}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class EllipseNode {
    /**
     * Constructor for an EllipseNode, a node representing an ellipse
     * @param width The width of the ellipse
     * @param height The height of the ellipse
     * @param ws Preceding whitespace
     */
    constructor(width, height, ws) {
        this._newLine = false;
        this._width = width;
        this._height = height;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this EllipseNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the ellipse on the canvas using EllipseEffect
     * @param context The current program context
     * @param dims The dimensions of the ellipse
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = this._width;
        dims.height = this._height;
        let e = new EllipseEffect_1.EllipseEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this EllipseNode equals another EllipseNode (if their widths and heights are equal)
     * @param right The right side of the equality (must be an EllipseNode)
     */
    equalsVal(right) {
        if (right instanceof EllipseNode) {
            return (this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    /**
     * Returns a string representation of the ellipse
     */
    toString() {
        return this._ws + "ellipse(" + this._width.toString() + ", " + this._height.toString() + ")";
    }
    move() { }
    /**
     * Returns the ellipse width
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the ellipse width
     */
    set width(width) {
        this._width = width;
    }
    /**
    * Returns the ellipse height
    */
    get height() {
        return this._height;
    }
    /**
     * Sets the ellipse height
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.EllipseNode = EllipseNode;

},{"../effects/EllipseEffect":13}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const EphEffect_1 = require("../effects/EphEffect");
class EphNode {
    /**
     * Constructor for an EphNode, a node representing something very special
     * @param width The width of the EphNode
     * @param height The height of the EphNode
     * @param ws Preceding whitespace
     */
    constructor(width, height, ws) {
        this._newLine = false;
        //this._image = image;
        this._width = width;
        this._height = height;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this EphNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the rectangle using EphEffect
     * @param context The current program context
     * @param dims The rectangle dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._width.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._height.eval(context).val, "");
        let e = new EphEffect_1.EphEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this EphNode equals another (if their widths and heights are equal)
     * @param right The right side of the equality (must be an EphNode)
     */
    equalsVal(right) {
        if (right instanceof EphNode) {
            return (this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the EphNode
     */
    toString() {
        return this._ws + "eph(" + this._width.toString() + ", " + this._height.toString() + ")";
    }
    /**
     * Returns the width of the EphNode
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the EphNode
     */
    set width(width) {
        this._width = width;
    }
    /**
     * Returns the height of the EphNode
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the EphNode
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.EphNode = EphNode;

},{"../effects/EphEffect":14,"../prims/NumberNode":65}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const LineEffect_1 = require("../effects/LineEffect");
class LineNode {
    /**
     * Constructor for a LineNode, a node representing a line
     * @param dx the run of the line
     * @param dy the rise of the line
     * @param ws Preceding whitespace
     */
    constructor(dx, dy, ws) {
        this._newLine = false;
        this._dx = dx;
        this._dy = dy;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this LineNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the line using LineEffect
     * @param context The current program context
     * @param dims The line dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._dx.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._dy.eval(context).val, "");
        let e = new LineEffect_1.LineEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this LineNode equals another (if their dx and dy are equal)
     * @param right The right side of the equality (must be a LineNode)
     */
    equalsVal(right) {
        if (right instanceof LineNode) {
            return (this.dx.equalsVal(right.dx) && this.dy.equalsVal(right.dy));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the line
     */
    toString() {
        return this._ws + "line(" + this._dx.toString() + ", " + this._dy.toString() + ")";
    }
    /**
     * Returns the run of the line
     */
    get dx() {
        return this._dx;
    }
    /**
     * Sets the run of the line
     */
    set dx(dx) {
        this._dx = dx;
    }
    /**
     * Returns the rise of the line
     */
    get dy() {
        return this._dy;
    }
    /**
     * Sets the rise of the line
     */
    set dy(dy) {
        this._dy = dy;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.LineNode = LineNode;

},{"../effects/LineEffect":15,"../prims/NumberNode":65}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const RectangleEffect_1 = require("../effects/RectangleEffect");
class RectangleNode {
    /**
     * Constructor for a RectangleNode, a node representing a rectangle
     * @param width The width of the rectangle
     * @param height The height of the rectangle
     * @param ws Preceding whitespace
     */
    constructor(width, height, ws) {
        this._newLine = false;
        this._width = width;
        this._height = height;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this RectangleNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the rectangle using RectangleEffect
     * @param context The current program context
     * @param dims The rectangle dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._width.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._height.eval(context).val, "");
        let e = new RectangleEffect_1.RectangleEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this RectangleNode equals another (if their widths and heights are equal)
     * @param right The right side of the equality (must be a RectangleNode)
     */
    equalsVal(right) {
        if (right instanceof RectangleNode) {
            return (this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the rectangle
     */
    toString() {
        return this._ws + "rect(" + this._width.toString() + ", " + this._height.toString() + ")";
    }
    /**
     * Returns the width of the rectangle
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the rectangle
     */
    set width(width) {
        this._width = width;
    }
    /**
     * Returns the height of the rectangle
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the rectangle
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.RectangleNode = RectangleNode;

},{"../effects/RectangleEffect":17,"../prims/NumberNode":65}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
class Dimensions {
    /**
     * Constructor for Dimensions, which stores object dimensions
     * @param x The x coordinate of the object
     * @param y The y coordinate of the object
     * @param scale The scale of the object
     * @param radius The radius of the object
     */
    constructor(x, y, scale, radius) {
        this._x = x;
        this._y = y;
        this._scale = scale;
        this._radius = radius || new NumberNode_1.NumberNode(30, "");
    }
    /**
     * Returns a string representation of the dimensions
     */
    toString() {
        return this.x.toString() + ", " + this.y.toString();
    }
    /**
     * Returns the x coordinate of the object
     */
    get x() {
        return this._x;
    }
    /**
     * Sets the x coordinate of the object
     */
    set x(val) {
        this._x = val;
    }
    /**
     * Returns the y coordinate of the object
     */
    get y() {
        return this._y;
    }
    /**
     * Sets the y coordinate of the object
     */
    set y(val) {
        this._y = val;
    }
    /**
     * Returns the radius of the object
     */
    get radius() {
        return this._radius;
    }
    /**
     * Sets the radius of the object
     */
    set radius(val) {
        this._radius = val;
    }
    /**
     * Returns the scale of the object
     */
    get scale() {
        return this._scale;
    }
    /**
     * Sets the scale of the object
     */
    set scale(val) {
        this._scale = val;
    }
    /**
     * Returns the width of the object
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the object
     */
    set width(val) {
        this._width = val;
    }
    /**
     * Returns the height of the object
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the object
     */
    set height(val) {
        this._height = val;
    }
    /**
     * Returns the curvature of the object
     */
    get curvature() {
        return this._curvature;
    }
    /**
     * Sets the curvature of the object
     */
    set curvature(val) {
        this._curvature = val;
    }
}
exports.Dimensions = Dimensions;

},{"../prims/NumberNode":65}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class PrintNode {
    /**
     * Constructor for a PrintNode, representing an object to be printed
     * @param toPrint The object to be printed
     * @param dimensions The dimensions of the object to be printed
     * @param ws Preceding whitespace
     */
    constructor(toPrint, dimensions, ws) {
        this._scale = 1;
        this._newLine = false;
        this._toPrint = toPrint;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
        this._dims = dimensions || null;
    }
    /**
     * Returns a string representation of the object to be printed
     */
    toString() {
        return this._ws + "print(" + this.toPrint.toString() + ", " + this.dims.toString() + ")";
    }
    /**
     * Equals cannot be called directly on a PrintNode
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on PrintNode");
    }
    /**
     * PrintNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw() on printOp");
    }
    /**
     * Evaluates the object to be printed and draws it
     * @param context
     */
    eval(context) {
        let res = this._toPrint.eval(context);
        res.draw(context, this._dims, this);
        return res;
    }
    /**
     * Returns the object to be printed
     */
    get toPrint() {
        return this._toPrint;
    }
    /**
     * Returns the dimensions of the object to be printed
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.PrintNode = PrintNode;

},{}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ReturnError_1 = require("./ReturnError");
class Return {
    /**
     * Constructor for a Return object, representing something to be returned in a function
     * @param expr The expression to be returned
     * @param ws Preceding whitespace
     */
    constructor(expr, ws) {
        this._newLine = false;
        this._expr = expr;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the expression to be returned and returns via a ReturnErro
     * @param context The current program context
     */
    eval(context) {
        // If return val is a var, returns that var's value
        let result = this._expr.eval(context);
        throw new ReturnError_1.ReturnError(result, context.retIDLookup());
    }
    /**
     * Equals cannot be called directly on Return nodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on Return");
    }
    /**
     * Returns a string representation of the Return node
     */
    toString() {
        return this._ws + "return " + this._expr.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Return nodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw on Return");
    }
}
exports.Return = Return;

},{"./ReturnError":76}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ReturnError extends Error {
    /**
     * Constructor for ReturnError, a custom error class that we abuse to return values
     * @param retVal The value to be returned
     * @param ID The ID of the value to be returned
     */
    constructor(retVal, ID) {
        super(ID);
        this.retVal = retVal;
        this.ID = ID;
        Object.setPrototypeOf(this, ReturnError.prototype);
    }
}
exports.ReturnError = ReturnError;

},{}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const space_lift_1 = require("space-lift");
class Scope {
    /**
     * Constructor for Scope, an object keeping track of objects within a particular context
     * @param parent The parent Scope
     * @param effects Effects within this Scope
     * @param myState The scope state
     * @param eventLog The log of events that occurred
     */
    constructor(parent, effects, eventLog) {
        this._retValID = space_lift_1.None;
        this._canvas = space_lift_1.None;
        this._eventLog = []; // The event log
        this._hadFunEval = false; // Was this created in a function?
        //public globalFunID = Math.random();
        this.globalFunID = 10000000; // The global ID for functions in this context
        this._varBindings = new Map();
        this._parent = parent;
        this._effects = effects || null;
        this._eventLog = eventLog;
        if (this._parent != null && this._parent._hadFunEval)
            this._hadFunEval = true; // copy function eval flag from parent
    }
    /**
     * Copies information from this Scope into another Scope and returns the new Scope
     */
    copy() {
        let s = new Scope(this._parent, this._effects, this._eventLog);
        s.varBindings = new Map(this._varBindings);
        s.canvas = this.canvas;
        s.eventLog = this.eventLog;
        return s;
    }
    /**
     * Declares a new variable
     * @param name The name of the variable to be declared
     */
    declare(name) {
        if (this._varBindings.has(name)) {
            throw new Error("Scope already has var with name " + name);
        }
        this._varBindings.set(name, space_lift_1.None);
    }
    /**
     * Assigns a value to a variable in this Context
     * @param name The name of the variable
     * @param val The value of the variable
     */
    assign(name, val) {
        this._varBindings.set(name, space_lift_1.Some(val)); //Some(val)?
    }
    /**
     * Looks up a value within the Scope and all its ancestor Scopes
     * @param name The name of the value
     * @param context The context to search within
     */
    lookup(name, context) {
        if (context.varBindings.has(name)) {
            if (context.varBindings.get(name).isDefined()) {
                return (context.varBindings.get(name).get()); //extra get to manage Some()
            }
        }
        if (!(context.parent == null)) {
            return this.lookup(name, context.parent);
        }
        throw new Error("Variable could not be found.");
    }
    /**
     * Looks up and returns the return ID value
     */
    retIDLookup() {
        if (this._retValID.isDefined()) {
            return this._retValID.get();
        }
        else {
            if (this._parent) {
                return this._parent.retIDLookup();
            }
            else {
                throw new Error("Unknown caller.");
            }
        }
    }
    /**
     * Returns the Map of variable bindings
     */
    get varBindings() {
        return this._varBindings;
    }
    /**
     * Sets the Map of variable bindings
     */
    set varBindings(m) {
        this._varBindings = m;
    }
    /**
     * Returns the parent Scope
     */
    get parent() {
        return this._parent;
    }
    /**
     * Returns the return value ID
     */
    get retValID() {
        return this._retValID;
    }
    /**
     * Sets the return value ID
     */
    set retValID(val) {
        this._retValID = val;
    }
    /**
     * Returns the HTML canvas
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Sets the HTML canvas
     */
    set canvas(val) {
        this._canvas = val;
    }
    /**
     * Returns the effects array
     */
    get effects() {
        return this._effects;
    }
    /**
     * Sets the effects array
     */
    set effects(arr) {
        this._effects = arr;
    }
    /**
     * Returns the event log
     */
    get eventLog() {
        return this._eventLog;
    }
    /**
     * Sets the event log
     */
    set eventLog(update) {
        this._eventLog = update;
    }
    /**
     * Returns the array of effects
     */
    get mulSelArray() {
        return this._mulSelArray;
    }
    /**
     * Sets the array of effects
     */
    set mulSelArray(update) {
        this._mulSelArray = update;
    }
    /**
     * Returns whether this Scope was created in a function
     */
    get hadFunEval() {
        return this._hadFunEval;
    }
    /**
     * Sets whether this Scope was created in a function
     */
    set hadFunEval(val) {
        this._hadFunEval = val;
    }
}
exports.Scope = Scope;

},{"space-lift":91}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("./Scope");
const space_lift_1 = require("space-lift");
class SequenceNode {
    /**
     * Constructor for a SequenceNode, the building block of the AST
     * @param left The left side of the Sequence
     * @param right The right side of the Sequence
     */
    constructor(left, right) {
        this._newLine = true;
        this._left = left;
        this._right = right;
    }
    /**
     * Evaluates the children in postorder (left, right, parent)
     * @param context The current program context
     */
    eval(context) {
        let leftScope = new Scope_1.Scope(context, context.effects, context.eventLog);
        leftScope.canvas = space_lift_1.Some(context.canvas.get());
        //throwing away after evaling
        this._leftVal = this._left.eval(leftScope);
        this._rightVal = this._right.eval(leftScope); // leftScope may be modified now
    }
    /**
     * SequenceNodes cannot be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw() on SequenceNodes");
    }
    /**
     * Equals cannot be directly called on SequenceNodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on SequenceNode");
    }
    /**
     * Returns a string representation of the AST
     */
    toString() {
        let result = this._left.toString();
        if (this._left.newLine() == true) {
            result += '\n';
        }
        else {
            result += ";\n";
        }
        if (this._right.newLine() == false) {
            result += this._right.toString() + ";";
        }
        else {
            result += this._right.toString();
        }
        return result;
    }
    /**
     * Returns the left child
     */
    set left(left) {
        this._left = left;
    }
    /**
     * Sets the left child
     */
    get left() {
        return this._left;
    }
    /**
     * Returns the right child
     */
    set right(right) {
        this._right = right;
    }
    /**
     * Sets the right child
     */
    get right() {
        return this._right;
    }
    /**
     * Returns the value of the left chile
     */
    get leftVal() {
        return this._leftVal;
    }
    /**
     * Returns the value of the right chile
     */
    get rightVal() {
        return this._rightVal;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.SequenceNode = SequenceNode;

},{"./Scope":77,"space-lift":91}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../../index");
const index_2 = require("../../index");
const space_lift_1 = require("space-lift");
let canvas = document.querySelector('canvas');
let ctx = canvas.getContext("2d");
let inputBox = document.getElementById('input');
let lastWorkingInputText = "";
let starCount = 0;
//the effects array that holds all the text, ellipses, and rectangles
let effects = [];
let ast;
let context;
let showDebug = true; // flag to show or hide debug button
let masterLog = [];
let selectedElems = [];
let checkpoint = null;
let modGen = new index_2.ModuleGenerator(true);
let checkpointIsActive = false;
let textBoxSelected; //sees if the text box is selected
let canvasIsDisabled = false;
let selected = 0; //the number of selected effects if multiply selecting
let alreadyLogged = false;
let numLogged = 0;
let globalID = 1;
let eph;
/*
let bugButton = document.getElementById('debug');
if(!showDebug){
    bugButton.style.visibility='hidden';
}

bugButton.onclick = function(){
    printLog();
}
*/
/**
 * <div class="col-item">
 *  <button id='paint' style="background-color:#DFB534"> Run </button>
 * </div>
 *
 * Put this in html file for Run button's styling
 */
//let paintButton = document.getElementById('paint');
/**
 * makes the paint button paint text from the textarea to the canvas!
 */
/*
paintButton.onclick = function () {
    effects.length = 0; // slightly sketch clearing method to maintain reference to original array
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    isPainting = true;
    let inputText = inputBox.value;

    let astOpt = Parser.parse(inputText);
    if(astOpt.isDefined()){
        ast = astOpt.get();
        context = new Scope(null, effects, masterLog);
        context.canvas = Some(canvas);
        ast.eval(context); //this is where we draw the objects to the screen
    } else {
        let error = "error text";
        alert("Quan: so something with this syntax error: " + error);
    }

    //let paintEvt = new PaintEvent(inputText); // will need to get from ast when that's implemented

    // Adding context log to master log
    //logEvent.push(paintEvt.assembleLog());
    printLog();
    //event1.logItem();
    // }
};
*/
//clears the canvas!
let resetButton = document.getElementById('reset');
resetButton.onclick = function () {
    if (checkpoint._starterCode != null) {
        textBoxSelected = true;
        inputBox.value = checkpoint._starterCode;
    }
    context.eventLog.push(new index_2.ClearEvent());
    masterLog.push(context.eventLog[context.eventLog.length - 1]); // Does this actually work?
    printLog();
    //let clearEvt = new ClearEvent();
    //logEvent.push(clearEvt.assembleLog());
    //console.log("Log: " + logEvent);
};
let timer = null;
inputBox.onkeydown = function () {
    if (timer != null) {
        clearTimeout(timer);
    }
    timer = setTimeout(parse, 200);
};
function parse() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let inputText = inputBox.value;
    let astOpt = index_1.Parser.parse(inputText);
    effects.length = 0; // slightly sketch clearing method to maintain reference to original array
    if (astOpt.isDefined()) {
        ast = astOpt.get();
        context = new index_2.Scope(null, effects, masterLog);
        context.canvas = space_lift_1.Some(canvas);
        ast.eval(context); //this is where we draw the objects to the screen
        lastWorkingInputText = inputText;
    }
    //let paintEvt = new PaintEvent(inputText); // will need to get from ast when that's implemented
    // Adding context log to master log
    //logEvent.push(paintEvt.assembleLog());
    printLog();
    //event1.logItem();
    // }
}
/**
 * The animation function that basically recursively calls itself, clearing and
 * redrawing to the canvas at 60fps.
 */
function animate() {
    requestAnimationFrame(animate);
    ctx.clearRect(0, 0, canvas.width, canvas.height); //clears canvas
    selected = 0;
    for (let i = 0; i < effects.length; i++) {
        effects[i].update();
        if (effects[i].selected) {
            selectedElems.push(effects[i]);
            selected++;
        }
        if (effects[i].getJustDragged()) { // Logs drag event
            context.eventLog.push(new index_2.DragEvent(effects[i]));
            masterLog.push(context.eventLog[context.eventLog.length - 1]);
            effects[i].setJustDragged(false);
        }
        if (effects[i].idObj == undefined) { // Gives object an ID if it doesn't have one
            effects[i].initID(globalID);
            context.eventLog.push(new index_2.IDEvent(effects[i])); // Logs ID
            globalID++;
            //console.log(effects[i].getID());
        }
        // if(((effects[i] as EllipseEffect).justDragged)){
        //     //context.eventLog.push(new DragEvent(effects[i]));
        // }
    }
    // at this point, have iterated through all effects and have complete list to log
    if (selected != numLogged) { // if selections have changed, should log again
        alreadyLogged = false;
    }
    if (!alreadyLogged && selected >= 2) { // logs if hasn't already
        numLogged = selected;
        context.eventLog.push(new index_2.SelectEvent(selectedElems));
        masterLog.push(context.eventLog[context.eventLog.length - 1]);
        alreadyLogged = true;
    }
    //This does the prodirect manipulation, passing the new strings to the text box
    if (ast != undefined && !textBoxSelected) {
        let newInput = ast.toString();
        inputBox.value = newInput;
    }
    if (checkpointIsActive) {
        checkpointChecksGoal();
    }
    if (checkpoint != null && checkpoint.drawGuides != null) {
        checkpoint.drawGuides(ctx);
        /*
              if (checkpoint._name == "l1c3") {
                ctx.beginPath();
                ctx.rect(10, 430, 100, 100);
                ctx.strokeStyle = '#6C6C6C';
                ctx.stroke();
        
                ctx.font = 20 + "px Courier New";
                ctx.fillStyle = '#6C6C6C';
                ctx.fillText("Put text", 10, 390);
                ctx.fillText("in here", 10, 410);
              }
        */
    }
    selectedElems = [];
}
//checks to see whether the text box is selected
window.addEventListener('mousedown', isInputBoxSelected);
/**
 * This function manages the state of the UI when the text box is selected and when it isn't.
 * If it is inside the text box, isPainting is false and textBoxSelected is true.
 * If it's not, if it's inside the paint button, then isPainting = true.
 * @param event the mouse down event
 */
function isInputBoxSelected(event) {
    let mouseX = event.clientX;
    let mouseY = event.clientY;
    let rect = inputBox.getBoundingClientRect();
    if (mouseX > rect.left && mouseX < rect.right && mouseY > rect.top && mouseY < rect.bottom) {
        textBoxSelected = true;
    }
    else {
        textBoxSelected = false;
    }
}
//checks to see whether the text box is selected
window.addEventListener('mousedown', disabledCanvasIsSelected);
/**
 * This function handles the case when a disabled canvas is selected.
 * @param event the mouse down event
 */
function disabledCanvasIsSelected(event) {
    let mouseX = event.clientX;
    let mouseY = event.clientY;
    let rect = canvas.getBoundingClientRect();
    let popUp = document.getElementById('popup');
    if (canvasIsDisabled && mouseX > rect.left && mouseX < rect.right && mouseY > rect.top && mouseY < rect.bottom) {
        popUp.style.display = 'block';
    }
    else {
        popUp.style.display = 'none';
    }
}
function printLog() {
    console.log("Log: ");
    for (let elem of masterLog) {
        console.log(elem.assembleLog());
    }
}
let paletteButtons = [
    "ellipse", "rect", "string", "number",
    "line", "curve"
];
for (let buttonName of paletteButtons) {
    let paletteButton = document.getElementById(buttonName);
    paletteButton.onclick = function () {
        textBoxSelected = true;
        printNewNode(buttonName);
    };
}
function printNewNode(buttonName) {
    let printLine = "";
    switch (buttonName) {
        case "ellipse":
            printLine = "print(ellipse(100,100));";
            break;
        case "rect":
            printLine = "print(rect(100,100));";
            break;
        case "string":
            printLine = 'print("newWord");';
            break;
        case "number":
            printLine = "print(10);";
            break;
        case "line":
            printLine = "print(line(100,100));";
            break;
        case "curve":
            printLine = "print(curve(100,100,100));";
            break;
        default:
            console.log("Problem with " + buttonName);
    }
    inputBox.value += printLine;
    parse();
}
let instructions = document.getElementById('goal');
let rewardBox = document.getElementById('reward-container');
let instrLabel = document.getElementById('instr-label');
//Map maintaining code last used at a checkpoint
let cpCode = new Map([
    ['l1c1', ""],
    ['l1c2', ""],
    ['l1c3', ""],
    ['l1c4', ""],
    ['l2c1', ""],
    ['l2c2', ""],
    ['l2c3', ""],
    ['l2c4', ""],
    ['l2c5', ""],
    ['l2c6', ""],
    ['l2c7', ""],
    ['l3c1', ""],
    ['l3c2', ""],
    ['l3c3', ""],
    ['l3c4', ""],
    ['l3c5', ""],
    ['l3c6', ""],
    ['l4c1', ""],
    ['l4c2', ""]
]);
//Map maintaining whether a checkpoint has been completed
let cpCompletion = new Map([
    ['l1c1', false],
    ['l1c2', false],
    ['l1c3', false],
    ['l1c4', false],
    ['l2c1', false],
    ['l2c2', false],
    ['l2c3', false],
    ['l2c4', false],
    ['l2c5', false],
    ['l2c6', false],
    ['l2c7', false],
    ['l3c1', false],
    ['l3c2', false],
    ['l3c3', false],
    ['l3c4', false],
    ['l3c5', false],
    ['l3c6', false],
    ['l4c1', false],
    ['l4c2', false]
]);
let cpNames = [
    'l1c1', 'l1c2', 'l1c3', 'l1c4',
    'l2c1', 'l2c2', 'l2c3', 'l2c4', 'l2c5', 'l2c6', 'l2c7',
    'l3c1', 'l3c2', 'l3c3', 'l3c4', 'l3c5', 'l3c6' /*,
    'l4c1', 'l4c2'*/
];
for (let cp of cpNames) {
    let cpButton = document.getElementById(cp);
    cpButton.onclick = function () {
        initCheckpoint(cp);
    };
}
/**
 * Creates a module corresponding to a checkpoint passed in.
 * Sets up the instruction, CODE area, and goal box accordingly.
 * @param cp: the name of the checkpoint
 */
function initCheckpoint(cp) {
    //store CODE of old checkpoint
    if (checkpoint != null) {
        cpCode.set(checkpoint._name, inputBox.value);
    }
    console.log("Initiating checkpoint " + cp);
    checkpoint = modGen.generateCheckpoint(cp);
    instrLabel.innerHTML = cp + " - GOAL";
    instructions.innerHTML = checkpoint._instructions;
    //set up the CODE and CANVAS areas
    if (checkpoint._constraint == 'code') {
        inputBox.setAttribute('disabled', 'disabled');
        inputBox.style.opacity = '0.5';
        canvas.style.pointerEvents = "auto";
        canvas.style.background = '#EBEBEB';
        canvasIsDisabled = false;
    }
    else if (checkpoint._constraint == 'canvas') {
        inputBox.removeAttribute('disabled');
        inputBox.style.opacity = '1.0';
        canvas.style.pointerEvents = "none";
        canvas.style.background = '#C0C0C0';
        canvasIsDisabled = true;
    }
    else {
        inputBox.removeAttribute('disabled');
        inputBox.style.opacity = '1.0';
        canvas.style.pointerEvents = "auto";
        canvas.style.background = '#EBEBEB';
        canvasIsDisabled = false;
    }
    let popUp = document.getElementById('popup');
    popUp.style.display = 'none';
    if (cpCode.get(checkpoint._name) !== "") {
        textBoxSelected = true;
        inputBox.value = cpCode.get(checkpoint._name);
    }
    //set up the instruction and goal boxes
    if (cpCompletion.get(cp)) {
        updateRewardBox();
    }
    else {
        if (checkpoint._starterCode != null) {
            textBoxSelected = true;
            inputBox.value = checkpoint._starterCode;
            parse();
        }
        let curInstruction = document.getElementById("instruction");
        if (curInstruction != null) {
            curInstruction.remove();
        }
        /*
              if (checkpoint._name === "l1c1") {
                checkpoint.renderInstruction(document);
              }
        */
        rewardBox.style.background = '#C0C0C0';
        let reward = document.getElementById('reward-text');
        reward.style.color = 'black';
        reward.innerHTML = 'Complete goal to earn a star!';
        let rewardImg = document.getElementById('reward-image');
        rewardImg.src = 'pics/greystar.svg';
        rewardImg.alt = 'a star to be earned';
        let nextBtn = document.getElementById('next');
        nextBtn.style.display = 'none';
        instructions.scrollTop = 0;
        checkpointIsActive = true;
    }
}
function checkpointChecksGoal() {
    if (checkpoint.checkGoal(document, effects)) {
        updateRewardBox();
        cpCompletion.set(checkpoint._name, true);
    }
}
function updateRewardBox() {
    rewardBox.style.background = '#673AB7';
    console.log(document);
    let rewardText = document.getElementById('reward-text');
    rewardText.style.color = '#D8D8D8';
    rewardText.innerHTML = "Goal met! Click 'Next' to go to next checkpoint!";
    let rewardImg = document.getElementById('reward-image');
    rewardImg.src = 'pics/star.svg';
    rewardImg.alt = 'star earned';
    let nextBtn = document.getElementById('next');
    nextBtn.style.display = 'block';
    instructions.scrollTop = instructions.scrollHeight;
    checkpointIsActive = false;
}
let nextButton = document.getElementById('next');
nextButton.onclick = function () {
    let nextModule = checkpoint._nextModule;
    if (nextModule != '') {
        initCheckpoint(nextModule);
    }
};
let prevButton = document.getElementById('prev');
prevButton.onclick = function () {
    let prevModule = checkpoint._prevModule;
    if (prevModule != '') {
        initCheckpoint(prevModule);
    }
};
//call to animate
animate();

},{"../../index":1,"space-lift":91}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const UnaryOperation_1 = require("./UnaryOperation");
const NumberNode_1 = require("../prims/NumberNode");
class NegOp extends UnaryOperation_1.UnaryOperation {
    /**
     * Constructor for a NegationOperation
     * @param val The value to be negated (must be a NumberNode)
     * @param ws Preceding whitespace
     */
    constructor(val, ws) {
        super(val);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the value into the negative version
     * @param context The current program context
     */
    eval(context) {
        let v = this.val.eval(context);
        return new NumberNode_1.NumberNode(-v.val, "");
    }
    /**
     * NegOps cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Negation ops cannot be drawn directly");
    }
    /**
     * Equals cannot be called directly on a NegOp
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on NegOp");
    }
    /**
     * Returns a string representation of the NegOp
     */
    toString() {
        return this._ws + "-" + this.val;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.NegOp = NegOp;

},{"../prims/NumberNode":65,"./UnaryOperation":81}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class UnaryOperation {
    /**
     * Abstract class constructor for Unary Operations
     * @param _val The object to be operated on
     */
    constructor(_val) {
        this._val = _val;
        this._newLine = false;
    }
    ;
    /**
     * Abstract draw method for undrawable UnaryOps
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Unary Operations cannot be drawn directly");
    }
    /**
     * Equals cannot be called directly on UnaryOps
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on UnaryOp");
    }
    ;
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the UnaryOp value
     */
    get val() {
        return this._val;
    }
    /**
     * Sets the UnaryOp value
     */
    set val(value) {
        this._val = value;
    }
}
exports.UnaryOperation = UnaryOperation;

},{}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class VariableNode {
    /**
     * Constructor for a VariableNode, a node representing a variable
     * @param name The variable name
     * @param ws Preceding whitespace
     */
    constructor(name, ws) {
        this._newLine = false;
        this._name = name;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Looks up the value of the variable in the context
     * @param context The current program context
     */
    eval(context) {
        return context.lookup(this._name, context);
    }
    /**
     * VariableNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw on variable nodes");
    }
    /**
     * Equals cannot be called directly on VariableNodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot directly compare vars, eval first");
    }
    /**
     * Returns a string representation of the VariableNode
     */
    toString() {
        return this._ws + this._name;
    }
    /**
     * Returns the name of the variable
     */
    get name() {
        return this._name;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.VariableNode = VariableNode;

},{}],83:[function(require,module,exports){
"use strict";
//--------------------------------------
//  Shallow update
//--------------------------------------
exports.__esModule = true;
/** Performs a shallow update of an object using a partial object of the same shape. A new object is returned. */
function update(host, spec) {
    var result = clone(host);
    for (var key in spec) {
        var specValue = spec[key];
        if (specValue === exports.DELETE) {
            delete result[key];
        }
        else {
            result[key] = specValue;
        }
    }
    return result;
}
exports.update = update;
// We lie about the public type so that only a property that is optional or that can be assigned to undefined can be DELETE'd
/** Marker used to delete a key */
exports.DELETE = {};
var _Updater = /** @class */ (function () {
    function _Updater(data) {
        this.data = data;
    }
    _Updater.prototype.at = function (keyOrIndex) {
        return new _Updater({ type: 'at', parent: this, field: keyOrIndex });
    };
    _Updater.prototype.set = function (value) {
        var _this = this;
        var doSet = function (target) {
            var result = _this.cloneForUpdate(target);
            if (result.name === 'aborted')
                return target;
            var clonedTarget = result.clonedTarget, leafHost = result.leafHost, field = result.field;
            value === exports.DELETE ? delete leafHost[field] : leafHost[field] = value;
            return clonedTarget;
        };
        var boundTarget = this.findBoundTarget();
        return boundTarget
            ? doSet(boundTarget)
            : doSet;
    };
    _Updater.prototype.modify = function (modifier) {
        var _this = this;
        var doModify = function (target) {
            var result = _this.cloneForUpdate(target);
            if (result.name === 'aborted')
                return target;
            var clonedTarget = result.clonedTarget, leafHost = result.leafHost, field = result.field;
            var value = modifier(leafHost[field]);
            value === exports.DELETE ? delete leafHost[field] : leafHost[field] = value;
            return clonedTarget;
        };
        var boundTarget = this.findBoundTarget();
        return boundTarget
            ? doModify(boundTarget)
            : doModify;
    };
    _Updater.prototype.withDefault = function (value) {
        return new _Updater({ type: 'withDefault', parent: this, defaultValue: value });
    };
    _Updater.prototype.abortIfUndef = function () {
        return new _Updater({ type: 'abortIfUndef', parent: this });
    };
    _Updater.prototype.findBoundTarget = function () {
        var current = this;
        while (true) {
            if (current.data.type === 'root')
                return current.data.boundTarget;
            current = current.data.parent;
        }
    };
    _Updater.prototype.parentUpdaters = function () {
        var updaters = [this];
        var parentUpdater = this.data.parent;
        // Ignore the root updater
        while (parentUpdater && parentUpdater.data.parent) {
            updaters.unshift(parentUpdater);
            parentUpdater = parentUpdater.data.parent;
        }
        return updaters;
    };
    _Updater.prototype.getNextValue = function (previousHost, host, field, isLast) {
        if (this.data.type === 'at') {
            var newField = this.data.field;
            var value_1 = host[newField];
            var nextValue = isObjectOrArray(value_1) ? clone(value_1) : value_1;
            var newHost_1 = isLast ? host : nextValue;
            host[this.data.field] = nextValue;
            return { host: newHost_1, field: newField };
        }
        var value = previousHost[field];
        if (this.data.type === 'abortIfUndef' && value === undefined) {
            return { host: host, field: field, aborted: true };
        }
        if (this.data.type === 'withDefault' && value === undefined) {
            var nextValue = this.data.defaultValue;
            var newHost_2 = isLast ? previousHost : nextValue;
            previousHost[field] = nextValue;
            return { host: newHost_2, field: field };
        }
        var newHost = isLast ? previousHost : host;
        return { host: newHost, field: field };
    };
    _Updater.prototype.cloneForUpdate = function (target) {
        var updaters = this.parentUpdaters();
        var obj = clone(target);
        var previousHost = obj;
        var host = obj;
        var field = '';
        for (var i = 0; i < updaters.length; i++) {
            var result = updaters[i].getNextValue(previousHost, host, field, i === updaters.length - 1);
            if (result.aborted)
                return { name: 'aborted' };
            previousHost = host;
            host = result.host;
            field = result.field;
        }
        return {
            name: 'result',
            clonedTarget: obj,
            leafHost: host,
            field: field
        };
    };
    return _Updater;
}());
function isObjectOrArray(obj) {
    return obj !== null && typeof obj === 'object';
}
function clone(obj) {
    if (Array.isArray(obj))
        return obj.slice();
    var cloned = {};
    Object.keys(obj).forEach(function (key) { cloned[key] = obj[key]; });
    return cloned;
}
function deepUpdate(target) {
    return new _Updater({ type: 'root', boundTarget: target });
}
exports.deepUpdate = deepUpdate;

},{}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CharUtil;
(function (CharUtil) {
    class CharStream {
        constructor(s, startpos, endpos, hasEOF) {
            this.hasEOF = true;
            this.input = s;
            if (hasEOF != undefined) {
                this.hasEOF = hasEOF;
            }
            if (startpos == undefined) {
                this.startpos = 0; // not specified; set default
            }
            else if (startpos > s.length) {
                this.startpos = s.length; // seek too far; set EOF
            }
            else {
                this.startpos = startpos; // specified and in bounds
            }
            if (endpos == undefined) {
                this.endpos = s.length; // not specified; set default
            }
            else if (endpos > s.length) {
                this.endpos = s.length; // seek too far; set EOF
            }
            else {
                this.endpos = endpos; // specified and in bounds
            }
            if (this.startpos > this.endpos) {
                this.startpos = this.endpos; // if the user flipped positions
            }
        }
        /**
         * Returns true of the end of the input has been reached.
         */
        isEOF() {
            return this.hasEOF && this.startpos == this.input.length;
        }
        /**
         * Returns a Javscript primitive string of the slice of input
         * represented by this CharStream.
         */
        toString() {
            return this.input.substring(this.startpos, this.endpos);
        }
        /**
         * Returns a new CharStream representing the input from the
         * current start position to an end position num chars from
         * the current start position.  If startpos + num > endpos,
         * the current CharStream is returned.
         * @param num
         */
        peek(num) {
            if (this.startpos + num > this.endpos) {
                return this;
            }
            else {
                let newHasEOF = this.startpos + num == this.endpos && this.hasEOF;
                return new CharStream(this.input, this.startpos, this.startpos + num, newHasEOF);
            }
        }
        /**
         * Returns a new CharStream representing the string after
         * seeking num characters from the current position.
         * @param num
         */
        seek(num) {
            if (this.startpos + num > this.endpos) {
                return new CharStream(this.input, this.endpos, this.endpos, this.hasEOF);
            }
            else {
                return new CharStream(this.input, this.startpos + num, this.endpos, this.hasEOF);
            }
        }
        /**
         * Returns a new CharStream representing the head of the input at
         * the current position.  Throws an exception if the CharStream is
         * empty.
         */
        head() {
            if (!this.isEmpty()) {
                const newHasEOF = this.startpos + 1 == this.endpos && this.hasEOF;
                return new CharStream(this.input, this.startpos, this.startpos + 1, newHasEOF);
            }
            else {
                throw new Error("Cannot get the head of an empty string.");
            }
        }
        /**
         * Returns a new CharStream representing the tail of the input at
         * the current position.  Throws an exception if the CharStream is
         * empty.
         */
        tail() {
            if (!this.isEmpty()) {
                return new CharStream(this.input, this.startpos + 1, this.endpos, this.hasEOF);
            }
            else {
                throw new Error("Cannot get the tail of an empty string.");
            }
        }
        /**
         * Returns true if the input at the current position is empty. Note
         * that a CharStream at the end of the input contains an empty
         * string but that an empty string may not be the end-of-file (i.e.,
         * isEOF is false).
         */
        isEmpty() {
            return this.startpos == this.endpos;
        }
        /**
         * Returns the number of characters remaining at
         * the current position.
         */
        length() {
            return this.endpos - this.startpos;
        }
        /**
         * Returns the substring between start and end at the
         * current position.
         * @param start the start index of the substring, inclusive
         * @param end the end index of the substring, exclusive
         */
        substring(start, end) {
            const start2 = this.startpos + start;
            const end2 = this.startpos + end;
            const newHasEOF = this.endpos == end2 && this.hasEOF;
            return new CharStream(this.input, start2, end2, newHasEOF);
        }
        /**
         * Returns the concatenation of the current CharStream with
         * the given CharStream. Note: returned object does not
         * reuse original input string, and startpos and endpos
         * are reset. If the given CharStream contains EOF, the
         * concatenated CharStream will also contain EOF.
         * @param cs the CharStream to concat to this CharStream
         */
        concat(cs) {
            const s = this.toString() + cs.toString();
            return new CharStream(s, 0, s.length, cs.hasEOF);
        }
        /**
         * Concatenate an array of CharStream objects into a single
         * CharStream object.
         * @param css a CharStream[]
         */
        static concat(css) {
            if (css.length == 0) {
                return new CharStream("", 0, 0, false);
            }
            else {
                let cs = css[0];
                for (let i = 1; i < css.length; i++) {
                    cs = cs.concat(css[i]);
                }
                return cs;
            }
        }
    }
    CharUtil.CharStream = CharStream;
})(CharUtil = exports.CharUtil || (exports.CharUtil = {}));

},{}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var primitives_1 = require("./primitives");
exports.Primitives = primitives_1.Primitives;
var charstream_1 = require("./charstream");
exports.CharUtil = charstream_1.CharUtil;

},{"./charstream":84,"./primitives":86}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const charstream_1 = require("./charstream");
var Primitives;
(function (Primitives) {
    class EOFMark {
        constructor() { }
        static get Instance() {
            return this._instance || (this._instance = new this());
        }
    }
    Primitives.EOFMark = EOFMark;
    Primitives.EOF = EOFMark.Instance;
    /**
     * Represents a successful parse.
     */
    class Success {
        /**
         * Returns an object representing a successful parse.
         * @param istream The remaining string.
         * @param res The result of the parse
         */
        constructor(istream, res) {
            this.tag = "success";
            this.inputstream = istream;
            this.result = res;
        }
    }
    Primitives.Success = Success;
    /**
     * Represents a failed parse.
     */
    class Failure {
        /**
         * Returns an object representing a failed parse.
         * @param istream The string, unmodified, that was given to the parser.
         */
        constructor(istream) {
            this.tag = "failure";
            this.inputstream = istream;
        }
    }
    Primitives.Failure = Failure;
    /**
     * result succeeds without consuming any input, and returns v.
     * @param v The result of the parse.
     */
    function result(v) {
        return (istream) => new Success(istream, v);
    }
    Primitives.result = result;
    /**
     * zero fails without consuming any input.
     */
    function zero() {
        return (istream) => new Failure(istream);
    }
    Primitives.zero = zero;
    /**
     * item successfully consumes the first character if the input
     * string is non-empty, otherwise it fails.
     */
    function item() {
        return (istream) => {
            if (istream.isEmpty()) {
                return new Failure(istream);
            }
            else {
                return new Success(istream.tail(), istream.head());
            }
        };
    }
    Primitives.item = item;
    /**
     * bind is a curried function that takes a parser p and returns
     * a function that takes a parser f which returns the composition
     * of p and f.  If _any_ of the parsers fail, the original inputstream
     * is returned in the Failure object (i.e., bind backtracks).
     * @param p A parser
     */
    function bind(p) {
        return (f) => {
            return (istream) => {
                let r = p(istream);
                switch (r.tag) {
                    case "success":
                        let o = f(r.result)(r.inputstream);
                        switch (o.tag) {
                            case "success": return o;
                            case "failure":
                                // note: backtracks, returning original istream
                                return new Failure(istream);
                        }
                    case "failure": return new Failure(istream);
                }
            };
        };
    }
    Primitives.bind = bind;
    function delay(p) {
        return () => p;
    }
    Primitives.delay = delay;
    /**
     * seq is a curried function that takes a parser p, a parser q,
     * and a function f. It applies p to the input, passing the
     * remaining input stream to q; q is then applied.  The function
     * f takes the result of p and q, as a tuple, and returns
     * a single result.
     * @param p A parser
     */
    // export let seq = function<T,U,V>(p: IParser<T>) {
    //     return (q: IParser<U>) => {
    //         return (f: (e: [T,U]) => V) => {
    //             return bind<T,V>(p)((x) => {
    //                 return bind<U,V>(q)((y) => {
    //                     let tup : [T,U] = [x,y];
    //                     return result<V>(f(tup));
    //                 });
    //             });
    //         }
    //     };
    // }
    function seq(p) {
        return (q) => {
            return (f) => {
                return bind(p)((x) => {
                    return bind(q)((y) => {
                        let tup = [x, y];
                        return result(f(tup));
                    });
                });
            };
        };
    }
    Primitives.seq = seq;
    /**
     * sat takes a predicate and yields a parser that consumes a
     * single character if the character satisfies the predicate,
     * otherwise it fails.
     * @param pred a character predicate
     */
    function sat(pred) {
        let pred2 = (cs) => pred(cs.toString());
        let a = item();
        let b = (x) => {
            if (pred2(x)) {
                return result(x);
            }
            else {
                return zero();
            }
        };
        return bind(a)(b);
    }
    Primitives.sat = sat;
    /**
     * char takes a character and yields a parser that consume
     * that character. The returned parser succeeds if the next
     * character in the input stream is c, otherwise it fails.
     * @param c
     */
    function char(c) {
        if (c.length != 1) {
            throw new Error("char parser takes a string of length 1 (i.e., a char)");
        }
        return sat(x => x == c);
    }
    Primitives.char = char;
    /**
     * letter returns a parser that consumes a single alphabetic
     * character, from a-z, regardless of case.
     */
    function letter() {
        let contains_letter = (x) => {
            let a_letter = /[A-Za-z]/;
            return x.match(a_letter) != undefined;
        };
        return sat(contains_letter);
    }
    Primitives.letter = letter;
    /**
     * digit returns a parser that consumes a single numeric
     * character, from 0-9.  Note that the type of the result
     * is a string, not a number.
     */
    function digit() {
        return sat(x => x == "0"
            || x == "1"
            || x == "2"
            || x == "3"
            || x == "4"
            || x == "5"
            || x == "6"
            || x == "7"
            || x == "8"
            || x == "9");
    }
    Primitives.digit = digit;
    /**
     * upper returns a parser that consumes a single character
     * if that character is uppercase.
     */
    function upper() {
        return (istream) => {
            let o1 = letter()(istream);
            switch (o1.tag) {
                case "success":
                    let o2 = sat(x => x == x.toUpperCase())(o1.result);
                    switch (o2.tag) {
                        case "success":
                            return o1;
                        case "failure":
                            return new Failure(istream);
                    }
                    break;
                case "failure":
                    return o1;
            }
            throw new Error("never happens");
        };
    }
    Primitives.upper = upper;
    /**
     * lower returns a parser that consumes a single character
     * if that character is lowercase.
     */
    function lower() {
        return (istream) => {
            let o1 = letter()(istream);
            switch (o1.tag) {
                case "success":
                    let o2 = sat(x => x == x.toLowerCase())(o1.result);
                    switch (o2.tag) {
                        case "success":
                            return o1;
                        case "failure":
                            return new Failure(istream);
                    }
                    break;
                case "failure":
                    return o1;
            }
            throw new Error("never happens");
        };
    }
    Primitives.lower = lower;
    /**
     * choice specifies an ordered choice between two parsers,
     * p1 and p2. The returned parser will first apply
     * parser p1.  If p1 succeeds, p1's Outcome is returned.
     * If p1 fails, p2 is applied and the Outcome of p2 is returned.
     * Note that the input stream given to p1 and p2 is exactly
     * the same input stream.
     * @param p1 A parser.
     */
    function choice(p1) {
        return (p2) => {
            return (istream) => {
                let o = p1(istream);
                switch (o.tag) {
                    case "success":
                        return o;
                    case "failure":
                        return p2(istream);
                }
            };
        };
    }
    Primitives.choice = choice;
    /**
     * appfun allows the user to apply a function f to
     * the result of a parser p, assuming that p is successful.
     * @param p A parser.  This is the same as the |>>
     * function from FParsec.
     */
    function appfun(p) {
        return (f) => {
            return (istream) => {
                let o = p(istream);
                switch (o.tag) {
                    case "success":
                        return new Success(o.inputstream, f(o.result));
                    case "failure":
                        return o;
                }
            };
        };
    }
    Primitives.appfun = appfun;
    /**
     * many repeatedly applies the parser p until p fails. many always
     * succeeds, even if it matches nothing.  many tries to guard
     * against an infinite loop by raising an exception if p succeeds
     * without changing the parser state.
     * @param p
     */
    function many(p) {
        return (istream) => {
            let istream2 = istream;
            let outputs = [];
            let succeeds = true;
            while (!istream2.isEmpty() && succeeds) {
                let o = p(istream2);
                switch (o.tag) {
                    case "success":
                        if (istream2 == o.inputstream) {
                            throw new Error("Parser loops infinitely.");
                        }
                        istream2 = o.inputstream;
                        outputs.push(o.result);
                        break;
                    case "failure":
                        succeeds = false;
                        break;
                }
            }
            return new Success(istream2, outputs);
        };
    }
    Primitives.many = many;
    /**
     * many1 repeatedly applies the parser p until p fails. many1 must
     * succeed at least once.  many1 tries to guard against an infinite
     * loop by raising an exception if p succeeds without changing the
     * parser state.
     * @param p
     */
    function many1(p) {
        return (istream) => {
            return seq(p)(many(p))(tup => {
                let hd = tup["0"];
                let tl = tup["1"];
                tl.unshift(hd);
                return tl;
            })(istream);
        };
    }
    Primitives.many1 = many1;
    /**
     * str yields a parser for the given string.
     * @param s A string
     */
    // TODO: this should actually be a sequence of parsers constructed
    // from the string s
    function str(s) {
        return (istream) => {
            // escape regex metacharacters
            // (this likely needs work)
            let s2 = s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
            let re = new RegExp("^" + s2);
            if (istream.toString().match(re)) {
                const rem = istream.substring(s.length, istream.length());
                const res = istream.substring(0, s.length);
                return new Success(rem, res);
            }
            else {
                return new Failure(istream);
            }
        };
    }
    Primitives.str = str;
    /**
     * Returns a parser that succeeds only if the end of the
     * input has been reached.
     */
    function eof() {
        return (istream) => {
            if (istream.isEOF()) {
                return new Success(istream, Primitives.EOF);
            }
            else {
                return new Failure(istream);
            }
        };
    }
    Primitives.eof = eof;
    /**
     * fresult returns a parser that applies the parser p,
     * and if p succeeds, returns the value x.
     * @param p a parser
     */
    function fresult(p) {
        return (x) => {
            return (istream) => {
                return bind(p)((t) => result(x))(istream);
            };
        };
    }
    Primitives.fresult = fresult;
    /**
     * left returns a parser that applies the parser p,
     * then the parser q, and if both are successful,
     * returns the result of p.
     * @param p a parser
     */
    function left(p) {
        return (q) => {
            return (istream) => {
                return bind(p)((t) => fresult(q)(t))(istream);
            };
        };
    }
    Primitives.left = left;
    /**
     * right returns a parser that applies the parser p,
     * then the parser q, and if both are successful,
     * returns the result of q.
     * @param p a parser
     */
    function right(p) {
        return (q) => {
            return (istream) => {
                return bind(p)(_ => q)(istream);
            };
        };
    }
    Primitives.right = right;
    /**
     * between returns a parser that applies the parser
     * popen, p, and pclose in sequence, and if all are
     * successful, returns the result of p.
     * @param popen the first parser
     */
    function between(popen) {
        return (pclose) => {
            return (p) => {
                let l = left(p)(pclose);
                let r = right(popen)(l);
                return r;
            };
        };
    }
    Primitives.between = between;
    /**
     * The debug parser takes a parser p and a debug string,
     * printing the debug string as a side-effect before
     * applying p to the input.
     * @param p a parser
     */
    function debug(p) {
        return (label) => {
            return (istream) => {
                console.log("apply: " + label);
                let o = p(istream);
                switch (o.tag) {
                    case "success":
                        console.log("success: " + label + ", startpos: " + istream.startpos + ", endpos: " + istream.endpos);
                        break;
                    case "failure":
                        console.log("failure: " + label + ", startpos: " + istream.startpos + ", endpos: " + istream.endpos);
                        break;
                }
                return o;
            };
        };
    }
    Primitives.debug = debug;
    let wschars = choice(sat(c => c == ' ' || c == '\t'))(nl());
    /**
     * ws matches zero or more of the following whitespace characters:
     * ' ', '\t', '\n', or '\r\n'
     * ws returns matched whitespace in a single CharStream result.
     */
    function ws() {
        return (istream) => {
            let o = many(wschars)(istream);
            switch (o.tag) {
                case "success":
                    return new Success(o.inputstream, charstream_1.CharUtil.CharStream.concat(o.result));
                // ws never fails
            }
        };
    }
    Primitives.ws = ws;
    /**
     * ws1 matches one or more of the following whitespace characters:
     * ' ', '\t', '\n', or '\r\n'
     * ws1 returns matched whitespace in a single CharStream result.
     */
    function ws1() {
        return (istream) => {
            let o = many1(wschars)(istream);
            switch (o.tag) {
                case "success":
                    return new Success(o.inputstream, charstream_1.CharUtil.CharStream.concat(o.result));
                case "failure":
                    return o;
            }
        };
    }
    Primitives.ws1 = ws1;
    /**
     * nl matches and returns a newline.
     */
    function nl() {
        return Primitives.choice(Primitives.str("\n"))(Primitives.str("\r\n"));
    }
    Primitives.nl = nl;
    function groupBy(list, keyGetter) {
        let m = new Map();
        list.forEach((item) => {
            const key = keyGetter(item);
            if (!m.has(key)) {
                m.set(key, []);
            }
            let collection = m.get(key);
            collection.push(item);
        });
        return m;
    }
    function strSat(strs) {
        // sort strings first by length, and then lexicograpically;
        // slice() called here so as not to modify original array
        let smap = groupBy(strs, s => s.length);
        let sizes = [];
        // find size classes;
        // also sort each set of equivalent-length values
        smap.forEach((vals, key, m) => {
            sizes.push(key);
            vals.sort();
        });
        sizes.sort();
        return (istream) => {
            // start with the smallest size class       
            for (let peekIndex = 0; peekIndex < sizes.length; peekIndex++) {
                // for each size class, try matching all of
                // the strings; if one is found, return the
                // appropriate CharStream; if not, fail.
                let peek = istream.peek(sizes[peekIndex]);
                let tail = istream.seek(sizes[peekIndex]);
                let candidates = smap.get(sizes[peekIndex]);
                for (let cIndex = 0; cIndex < candidates.length; cIndex++) {
                    if (candidates[cIndex] === peek.toString()) {
                        return new Success(tail, peek);
                    }
                }
            }
            return new Failure(istream);
        };
    }
    Primitives.strSat = strSat;
})(Primitives = exports.Primitives || (exports.Primitives = {}));

},{"./charstream":84}],87:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
/**
 * Converts an Array-like object (such as an arguments or NodeList instance) to a regular Array
 */
function fromArrayLike(arrayLike) {
    return new lift_1.ArrayOps([].slice.call(arrayLike));
}
exports.fromArrayLike = fromArrayLike;

},{"../lift":92}],88:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
/*
* Returns a number[] wrapper with all numbers from start to stop (inclusive),
* incremented or decremented by step.
*/
function range(start, stop, step) {
    if (arguments.length === 1) {
        stop = arguments[0] - 1;
        start = 0;
    }
    step = step || 1;
    var result = [];
    var increasing = step > 0;
    var next = start;
    while ((increasing && next <= stop) || (!increasing && next >= stop)) {
        result.push(next);
        next = next + step;
    }
    return new lift_1.ArrayOps(result);
}
exports.range = range;

},{"../lift":92}],89:[function(require,module,exports){
"use strict";
exports.__esModule = true;
function tuple(arr) {
    return arr;
}
exports.tuple = tuple;

},{}],90:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var is_1 = require("../object/is");
var currentMemoId = 0;
/**
 * Memoizes a function of arbitrary arity.
 * This has two main uses:
 *   1) Reducing the CPU time taken by expensive calculations at the cost of some memory overhead
 *   2) Producing stable references for a given set of arguments. Useful when relying on reference equality.
 *
 * Memoized functions keep internal state. If you wish to clear that state entirely, you can recreate the function.
 */
function memoize(fun, options) {
    // The unique property name used by this memoize function instance.
    // This is used to store the id/reference of object arguments, as Weak maps/sets are very limited.
    var memoKey = "__memo__" + currentMemoId++;
    var lastArgKeys = [];
    var cacheSize = (options && options.cacheSize) || 30;
    var keyFunction = options && options.key;
    // The unique ids/references of objects inside the arityNCache cache
    var objId = 0;
    var arity0Cache;
    var arityNCache;
    var keyCache;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // 0 arguments edge-case
        if (args.length === 0) {
            if (!arity0Cache)
                arity0Cache = fun();
            return arity0Cache;
        }
        // custom key function
        else if (keyFunction) {
            keyCache = keyCache || {};
            var key = keyFunction.apply(null, args);
            var result = keyCache[key];
            if (!result) {
                lastArgKeys.push(key);
                limitCacheSize(keyCache, lastArgKeys, cacheSize);
                result = keyCache[key] = fun.apply(null, args);
            }
            return result;
        }
        // N arguments
        else {
            arityNCache = arityNCache || {};
            var key = '';
            for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                var argKey = void 0;
                if (is_1.object(arg)) {
                    argKey = arg[memoKey];
                    if (!argKey) {
                        // Non enumerable
                        Object.defineProperty(arg, memoKey, { value: "obj" + objId++ });
                        argKey = arg[memoKey];
                    }
                }
                else {
                    argKey = arg;
                }
                key += (argKey + '_');
            }
            var result = arityNCache[key];
            if (!result) {
                lastArgKeys.push(key);
                limitCacheSize(arityNCache, lastArgKeys, cacheSize);
                result = arityNCache[key] = fun.apply(null, args);
            }
            return result;
        }
    };
}
exports.memoize = memoize;
function limitCacheSize(cache, lastArgKeys, size) {
    if (lastArgKeys.length === size + 1) {
        var key = lastArgKeys.shift();
        delete cache[key];
    }
}

},{"../object/is":93}],91:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("./lift");
exports["default"] = lift_1["default"];
var lift_2 = require("./lift");
exports.ArrayOps = lift_2.ArrayOps;
exports.ObjectOps = lift_2.ObjectOps;
exports.NumberOps = lift_2.NumberOps;
exports.StringOps = lift_2.StringOps;
exports.DateOps = lift_2.DateOps;
exports.getValue = lift_2.getValue;
var immupdate_1 = require("immupdate");
exports.update = immupdate_1.update;
exports.deepUpdate = immupdate_1.deepUpdate;
exports.DELETE = immupdate_1.DELETE;
var option_1 = require("./option");
exports.Option = option_1.Option;
exports.None = option_1.None;
exports.Some = option_1.Some;
var result_1 = require("./result");
exports.Result = result_1.Result;
exports.Ok = result_1.Ok;
exports.Err = result_1.Err;
var range_1 = require("./array/range");
exports.range = range_1.range;
var fromArrayLike_1 = require("./array/fromArrayLike");
exports.fromArrayLike = fromArrayLike_1.fromArrayLike;
var tuple_1 = require("./array/tuple");
exports.tuple = tuple_1.tuple;
var set_1 = require("./object/set");
exports.Set = set_1.Set;
var memoize_1 = require("./function/memoize");
exports.memoize = memoize_1.memoize;
var isType = require("./object/is");
exports.is = isType;

},{"./array/fromArrayLike":87,"./array/range":88,"./array/tuple":89,"./function/memoize":90,"./lift":92,"./object/is":93,"./object/set":94,"./option":95,"./result":96,"immupdate":83}],92:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift = function (obj) {
    if (obj instanceof Array)
        return new exports.ArrayOps(obj);
    if (obj instanceof Date)
        return new exports.DateOps(obj);
    if (typeof obj === 'string')
        return new exports.StringOps(obj);
    if (typeof obj === 'number')
        return new exports.NumberOps(obj);
    return new exports.ObjectOps(obj);
};
exports["default"] = lift;
function getValue(input) {
    return input && input['_isLiftWrapper']
        ? input.value()
        : input;
}
exports.getValue = getValue;
function makeOps() {
    var Ops = /** @class */ (function () {
        function Ops(_value) {
            this._value = _value;
            this._isLiftWrapper = true;
        }
        Ops.prototype.value = function () { return this._value; };
        return Ops;
    }());
    return Ops;
}
exports.ArrayOps = makeOps();
exports.ObjectOps = makeOps();
exports.NumberOps = makeOps();
exports.StringOps = makeOps();
exports.DateOps = makeOps();

},{}],93:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/** Returns whether an object is an Array */
exports.array = Array.isArray;
/** Returns whether this object is a function */
function func(obj) {
    return (typeof obj === 'function');
}
exports.func = func;
/** Returns whether this object is a string */
function string(obj) {
    return (typeof obj === 'string');
}
exports.string = string;
/** Returns whether this object is a number */
function number(obj) {
    return (typeof obj === 'number');
}
exports.number = number;
/** Returns whether this object is a boolean */
function boolean(obj) {
    return (typeof obj === 'boolean');
}
exports.boolean = boolean;
/** Returns whether this value is an object (e.g not a primitive: dates, arrays, functions, objects, regexes, `new Number(0)`, and `new String('')) */
function object(obj) {
    var type = typeof obj;
    return (type == 'object' || type == 'function');
}
exports.object = object;

},{}],94:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
/**
 * Creates a Set-like object (string keys, true values) from a list of keys
 */
function Set() {
    var keys = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        keys[_i] = arguments[_i];
    }
    var result = {};
    keys.forEach(function (key) { return result[key] = true; });
    return new lift_1.ObjectOps(result);
}
exports.Set = Set;

},{"../lift":92}],95:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
// The Option factory / static object
var OptionObject = function (value) {
    return isDef(value) ? Some(value) : exports.None;
};
OptionObject.all = function (arr) {
    var values = [];
    for (var i = 0; i < arr.length; i++) {
        var value = arr[i];
        if (exports.Option.isOption(value))
            value = value.get();
        if (!isDef(value))
            return exports.None;
        values.push(value);
    }
    return Some(values);
};
OptionObject.isOption = function (value) {
    return !!value && (value.type === 'some' || value.type === 'none');
};
function makeNone() {
    var self = {};
    function returnNone() { return exports.None; }
    self.type = 'none';
    self.get = function () { return undefined; };
    self.isDefined = function () { return false; };
    self.forEach = function () { };
    self.map = returnNone;
    self.flatMap = returnNone;
    self.filter = returnNone;
    self.fold = function (ifEmpty) { return ifEmpty(); };
    self.orElse = function (alt) { return alt(); };
    self.getOrElse = function (alt) { return alt; };
    self.toArray = function () { return lift_1["default"]([]); };
    self.toString = function () { return 'None'; };
    self.toJSON = function () { return null; };
    return self;
}
function _Some(value) {
    this.value = value;
}
_Some.prototype = {
    type: 'some',
    get: function () {
        return this.value;
    },
    isDefined: function () {
        return true;
    },
    forEach: function (fn) {
        fn(this.value);
    },
    map: function (fn) {
        return exports.Option(lift_1.getValue(fn(this.value)));
    },
    flatMap: function (fn) {
        return fn(this.value);
    },
    filter: function (fn) {
        return fn(this.value) ? this : exports.None;
    },
    fold: function (ifEmpty, ifDefined) {
        return ifDefined(this.value);
    },
    orElse: function () {
        return this;
    },
    getOrElse: function () {
        return this.value;
    },
    toArray: function () {
        return lift_1["default"]([this.value]);
    },
    toString: function () {
        return "Some(" + this.value + ")";
    },
    toJSON: function () {
        return this.value;
    }
};
function isDef(value) {
    return value !== null && value !== undefined;
}
exports.Option = OptionObject;
/** Creates a new Some instance using a non nullable value */
// extends {} to prevent null and undefined being passed
function Some(value) {
    return new _Some(value);
}
exports.Some = Some;
exports.None = makeNone();

},{"../lift":92}],96:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
var ResultObject = {};
ResultObject.all = function (arr) {
    var okValues = [];
    var currentResult;
    for (var i = 0; i < arr.length; i++) {
        var currentResult_1 = arr[i];
        if (!currentResult_1.isOk())
            return currentResult_1;
        okValues.push(currentResult_1.get());
    }
    return Ok(okValues);
};
ResultObject.isResult = function (value) {
    return !!value && (value.type === 'ok' || value.type === 'err');
};
function _Ok(value) {
    this._value = value;
}
_Ok.prototype = {
    type: 'ok',
    isOk: function () {
        return true;
    },
    map: function (fn) {
        return Ok(lift_1.getValue(fn(this._value)));
    },
    mapError: function (fn) {
        return this;
    },
    flatMap: function (fn) {
        return fn(this._value);
    },
    fold: function (ifErr, ifOk) {
        return ifOk(this._value);
    },
    toString: function () {
        return "Ok(" + this._value + ")";
    },
    get: function () {
        return this._value;
    }
};
function _Err(error) {
    this._error = error;
}
_Err.prototype = {
    type: 'err',
    isOk: function () {
        return false;
    },
    map: function (fn) {
        return this;
    },
    mapError: function (fn) {
        return Err(fn(this._error));
    },
    flatMap: function (fn) {
        return this;
    },
    fold: function (ifErr, ifOk) {
        return ifErr(this._error);
    },
    toString: function () {
        return "Err(" + this._error + ")";
    },
    get: function () {
        return this._error;
    }
};
exports.Result = ResultObject;
function Ok(value) {
    return new _Ok(value);
}
exports.Ok = Ok;
function Err(error) {
    return new _Err(error);
}
exports.Err = Err;

},{"../lift":92}]},{},[79])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImRpc3QvaW5kZXguanMiLCJkaXN0L2xpYi9iaW5vcHMvQXNzaWduT3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvQmluYXJ5T3BlcmF0aW9uLmpzIiwiZGlzdC9saWIvYmlub3BzL0RlY2xhcmVPcC5qcyIsImRpc3QvbGliL2Jpbm9wcy9EZWNyZW1lbnQuanMiLCJkaXN0L2xpYi9iaW5vcHMvRGl2T3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvSW5jcmVtZW50LmpzIiwiZGlzdC9saWIvYmlub3BzL01pbnVzT3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvTXVsT3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvUGx1c09wLmpzIiwiZGlzdC9saWIvY29uZGl0aW9uYWxzL0NvbmRpdGlvbmFsLmpzIiwiZGlzdC9saWIvZWZmZWN0cy9DdXJ2ZUVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvRWxsaXBzZUVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvRXBoRWZmZWN0LmpzIiwiZGlzdC9saWIvZWZmZWN0cy9MaW5lRWZmZWN0LmpzIiwiZGlzdC9saWIvZWZmZWN0cy9OdW1iZXJFZmZlY3QuanMiLCJkaXN0L2xpYi9lZmZlY3RzL1JlY3RhbmdsZUVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvU3RyaW5nRWZmZWN0LmpzIiwiZGlzdC9saWIvZnVuaG91c2UvRnVuQXBwLmpzIiwiZGlzdC9saWIvZnVuaG91c2UvRnVuRGVmLmpzIiwiZGlzdC9saWIvbGlzdHMvTGlzdE5vZGUuanMiLCJkaXN0L2xpYi9sb2dnaW5nL0NsZWFyRXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL0NsaWNrRXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL0RyYWdFdmVudC5qcyIsImRpc3QvbGliL2xvZ2dpbmcvSURFdmVudC5qcyIsImRpc3QvbGliL2xvZ2dpbmcvTG9nRXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL1BhaW50RXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL1Jlc2l6ZUV2ZW50LmpzIiwiZGlzdC9saWIvbG9nZ2luZy9TZWxlY3RFdmVudC5qcyIsImRpc3QvbGliL2xvZ2ljL0FuZC5qcyIsImRpc3QvbGliL2xvZ2ljL0VxdWFscy5qcyIsImRpc3QvbGliL2xvZ2ljL0dyZWF0ZXJUaGFuLmpzIiwiZGlzdC9saWIvbG9naWMvR3JlYXRlclRoYW5FcS5qcyIsImRpc3QvbGliL2xvZ2ljL0xlc3NUaGFuLmpzIiwiZGlzdC9saWIvbG9naWMvTGVzc1RoYW5FcS5qcyIsImRpc3QvbGliL2xvZ2ljL05vdC5qcyIsImRpc3QvbGliL2xvZ2ljL05vdEVxdWFsLmpzIiwiZGlzdC9saWIvbG9naWMvT3IuanMiLCJkaXN0L2xpYi9sb29wcy9Gb3JOb2RlLmpzIiwiZGlzdC9saWIvbG9vcHMvV2hpbGVOb2RlLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9JbnN0cnVjdGlvbi5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uRm91ckNwT25lLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Gb3VyQ3BUd28uanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3Nvbk9uZUNwRm91ci5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uT25lQ3BPbmUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3Nvbk9uZUNwVGhyZWUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3Nvbk9uZUNwVHdvLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25UaHJlZUNwRml2ZS5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcEZvdXIuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BPbmUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BTaXguanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BUaHJlZS5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFR3by5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVHdvQ3BGaXZlLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Ud29DcEZvdXIuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwT25lLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFNldmVuLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFNpeC5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVHdvQ3BUaHJlZS5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVHdvQ3BUd28uanMiLCJkaXN0L2xpYi9tb2R1bGVzL01vZHVsZUdlbmVyYXRvci5qcyIsImRpc3QvbGliL3BhcnNlci9wYXJzZXIuanMiLCJkaXN0L2xpYi9wcmltcy9Cb29sZWFuTm9kZS5qcyIsImRpc3QvbGliL3ByaW1zL05PUC5qcyIsImRpc3QvbGliL3ByaW1zL051bWJlck5vZGUuanMiLCJkaXN0L2xpYi9wcmltcy9TdHJpbmdOb2RlLmpzIiwiZGlzdC9saWIvc2hhcGVzL0NvbG9yTm9kZS5qcyIsImRpc3QvbGliL3NoYXBlcy9DdXJ2ZU5vZGUuanMiLCJkaXN0L2xpYi9zaGFwZXMvRWxsaXBzZU5vZGUuanMiLCJkaXN0L2xpYi9zaGFwZXMvRXBoTm9kZS5qcyIsImRpc3QvbGliL3NoYXBlcy9MaW5lTm9kZS5qcyIsImRpc3QvbGliL3NoYXBlcy9SZWN0YW5nbGVOb2RlLmpzIiwiZGlzdC9saWIvc3RydWN0dXJhbC9EaW1lbnNpb25zLmpzIiwiZGlzdC9saWIvc3RydWN0dXJhbC9QcmludE5vZGUuanMiLCJkaXN0L2xpYi9zdHJ1Y3R1cmFsL1JldHVybi5qcyIsImRpc3QvbGliL3N0cnVjdHVyYWwvUmV0dXJuRXJyb3IuanMiLCJkaXN0L2xpYi9zdHJ1Y3R1cmFsL1Njb3BlLmpzIiwiZGlzdC9saWIvc3RydWN0dXJhbC9TZXF1ZW5jZU5vZGUuanMiLCJkaXN0L2xpYi91aS91aS5qcyIsImRpc3QvbGliL3Vub3BzL05lZ09wLmpzIiwiZGlzdC9saWIvdW5vcHMvVW5hcnlPcGVyYXRpb24uanMiLCJkaXN0L2xpYi92YXJzL1ZhcmlhYmxlTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9pbW11cGRhdGUvY29tbW9uanMvaW1tdXBkYXRlLmpzIiwibm9kZV9tb2R1bGVzL3BhbnRzL2xpYi9jaGFyc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3BhbnRzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYW50cy9saWIvcHJpbWl0aXZlcy5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL2FycmF5L2Zyb21BcnJheUxpa2UuanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9hcnJheS9yYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL2FycmF5L3R1cGxlLmpzIiwibm9kZV9tb2R1bGVzL3NwYWNlLWxpZnQvY29tbW9uanMvZnVuY3Rpb24vbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NwYWNlLWxpZnQvY29tbW9uanMvbGlmdC5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL29iamVjdC9pcy5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL29iamVjdC9zZXQuanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9vcHRpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9yZXN1bHQvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3J3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2h2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9qQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNydkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9hQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTY29wZV8xID0gcmVxdWlyZShcIi4vbGliL3N0cnVjdHVyYWwvU2NvcGVcIik7XG5leHBvcnRzLlNjb3BlID0gU2NvcGVfMS5TY29wZTtcbi8qIEJJTkFSWSBPUFMgKi9cbnZhciBBc3NpZ25PcF8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9Bc3NpZ25PcFwiKTtcbmV4cG9ydHMuQXNzaWduT3AgPSBBc3NpZ25PcF8xLkFzc2lnbk9wO1xudmFyIEJpbmFyeU9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9CaW5hcnlPcGVyYXRpb25cIik7XG5leHBvcnRzLkJpbmFyeU9wZXJhdGlvbiA9IEJpbmFyeU9wZXJhdGlvbl8xLkJpbmFyeU9wZXJhdGlvbjtcbnZhciBEaXZPcF8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9EaXZPcFwiKTtcbmV4cG9ydHMuRGl2T3AgPSBEaXZPcF8xLkRpdk9wO1xudmFyIE1pbnVzT3BfMSA9IHJlcXVpcmUoXCIuL2xpYi9iaW5vcHMvTWludXNPcFwiKTtcbmV4cG9ydHMuTWludXNPcCA9IE1pbnVzT3BfMS5NaW51c09wO1xudmFyIE11bE9wXzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL011bE9wXCIpO1xuZXhwb3J0cy5NdWxPcCA9IE11bE9wXzEuTXVsT3A7XG52YXIgUGx1c09wXzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL1BsdXNPcFwiKTtcbmV4cG9ydHMuUGx1c09wID0gUGx1c09wXzEuUGx1c09wO1xudmFyIEdyZWF0ZXJUaGFuXzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvR3JlYXRlclRoYW5cIik7XG5leHBvcnRzLkdyZWF0ZXJUaGFuID0gR3JlYXRlclRoYW5fMS5HcmVhdGVyVGhhbjtcbnZhciBHcmVhdGVyVGhhbkVxXzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvR3JlYXRlclRoYW5FcVwiKTtcbmV4cG9ydHMuR3JlYXRlclRoYW5FcSA9IEdyZWF0ZXJUaGFuRXFfMS5HcmVhdGVyVGhhbkVxO1xudmFyIExlc3NUaGFuXzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvTGVzc1RoYW5cIik7XG5leHBvcnRzLkxlc3NUaGFuID0gTGVzc1RoYW5fMS5MZXNzVGhhbjtcbnZhciBMZXNzVGhhbkVxXzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvTGVzc1RoYW5FcVwiKTtcbmV4cG9ydHMuTGVzc1RoYW5FcSA9IExlc3NUaGFuRXFfMS5MZXNzVGhhbkVxO1xudmFyIERlY2xhcmVPcF8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9EZWNsYXJlT3BcIik7XG5leHBvcnRzLkRlY2xhcmVPcCA9IERlY2xhcmVPcF8xLkRlY2xhcmVPcDtcbnZhciBBbmRfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9BbmRcIik7XG5leHBvcnRzLkFuZCA9IEFuZF8xLkFuZDtcbnZhciBPcl8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2ljL09yXCIpO1xuZXhwb3J0cy5PciA9IE9yXzEuT3I7XG52YXIgRXF1YWxzXzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvRXF1YWxzXCIpO1xuZXhwb3J0cy5FcXVhbHMgPSBFcXVhbHNfMS5FcXVhbHM7XG52YXIgTm90RXF1YWxfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9Ob3RFcXVhbFwiKTtcbmV4cG9ydHMuTm90RXF1YWwgPSBOb3RFcXVhbF8xLk5vdEVxdWFsO1xudmFyIEluY3JlbWVudF8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9JbmNyZW1lbnRcIik7XG5leHBvcnRzLkluY3JlbWVudCA9IEluY3JlbWVudF8xLkluY3JlbWVudDtcbnZhciBEZWNyZW1lbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9iaW5vcHMvRGVjcmVtZW50XCIpO1xuZXhwb3J0cy5EZWNyZW1lbnQgPSBEZWNyZW1lbnRfMS5EZWNyZW1lbnQ7XG4vKiBVTkFSWSBPUFMgKi9cbnZhciBVbmFyeU9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vbGliL3Vub3BzL1VuYXJ5T3BlcmF0aW9uXCIpO1xuZXhwb3J0cy5VbmFyeU9wZXJhdGlvbiA9IFVuYXJ5T3BlcmF0aW9uXzEuVW5hcnlPcGVyYXRpb247XG52YXIgTmVnT3BfMSA9IHJlcXVpcmUoXCIuL2xpYi91bm9wcy9OZWdPcFwiKTtcbmV4cG9ydHMuTmVnT3AgPSBOZWdPcF8xLk5lZ09wO1xudmFyIE5vdF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2ljL05vdFwiKTtcbmV4cG9ydHMuTm90ID0gTm90XzEuTm90O1xuLyogREFUQSBUWVBFUyAqL1xudmFyIExpc3ROb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvbGlzdHMvTGlzdE5vZGVcIik7XG5leHBvcnRzLkxpc3ROb2RlID0gTGlzdE5vZGVfMS5MaXN0Tm9kZTtcbnZhciBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmV4cG9ydHMuTnVtYmVyTm9kZSA9IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlO1xudmFyIFN0cmluZ05vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9wcmltcy9TdHJpbmdOb2RlXCIpO1xuZXhwb3J0cy5TdHJpbmdOb2RlID0gU3RyaW5nTm9kZV8xLlN0cmluZ05vZGU7XG52YXIgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmV4cG9ydHMuQm9vbGVhbk5vZGUgPSBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlO1xudmFyIE5PUF8xID0gcmVxdWlyZShcIi4vbGliL3ByaW1zL05PUFwiKTtcbmV4cG9ydHMuTk9QID0gTk9QXzEuTk9QO1xuLyogVkFSSUFCTEVTICovXG52YXIgVmFyaWFibGVOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvdmFycy9WYXJpYWJsZU5vZGVcIik7XG5leHBvcnRzLlZhcmlhYmxlTm9kZSA9IFZhcmlhYmxlTm9kZV8xLlZhcmlhYmxlTm9kZTtcbi8qIENPTlRST0wgQ09OU1RSVUNUUyAqL1xudmFyIENvbmRpdGlvbmFsXzEgPSByZXF1aXJlKFwiLi9saWIvY29uZGl0aW9uYWxzL0NvbmRpdGlvbmFsXCIpO1xuZXhwb3J0cy5Db25kaXRpb25hbCA9IENvbmRpdGlvbmFsXzEuQ29uZGl0aW9uYWw7XG52YXIgRnVuQXBwXzEgPSByZXF1aXJlKFwiLi9saWIvZnVuaG91c2UvRnVuQXBwXCIpO1xuZXhwb3J0cy5GdW5BcHAgPSBGdW5BcHBfMS5GdW5BcHA7XG52YXIgRnVuRGVmXzEgPSByZXF1aXJlKFwiLi9saWIvZnVuaG91c2UvRnVuRGVmXCIpO1xuZXhwb3J0cy5GdW5EZWYgPSBGdW5EZWZfMS5GdW5EZWY7XG52YXIgU2VxdWVuY2VOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvc3RydWN0dXJhbC9TZXF1ZW5jZU5vZGVcIik7XG5leHBvcnRzLlNlcXVlbmNlTm9kZSA9IFNlcXVlbmNlTm9kZV8xLlNlcXVlbmNlTm9kZTtcbnZhciBXaGlsZU5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb29wcy9XaGlsZU5vZGVcIik7XG5leHBvcnRzLldoaWxlTm9kZSA9IFdoaWxlTm9kZV8xLldoaWxlTm9kZTtcbnZhciBGb3JOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvbG9vcHMvRm9yTm9kZVwiKTtcbmV4cG9ydHMuRm9yTm9kZSA9IEZvck5vZGVfMS5Gb3JOb2RlO1xuLyogQlVJTFRJTiBGVU5DVElPTlMgKi9cbnZhciBDb2xvck5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zaGFwZXMvQ29sb3JOb2RlXCIpO1xuZXhwb3J0cy5Db2xvck5vZGUgPSBDb2xvck5vZGVfMS5Db2xvck5vZGU7XG52YXIgRWxsaXBzZU5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zaGFwZXMvRWxsaXBzZU5vZGVcIik7XG5leHBvcnRzLkVsbGlwc2VOb2RlID0gRWxsaXBzZU5vZGVfMS5FbGxpcHNlTm9kZTtcbnZhciBSZWN0YW5nbGVOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvc2hhcGVzL1JlY3RhbmdsZU5vZGVcIik7XG5leHBvcnRzLlJlY3RhbmdsZU5vZGUgPSBSZWN0YW5nbGVOb2RlXzEuUmVjdGFuZ2xlTm9kZTtcbnZhciBMaW5lTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3NoYXBlcy9MaW5lTm9kZVwiKTtcbmV4cG9ydHMuTGluZU5vZGUgPSBMaW5lTm9kZV8xLkxpbmVOb2RlO1xudmFyIEN1cnZlTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3NoYXBlcy9DdXJ2ZU5vZGVcIik7XG5leHBvcnRzLkN1cnZlTm9kZSA9IEN1cnZlTm9kZV8xLkN1cnZlTm9kZTtcbnZhciBFcGhOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvc2hhcGVzL0VwaE5vZGVcIik7XG5leHBvcnRzLkVwaE5vZGUgPSBFcGhOb2RlXzEuRXBoTm9kZTtcbnZhciBQcmludE5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zdHJ1Y3R1cmFsL1ByaW50Tm9kZVwiKTtcbmV4cG9ydHMuUHJpbnROb2RlID0gUHJpbnROb2RlXzEuUHJpbnROb2RlO1xudmFyIFJldHVybl8xID0gcmVxdWlyZShcIi4vbGliL3N0cnVjdHVyYWwvUmV0dXJuXCIpO1xuZXhwb3J0cy5SZXR1cm4gPSBSZXR1cm5fMS5SZXR1cm47XG52YXIgUmV0dXJuRXJyb3JfMSA9IHJlcXVpcmUoXCIuL2xpYi9zdHJ1Y3R1cmFsL1JldHVybkVycm9yXCIpO1xuZXhwb3J0cy5SZXR1cm5FcnJvciA9IFJldHVybkVycm9yXzEuUmV0dXJuRXJyb3I7XG52YXIgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4vbGliL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmV4cG9ydHMuRWxsaXBzZUVmZmVjdCA9IEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0O1xudmFyIE51bWJlckVmZmVjdF8xID0gcmVxdWlyZShcIi4vbGliL2VmZmVjdHMvTnVtYmVyRWZmZWN0XCIpO1xuZXhwb3J0cy5OdW1iZXJFZmZlY3QgPSBOdW1iZXJFZmZlY3RfMS5OdW1iZXJFZmZlY3Q7XG52YXIgU3RyaW5nRWZmZWN0XzEgPSByZXF1aXJlKFwiLi9saWIvZWZmZWN0cy9TdHJpbmdFZmZlY3RcIik7XG5leHBvcnRzLlN0cmluZ0VmZmVjdCA9IFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdDtcbnZhciBEaW1lbnNpb25zXzEgPSByZXF1aXJlKFwiLi9saWIvc3RydWN0dXJhbC9EaW1lbnNpb25zXCIpO1xuZXhwb3J0cy5EaW1lbnNpb25zID0gRGltZW5zaW9uc18xLkRpbWVuc2lvbnM7XG52YXIgUmVjdGFuZ2xlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi9saWIvZWZmZWN0cy9SZWN0YW5nbGVFZmZlY3RcIik7XG5leHBvcnRzLlJlY3RhbmdsZUVmZmVjdCA9IFJlY3RhbmdsZUVmZmVjdF8xLlJlY3RhbmdsZUVmZmVjdDtcbnZhciBMaW5lRWZmZWN0XzEgPSByZXF1aXJlKFwiLi9saWIvZWZmZWN0cy9MaW5lRWZmZWN0XCIpO1xuZXhwb3J0cy5MaW5lRWZmZWN0ID0gTGluZUVmZmVjdF8xLkxpbmVFZmZlY3Q7XG52YXIgQ3VydmVFZmZlY3RfMSA9IHJlcXVpcmUoXCIuL2xpYi9lZmZlY3RzL0N1cnZlRWZmZWN0XCIpO1xuZXhwb3J0cy5DdXJ2ZUVmZmVjdCA9IEN1cnZlRWZmZWN0XzEuQ3VydmVFZmZlY3Q7XG52YXIgRXBoRWZmZWN0XzEgPSByZXF1aXJlKFwiLi9saWIvZWZmZWN0cy9FcGhFZmZlY3RcIik7XG5leHBvcnRzLkVwaEVmZmVjdCA9IEVwaEVmZmVjdF8xLkVwaEVmZmVjdDtcbi8qIEVWRU5UUyAqL1xudmFyIExvZ0V2ZW50XzEgPSByZXF1aXJlKFwiLi9saWIvbG9nZ2luZy9Mb2dFdmVudFwiKTtcbmV4cG9ydHMuTG9nRXZlbnQgPSBMb2dFdmVudF8xLkxvZ0V2ZW50O1xudmFyIENsZWFyRXZlbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dnaW5nL0NsZWFyRXZlbnRcIik7XG5leHBvcnRzLkNsZWFyRXZlbnQgPSBDbGVhckV2ZW50XzEuQ2xlYXJFdmVudDtcbnZhciBEcmFnRXZlbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dnaW5nL0RyYWdFdmVudFwiKTtcbmV4cG9ydHMuRHJhZ0V2ZW50ID0gRHJhZ0V2ZW50XzEuRHJhZ0V2ZW50O1xudmFyIFBhaW50RXZlbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dnaW5nL1BhaW50RXZlbnRcIik7XG5leHBvcnRzLlBhaW50RXZlbnQgPSBQYWludEV2ZW50XzEuUGFpbnRFdmVudDtcbnZhciBSZXNpemVFdmVudF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2dpbmcvUmVzaXplRXZlbnRcIik7XG5leHBvcnRzLlJlc2l6ZUV2ZW50ID0gUmVzaXplRXZlbnRfMS5SZXNpemVFdmVudDtcbnZhciBTZWxlY3RFdmVudF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2dpbmcvU2VsZWN0RXZlbnRcIik7XG5leHBvcnRzLlNlbGVjdEV2ZW50ID0gU2VsZWN0RXZlbnRfMS5TZWxlY3RFdmVudDtcbnZhciBJREV2ZW50XzEgPSByZXF1aXJlKFwiLi9saWIvbG9nZ2luZy9JREV2ZW50XCIpO1xuZXhwb3J0cy5JREV2ZW50ID0gSURFdmVudF8xLklERXZlbnQ7XG52YXIgTW9kdWxlR2VuZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9Nb2R1bGVHZW5lcmF0b3JcIik7XG5leHBvcnRzLk1vZHVsZUdlbmVyYXRvciA9IE1vZHVsZUdlbmVyYXRvcl8xLk1vZHVsZUdlbmVyYXRvcjtcbnZhciBMZXNzb25PbmVDcE9uZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uT25lQ3BPbmVcIik7XG5leHBvcnRzLkxlc3Nvbk9uZUNwT25lID0gTGVzc29uT25lQ3BPbmVfMS5MZXNzb25PbmVDcE9uZTtcbnZhciBMZXNzb25PbmVDcFR3b18xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uT25lQ3BUd29cIik7XG5leHBvcnRzLkxlc3Nvbk9uZUNwVHdvID0gTGVzc29uT25lQ3BUd29fMS5MZXNzb25PbmVDcFR3bztcbnZhciBMZXNzb25PbmVDcFRocmVlXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25PbmVDcFRocmVlXCIpO1xuZXhwb3J0cy5MZXNzb25PbmVDcFRocmVlID0gTGVzc29uT25lQ3BUaHJlZV8xLkxlc3Nvbk9uZUNwVGhyZWU7XG52YXIgTGVzc29uT25lQ3BGb3VyXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25PbmVDcEZvdXJcIik7XG5leHBvcnRzLkxlc3Nvbk9uZUNwRm91ciA9IExlc3Nvbk9uZUNwRm91cl8xLkxlc3Nvbk9uZUNwRm91cjtcbnZhciBMZXNzb25Ud29DcE9uZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVHdvQ3BPbmVcIik7XG5leHBvcnRzLkxlc3NvblR3b0NwT25lID0gTGVzc29uVHdvQ3BPbmVfMS5MZXNzb25Ud29DcE9uZTtcbnZhciBMZXNzb25Ud29DcFR3b18xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVHdvQ3BUd29cIik7XG5leHBvcnRzLkxlc3NvblR3b0NwVHdvID0gTGVzc29uVHdvQ3BUd29fMS5MZXNzb25Ud29DcFR3bztcbnZhciBMZXNzb25Ud29DcFRocmVlXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFRocmVlXCIpO1xuZXhwb3J0cy5MZXNzb25Ud29DcFRocmVlID0gTGVzc29uVHdvQ3BUaHJlZV8xLkxlc3NvblR3b0NwVGhyZWU7XG52YXIgTGVzc29uVHdvQ3BGb3VyXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Ud29DcEZvdXJcIik7XG5leHBvcnRzLkxlc3NvblR3b0NwRm91ciA9IExlc3NvblR3b0NwRm91cl8xLkxlc3NvblR3b0NwRm91cjtcbnZhciBMZXNzb25Ud29DcEZpdmVfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwRml2ZVwiKTtcbmV4cG9ydHMuTGVzc29uVHdvQ3BGaXZlID0gTGVzc29uVHdvQ3BGaXZlXzEuTGVzc29uVHdvQ3BGaXZlO1xudmFyIExlc3NvblR3b0NwU2l4XzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFNpeFwiKTtcbmV4cG9ydHMuTGVzc29uVHdvQ3BTaXggPSBMZXNzb25Ud29DcFNpeF8xLkxlc3NvblR3b0NwU2l4O1xudmFyIExlc3NvblR3b0NwU2V2ZW5fMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwU2V2ZW5cIik7XG5leHBvcnRzLkxlc3NvblR3b0NwU2V2ZW4gPSBMZXNzb25Ud29DcFNldmVuXzEuTGVzc29uVHdvQ3BTZXZlbjtcbnZhciBMZXNzb25UaHJlZUNwT25lXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25UaHJlZUNwT25lXCIpO1xuZXhwb3J0cy5MZXNzb25UaHJlZUNwT25lID0gTGVzc29uVGhyZWVDcE9uZV8xLkxlc3NvblRocmVlQ3BPbmU7XG52YXIgTGVzc29uVGhyZWVDcFR3b18xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFR3b1wiKTtcbmV4cG9ydHMuTGVzc29uVGhyZWVDcFR3byA9IExlc3NvblRocmVlQ3BUd29fMS5MZXNzb25UaHJlZUNwVHdvO1xudmFyIExlc3NvblRocmVlQ3BUaHJlZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFRocmVlXCIpO1xuZXhwb3J0cy5MZXNzb25UaHJlZUNwVGhyZWUgPSBMZXNzb25UaHJlZUNwVGhyZWVfMS5MZXNzb25UaHJlZUNwVGhyZWU7XG52YXIgTGVzc29uVGhyZWVDcEZvdXJfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BGb3VyXCIpO1xuZXhwb3J0cy5MZXNzb25UaHJlZUNwRm91ciA9IExlc3NvblRocmVlQ3BGb3VyXzEuTGVzc29uVGhyZWVDcEZvdXI7XG52YXIgTGVzc29uVGhyZWVDcEZpdmVfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BGaXZlXCIpO1xuZXhwb3J0cy5MZXNzb25UaHJlZUNwRml2ZSA9IExlc3NvblRocmVlQ3BGaXZlXzEuTGVzc29uVGhyZWVDcEZpdmU7XG52YXIgTGVzc29uVGhyZWVDcFNpeF8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFNpeFwiKTtcbmV4cG9ydHMuTGVzc29uVGhyZWVDcFNpeCA9IExlc3NvblRocmVlQ3BTaXhfMS5MZXNzb25UaHJlZUNwU2l4O1xudmFyIExlc3NvbkZvdXJDcE9uZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uRm91ckNwT25lXCIpO1xuZXhwb3J0cy5MZXNzb25Gb3VyQ3BPbmUgPSBMZXNzb25Gb3VyQ3BPbmVfMS5MZXNzb25Gb3VyQ3BPbmU7XG52YXIgTGVzc29uRm91ckNwVHdvXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Gb3VyQ3BUd29cIik7XG5leHBvcnRzLkxlc3NvbkZvdXJDcFR3byA9IExlc3NvbkZvdXJDcFR3b18xLkxlc3NvbkZvdXJDcFR3bztcbi8qIFBBUlNFUiAqL1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4vbGliL3BhcnNlci9wYXJzZXJcIik7XG5leHBvcnRzLlBhcnNlciA9IHBhcnNlcl8xLlBhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmluYXJ5T3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9CaW5hcnlPcGVyYXRpb25cIik7XG5jb25zdCBWYXJpYWJsZU5vZGVfMSA9IHJlcXVpcmUoXCIuLi92YXJzL1ZhcmlhYmxlTm9kZVwiKTtcbi8vIGxlZnQgc2lkZSBpcyB2YXJpYWJsZSwgcmlnaHQgc2lkZSBpcyB2YWxcbi8vIFJlYXNzaWduIG5ldyB2YWx1ZSB0byB2YXJcbmNsYXNzIEFzc2lnbk9wIGV4dGVuZHMgQmluYXJ5T3BlcmF0aW9uXzEuQmluYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYW4gYXNzaWdubWVudCBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbGVmdCBzaWRlIG9mIHRoZSBhc3NpZ25tZW50ICh0aGUgdmFyKVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgYXNzaWdubWVudCAodGhlIHZhbHVlKVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICBzdXBlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmICghKGxlZnQgaW5zdGFuY2VvZiBWYXJpYWJsZU5vZGVfMS5WYXJpYWJsZU5vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGFzc2lnbm1lbnQgbXVzdCBiZSBhIHZhcmlhYmxlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIGFzc2lnbiBvcCBieSBhc3NpZ25pbmcgdmFsdWUgdG8gdmFyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0IGluc3RhbmNlb2YgVmFyaWFibGVOb2RlXzEuVmFyaWFibGVOb2RlKSB7XG4gICAgICAgICAgICBsZXQgciA9IHRoaXMucmlnaHQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnRleHQuYXNzaWduKHRoaXMubGVmdC5uYW1lLCByKTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhBTFAgKGluIEFzc2lnbk9wKVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQXNzaWduT3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5sZWZ0LnRvU3RyaW5nKCkgKyAnID0gJyArIHRoaXMucmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzaWduT3BzIGNhbid0IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW4ndCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gQXNzaWduT3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGJpbmFyeSBvcGVyYXRpb25zXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzaWduT3AgPSBBc3NpZ25PcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzc2lnbk9wLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQmluYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIEJpbk9wIGFic3RyYWN0IGNsYXNzXG4gICAgICogQHBhcmFtIF9sZWZ0IFRoZSBsZWZ0IHNpZGUgb2YgdGhlIGJpbmFyeSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gX3JpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBiaW5hcnkgb3BlcmF0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX2xlZnQsIF9yaWdodCkge1xuICAgICAgICB0aGlzLl9sZWZ0ID0gX2xlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gX3JpZ2h0O1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYmluYXJ5IG9wZXJhdGlvbiwgaWYgYXBwbGljYWJsZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIGFzdCBUaGUgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHsgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBlcXVhbCB0byBhbm90aGVyIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBCaW5PcFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmluYXJ5IG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gXCJcIjsgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZXRzIGxlZnQgc2lkZSBvZiB0aGUgYmluYXJ5IG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBsZWZ0IHNpZGUgb2YgdGhlIGJpbmFyeSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBzZXQgbGVmdChsZWZ0KSB7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHJpZ2h0IHNpZGUgb2YgdGhlIGJpbmFyeSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyByaWdodCBzaWRlIG9mIHRoZSBiaW5hcnkgb3BlcmF0aW9uXG4gICAgICovXG4gICAgc2V0IHJpZ2h0KHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkJpbmFyeU9wZXJhdGlvbiA9IEJpbmFyeU9wZXJhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpbmFyeU9wZXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJpbmFyeU9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vQmluYXJ5T3BlcmF0aW9uXCIpO1xuY29uc3QgVmFyaWFibGVOb2RlXzEgPSByZXF1aXJlKFwiLi4vdmFycy9WYXJpYWJsZU5vZGVcIik7XG4vLyBsZWZ0IHNpZGUgaXMgdmFyaWFibGUsIHJpZ2h0IHNpZGUgaXMgdmFsXG4vLyBEZWNsYXJlcyBuZXcgdmFsXG5jbGFzcyBEZWNsYXJlT3AgZXh0ZW5kcyBCaW5hcnlPcGVyYXRpb25fMS5CaW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgZGVjbGFyZSBvcGVyYXRpb24sIHdoaWNoIGRlY2xhcmVzIGEgdmFyaWFibGUgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgc2lkZSBvZiB0aGUgZGVjbGFyZSBvcCAodGhlIHZhcmlhYmxlKVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgb3AgKHRoZSB2YWx1ZSlcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgc3VwZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoIShsZWZ0IGluc3RhbmNlb2YgVmFyaWFibGVOb2RlXzEuVmFyaWFibGVOb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxlZnQgaGFuZCBzaWRlIG9mIHRoZSBhc3NpZ25tZW50IG11c3QgYmUgYSB2YXJpYWJsZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyB0aGUgZGVjbGFyYXRpb24gYnkgZGVjbGFyaW5nIHRoZSB2YXJpYWJsZSBpbiB0aGUgY29udGV4dCBhbmQgYXNzaWduaW5nIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0IGluc3RhbmNlb2YgVmFyaWFibGVOb2RlXzEuVmFyaWFibGVOb2RlKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlY2xhcmUodGhpcy5sZWZ0Lm5hbWUpO1xuICAgICAgICAgICAgbGV0IHIgPSB0aGlzLnJpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgICAgICBjb250ZXh0LmFzc2lnbih0aGlzLmxlZnQubmFtZSwgcik7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIQUxQIChpbiBEZWNsYXJlT3ApXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkZWNsYXJlIG9wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwidmFyIFwiICsgdGhpcy5sZWZ0LnRvU3RyaW5nKCkgKyAnID0gJyArIHRoaXMucmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjbGFyZU9wcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbid0IGJlIGNhbGxlZCBkaXJlY2x5IG9uIGEgRGVjbGFyZU9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBiaW5hcnkgb3BlcmF0aW9uc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLkRlY2xhcmVPcCA9IERlY2xhcmVPcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlY2xhcmVPcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgTWludXNPcF8xID0gcmVxdWlyZShcIi4vTWludXNPcFwiKTtcbmNvbnN0IEFzc2lnbk9wXzEgPSByZXF1aXJlKFwiLi9Bc3NpZ25PcFwiKTtcbmNvbnN0IFZhcmlhYmxlTm9kZV8xID0gcmVxdWlyZShcIi4uL3ZhcnMvVmFyaWFibGVOb2RlXCIpO1xuY2xhc3MgRGVjcmVtZW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIGRlY3JlbWVudCBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gdmFyaWFibGUgVGhlIGV4cHJlc3Npb24gdG8gYmUgZGVjcmVtZW50ZWRcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2YXJpYWJsZSwgd3MpIHtcbiAgICAgICAgdGhpcy5leHByID0gdmFyaWFibGU7XG4gICAgICAgIGlmICh2YXJpYWJsZSBpbnN0YW5jZW9mIFZhcmlhYmxlTm9kZV8xLlZhcmlhYmxlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5pbm5lclJlcCA9IG5ldyBBc3NpZ25PcF8xLkFzc2lnbk9wKHZhcmlhYmxlLCBuZXcgTWludXNPcF8xLk1pbnVzT3AodmFyaWFibGUsIG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbm5lclJlcCA9IG5ldyBNaW51c09wXzEuTWludXNPcCh2YXJpYWJsZSwgbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBkZWNyZW1lbnQgb3AgdG8gYSBOdW1iZXJOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlubmVyUmVwLmV2YWwoY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRlY3JlbWVudCBvcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLmV4cHIudG9TdHJpbmcoKSArIFwiLS1cIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjcmVtZW50IG9wcyBjYW4ndCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2FuJ3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGRlY3JlbWVudFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5EZWNyZW1lbnQgPSBEZWNyZW1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWNyZW1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCaW5hcnlPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL0JpbmFyeU9wZXJhdGlvblwiKTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgRGl2T3AgZXh0ZW5kcyBCaW5hcnlPcGVyYXRpb25fMS5CaW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgZGl2aXNpb24gb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGRpdmlkZW5kXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSBkaXZpc29yXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHN1cGVyKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBkaXZpc2lvbiBhbmQgZXZhbHVhdGVzIGludG8gYSBzaW5nbGUgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMubGVmdC5ldmFsKG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpKS5ldmFsKGNvbnRleHQpLnZhbCAvIHRoaXMucmlnaHQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXZpc2lvbiBvcHMgY2FuJ3QgYmUgZGlyZWN0bHkgZHJhd25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbid0IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhIGRpdmlzaW9uIG9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBiaW5hcnkgb3BlcmF0aW9uc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGl2aXNpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5sZWZ0LnRvU3RyaW5nKCkgKyAnIC8gJyArIHRoaXMucmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLkRpdk9wID0gRGl2T3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaXZPcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgUGx1c09wXzEgPSByZXF1aXJlKFwiLi9QbHVzT3BcIik7XG5jb25zdCBBc3NpZ25PcF8xID0gcmVxdWlyZShcIi4vQXNzaWduT3BcIik7XG5jb25zdCBWYXJpYWJsZU5vZGVfMSA9IHJlcXVpcmUoXCIuLi92YXJzL1ZhcmlhYmxlTm9kZVwiKTtcbmNsYXNzIEluY3JlbWVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIEluY3JlbWVudFxuICAgICAqIEBwYXJhbSB2YXJpYWJsZSBUaGUgZXhwcmVzc2lvbiB0byBpbmNyZW1lbnRcbiAgICAgKiBAcGFyYW0gd3MgVHJhY2tzIHByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFyaWFibGUsIHdzKSB7XG4gICAgICAgIHRoaXMuZXhwciA9IHZhcmlhYmxlO1xuICAgICAgICBpZiAodmFyaWFibGUgaW5zdGFuY2VvZiBWYXJpYWJsZU5vZGVfMS5WYXJpYWJsZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJSZXAgPSBuZXcgQXNzaWduT3BfMS5Bc3NpZ25PcCh2YXJpYWJsZSwgbmV3IFBsdXNPcF8xLlBsdXNPcCh2YXJpYWJsZSwgbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyUmVwID0gbmV3IFBsdXNPcF8xLlBsdXNPcCh2YXJpYWJsZSwgbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEsIFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIGluY3JlbWVudCBpbnRvIGEgbnVtYmVyIG5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgZnVuY3Rpb24gc2NvcGVcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXJSZXAuZXZhbChjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5jcmVtZW50cyBjYW5ub3QgYmUgZHJhd25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGJpbm9wc1xuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluY3JlbWVudCBleHByZXNzaW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuZXhwci50b1N0cmluZygpICsgXCIrK1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5jcmVtZW50ID0gSW5jcmVtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5jcmVtZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmluYXJ5T3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9CaW5hcnlPcGVyYXRpb25cIik7XG5jb25zdCBTY29wZV8xID0gcmVxdWlyZShcIi4uL3N0cnVjdHVyYWwvU2NvcGVcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIE1pbnVzT3AgZXh0ZW5kcyBCaW5hcnlPcGVyYXRpb25fMS5CaW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHN1YnRyYWN0aW9uIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBtaW51ZW5kXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSBzdWJyYWhlbmRcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgc3VwZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIHN1YnRyYWN0aW9uIGFuZCBldmFsdWF0ZXMgdG8gYSBzaW5nbGUgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMubGVmdC5ldmFsKG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpKS5ldmFsKGNvbnRleHQpLnZhbCAtIHRoaXMucmlnaHQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdGlvbiBvcHMgY2FuJ3QgYmUgZGlyZWN0bHkgZHJhd25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbid0IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBzdWJ0cmFjdGlvblxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHN1YnRyYWN0aW9uIG9wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMubGVmdC50b1N0cmluZygpICsgJyAtICcgKyB0aGlzLnJpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5NaW51c09wID0gTWludXNPcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1pbnVzT3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCaW5hcnlPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL0JpbmFyeU9wZXJhdGlvblwiKTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgTXVsT3AgZXh0ZW5kcyBCaW5hcnlPcGVyYXRpb25fMS5CaW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgbXVsdGlwbGljYXRpb24gb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIG11bHRpcGxpY2FuZFxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgbXVsdGlwbGllclxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICBzdXBlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgbXVsdGlwbGljYXRpb24gYW5kIHJldHVybnMgYSBzaW5nbGUgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMubGVmdC5ldmFsKG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpKS5ldmFsKGNvbnRleHQpLnZhbCAqIHRoaXMucmlnaHQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtdWx0aXBsaWNhdGlvbiBvcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLmxlZnQudG9TdHJpbmcoKSArICcgKiAnICsgdGhpcy5yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWNhdGlvbiBvcHMgY2Fubm90IGJlIGRpcmVjdGx5IGRyYXduXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgbXVsdGlwbGljYWl0b24gb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBiaW5hcnkgb3BlcmF0aW9uc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLk11bE9wID0gTXVsT3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NdWxPcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJpbmFyeU9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vQmluYXJ5T3BlcmF0aW9uXCIpO1xuY29uc3QgU2NvcGVfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3R1cmFsL1Njb3BlXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG4vLyBsZWZ0IGFuZCByaWdodCBhcmUgYm90aCBleHByZXNzaW9uc1xuY2xhc3MgUGx1c09wIGV4dGVuZHMgQmluYXJ5T3BlcmF0aW9uXzEuQmluYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIGFkZGl0aW9uIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBmaXJzdCBhZGRlbmRcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHNlY29uZCBhZGRlbmRcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgc3VwZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIGFkZGl0aW9uIGFuZCByZXR1cm5zIGEgc2luZ2xlIE51bWJlck5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLmxlZnQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwgKyB0aGlzLnJpZ2h0LmV2YWwobmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCkpLmV2YWwoY29udGV4dCkudmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkaXRpb24gb3BzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhbiBhZGRpdGlvbiBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGFkZGl0aW9uIG9wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMubGVmdC50b1N0cmluZygpICsgJyArICcgKyB0aGlzLnJpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5QbHVzT3AgPSBQbHVzT3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QbHVzT3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTY29wZV8xID0gcmVxdWlyZShcIi4uL3N0cnVjdHVyYWwvU2NvcGVcIik7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY29uc3Qgc3BhY2VfbGlmdF8xID0gcmVxdWlyZShcInNwYWNlLWxpZnRcIik7XG5jbGFzcyBDb25kaXRpb25hbCB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBjb25kaXRpb25hbHMgKGlmLCBlbHNlIGlmLCBhbmQgZWxzZSBzdGF0ZW1lbnRzKVxuICAgICAqIEBwYXJhbSB0ZXN0IFRoZSBjb25kaXRpb24gb2YgdGhlIHN0YXRlbWVudFxuICAgICAqIEBwYXJhbSB0cnVlQnJhbmNoIFRoZSBicmFuY2ggdG8gZm9sbG93IGlmIHRoZSBjb25kaXRpb24gZXZhbHVhdGVzIHRvIHRydWVcbiAgICAgKiBAcGFyYW0gZmFsc2VCcmFuY2ggVGhlIGJyYW5jaCB0byBmb2xsb3cgaWYgdGhlIGNvbmRpdGlvbiBldmFsdWF0ZXMgdG8gZmFsc2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXN0LCB0cnVlQnJhbmNoLCBmYWxzZUJyYW5jaCkge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdGVzdCA9IHRlc3Q7XG4gICAgICAgIHRoaXMuX3RydWVCcmFuY2ggPSB0cnVlQnJhbmNoO1xuICAgICAgICB0aGlzLl9mYWxzZUJyYW5jaCA9IGZhbHNlQnJhbmNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIHRlc3QgcmVzdWx0IGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIHRydWUgb3IgZmFsc2UgYnJhbmNoLCBkZXBlbmRpbmcgb24gdGhlIHRlc3RcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGNoaWxkQ3R4ID0gbmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCwgY29udGV4dC5lZmZlY3RzLCBjb250ZXh0LmV2ZW50TG9nKTtcbiAgICAgICAgY2hpbGRDdHguY2FudmFzID0gc3BhY2VfbGlmdF8xLlNvbWUoY29udGV4dC5jYW52YXMuZ2V0KCkpO1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5fdGVzdC5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgaWYgKCEocmVzIGluc3RhbmNlb2YgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjb25kaXRpb24gbXVzdCBiZSBhIGJvb2xlYW4gZXhwcmVzc2lvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcy52YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cnVlQnJhbmNoLmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2ZhbHNlQnJhbmNoICE9IG51bGwpIHsgLy8gY2hlY2sgaWYgZWxzZS9lbHNlIGlmIGlzIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmFsc2VCcmFuY2guZXZhbChjaGlsZEN0eCk7IC8vIHBvc3NpYmx5IGEgYmFkIGlkZWFcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb25kaXRpb25hbCBzdGF0ZW1lbnRcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlcyA9ICdpZignICsgdGhpcy5fdGVzdC50b1N0cmluZygpICsgXCIpIHtcXG4gXCIgKyB0aGlzLl90cnVlQnJhbmNoLnRvU3RyaW5nKCkgKyBcIn1cIjtcbiAgICAgICAgaWYgKHRoaXMuX2ZhbHNlQnJhbmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlcyArPSAnXFxuZWxzZSB7XFxuICcgKyB0aGlzLl9mYWxzZUJyYW5jaC50b1N0cmluZygpICsgJ30nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJ1ZSBicmFuY2ggb2YgdGhlIGNvbmRpdGlvbmFsXG4gICAgICovXG4gICAgZ2V0IHRydWVCcmFuY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cnVlQnJhbmNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmYWxzZSBicmFuY2ggb2YgdGhlIGNvbmRpdGlvbmFsXG4gICAgICovXG4gICAgZ2V0IGZhbHNlQnJhbmNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFsc2VCcmFuY2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmRpdGlvbmFscyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgY29uZGl0aW9uYWxcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGNvbmRpdGlvbmFsc1wiKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbmRpdGlvbmFsID0gQ29uZGl0aW9uYWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25kaXRpb25hbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgUGFpbnRFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUGFpbnRFdmVudFwiKTtcbmNvbnN0IFJlc2l6ZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9SZXNpemVFdmVudFwiKTtcbmNvbnN0IENsaWNrRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL0NsaWNrRXZlbnRcIik7XG5jbGFzcyBDdXJ2ZUVmZmVjdCB7XG4gICAgY29uc3RydWN0b3IoY3VydmUpIHtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBwcml2YXRlIGJvb2xzXG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JhdGlvID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnggPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IDA7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX21vdXNlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY3VydmUgPSBjdXJ2ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIGV2YWx1YXRpbmcgbm9kZXMgKFN0cmluZ05vZGUsIEVsbGlwc2VOb2RlLCBldGMpXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyBhbGwgcGFyYW1zIHRvIHByaXZhdGUgdmFyaWFibGVzIGFuZCBkcmF3cyB0aGUgaW5pdGlhbCBvYmplY3QgdG8gdGhlIGNhbnZhc1xuICAgICAqIGJ5IGNhbGxpbmcgdXBkYXRlKClcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgcGFyZW50IFNjb3BlIHRoYXQgY29udGFpbnMgdGhlIGNhbnZhcyBhbW9uZyBvdGhlciB0aGluZ3NcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgb2JqZWN0J3MgZGltZW5zaW9ucyBpbmNsdWRpbmcgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBhc3QgVW5uZWNlc3Nhcnkgbm93LCB1c2VkIHRvIGJlIHRoZSBwYXJlbnQgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY2FudmFzLmlzRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zID0gZGltcztcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IGNvbnRleHQuY2FudmFzLmdldCgpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgY3R4ID0gY29udGV4dC5jYW52YXMuZ2V0KCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1BhaW50KCkpO1xuICAgICAgICBjb250ZXh0LmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gZHJhdyBhbmQgcmVkcmF3IHRoZSBvYmplY3Qgd2hlbiBtYW5pcHVsYXRpb25zIGFyZSBtYWRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudztcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuaDtcbiAgICAgICAgbGV0IGN1cnZhdHVyZSA9IHRoaXMuY3VydmF0dXJlO1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIGxldCB2ID0gdGhpcy5wZXJwZW5kaWN1bGFyVmVjdG9yKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLl9jdHgucXVhZHJhdGljQ3VydmVUbygoeCArIHdpZHRoIC8gMikgKyBjdXJ2YXR1cmUgKiB2WzBdLCAoeSArIGhlaWdodCAvIDIpICsgY3VydmF0dXJlICogdlsxXSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gXCIjNjczQUI3XCI7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0d1aWRlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0aGlzLl9jb3JuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vYSAqIHcgKyBiICogaCA9IDBcbiAgICBwZXJwZW5kaWN1bGFyVmVjdG9yKHcsIGgpIHtcbiAgICAgICAgaWYgKHcgPT0gMCAmJiBoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodyA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gWzEsIDBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFswLCAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzEsICgtdykgLyBoXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gb25lIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7IC8vIGJpbmQgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIG1lYW5pbmcgb2YgJ3RoaXMnXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25TaGlmdERvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25TaGlmdFVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy9tYWtlcyBpdCBzbyB0aGF0IGRvdWJsZSBjbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0ZXh0IG9uIHRoZSBwYWdlXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uIChlKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGZhbHNlOyB9LCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIGFub3RoZXIgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvZiB0aGUgb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgY29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAobXggPiB4ICYmIG14IDwgeCArIHcgJiYgbXkgPiB5ICYmIG15IDwgeSArIGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciA+IDAgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvbmUgb2YgdGhlIGNvcm5lci9zaWRlIGd1aWRlcywgcmV0dXJucyAwIGlmIG5vdFxuICAgICAqIFRoZSBjb3JuZXIgZ3VpZGVzIGFyZSBudW1iZXJlZCAxLTQgd2l0aCAxIGJlaW5nIHRoZSB0b3AgbGVmdCwgMiBiZWluZyB0aGUgdG9wIHJpZ2h0LCBhbmQgc28gb24uXG4gICAgICogVGhlIG1pZGRsZSBndWlkZXMgYXJlIG51bWJlcmVkIDUtOCwgd2l0aCA1IGJlaW5nIHRoZSB0b3AgbWlkZGxlLCA2IGJlaW5nIHRoZSByaWdodCBtaWRkbGUsIGFuZCBzbyBvbi5cbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ3VpZGVDb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGxldCB4ZGlmID0gbXggLSB4O1xuICAgICAgICBsZXQgeWRpZiA9IG15IC0geTtcbiAgICAgICAgLyogQ29ybmVyIEd1aWRlcyAqL1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIGxlZnRcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogTWlkZGxlIEd1aWRlcyAqL1xuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0geTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGFuZCBndWlkZXMgZm9yIHRoZSBvYmplY3Qgd2hlbiB0aGUgb2JqZWN0IGlzIHNlbGVjdGVkXG4gICAgICogSWYgb25lIG9mIHRoZSBndWlkZXMgaXMgc2VsZWN0ZWQsIGl0IGNvbG9ycyB0aGF0IGd1aWRlIGJsdWVcbiAgICAgKiBAcGFyYW0geCB0aGUgeCBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0geSB0aGUgeSBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb3JuZXIgdGhlIG51bWJlciBvZiB0aGUgY29ybmVyIHRvIGJlIGNvbG9yZWQgYmx1ZSAoaWYgYW55IGF0IGFsbCwgaWYgMCwgYWxsIGFyZSB3aGl0ZSlcbiAgICAgKi9cbiAgICBkcmF3R3VpZGVzKHgsIHksIHcsIGgsIGNvcm5lcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKGNvcm5lciAhPT0gMCAmJiBjb3JuZXIgPD0gNCkgeyAvLyBhIGNvcm5lciBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcnJlY3QgZ3VpZGUgYmx1ZVxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3JuZXIgIT09IDApIHsgLy8gYSBtaWRkbGUgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vaWYgbm8gZ3VpZGVzIGFyZSBzZWxlY3RlZCwgY29sb3JzIGV2ZXJ5dGhpbmcgd2hpdGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBtZXRob2QgdGhhdCBkcmF3cyBhIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB4IHggY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHkgeSBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gdyB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29sb3IgY29sb3Igb2YgdGhlIHJlY3RhbmdsZSdzIGZpbGxcbiAgICAgKi9cbiAgICBkcmF3U3F1YXJlKHgsIHksIHcsIGgsIGNvbG9yKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBtb3ZlcyB3aXRoaW4gdGhlIGNhbnZhcy5cbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiwgY2FsbHMgdGhlIG1vZGlmeSBtZXRob2RzIGlmIHRoZSBib29sZWFucyBzYXRpc2Z5IHRoZW0uXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICB0aGlzLmdldE1vdXNlUG9zaXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlEcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZXNpemluZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZSh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQ2hhbmdpbmdEaW1zICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltcyh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5U3RhdGUodGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpLCB0aGlzLmNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSB1bmNsaWNrcy5cbiAgICAgKiBDYWxscyBtb2RpZnlSZXNldCB0byByZXNldCBkcmFnZ2luZyBhbmQgcmVzaXppbmcgYm9vbGVhbnMgYW1vbmcgb3RoZXJzLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2V1cCBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VVcChldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyBwcmVzc2VkIGRvd25cbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSBwcmVzc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcmVsZWFzZWRcbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSByZWxlYXNlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdFVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBNb2RpZmljYXRpb24gZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGRyYWcgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBtb2RpZnlEcmFnKCkge1xuICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS54IC0gdGhpcy5fZHJhZ29mZng7XG4gICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLl9kcmFnb2ZmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkICh3aGVuIGEgY29ybmVyIGd1aWRlIGlzIGNsaWNrZWQgYW5kIGRyYWdnZWQpLlxuICAgICAqXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMCBhbmQgdGhlIG90aGVyIGVxdWFsIHRvXG4gICAgICogMTAgZGl2aWRlZCBvciBtdWx0aXBsaWVkIGJ5IHRoZSByYXRpbyBvZiB3aWR0aC9oZWlnaHQgdG8ga2VlcCBpdCB0aGUgc2FtZS5cbiAgICAgKlxuICAgICAqIFRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIGlzIGRvbmUgYnkgY2FsbGluZyB0aGUgaGVscGVyIG1ldGhvZCBtb2RpZnlSZXNpemVIZWxwZXIuXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7IC8vIHNldCBmb3IgdGhlIHByb2RpcmVjdCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTAgLyB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fY3VydmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApOyAvLyBzZXQgZm9yIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgKiB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTAgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIHRoZSByZWN0YW5nbGUgb3JpZ2luYXRlcyBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgYW5kIG5vdCB0aGUgY2VudGVyLFxuICAgICAqIGl0IGNoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXMgd2VsbCBpZiBndWlkZXMgMSwgMiwgb3IgNCBhcmUgc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdEaXN0YW5jZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbW91c2UgYW5kIHRoZSBsb2NhdGlvbiBvcHBvc2l0ZSB0byBpdFxuICAgICAqIChpZiB0b3AgcmlnaHQgZ3VpZGUgaXMgY2xpY2tlZCwgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhhdCBhbmQgdGhlIGJvdHRvbSBsZWZ0IGd1aWRlIGlzIG5ld0Rpc3RhbmNlKVxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSkge1xuICAgICAgICBpZiAodGhpcy53ID4gMTAgJiYgdGhpcy5oID4gMTApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQoKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAvIHRoaXMuX3JhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgIHRoaXMuX2N1cnZlLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgdGhpcy5fY3VydmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZC5cbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDEwLlxuICAgICAqIENhbGxzIG1vZGlmeUNoYW5nZURpbXNIZWxwZXIgdG8gYWN0dWFsbHkgZG8gdGhlIHdvcmtcbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fY3VydmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyA1IG9yIDggYXJlIHNlbGVjdGVkXG4gICAgICovXG4gICAgbW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oID4gMTApIHsgLy9hcyBsb25nIGFzIHRoZSBoZWlnaHQgaXMgPiAxMFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudyA+IDEwKSB7IC8vIGFzIGxvbmcgYXMgd2lkdGggaXMgPiAxMFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VydmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyBkZXBlbmRpbmcgb24gdGhlIG1vdXNlIHBvc2l0aW9uIHdoZW4gY2FsbGVkIChvbk1vdXNlRG93bilcbiAgICAgKiBlLmcuIGlmIHRoZSBtb3VzZSBpcyB3aXRoaW4gdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSB3aGVuIHRoaXMgaXMgY2FsbGVkLCBpc1NlbGVjdGVkID0gdHJ1ZVxuICAgICAqIEBwYXJhbSBndWlkZUNvbnRhaW5zXG4gICAgICogQHBhcmFtIGNvbnRhaW5zXG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGUoZ3VpZGVDb250YWlucywgY29udGFpbnMpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7IC8vcHJlcGFyZXMgdGhlIG9iamVjdCBmb3IgZHJhZ2dpbmcgd2hldGhlciBpdCBpcyBwZXJzb25hbGx5IHNlbGVjdGVkIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5feTEgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiAwICYmIGd1aWRlQ29udGFpbnMgPD0gNCkgeyAvL3Jlc2l6aW5nXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSB0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSk7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQxID0gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy5fd2lkdGgxID0gdGhpcy53O1xuICAgICAgICAgICAgLy90aGlzLl9zaXplMSA9IE1hdGguc3FydChNYXRoLnBvdyh3LDIpICsgTWF0aC5wb3coaCwyKSk7IC8vIHNpemUgaXMgZGlhZ29uYWwgbGVuZ3RoXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikgeyAvLyBzZXRzIHRoZSBvZmZzZXRzIGRlcGVuZGluZyBvbiB3aGljaCBjb3JuZXIgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7IC8vIG9mZnNldCBpcyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7IC8vIG9mZnNldCBpcyBib3R0b20gbGVmdCwgZXRjXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gNCkgeyAvL2NoYW5naW5nIHNoYXBlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gZ3VpZGVDb250YWlucztcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7IC8vIHNldHMgdGhlIG9mZnNldHMgZGVwZW5kaW5nIG9uIHdoaWNoIG1pZGRsZSBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgNTogLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdyAvIDIsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdyAvIDI7IC8vIG9mZnNldCBpcyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogLy9yaWdodCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoIC8gMjsgLy8gb2Zmc2V0IGlzIGxlZnQgbWlkZGxlIGV0Y1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWlucykgeyAvLyBkcmFnZ2luZ1xuICAgICAgICAgICAgdGhpcy5feDEgPSB4OyAvLyBTYXZpbmcgb3JpZ2luYWwgeCBhbmQgeVxuICAgICAgICAgICAgdGhpcy5feTEgPSB5O1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy8gbm90IHNlbGVjdGVkXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyB0byBmYWxzZSAobGlrZSBkcmFnZ2luZywgcmVzaXppbmcsIGV0Yykgd2hlbiB0aGUgbW91c2UgaXMgcmVsZWFzZWRcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0gdGhpcy54KSA+IDEgfHwgTWF0aC5hYnModGhpcy5feTEgLSB0aGlzLnkpID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodGhpcy5faXNSZXNpemluZyB8fCB0aGlzLl9pc0NoYW5naW5nRGltcykgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHNpemUyID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMudywgMikgKyBNYXRoLnBvdyh0aGlzLmgsIDIpKTtcbiAgICAgICAgICAgIGlmICgoTWF0aC5hYnModGhpcy5fd2lkdGgxIC0gdGhpcy53KSA+IDApIHx8IChNYXRoLmFicyh0aGlzLl9oZWlnaHQxIC0gdGhpcy5oKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUmVzaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICovXG4gICAgZ2V0TW91c2VQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbW91c2UueCA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLng7XG4gICAgICAgIHRoaXMuX21vdXNlLnkgPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzQ2hhbmdpbmdEaW1zLCBhbmQgaXNTZWxlY3RlZCB0byBmYWxzZSBpZiB0aGUgbW91c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgaXNNb3VzZU91dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1vdXNlWCA8IHJlY3QubGVmdCB8fCBtb3VzZVggPiByZWN0LnJpZ2h0IHx8IG1vdXNlWSA8IHJlY3QudG9wIHx8IG1vdXNlWSA+IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIHBhaW50IGV2ZW50XG4gICAgICovXG4gICAgbG9nUGFpbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpbnRFdmVudF8xLlBhaW50RXZlbnQoXCJyZWN0YW5nbGVcIiwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIHJlc2l6ZSBldmVudFxuICAgICAqL1xuICAgIGxvZ1Jlc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVFdmVudF8xLlJlc2l6ZUV2ZW50KFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgTWF0aC5yb3VuZCh0aGlzLl93aWR0aDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuX2hlaWdodDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMudyAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5oICogMTAwKSAvIDEwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZWN0YW5nbGUgY2xpY2sgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dDbGljaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGlja0V2ZW50XzEuQ2xpY2tFdmVudChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIGFzc2lnbnMgYW4gSUQgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIGlkIFRoZSBJRCB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIGluaXRJRChpZCkge1xuICAgICAgICB0aGlzLmlkT2JqID0geyBfaWQ6IGlkIH07XG4gICAgfVxuICAgIGFzdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHggcG9zaXRpb24gb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VydmF0dXJlIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIGdldCBjdXJ2YXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLmN1cnZhdHVyZS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRGltZW5zaW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgZGltcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZE9iai5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICovXG4gICAgZ2V0SnVzdERyYWdnZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdXN0RHJhZ2dlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldEp1c3REcmFnZ2VkKHZhbCkge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBpcyBkcmFnZ2luZ1xuICAgICAqL1xuICAgIGdldCBpc0RyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEcmFnZ2luZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBzZWxlY3Rpb24gZXZlbnRzXG4gICAgICovXG4gICAgdG9TZWxTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIiByZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBkcmFnIGV2ZW50c1xuICAgICovXG4gICAgdG9EcmFnU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94MSArIFwiLCBcIiArIHRoaXMuX3kxICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gcmVjdGFuZ2xlIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG59XG5leHBvcnRzLkN1cnZlRWZmZWN0ID0gQ3VydmVFZmZlY3Q7XG4vKipcbiAqIEdldHMgdGhlIG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZXMgaW4gcmVsYXRpb24gdG8gdGhlIGNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB0aGUgY2FudmFzIG9iamVjdFxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0TW91c2VQb3MoY2FudmFzLCBldmVudCkge1xuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB4MSB4IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB5MSB5IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB4MiB4IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKiBAcGFyYW0geTIgeSBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MiwgMikgKyBNYXRoLnBvdyh5MSAtIHkyLCAyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DdXJ2ZUVmZmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBhaW50RXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1BhaW50RXZlbnRcIik7XG5jb25zdCBSZXNpemVFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUmVzaXplRXZlbnRcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IENsaWNrRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL0NsaWNrRXZlbnRcIik7XG5jbGFzcyBFbGxpcHNlRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihjaXJjbGUpIHtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBQcml2YXRlIGJvb2xzXG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7IC8vIEhhcyB0aGlzIG9iamVjdCBqdXN0IGJlZW4gZHJhZ2dlZD9cbiAgICAgICAgdGhpcy5fcmF0aW8gPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gMDtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5fbW91c2UgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jaXJjbGUgPSBjaXJjbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiBldmFsdWF0aW5nIG5vZGVzIChTdHJpbmdOb2RlLCBFbGxpcHNlTm9kZSwgZXRjKVxuICAgICAqIFRoaXMgbWV0aG9kIGFzc2lnbnMgYWxsIHBhcmFtcyB0byBwcml2YXRlIHZhcmlhYmxlcyBhbmQgZHJhd3MgdGhlIGluaXRpYWwgb2JqZWN0IHRvIHRoZSBjYW52YXNcbiAgICAgKiBieSBjYWxsaW5nIHVwZGF0ZSgpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIHBhcmVudCBTY29wZSB0aGF0IGNvbnRhaW5zIHRoZSBjYW52YXMgYW1vbmcgb3RoZXIgdGhpbmdzXG4gICAgICogQHBhcmFtIGRpbXMgVGhlIG9iamVjdCdzIGRpbWVuc2lvbnMgaW5jbHVkaW5nIHggYW5kIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gYXN0IFVubmVjZXNzYXJ5IG5vdywgdXNlZCB0byBiZSB0aGUgcGFyZW50IEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNhbnZhcy5pc0RlZmluZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZGltcyA9IGRpbXM7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBjb250ZXh0LmNhbnZhcy5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgbGV0IGN0eCA9IGNvbnRleHQuY2FudmFzLmdldCgpLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb2dnaW5nXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1BhaW50KCkpO1xuICAgICAgICBjb250ZXh0LmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gZHJhdyBhbmQgcmVkcmF3IHRoZSBvYmplY3Qgd2hlbiBtYW5pcHVsYXRpb25zIGFyZSBtYWRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHguZWxsaXBzZSh4LCB5LCB3IC8gMiwgaCAvIDIsIDAsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgICAgIC8vdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICAvL3RoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IFwiI0Q1QjhGRlwiO1xuICAgICAgICB0aGlzLl9jdHguc2hhZG93Q29sb3IgPSBcIiM2QzZDNkNcIjtcbiAgICAgICAgdGhpcy5fY3R4LnNoYWRvd0JsdXIgPSAxNTtcbiAgICAgICAgLy90aGlzLl9jdHguc2hhZG93T2Zmc2V0WCA9IDI7XG4gICAgICAgIC8vdGhpcy5fY3R4LnNoYWRvd09mZnNldFkgPSAyO1xuICAgICAgICB0aGlzLl9jdHguZmlsbCgpO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3R3VpZGVzKHggLSB3IC8gMiwgeSAtIGggLyAyLCB3LCBoLCB0aGlzLl9jb3JuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICAgIHByaXZhdGUgbW91c2VNb3ZlID0gdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICBwcml2YXRlIG1vdXNlRG93biA9IHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgcHJpdmF0ZSBtb3VzZVVwID0gdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgcHJpdmF0ZSBzaGlmdERvd24gPSB0aGlzLm9uU2hpZnREb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHByaXZhdGUgc2hpZnRVcCA9IHRoaXMub25TaGlmdFVwLmJpbmQodGhpcyk7XG4gICAgICAgIHByaXZhdGUgbW91c2VPdXRzaWRlID0gdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpO1xuICAgICAgICBwcml2YXRlIHNlbGVjdFN0YXJ0ID0gZnVuY3Rpb24oZTphbnkpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZmFsc2U7IH07XG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBvbmUgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTsgLy8gYmluZCBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgbWVhbmluZyBvZiAndGhpcydcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vblNoaWZ0RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vblNoaWZ0VXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmlzTW91c2VPdXRzaWRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL21ha2VzIGl0IHNvIHRoYXQgZG91YmxlIGNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRleHQgb24gdGhlIHBhZ2VcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgZnVuY3Rpb24gKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZmFsc2U7IH0sIGZhbHNlKTtcbiAgICB9XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIC8qXG4gICAgICAgIGNvbnNvbGUubG9nKFwicmVtb3ZpbmcgRXZlbnRMaXN0bmVyc1wiKTtcbiAgICAgICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZU1vdmUpOyAvLyBiaW5kIGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBtZWFuaW5nIG9mICd0aGlzJ1xuICAgICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlRG93bik7XG4gICAgICAgICAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNlVXApO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5zaGlmdERvd24pO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuc2hpZnRVcCk7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2VPdXRzaWRlKTtcbiAgICAgICAgICAvL21ha2VzIGl0IHNvIHRoYXQgZG91YmxlIGNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRleHQgb24gdGhlIHBhZ2VcbiAgICAgICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCB0aGlzLnNlbGVjdFN0YXJ0LCBmYWxzZSk7XG4gICAgICAgICAgKi9cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb2YgdGhlIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSwgZmFsc2UgaWYgb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KG14IC0geCwgMikgLyBNYXRoLnBvdyh3IC8gMiwgMikgKyBNYXRoLnBvdyhteSAtIHksIDIpIC8gTWF0aC5wb3coaCAvIDIsIDIpIDw9IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgPiAwIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb25lIG9mIHRoZSBjb3JuZXIvc2lkZSBndWlkZXMsIHJldHVybnMgMCBpZiBub3RcbiAgICAgKiBUaGUgY29ybmVyIGd1aWRlcyBhcmUgbnVtYmVyZWQgMS00IHdpdGggMSBiZWluZyB0aGUgdG9wIGxlZnQsIDIgYmVpbmcgdGhlIHRvcCByaWdodCwgYW5kIHNvIG9uLlxuICAgICAqIFRoZSBtaWRkbGUgZ3VpZGVzIGFyZSBudW1iZXJlZCA1LTgsIHdpdGggNSBiZWluZyB0aGUgdG9wIG1pZGRsZSwgNiBiZWluZyB0aGUgcmlnaHQgbWlkZGxlLCBhbmQgc28gb24uXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGd1aWRlQ29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBsZXQgeGRpZiA9IG14IC0gKHggLSB3IC8gMik7XG4gICAgICAgIGxldCB5ZGlmID0gbXkgLSAoeSAtIGggLyAyKTtcbiAgICAgICAgLyogQ29ybmVyIEd1aWRlcyAqL1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIGxlZnRcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4IC0gdyAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICB9XG4gICAgICAgIC8qIE1pZGRsZSBHdWlkZXMgKi9cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgLSBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0geTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCAtIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0geTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBhbmQgZ3VpZGVzIGZvciB0aGUgb2JqZWN0IHdoZW4gdGhlIG9iamVjdCBpcyBzZWxlY3RlZFxuICAgICAqIElmIG9uZSBvZiB0aGUgZ3VpZGVzIGlzIHNlbGVjdGVkLCBpdCBjb2xvcnMgdGhhdCBndWlkZSBibHVlXG4gICAgICogQHBhcmFtIHggdGhlIHggY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHkgdGhlIHkgY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHcgdGhlIHdpZHRoIG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29ybmVyIHRoZSBudW1iZXIgb2YgdGhlIGNvcm5lciB0byBiZSBjb2xvcmVkIGJsdWUgKGlmIGFueSBhdCBhbGwsIGlmIDAsIGFsbCBhcmUgd2hpdGUpXG4gICAgICovXG4gICAgZHJhd0d1aWRlcyh4LCB5LCB3LCBoLCBjb3JuZXIpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmIChjb3JuZXIgIT09IDAgJiYgY29ybmVyIDw9IDQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29ybmVyICE9PSAwICYmIGNvcm5lciA+IDQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgbWV0aG9kIHRoYXQgZHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geCB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5IHkgY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHcgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIGNvbG9yIG9mIHRoZSByZWN0YW5nbGUncyBmaWxsXG4gICAgICovXG4gICAgZHJhd1NxdWFyZSh4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgd2l0aGluIHRoZSBjYW52YXMuXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24sIGNhbGxzIHRoZSBtb2RpZnkgbWV0aG9kcyBpZiB0aGUgYm9vbGVhbnMgc2F0aXNmeSB0aGVtLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRNb3VzZVBvc2l0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5RHJhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemUodGhpcy53IDwgMTQsIHRoaXMuaCA8IDE0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0NoYW5naW5nRGltcyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXModGhpcy53IDwgMTQsIHRoaXMuaCA8IDE0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIGNsaWNrcyBpbnNpZGUgdGhlIGNhbnZhcy5cbiAgICAgKiBNb2RpZmllcyB0aGUgc3RhdGUgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGd1aWRlcyBjb250YWluIHRoZSBtb3VzZSBvciB0aGUgYm91bmRpbmcgcmVjdCBjb250YWlucyB0aGUgbW91c2UuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVN0YXRlKHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSwgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgdW5jbGlja3MuXG4gICAgICogQ2FsbHMgbW9kaWZ5UmVzZXQgdG8gcmVzZXQgZHJhZ2dpbmcgYW5kIHJlc2l6aW5nIGJvb2xlYW5zIGFtb25nIG90aGVycy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNldXAgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkknbSBhbiBlbGxpcHNlIVwiKTtcbiAgICAgICAgdGhpcy5tb2RpZnlSZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcHJlc3NlZCBkb3duXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcHJlc3NlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdERvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHJlbGVhc2VkXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcmVsZWFzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnRVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogTW9kaWZpY2F0aW9uIGZ1bmN0aW9ucyAqL1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBpbiBvcmRlciB0byBkcmFnIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgbW9kaWZ5RHJhZygpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImVsbGlwc2UgZHJhZ29mZng6IFwiICsgdGhpcy5fZHJhZ29mZngpO1xuICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS54IC0gdGhpcy5fZHJhZ29mZng7XG4gICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLl9kcmFnb2ZmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkICh3aGVuIGEgY29ybmVyIGd1aWRlIGlzIGNsaWNrZWQgYW5kIGRyYWdnZWQpLlxuICAgICAqXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxNCBhbmQgdGhlIG90aGVyIGVxdWFsIHRvXG4gICAgICogMTAgZGl2aWRlZCBvciBtdWx0aXBsaWVkIGJ5IHRoZSByYXRpbyBvZiB3aWR0aC9oZWlnaHQgdG8ga2VlcCBpdCB0aGUgc2FtZS5cbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxNFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTRcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNpemUod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgaWYgKHdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxNDtcbiAgICAgICAgICAgIHRoaXMuX2NpcmNsZS53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxNCk7IC8vIHNldCBmb3IgdGhlIHByb2RpcmVjdCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTQgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2NpcmNsZS5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxNCAvIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDI7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDIgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDE0O1xuICAgICAgICAgICAgdGhpcy5fY2lyY2xlLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxNCk7IC8vIHNldCBmb3IgdGhlIHByb2RpcmVjdCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxNCAqIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fY2lyY2xlLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTQgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyIC8gdGhpcy5fcmF0aW87XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDI7XG4gICAgICAgICAgICB0aGlzLl9jaXJjbGUud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyIC8gdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9jaXJjbGUuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQuXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMC5cbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgIGlmICh0aGlzLl9jb3JuZXIgPT0gNSB8fCB0aGlzLl9jb3JuZXIgPT0gNykgeyAvLyBpZiBtb2RpZnlpbmcgaGVpZ2h0XG4gICAgICAgICAgICBpZiAoIWhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDIgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7IC8vIHNldHRpbmcgd2lkdGgvaGVpZ2h0IHJhdGlvID0gdG8gdGhlIG5ldyByYXRpb1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxNDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDE0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyIC8gdGhpcy5fcmF0aW87XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gbW9kaWZ5aW5nIHdpZHRoXG4gICAgICAgICAgICBpZiAoIXdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDE0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxNCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyBkZXBlbmRpbmcgb24gdGhlIG1vdXNlIHBvc2l0aW9uIHdoZW4gY2FsbGVkIChvbk1vdXNlRG93bilcbiAgICAgKiBlLmcuIGlmIHRoZSBtb3VzZSBpcyB3aXRoaW4gdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSB3aGVuIHRoaXMgaXMgY2FsbGVkLCBpc1NlbGVjdGVkID0gdHJ1ZVxuICAgICAqIEBwYXJhbSBndWlkZUNvbnRhaW5zXG4gICAgICogQHBhcmFtIGNvbnRhaW5zXG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGUoZ3VpZGVDb250YWlucywgY29udGFpbnMpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy9wcmVwYXJlcyB0aGUgb2JqZWN0IGZvciBkcmFnZ2luZyB3aGV0aGVyIGl0IGlzIHBlcnNvbmFsbHkgc2VsZWN0ZWQgb3Igbm90XG4gICAgICAgICAgICBpZiAoY29udGFpbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94MSA9IHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl95MSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gMCAmJiBndWlkZUNvbnRhaW5zIDw9IDQpIHsgLy9yZXNpemluZ1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gZ3VpZGVDb250YWlucztcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy54O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLnk7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICB0aGlzLl93aWR0aDEgPSB0aGlzLnc7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQxID0gdGhpcy5oO1xuICAgICAgICAgICAgLy90aGlzLl9zaXplMSA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLncsMikgKyBNYXRoLnBvdyh0aGlzLmgsMikpOyAvLyBzYXZpbmcgb2xkIHNpemVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gNCkgeyAvL2NoYW5naW5nIHNoYXBlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gZ3VpZGVDb250YWlucztcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy54O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLnk7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbnMpIHsgLy9zaW1wbHkgc2VsZWN0aW5nIHRoZSBzaGFwZSBvciBkcmFnZ2luZ1xuICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLng7IC8vIFNhdmluZyBvcmlnaW5hbCB4IGFuZCB5XG4gICAgICAgICAgICB0aGlzLl95MSA9IHRoaXMueTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHRoaXMueDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgdG8gZmFsc2UgKGxpa2UgZHJhZ2dpbmcsIHJlc2l6aW5nLCBldGMpIHdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkXG4gICAgICovXG4gICAgbW9kaWZ5UmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHsgLy8gcHJvYnMgb25seSBuZWVkIGRyYWdnaW5nIGJ1dCBvaCB3ZWxsIHwgaXNTZWwgfHwgc2VsTXVsP1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0gdGhpcy54KSA+IDEgfHwgTWF0aC5hYnModGhpcy5feTEgLSB0aGlzLnkpID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvL3RoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ01vdmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHRoaXMuX2lzUmVzaXppbmcgfHwgdGhpcy5faXNDaGFuZ2luZ0RpbXMpICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJyZXNpemluZyBlbGxpcHNlXCIpO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy9sZXQgc2l6ZTIgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53LDIpICsgTWF0aC5wb3codGhpcy5oLDIpKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTaXplIGRpZmY6IFwiICsgTWF0aC5hYnModGhpcy5fc2l6ZTEgLSBzaXplMikpO1xuICAgICAgICAgICAgaWYgKChNYXRoLmFicyh0aGlzLl93aWR0aDEgLSB0aGlzLncpID4gMCkgfHwgKE1hdGguYWJzKHRoaXMuX2hlaWdodDEgLSB0aGlzLmgpID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dSZXNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYodGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSl7XG4gICAgICAgIC8vICAgICBpZihNYXRoLmFicyh0aGlzLl94MSAtIHRoaXMueCkgPiAxIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0gdGhpcy55KSA+IDEpIHtcbiAgICAgICAgLy8gICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dNb3ZlKCkpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICovXG4gICAgZ2V0TW91c2VQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbW91c2UueCA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLng7XG4gICAgICAgIHRoaXMuX21vdXNlLnkgPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzQ2hhbmdpbmdEaW1zLCBhbmQgaXNTZWxlY3RlZCB0byBmYWxzZSBpZiB0aGUgbW91c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgaXNNb3VzZU91dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1vdXNlWCA8IHJlY3QubGVmdCB8fCBtb3VzZVggPiByZWN0LnJpZ2h0IHx8IG1vdXNlWSA8IHJlY3QudG9wIHx8IG1vdXNlWSA+IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSBwYWludCBldmVudFxuICAgICAqL1xuICAgIGxvZ1BhaW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhaW50RXZlbnRfMS5QYWludEV2ZW50KFwiZWxsaXBzZVwiLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZXNpemUgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dSZXNpemUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplRXZlbnRfMS5SZXNpemVFdmVudChcImVsbGlwc2Ugd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCBNYXRoLnJvdW5kKHRoaXMuX3dpZHRoMSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5faGVpZ2h0MSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy53ICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLmggKiAxMDApIC8gMTAwKTtcbiAgICAgICAgLy9NYXRoLnJvdW5kKHRoaXMuX3NpemUxKjEwMCkvMTAwLCBNYXRoLnJvdW5kKChNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53LDIpICsgTWF0aC5wb3codGhpcy5oLDIpKSoxMDApKS8xMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgY2xpY2sgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dDbGljaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGlja0V2ZW50XzEuQ2xpY2tFdmVudChcImVsbGlwc2Ugd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCBhc3NpZ25zIGFuIElEIHRvIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSBpZCBUaGUgSUQgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBpbml0SUQoaWQpIHtcbiAgICAgICAgdGhpcy5pZE9iaiA9IHsgX2lkOiBpZCB9O1xuICAgIH1cbiAgICBhc3QoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBlbGxpcHNlXG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIGVsbGlwc2VcbiAgICAgKi9cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGVsbGlwc2VcbiAgICAgKi9cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgZWxsaXBzZVxuICAgICAqL1xuICAgIGdldCBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERpbWVuc2lvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIGVsbGlwc2VcbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRPYmouX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqL1xuICAgIGdldEp1c3REcmFnZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fanVzdERyYWdnZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIGVsbGlwc2UgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBzZXRKdXN0RHJhZ2dlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVsbGlwc2UgaXMgZHJhZ2dpbmdcbiAgICAgKi9cbiAgICBnZXQgaXNEcmFnZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRHJhZ2dpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3Igc2VsZWN0aW9uIGV2ZW50c1xuICAgICAqL1xuICAgIHRvU2VsU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKFwiIGVsbGlwc2Ugd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgZHJhZyBldmVudHNcbiAgICAqL1xuICAgIHRvRHJhZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChcImVsbGlwc2Ugd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgZnJvbSBcIiArIHRoaXMuX3gxICsgXCIsIFwiICsgdGhpcy5feTEgKyBcIiB0byBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgSUQgYXNzaWdubWVudCBldmVudHNcbiAgICAgKi9cbiAgICB0b0lEU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaWRPYmouX2lkLnRvU3RyaW5nKCkgKyBcIiB0byBlbGxpcHNlIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG59XG5leHBvcnRzLkVsbGlwc2VFZmZlY3QgPSBFbGxpcHNlRWZmZWN0O1xuLyoqXG4gKiBHZXQncyB0aGUgbW91c2UgeCBhbmQgeSBjb29yZGluYXRlcyBpbiByZWxhdGlvbiB0byB0aGUgY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHRoZSBjYW52YXMgb2JqZWN0XG4gKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICovXG5mdW5jdGlvbiBnZXRNb3VzZVBvcyhjYW52YXMsIGV2ZW50KSB7XG4gICAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHgxIHggY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHkxIHkgY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHgyIHggY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSB5MiB5IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgyLCAyKSArIE1hdGgucG93KHkxIC0geTIsIDIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVsbGlwc2VFZmZlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IFBhaW50RXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1BhaW50RXZlbnRcIik7XG5jb25zdCBSZXNpemVFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUmVzaXplRXZlbnRcIik7XG5jb25zdCBDbGlja0V2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9DbGlja0V2ZW50XCIpO1xuY2xhc3MgRXBoRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihlcGgpIHtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBwcml2YXRlIGJvb2xzXG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JhdGlvID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnggPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IDA7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX21vdXNlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZXBoID0gZXBoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gZXZhbHVhdGluZyBub2RlcyAoU3RyaW5nTm9kZSwgRWxsaXBzZU5vZGUsIGV0YylcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3NpZ25zIGFsbCBwYXJhbXMgdG8gcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIGRyYXdzIHRoZSBpbml0aWFsIG9iamVjdCB0byB0aGUgY2FudmFzXG4gICAgICogYnkgY2FsbGluZyB1cGRhdGUoKVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBwYXJlbnQgU2NvcGUgdGhhdCBjb250YWlucyB0aGUgY2FudmFzIGFtb25nIG90aGVyIHRoaW5nc1xuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBvYmplY3QncyBkaW1lbnNpb25zIGluY2x1ZGluZyB4IGFuZCB5IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGFzdCBVbm5lY2Vzc2FyeSBub3csIHVzZWQgdG8gYmUgdGhlIHBhcmVudCBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBpZiAoY29udGV4dC5jYW52YXMuaXNEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMgPSBkaW1zO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gY29udGV4dC5jYW52YXMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0LmNhbnZhcy5nZXQoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICB0aGlzLl9lcGhJbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2VwaEltZy5zcmMgPSAnLi9waWNzL2RlbW9uY293LnBuZyc7XG4gICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUGFpbnQoKSk7XG4gICAgICAgIGNvbnRleHQuZWZmZWN0cy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBpbiBvcmRlciB0byBkcmF3IGFuZCByZWRyYXcgdGhlIG9iamVjdCB3aGVuIG1hbmlwdWxhdGlvbnMgYXJlIG1hZGVcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy53O1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5oO1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIC8vdmFyIGltZ09iaiA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAvL2xldCBjdHggPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgLy8gdGhpcy5fZXBoSW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIC8vIHRoaXMuX2VwaEltZy5zcmMgPSAnLi9waWNzL2RlbW9uY293LnBuZyc7XG4gICAgICAgIC8vaW1nT2JqLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vdGhpcy5fZXBoSW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuX2N0eC5kcmF3SW1hZ2UodGhpcy5fZXBoSW1nLCB0aGlzLngsIHRoaXMueSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIC8vdGhpcy5fZXBoSW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIHRoaXMuX2VwaEltZy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAvLyB0aGlzLl9lcGhJbWcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAvL31cbiAgICAgICAgLy99XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdHdWlkZXMoeCwgeSwgd2lkdGgsIGhlaWdodCwgdGhpcy5fY29ybmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBvbmUgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vblNoaWZ0RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vblNoaWZ0VXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmlzTW91c2VPdXRzaWRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL21ha2VzIGl0IHNvIHRoYXQgZG91YmxlIGNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRleHQgb24gdGhlIHBhZ2VcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgZnVuY3Rpb24gKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZmFsc2U7IH0sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gYW5vdGhlciBmZWxsIHN3b29wXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9mIHRoZSBvYmplY3QncyBib3VuZGluZyByZWN0YW5nbGUsIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBjb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGlmIChteCA+IHggJiYgbXggPCB4ICsgdyAmJiBteSA+IHkgJiYgbXkgPCB5ICsgaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbnVtYmVyID4gMCBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9uZSBvZiB0aGUgY29ybmVyL3NpZGUgZ3VpZGVzLCByZXR1cm5zIDAgaWYgbm90XG4gICAgICogVGhlIGNvcm5lciBndWlkZXMgYXJlIG51bWJlcmVkIDEtNCB3aXRoIDEgYmVpbmcgdGhlIHRvcCBsZWZ0LCAyIGJlaW5nIHRoZSB0b3AgcmlnaHQsIGFuZCBzbyBvbi5cbiAgICAgKiBUaGUgbWlkZGxlIGd1aWRlcyBhcmUgbnVtYmVyZWQgNS04LCB3aXRoIDUgYmVpbmcgdGhlIHRvcCBtaWRkbGUsIDYgYmVpbmcgdGhlIHJpZ2h0IG1pZGRsZSwgYW5kIHNvIG9uLlxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBndWlkZUNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgbGV0IHhkaWYgPSBteCAtIHg7XG4gICAgICAgIGxldCB5ZGlmID0gbXkgLSB5O1xuICAgICAgICAvKiBDb3JuZXIgR3VpZGVzICovXG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgfVxuICAgICAgICAvKiBNaWRkbGUgR3VpZGVzICovXG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICB5ZGlmID0gbXkgLSB5O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIG1pZGRsZVxuICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9taWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiA2O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGgpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgcmV0dXJuIDc7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9taWRkbGUgbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBib3VuZGluZyByZWN0YW5nbGUgYW5kIGd1aWRlcyBmb3IgdGhlIG9iamVjdCB3aGVuIHRoZSBvYmplY3QgaXMgc2VsZWN0ZWRcbiAgICAgKiBJZiBvbmUgb2YgdGhlIGd1aWRlcyBpcyBzZWxlY3RlZCwgaXQgY29sb3JzIHRoYXQgZ3VpZGUgYmx1ZVxuICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB5IHRoZSB5IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB3IHRoZSB3aWR0aCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggdGhlIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvcm5lciB0aGUgbnVtYmVyIG9mIHRoZSBjb3JuZXIgdG8gYmUgY29sb3JlZCBibHVlIChpZiBhbnkgYXQgYWxsLCBpZiAwLCBhbGwgYXJlIHdoaXRlKVxuICAgICAqL1xuICAgIGRyYXdHdWlkZXMoeCwgeSwgdywgaCwgY29ybmVyKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAoY29ybmVyICE9PSAwICYmIGNvcm5lciA8PSA0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgY29yZXBoIGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29ybmVyICE9PSAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgY29yZXBoIGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgbWV0aG9kIHRoYXQgZHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geCB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5IHkgY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHcgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIGNvbG9yIG9mIHRoZSByZWN0YW5nbGUncyBmaWxsXG4gICAgICovXG4gICAgZHJhd1NxdWFyZSh4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgd2l0aGluIHRoZSBjYW52YXMuXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24sIGNhbGxzIHRoZSBtb2RpZnkgbWV0aG9kcyBpZiB0aGUgYm9vbGVhbnMgc2F0aXNmeSB0aGVtLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRNb3VzZVBvc2l0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5RHJhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemUodGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0NoYW5naW5nRGltcyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXModGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIGNsaWNrcyBpbnNpZGUgdGhlIGNhbnZhcy5cbiAgICAgKiBNb2RpZmllcyB0aGUgc3RhdGUgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGd1aWRlcyBjb250YWluIHRoZSBtb3VzZSBvciB0aGUgYm91bmRpbmcgcmVjdCBjb250YWlucyB0aGUgbW91c2UuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVN0YXRlKHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSwgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgdW5jbGlja3MuXG4gICAgICogQ2FsbHMgbW9kaWZ5UmVzZXQgdG8gcmVzZXQgZHJhZ2dpbmcgYW5kIHJlc2l6aW5nIGJvb2xlYW5zIGFtb25nIG90aGVycy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNldXAgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlSZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcHJlc3NlZCBkb3duXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcHJlc3NlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdERvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdFVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBNb2RpZmljYXRpb24gZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGRyYWcgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBtb2RpZnlEcmFnKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiZXBoYW5nbGUgZHJhZ29mZng6IFwiICsgdGhpcy5fZHJhZ29mZngpO1xuICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS54IC0gdGhpcy5fZHJhZ29mZng7XG4gICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLl9kcmFnb2ZmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkICh3aGVuIGEgY29ybmVyIGd1aWRlIGlzIGNsaWNrZWQgYW5kIGRyYWdnZWQpLlxuICAgICAqXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMCBhbmQgdGhlIG90aGVyIGVxdWFsIHRvXG4gICAgICogMTAgZGl2aWRlZCBvciBtdWx0aXBsaWVkIGJ5IHRoZSByYXRpbyBvZiB3aWR0aC9oZWlnaHQgdG8ga2VlcCBpdCB0aGUgc2FtZS5cbiAgICAgKlxuICAgICAqIFRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIGlzIGRvbmUgYnkgY2FsbGluZyB0aGUgaGVscGVyIG1ldGhvZCBtb2RpZnlSZXNpemVIZWxwZXIuXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9lcGgud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMCAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fZXBoLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDEwIC8gdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2VwaC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwICogdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9lcGgud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyAxLCAyLCBvciA0IGFyZSBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0Rpc3RhbmNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBtb3VzZSBhbmQgdGhlIGxvY2F0aW9uIG9wcG9zaXRlIHRvIGl0XG4gICAgICogKGlmIHRvcCByaWdodCBndWlkZSBpcyBjbGlja2VkLCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGFuZCB0aGUgYm90dG9tIGxlZnQgZ3VpZGUgaXMgbmV3RGlzdGFuY2UpXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgdGhpcy5fZXBoLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgdGhpcy5fZXBoLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkLlxuICAgICAqIElmIGFueSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgdG9vIHNtYWxsLCBpdCBzZXRzIHRoZW0gZXF1YWwgdG8gMTAuXG4gICAgICogQ2FsbHMgbW9kaWZ5Q2hhbmdlRGltc0hlbHBlciB0byBhY3R1YWxseSBkbyB0aGUgd29ya1xuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqL1xuICAgIG1vZGlmeUNoYW5nZURpbXMod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgaWYgKHdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2VwaC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fZXBoLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGUgcmVjdGFuZ2xlIG9yaWdpbmF0ZXMgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIGFuZCBub3QgdGhlIGNlbnRlcixcbiAgICAgKiBpdCBjaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFzIHdlbGwgaWYgZ3VpZGVzIDUgb3IgOCBhcmUgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VwaC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VwaC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VwaC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53ID4gMTAgJiYgdGhpcy5oID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VwaC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIGRlcGVuZGluZyBvbiB0aGUgbW91c2UgcG9zaXRpb24gd2hlbiBjYWxsZWQgKG9uTW91c2VEb3duKVxuICAgICAqIGUuZy4gaWYgdGhlIG1vdXNlIGlzIHdpdGhpbiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIHdoZW4gdGhpcyBpcyBjYWxsZWQsIGlzU2VsZWN0ZWQgPSB0cnVlXG4gICAgICogQHBhcmFtIGd1aWRlQ29udGFpbnNcbiAgICAgKiBAcGFyYW0gY29udGFpbnNcbiAgICAgKi9cbiAgICBtb2RpZnlTdGF0ZShndWlkZUNvbnRhaW5zLCBjb250YWlucykge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kxID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gMCAmJiBndWlkZUNvbnRhaW5zIDw9IDQpIHsgLy9yZXNpemluZ1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gdGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0MSA9IHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoMSA9IHRoaXMudztcbiAgICAgICAgICAgIC8vdGhpcy5fc2l6ZTEgPSBNYXRoLnNxcnQoTWF0aC5wb3codywyKSArIE1hdGgucG93KGgsMikpOyAvLyBzaXplIGlzIGRpYWdvbmFsIGxlbmd0aFxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5ICsgaCAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiA0KSB7IC8vY2hhbmdpbmcgc2hhcGUgZGltZW5zaW9uc1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSBndWlkZUNvbnRhaW5zO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5ICsgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgdGhpcy5feDEgPSB4OyAvLyBTYXZpbmcgb3JpZ2luYWwgeCBhbmQgeVxuICAgICAgICAgICAgdGhpcy5feTEgPSB5O1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIHRvIGZhbHNlIChsaWtlIGRyYWdnaW5nLCByZXNpemluZywgZXRjKSB3aGVuIHRoZSBtb3VzZSBpcyByZWxlYXNlZFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB0aGlzLngpID4gMSB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHRoaXMueSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh0aGlzLl9pc1Jlc2l6aW5nIHx8IHRoaXMuX2lzQ2hhbmdpbmdEaW1zKSAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc2l6ZTIgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53LCAyKSArIE1hdGgucG93KHRoaXMuaCwgMikpO1xuICAgICAgICAgICAgaWYgKChNYXRoLmFicyh0aGlzLl93aWR0aDEgLSB0aGlzLncpID4gMCkgfHwgKE1hdGguYWJzKHRoaXMuX2hlaWdodDEgLSB0aGlzLmgpID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dSZXNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKi9cbiAgICBnZXRNb3VzZVBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLl9tb3VzZS54ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueDtcbiAgICAgICAgdGhpcy5fbW91c2UueSA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNDaGFuZ2luZ0RpbXMsIGFuZCBpc1NlbGVjdGVkIHRvIGZhbHNlIGlmIHRoZSBtb3VzZSBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBpc01vdXNlT3V0c2lkZShldmVudCkge1xuICAgICAgICBsZXQgbW91c2VYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgbGV0IG1vdXNlWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIGxldCBlcGggPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtb3VzZVggPCBlcGgubGVmdCB8fCBtb3VzZVggPiBlcGgucmlnaHQgfHwgbW91c2VZIDwgZXBoLnRvcCB8fCBtb3VzZVkgPiBlcGguYm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYW4gZXBoIHBhaW50IGV2ZW50XG4gICAgICovXG4gICAgbG9nUGFpbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpbnRFdmVudF8xLlBhaW50RXZlbnQoXCJlcGhcIiwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGFuIGVwaCByZXNpemUgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dSZXNpemUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplRXZlbnRfMS5SZXNpemVFdmVudChcImVwaCB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIE1hdGgucm91bmQodGhpcy5fd2lkdGgxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLl9oZWlnaHQxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLncgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuaCAqIDEwMCkgLyAxMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGFuIGVwaCBjbGljayBldmVudFxuICAgICAqL1xuICAgIGxvZ0NsaWNrKCkge1xuICAgICAgICByZXR1cm4gbmV3IENsaWNrRXZlbnRfMS5DbGlja0V2ZW50KFwiZXBoIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgYXNzaWducyBhbiBJRCB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgaW5pdElEKGlkKSB7XG4gICAgICAgIHRoaXMuaWRPYmogPSB7IF9pZDogaWQgfTtcbiAgICB9XG4gICAgYXN0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIHVwZGF0ZUFTVCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBlcGhcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgZXBoXG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBlcGhcbiAgICAgKi9cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgZXBoXG4gICAgICovXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRGltZW5zaW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgZGltcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVwaCBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGltYWdlXG4gICAgICovXG4gICAgZ2V0IGltYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXBoSW1nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgZXBoXG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkT2JqLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZXBoIGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqL1xuICAgIGdldEp1c3REcmFnZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fanVzdERyYWdnZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIGVwaCBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldEp1c3REcmFnZ2VkKHZhbCkge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZXBoIGlzIGRyYWdnaW5nXG4gICAgICovXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIHNlbGVjdGlvbiBldmVudHNcbiAgICAgKi9cbiAgICB0b1NlbFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiIGVwaCB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIGRyYWcgZXZlbnRzXG4gICAgKi9cbiAgICB0b0RyYWdTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoXCJlcGggd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgZnJvbSBcIiArIHRoaXMuX3gxICsgXCIsIFwiICsgdGhpcy5feTEgKyBcIiB0byBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgSUQgYXNzaWdubWVudCBldmVudHNcbiAgICAgKi9cbiAgICB0b0lEU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaWRPYmouX2lkLnRvU3RyaW5nKCkgKyBcIiB0byBlcGggYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXBoRWZmZWN0ID0gRXBoRWZmZWN0O1xuLyoqXG4gKiBHZXRzIHRoZSBtb3VzZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGluIHJlbGF0aW9uIHRvIHRoZSBjYW52YXNcbiAqIEBwYXJhbSBjYW52YXMgdGhlIGNhbnZhcyBvYmplY3RcbiAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGdldE1vdXNlUG9zKGNhbnZhcywgZXZlbnQpIHtcbiAgICBsZXQgZXBoID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSBlcGgubGVmdCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIGVwaC50b3BcbiAgICB9O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0geDEgeCBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geTEgeSBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geDIgeCBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICogQHBhcmFtIHkyIHkgY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDIsIDIpICsgTWF0aC5wb3coeTEgLSB5MiwgMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXBoRWZmZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBQYWludEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9QYWludEV2ZW50XCIpO1xuY29uc3QgUmVzaXplRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1Jlc2l6ZUV2ZW50XCIpO1xuY29uc3QgQ2xpY2tFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvQ2xpY2tFdmVudFwiKTtcbmNsYXNzIExpbmVFZmZlY3Qge1xuICAgIGNvbnN0cnVjdG9yKGxpbmUpIHtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBwcml2YXRlIGJvb2xzXG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JhdGlvID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnggPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IDA7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX21vdXNlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbGluZSA9IGxpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiBldmFsdWF0aW5nIG5vZGVzIChTdHJpbmdOb2RlLCBFbGxpcHNlTm9kZSwgZXRjKVxuICAgICAqIFRoaXMgbWV0aG9kIGFzc2lnbnMgYWxsIHBhcmFtcyB0byBwcml2YXRlIHZhcmlhYmxlcyBhbmQgZHJhd3MgdGhlIGluaXRpYWwgb2JqZWN0IHRvIHRoZSBjYW52YXNcbiAgICAgKiBieSBjYWxsaW5nIHVwZGF0ZSgpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIHBhcmVudCBTY29wZSB0aGF0IGNvbnRhaW5zIHRoZSBjYW52YXMgYW1vbmcgb3RoZXIgdGhpbmdzXG4gICAgICogQHBhcmFtIGRpbXMgVGhlIG9iamVjdCdzIGRpbWVuc2lvbnMgaW5jbHVkaW5nIHggYW5kIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gYXN0IFVubmVjZXNzYXJ5IG5vdywgdXNlZCB0byBiZSB0aGUgcGFyZW50IEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNhbnZhcy5pc0RlZmluZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZGltcyA9IGRpbXM7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBjb250ZXh0LmNhbnZhcy5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgbGV0IGN0eCA9IGNvbnRleHQuY2FudmFzLmdldCgpLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dQYWludCgpKTtcbiAgICAgICAgY29udGV4dC5lZmZlY3RzLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGluIG9yZGVyIHRvIGRyYXcgYW5kIHJlZHJhdyB0aGUgb2JqZWN0IHdoZW4gbWFuaXB1bGF0aW9ucyBhcmUgbWFkZVxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnc7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmg7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgdGhpcy5fY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSBcIiM2NzNBQjdcIjtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3R3VpZGVzKHgsIHksIHdpZHRoLCBoZWlnaHQsIHRoaXMuX2Nvcm5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gb25lIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7IC8vIGJpbmQgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIG1lYW5pbmcgb2YgJ3RoaXMnXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25TaGlmdERvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25TaGlmdFVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy9tYWtlcyBpdCBzbyB0aGF0IGRvdWJsZSBjbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0ZXh0IG9uIHRoZSBwYWdlXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uIChlKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGZhbHNlOyB9LCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIGFub3RoZXIgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvZiB0aGUgb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgY29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAobXggPiB4ICYmIG14IDwgeCArIHcgJiYgbXkgPiB5ICYmIG15IDwgeSArIGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciA+IDAgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvbmUgb2YgdGhlIGNvcm5lci9zaWRlIGd1aWRlcywgcmV0dXJucyAwIGlmIG5vdFxuICAgICAqIFRoZSBjb3JuZXIgZ3VpZGVzIGFyZSBudW1iZXJlZCAxLTQgd2l0aCAxIGJlaW5nIHRoZSB0b3AgbGVmdCwgMiBiZWluZyB0aGUgdG9wIHJpZ2h0LCBhbmQgc28gb24uXG4gICAgICogVGhlIG1pZGRsZSBndWlkZXMgYXJlIG51bWJlcmVkIDUtOCwgd2l0aCA1IGJlaW5nIHRoZSB0b3AgbWlkZGxlLCA2IGJlaW5nIHRoZSByaWdodCBtaWRkbGUsIGFuZCBzbyBvbi5cbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ3VpZGVDb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGxldCB4ZGlmID0gbXggLSB4O1xuICAgICAgICBsZXQgeWRpZiA9IG15IC0geTtcbiAgICAgICAgLyogQ29ybmVyIEd1aWRlcyAqL1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIGxlZnRcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogTWlkZGxlIEd1aWRlcyAqL1xuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0geTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGFuZCBndWlkZXMgZm9yIHRoZSBvYmplY3Qgd2hlbiB0aGUgb2JqZWN0IGlzIHNlbGVjdGVkXG4gICAgICogSWYgb25lIG9mIHRoZSBndWlkZXMgaXMgc2VsZWN0ZWQsIGl0IGNvbG9ycyB0aGF0IGd1aWRlIGJsdWVcbiAgICAgKiBAcGFyYW0geCB0aGUgeCBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0geSB0aGUgeSBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb3JuZXIgdGhlIG51bWJlciBvZiB0aGUgY29ybmVyIHRvIGJlIGNvbG9yZWQgYmx1ZSAoaWYgYW55IGF0IGFsbCwgaWYgMCwgYWxsIGFyZSB3aGl0ZSlcbiAgICAgKi9cbiAgICBkcmF3R3VpZGVzKHgsIHksIHcsIGgsIGNvcm5lcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKGNvcm5lciAhPT0gMCAmJiBjb3JuZXIgPD0gNCkgeyAvLyBhIGNvcm5lciBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcnJlY3QgZ3VpZGUgYmx1ZVxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3JuZXIgIT09IDApIHsgLy8gYSBtaWRkbGUgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vaWYgbm8gZ3VpZGVzIGFyZSBzZWxlY3RlZCwgY29sb3JzIGV2ZXJ5dGhpbmcgd2hpdGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBtZXRob2QgdGhhdCBkcmF3cyBhIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB4IHggY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHkgeSBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gdyB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29sb3IgY29sb3Igb2YgdGhlIHJlY3RhbmdsZSdzIGZpbGxcbiAgICAgKi9cbiAgICBkcmF3U3F1YXJlKHgsIHksIHcsIGgsIGNvbG9yKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBtb3ZlcyB3aXRoaW4gdGhlIGNhbnZhcy5cbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiwgY2FsbHMgdGhlIG1vZGlmeSBtZXRob2RzIGlmIHRoZSBib29sZWFucyBzYXRpc2Z5IHRoZW0uXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICB0aGlzLmdldE1vdXNlUG9zaXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlEcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZXNpemluZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZSh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQ2hhbmdpbmdEaW1zICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltcyh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5U3RhdGUodGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpLCB0aGlzLmNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSB1bmNsaWNrcy5cbiAgICAgKiBDYWxscyBtb2RpZnlSZXNldCB0byByZXNldCBkcmFnZ2luZyBhbmQgcmVzaXppbmcgYm9vbGVhbnMgYW1vbmcgb3RoZXJzLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2V1cCBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VVcChldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyBwcmVzc2VkIGRvd25cbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSBwcmVzc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcmVsZWFzZWRcbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSByZWxlYXNlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdFVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBNb2RpZmljYXRpb24gZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGRyYWcgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBtb2RpZnlEcmFnKCkge1xuICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS54IC0gdGhpcy5fZHJhZ29mZng7XG4gICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLl9kcmFnb2ZmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkICh3aGVuIGEgY29ybmVyIGd1aWRlIGlzIGNsaWNrZWQgYW5kIGRyYWdnZWQpLlxuICAgICAqXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMCBhbmQgdGhlIG90aGVyIGVxdWFsIHRvXG4gICAgICogMTAgZGl2aWRlZCBvciBtdWx0aXBsaWVkIGJ5IHRoZSByYXRpbyBvZiB3aWR0aC9oZWlnaHQgdG8ga2VlcCBpdCB0aGUgc2FtZS5cbiAgICAgKlxuICAgICAqIFRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIGlzIGRvbmUgYnkgY2FsbGluZyB0aGUgaGVscGVyIG1ldGhvZCBtb2RpZnlSZXNpemVIZWxwZXIuXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9saW5lLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTsgLy8gc2V0IGZvciB0aGUgcHJvZGlyZWN0IG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMCAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fbGluZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDEwIC8gdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApOyAvLyBzZXQgZm9yIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgKiB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2xpbmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyAxLCAyLCBvciA0IGFyZSBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0Rpc3RhbmNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBtb3VzZSBhbmQgdGhlIGxvY2F0aW9uIG9wcG9zaXRlIHRvIGl0XG4gICAgICogKGlmIHRvcCByaWdodCBndWlkZSBpcyBjbGlja2VkLCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGFuZCB0aGUgYm90dG9tIGxlZnQgZ3VpZGUgaXMgbmV3RGlzdGFuY2UpXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgdGhpcy5fbGluZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW87XG4gICAgICAgIHRoaXMuX2xpbmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZC5cbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDEwLlxuICAgICAqIENhbGxzIG1vZGlmeUNoYW5nZURpbXNIZWxwZXIgdG8gYWN0dWFsbHkgZG8gdGhlIHdvcmtcbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9saW5lLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9saW5lLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIHRoZSByZWN0YW5nbGUgb3JpZ2luYXRlcyBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgYW5kIG5vdCB0aGUgY2VudGVyLFxuICAgICAqIGl0IGNoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXMgd2VsbCBpZiBndWlkZXMgNSBvciA4IGFyZSBzZWxlY3RlZFxuICAgICAqL1xuICAgIG1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKSB7XG4gICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaCA+IDEwKSB7IC8vYXMgbG9uZyBhcyB0aGUgaGVpZ2h0IGlzID4gMTBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLncgPiAxMCkgeyAvLyBhcyBsb25nIGFzIHdpZHRoIGlzID4gMTBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyBkZXBlbmRpbmcgb24gdGhlIG1vdXNlIHBvc2l0aW9uIHdoZW4gY2FsbGVkIChvbk1vdXNlRG93bilcbiAgICAgKiBlLmcuIGlmIHRoZSBtb3VzZSBpcyB3aXRoaW4gdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSB3aGVuIHRoaXMgaXMgY2FsbGVkLCBpc1NlbGVjdGVkID0gdHJ1ZVxuICAgICAqIEBwYXJhbSBndWlkZUNvbnRhaW5zXG4gICAgICogQHBhcmFtIGNvbnRhaW5zXG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGUoZ3VpZGVDb250YWlucywgY29udGFpbnMpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7IC8vcHJlcGFyZXMgdGhlIG9iamVjdCBmb3IgZHJhZ2dpbmcgd2hldGhlciBpdCBpcyBwZXJzb25hbGx5IHNlbGVjdGVkIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5feTEgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiAwICYmIGd1aWRlQ29udGFpbnMgPD0gNCkgeyAvL3Jlc2l6aW5nXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSB0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSk7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQxID0gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy5fd2lkdGgxID0gdGhpcy53O1xuICAgICAgICAgICAgLy90aGlzLl9zaXplMSA9IE1hdGguc3FydChNYXRoLnBvdyh3LDIpICsgTWF0aC5wb3coaCwyKSk7IC8vIHNpemUgaXMgZGlhZ29uYWwgbGVuZ3RoXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikgeyAvLyBzZXRzIHRoZSBvZmZzZXRzIGRlcGVuZGluZyBvbiB3aGljaCBjb3JuZXIgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7IC8vIG9mZnNldCBpcyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7IC8vIG9mZnNldCBpcyBib3R0b20gbGVmdCwgZXRjXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gNCkgeyAvL2NoYW5naW5nIHNoYXBlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gZ3VpZGVDb250YWlucztcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7IC8vIHNldHMgdGhlIG9mZnNldHMgZGVwZW5kaW5nIG9uIHdoaWNoIG1pZGRsZSBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgNTogLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdyAvIDIsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdyAvIDI7IC8vIG9mZnNldCBpcyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogLy9yaWdodCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoIC8gMjsgLy8gb2Zmc2V0IGlzIGxlZnQgbWlkZGxlIGV0Y1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWlucykgeyAvLyBkcmFnZ2luZ1xuICAgICAgICAgICAgdGhpcy5feDEgPSB4OyAvLyBTYXZpbmcgb3JpZ2luYWwgeCBhbmQgeVxuICAgICAgICAgICAgdGhpcy5feTEgPSB5O1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy8gbm90IHNlbGVjdGVkXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyB0byBmYWxzZSAobGlrZSBkcmFnZ2luZywgcmVzaXppbmcsIGV0Yykgd2hlbiB0aGUgbW91c2UgaXMgcmVsZWFzZWRcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0gdGhpcy54KSA+IDEgfHwgTWF0aC5hYnModGhpcy5feTEgLSB0aGlzLnkpID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodGhpcy5faXNSZXNpemluZyB8fCB0aGlzLl9pc0NoYW5naW5nRGltcykgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHNpemUyID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMudywgMikgKyBNYXRoLnBvdyh0aGlzLmgsIDIpKTtcbiAgICAgICAgICAgIGlmICgoTWF0aC5hYnModGhpcy5fd2lkdGgxIC0gdGhpcy53KSA+IDApIHx8IChNYXRoLmFicyh0aGlzLl9oZWlnaHQxIC0gdGhpcy5oKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUmVzaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICovXG4gICAgZ2V0TW91c2VQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbW91c2UueCA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLng7XG4gICAgICAgIHRoaXMuX21vdXNlLnkgPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzQ2hhbmdpbmdEaW1zLCBhbmQgaXNTZWxlY3RlZCB0byBmYWxzZSBpZiB0aGUgbW91c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgaXNNb3VzZU91dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1vdXNlWCA8IHJlY3QubGVmdCB8fCBtb3VzZVggPiByZWN0LnJpZ2h0IHx8IG1vdXNlWSA8IHJlY3QudG9wIHx8IG1vdXNlWSA+IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIHBhaW50IGV2ZW50XG4gICAgICovXG4gICAgbG9nUGFpbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpbnRFdmVudF8xLlBhaW50RXZlbnQoXCJyZWN0YW5nbGVcIiwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIHJlc2l6ZSBldmVudFxuICAgICAqL1xuICAgIGxvZ1Jlc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVFdmVudF8xLlJlc2l6ZUV2ZW50KFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgTWF0aC5yb3VuZCh0aGlzLl93aWR0aDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuX2hlaWdodDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMudyAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5oICogMTAwKSAvIDEwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZWN0YW5nbGUgY2xpY2sgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dDbGljaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGlja0V2ZW50XzEuQ2xpY2tFdmVudChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIGFzc2lnbnMgYW4gSUQgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIGlkIFRoZSBJRCB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIGluaXRJRChpZCkge1xuICAgICAgICB0aGlzLmlkT2JqID0geyBfaWQ6IGlkIH07XG4gICAgfVxuICAgIGFzdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHggcG9zaXRpb24gb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRGltZW5zaW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgZGltcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZE9iai5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICovXG4gICAgZ2V0SnVzdERyYWdnZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdXN0RHJhZ2dlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldEp1c3REcmFnZ2VkKHZhbCkge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBpcyBkcmFnZ2luZ1xuICAgICAqL1xuICAgIGdldCBpc0RyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEcmFnZ2luZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBzZWxlY3Rpb24gZXZlbnRzXG4gICAgICovXG4gICAgdG9TZWxTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIiByZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBkcmFnIGV2ZW50c1xuICAgICovXG4gICAgdG9EcmFnU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94MSArIFwiLCBcIiArIHRoaXMuX3kxICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gcmVjdGFuZ2xlIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG59XG5leHBvcnRzLkxpbmVFZmZlY3QgPSBMaW5lRWZmZWN0O1xuLyoqXG4gKiBHZXRzIHRoZSBtb3VzZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGluIHJlbGF0aW9uIHRvIHRoZSBjYW52YXNcbiAqIEBwYXJhbSBjYW52YXMgdGhlIGNhbnZhcyBvYmplY3RcbiAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGdldE1vdXNlUG9zKGNhbnZhcywgZXZlbnQpIHtcbiAgICBsZXQgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0LFxuICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gcmVjdC50b3BcbiAgICB9O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0geDEgeCBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geTEgeSBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geDIgeCBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICogQHBhcmFtIHkyIHkgY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDIsIDIpICsgTWF0aC5wb3coeTEgLSB5MiwgMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGluZUVmZmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBhaW50RXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1BhaW50RXZlbnRcIik7XG5jb25zdCBSZXNpemVFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUmVzaXplRXZlbnRcIik7XG5jb25zdCBDbGlja0V2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9DbGlja0V2ZW50XCIpO1xuY2xhc3MgTnVtYmVyRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihudW0pIHtcbiAgICAgICAgdGhpcy5fZm9udFNpemUgPSAyMDtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzTGlzdGVuaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSAwO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9tb3VzZSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MgPSB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGludGVydmFsOiAwLFxuICAgICAgICAgICAgc3RyOiBcIlwiLFxuICAgICAgICAgICAgaW5pdE1vdXNlUG9zOiAwLFxuICAgICAgICAgICAgY3Vyc29yUG9zOiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX251bSA9IG51bTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIGV2YWx1YXRpbmcgbm9kZXMgKFN0cmluZ05vZGUsIEVsbGlwc2VOb2RlLCBldGMpXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyBhbGwgcGFyYW1zIHRvIHByaXZhdGUgdmFyaWFibGVzIGFuZCBkcmF3cyB0aGUgaW5pdGlhbCBvYmplY3QgdG8gdGhlIGNhbnZhc1xuICAgICAqIGJ5IGNhbGxpbmcgdXBkYXRlKClcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgcGFyZW50IFNjb3BlIHRoYXQgY29udGFpbnMgdGhlIGNhbnZhcyBhbW9uZyBvdGhlciB0aGluZ3NcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgb2JqZWN0J3MgZGltZW5zaW9ucyBpbmNsdWRpbmcgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBhc3QgVW5uZWNlc3Nhcnkgbm93LCB1c2VkIHRvIGJlIHRoZSBwYXJlbnQgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY2FudmFzICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBjb250ZXh0LmNhbnZhcy5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMgPSBkaW1zO1xuICAgICAgICAgICAgbGV0IGN0eCA9IGNvbnRleHQuY2FudmFzLmdldCgpLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAvLyBsb2dnaW5nXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dQYWludCgpKTsgLy8gdGhpcy5jb250ZXh0IG9yIGNvbnRleHQ/XG4gICAgICAgICAgICBjb250ZXh0LmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2FudmFzIGlzIE5PVCBkZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBpbiBvcmRlciB0byBkcmF3IGFuZCByZWRyYXcgdGhlIG9iamVjdCB3aGVuIG1hbmlwdWxhdGlvbnMgYXJlIG1hZGVcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCBmb250RGVldHMgPSB0aGlzLl9mb250U2l6ZSArIFwicHggQ291cmllciBOZXdcIjtcbiAgICAgICAgdGhpcy5fY3R4LmZvbnQgPSBmb250RGVldHM7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBcIiM2NzNBQjdcIjtcbiAgICAgICAgbGV0IHN0ciA9IHRoaXMuX251bS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFRleHQoc3RyLCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIGxldCBudW1iZXJEaW1zID0gdGhpcy5fY3R4Lm1lYXN1cmVUZXh0KHN0cik7XG4gICAgICAgIHRoaXMuX251bWJlck1ldHJpY3Mud2lkdGggPSBudW1iZXJEaW1zLndpZHRoO1xuICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmhlaWdodCA9IHRoaXMuX2ZvbnRTaXplO1xuICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLnN0ciA9IHN0cjtcbiAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5pbnRlcnZhbCA9IHRoaXMuX251bWJlck1ldHJpY3Mud2lkdGggLyB0aGlzLl9udW1iZXJNZXRyaWNzLnN0ci5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdUZXh0R3VpZGVzKHRoaXMueCwgdGhpcy55IC0gdGhpcy5fZm9udFNpemUsIHRoaXMuX251bWJlck1ldHJpY3Mud2lkdGgsIHRoaXMuX251bWJlck1ldHJpY3MuaGVpZ2h0LCB0aGlzLl9jb3JuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIG9uZSBmZWxsIHN3b29wXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpOyAvLyBiaW5kIGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBtZWFuaW5nIG9mICd0aGlzJ1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uU2hpZnREb3duLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uU2hpZnRVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaXNNb3VzZU91dHNpZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vbWFrZXMgaXQgc28gdGhhdCBkb3VibGUgY2xpY2tpbmcgZG9lc24ndCBzZWxlY3QgdGV4dCBvbiB0aGUgcGFnZVxuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBmdW5jdGlvbiAoZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IHJldHVybiBmYWxzZTsgfSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBhbm90aGVyIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb2YgdGhlIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSwgZmFsc2UgaWYgb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICByZXR1cm4gKHRoaXMueCA8PSBteCkgJiYgKHRoaXMueCArIHRoaXMuX251bWJlck1ldHJpY3Mud2lkdGggPj0gbXgpICYmXG4gICAgICAgICAgICAodGhpcy55IC0gdGhpcy5fZm9udFNpemUgPD0gbXkpICYmICh0aGlzLnkgPj0gbXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbnVtYmVyID4gMCBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9uZSBvZiB0aGUgY29ybmVyL3NpZGUgZ3VpZGVzLCByZXR1cm5zIDAgaWYgbm90XG4gICAgICogVGhlIGNvcm5lciBndWlkZXMgYXJlIG51bWJlcmVkIDEtNCB3aXRoIDEgYmVpbmcgdGhlIHRvcCBsZWZ0LCAyIGJlaW5nIHRoZSB0b3AgcmlnaHQsIGFuZCBzbyBvbi5cbiAgICAgKiBUaGUgbWlkZGxlIGd1aWRlcyBhcmUgbnVtYmVyZWQgNS04LCB3aXRoIDUgYmVpbmcgdGhlIHRvcCBtaWRkbGUsIDYgYmVpbmcgdGhlIHJpZ2h0IG1pZGRsZSwgYW5kIHNvIG9uLlxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBndWlkZUNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeGRpZiA9IG14IC0gKHRoaXMueCArIHRoaXMuX251bWJlck1ldHJpY3Mud2lkdGgpO1xuICAgICAgICBsZXQgeWRpZiA9IG15IC0gKHRoaXMueSAtIHRoaXMuX2ZvbnRTaXplKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkge1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBhbmQgZ3VpZGVzIGZvciB0aGUgb2JqZWN0IHdoZW4gdGhlIG9iamVjdCBpcyBzZWxlY3RlZFxuICAgICAqIElmIG9uZSBvZiB0aGUgZ3VpZGVzIGlzIHNlbGVjdGVkLCBpdCBjb2xvcnMgdGhhdCBndWlkZSBibHVlXG4gICAgICogQHBhcmFtIHggdGhlIHggY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHkgdGhlIHkgY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHcgdGhlIHdpZHRoIG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29ybmVyIHRoZSBudW1iZXIgb2YgdGhlIGNvcm5lciB0byBiZSBjb2xvcmVkIGJsdWUgKGlmIGFueSBhdCBhbGwsIGlmIDAsIGFsbCBhcmUgd2hpdGUpXG4gICAgICovXG4gICAgZHJhd1RleHRHdWlkZXMoeCwgeSwgdywgaCwgY29ybmVyKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAoY29ybmVyICE9PSAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgZ3VpZGUgYmx1ZSBpZiBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltcGxlIG1ldGhvZCB0aGF0IGRyYXdzIGEgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHggeCBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geSB5IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB3IHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb2xvciBjb2xvciBvZiB0aGUgcmVjdGFuZ2xlJ3MgZmlsbFxuICAgICAqL1xuICAgIGRyYXdTcXVhcmUoeCwgeSwgdywgaCwgY29sb3IpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvKiBFdmVudCBsaXN0ZW5lciBmdW5jdGlvbnMgKi9cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIHdpdGhpbiB0aGUgY2FudmFzLlxuICAgICAqIEdldHMgdGhlIG1vdXNlIHBvc2l0aW9uLCBjYWxscyB0aGUgbW9kaWZ5IG1ldGhvZHMgaWYgdGhlIGJvb2xlYW5zIHNhdGlzZnkgdGhlbS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZ2V0TW91c2VQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCAmJiB0aGlzLl9pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeURyYWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jlc2l6aW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplKHRoaXMuX2ZvbnRTaXplIDwgMTUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSAmJiB0aGlzLl9pc1NlbGVjdGVkICYmIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpIHsgLy90ZXh0IGVkaXRpbmdcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMubW9kaWZ5VGV4dC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2lzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmluaXRNb3VzZVBvcyA9IHRoaXMuX21vdXNlLng7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGlmeVN0YXRlKHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSA+IDAsIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIHVuY2xpY2tzLlxuICAgICAqIENhbGxzIG1vZGlmeVJlc2V0IHRvIHJlc2V0IGRyYWdnaW5nIGFuZCByZXNpemluZyBib29sZWFucyBhbW9uZyBvdGhlcnMuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZXVwIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5UmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHByZXNzZWQgZG93blxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHByZXNzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnREb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyByZWxlYXNlZFxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHJlbGVhc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0VXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIE1vZGlmaWNhdGlvbiBmdW5jdGlvbnMgKi9cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgaW4gb3JkZXIgdG8gZHJhZyB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIG1vZGlmeURyYWcoKSB7XG4gICAgICAgIC8vKFwic3RyaW5nIGRyYWdvZmZ4OiBcIiArIHRoaXMuX2RyYWdvZmZ4KTtcbiAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueCAtIHRoaXMuX2RyYWdvZmZ4O1xuICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy5fZHJhZ29mZnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIG1vdmVzIHRoZSB0ZXh0IGVkaXQgY3Vyc29yIGJhc2VkIG9uIHdoZXJlIHRoZSBtb3VzZSBpcyBjbGlja2VkXG4gICAgICovXG4gICAgbW9kaWZ5VGV4dEN1cnNvcigpIHtcbiAgICAgICAgbGV0IGxlZnRXYWxsID0gdGhpcy54OyAvLyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgbGVmdCBtb3N0IHNpZGUgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAgICBsZXQgeERpZiA9IHRoaXMuX251bWJlck1ldHJpY3MuaW5pdE1vdXNlUG9zIC0gbGVmdFdhbGw7IC8vIGRpZmZlcmVuY2UgYmV0d2VlbiBtb3VzZSB4IGFuZCBsZWZ0IHdhbGxcbiAgICAgICAgbGV0IGludGVydmFsID0gdGhpcy5fbnVtYmVyTWV0cmljcy5pbnRlcnZhbDsgLy8gdGhlIHRleHQgd2lkdGggZGl2aWRlZCBieSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmdcbiAgICAgICAgbGV0IG1vdmVGYWN0b3IgPSAwO1xuICAgICAgICBpZiAoeERpZiA+PSBpbnRlcnZhbCAvIDIgJiYgeERpZiA8PSBpbnRlcnZhbCkge1xuICAgICAgICAgICAgbW92ZUZhY3RvciA9IGxlZnRXYWxsICsgaW50ZXJ2YWw7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmN1cnNvclBvcyA9IGludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHhEaWYgPD0gaW50ZXJ2YWwgLyAyKSB7XG4gICAgICAgICAgICBtb3ZlRmFjdG9yID0gbGVmdFdhbGw7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmN1cnNvclBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeERpZiAlIGludGVydmFsID49IGludGVydmFsIC8gMikge1xuICAgICAgICAgICAgbW92ZUZhY3RvciA9IGxlZnRXYWxsICsgaW50ZXJ2YWwgKiBNYXRoLmNlaWwoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuY3Vyc29yUG9zID0gaW50ZXJ2YWwgKiBNYXRoLmNlaWwoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4RGlmICUgaW50ZXJ2YWwgPCBpbnRlcnZhbCAvIDIpIHtcbiAgICAgICAgICAgIG1vdmVGYWN0b3IgPSBsZWZ0V2FsbCArIGludGVydmFsICogTWF0aC5mbG9vcih4RGlmIC8gaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5jdXJzb3JQb3MgPSBpbnRlcnZhbCAqIE1hdGguZmxvb3IoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdHgubW92ZVRvKG1vdmVGYWN0b3IsIHRoaXMueSAtIHRoaXMuX2ZvbnRTaXplKTtcbiAgICAgICAgdGhpcy5fY3R4LmxpbmVUbyhtb3ZlRmFjdG9yLCB0aGlzLnkpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSBcImdyZXlcIjtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGVkaXRzIHRoZSBzdHJpbmcgd2hlbiBlZGl0aW5nIHRleHRcbiAgICAgKiBAcGFyYW0gZXZlbnQga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG1vZGlmeVRleHQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRWRpdGluZykge1xuICAgICAgICAgICAgbGV0IGZpcnN0SGFsZjtcbiAgICAgICAgICAgIGxldCBzZWNvbmRIYWxmO1xuICAgICAgICAgICAgbGV0IHN0ciA9IHRoaXMuX251bS50b1N0cmluZygpO1xuICAgICAgICAgICAgbGV0IGJyZWFrUG9pbnQgPSB0aGlzLl9udW1iZXJNZXRyaWNzLmN1cnNvclBvcyAvIHRoaXMuX251bWJlck1ldHJpY3MuaW50ZXJ2YWw7XG4gICAgICAgICAgICBmaXJzdEhhbGYgPSBzdHIuc3Vic3RyaW5nKDAsIGJyZWFrUG9pbnQpO1xuICAgICAgICAgICAgc2Vjb25kSGFsZiA9IHN0ci5zdWJzdHJpbmcoYnJlYWtQb2ludCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNyAmJiB0aGlzLl9udW1iZXJNZXRyaWNzLmluaXRNb3VzZVBvcyA+IHRoaXMueCArIHRoaXMuX251bWJlck1ldHJpY3MuaW50ZXJ2YWwgLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5pbml0TW91c2VQb3MgLT0gdGhpcy5fbnVtYmVyTWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzkgJiYgdGhpcy5fbnVtYmVyTWV0cmljcy5pbml0TW91c2VQb3MgPCB0aGlzLnggKyB0aGlzLl9udW1iZXJNZXRyaWNzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5pbml0TW91c2VQb3MgKz0gdGhpcy5fbnVtYmVyTWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gOCAmJiBzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpcnN0SGFsZiA9IGZpcnN0SGFsZi5zdWJzdHJpbmcoMCwgZmlyc3RIYWxmLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIHN0ciA9IGZpcnN0SGFsZiArIHNlY29uZEhhbGY7XG4gICAgICAgICAgICAgICAgdGhpcy5fbnVtLnZhbCA9IE51bWJlcihzdHIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuaW5pdE1vdXNlUG9zIC09IHRoaXMuX251bWJlck1ldHJpY3MuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQga2V5TmFtZSA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5TmFtZS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEhhbGYgKz0ga2V5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gZmlyc3RIYWxmICsgc2Vjb25kSGFsZjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbnVtLnZhbCA9IE51bWJlcihzdHIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmluaXRNb3VzZVBvcyArPSB0aGlzLl9udW1iZXJNZXRyaWNzLmludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9kaWZpZXMgdGhlIGZvbnQgc2l6ZSBvZiB0aGUgdGV4dFxuICAgICAqIElmIHRoZSB0ZXh0IGZvbnQgaXMgc21hbGxlciB0aGFuIDE1cHQsIGl0IHNldCdzIGl0IGVxdWFsIHRvIDE1cHRcbiAgICAgKiBAcGFyYW0gaXNUb29TbWFsbCB0cnVlIGlmIHRoZSBmb250IHNpemUgaXMgPCAxNVxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZShpc1Rvb1NtYWxsKSB7XG4gICAgICAgIGlmIChpc1Rvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9mb250U2l6ZSA9IDE1O1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250U2l6ZSArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMC4yO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAwLjI7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyBkZXBlbmRpbmcgb24gdGhlIG1vdXNlIHBvc2l0aW9uIHdoZW4gY2FsbGVkIChvbk1vdXNlRG93bilcbiAgICAgKiBlLmcuIGlmIHRoZSBtb3VzZSBpcyB3aXRoaW4gdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSB3aGVuIHRoaXMgaXMgY2FsbGVkLCBpc1NlbGVjdGVkID0gdHJ1ZVxuICAgICAqIEBwYXJhbSBndWlkZUNvbnRhaW5zXG4gICAgICogQHBhcmFtIGNvbnRhaW5zXG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGUoZ3VpZGVDb250YWlucywgY29udGFpbnMpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy9wcmVwYXJlcyB0aGUgb2JqZWN0IGZvciBkcmFnZ2luZyB3aGV0aGVyIGl0IGlzIHBlcnNvbmFsbHkgc2VsZWN0ZWQgb3Igbm90XG4gICAgICAgICAgICBpZiAoY29udGFpbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZih0aGlzLl9jb250ZXh0Lm11bFNlbGVjdGVkLm11bFNlbCl7XG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJzdHJpbmcgZWZmZWN0IG11bFNlbGVjdGVkOiBcIiArIHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQubXVsU2VsKTtcbiAgICAgICAgICAgIC8vICAgICAvL2lmKHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQudmFsKXtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dTZWxlY3RlZCgpKTtcbiAgICAgICAgICAgIC8vICAgICAvL3RoaXMubG9nU2VsZWN0ZWQoKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zKSB7IC8vaWYgdGhlIGNvcm5lciBndWlkZXMgY29udGFpbiB0aGUgbW91c2Ugd2UgYXJlIHJlc2l6aW5nXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLng7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMueTtcbiAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZTEgPSB0aGlzLl9mb250U2l6ZTsgLy8gc2F2aW5nIG9sZCBmb250IHNpemVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgdGhpcy5feCA9IHRoaXMueDsgLy8gU2F2aW5nIG9yaWdpbmFsIHggYW5kIHlcbiAgICAgICAgICAgIHRoaXMuX3kgPSB0aGlzLnk7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyB0byBmYWxzZSAobGlrZSBkcmFnZ2luZywgcmVzaXppbmcsIGV0Yykgd2hlbiB0aGUgbW91c2UgaXMgcmVsZWFzZWRcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3ggLSB0aGlzLngpID4gMSB8fCBNYXRoLmFicyh0aGlzLl95IC0gdGhpcy55KSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy90aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dNb3ZlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3NpemUxIC0gdGhpcy5fZm9udFNpemUpID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1Jlc2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJzdHJpbmcgZWZmZWN0IG11bFNlbGVjdGVkOiBcIiArIHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQudmFsKTtcbiAgICAgICAgLy8gaWYodGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC52YWwpe1xuICAgICAgICAvLyAgICAgdGhpcy5sb2dTZWxlY3RlZCgpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmKHRoaXMuaXNNdWx0aXBsZVNlbGVjdGVkKXtcbiAgICAgICAgLy8gICAgIGNvbnRleHQuZXZlbnRMb2cucHVzaChuZXcgU2VsZWN0RXZlbnQoc2VsZWN0ZWRFbGVtcykpO1xuICAgICAgICAvLyAgICAgbWFzdGVyTG9nLnB1c2goY29udGV4dC5ldmVudExvZ1tjb250ZXh0LmV2ZW50TG9nLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgLy8gICAgIC8vY29uc29sZS5sb2coXCJtdWx0aXBsZSBzZWxlY3RlZFwiKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyAvL3RoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ01vdmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKi9cbiAgICBnZXRNb3VzZVBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLl9tb3VzZS54ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueDtcbiAgICAgICAgdGhpcy5fbW91c2UueSA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNDaGFuZ2luZ0RpbXMsIGFuZCBpc1NlbGVjdGVkIHRvIGZhbHNlIGlmIHRoZSBtb3VzZSBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBpc01vdXNlT3V0c2lkZShldmVudCkge1xuICAgICAgICBsZXQgbW91c2VYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgbGV0IG1vdXNlWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5fY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobW91c2VYIDwgcmVjdC5sZWZ0IHx8IG1vdXNlWCA+IHJlY3QucmlnaHQgfHwgbW91c2VZIDwgcmVjdC50b3AgfHwgbW91c2VZID4gcmVjdC5ib3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcGFpbnQgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dQYWludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWludEV2ZW50XzEuUGFpbnRFdmVudCh0aGlzLl9udW0udG9TdHJpbmcoKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVzaXplIGV2ZW50XG4gICAgICovXG4gICAgbG9nUmVzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZUV2ZW50XzEuUmVzaXplRXZlbnQodGhpcy5fbnVtLnRvU3RyaW5nKCkgKyBcIiB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIE1hdGgucm91bmQodGhpcy5fc2l6ZTEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuX2ZvbnRTaXplICogMTAwKSAvIDEwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSBjbGljayBldmVudFxuICAgICAqL1xuICAgIGxvZ0NsaWNrKCkge1xuICAgICAgICByZXR1cm4gbmV3IENsaWNrRXZlbnRfMS5DbGlja0V2ZW50KHRoaXMuX251bS50b1N0cmluZygpICsgXCIgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCBhc3NpZ25zIGFuIElEIHRvIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSBpZCBUaGUgSUQgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBpbml0SUQoaWQpIHtcbiAgICAgICAgdGhpcy5pZE9iaiA9IHsgX2lkOiBpZCwgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2FudmFzXG4gICAgICovXG4gICAgZ2V0IGNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGNhbnZhcyBUaGUgY2FudmFzIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgc2V0IGNhbnZhcyhjYW52YXMpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgIH1cbiAgICBhc3QoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBudW1iZXJcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERpbWVuc2lvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVsbGlwc2UgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgKi9cbiAgICBnZXRKdXN0RHJhZ2dlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1c3REcmFnZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgc2V0SnVzdERyYWdnZWQodmFsKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGlzIGRyYWdnaW5nXG4gICAgICovXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXJcbiAgICAgKi9cbiAgICBnZXQgbnVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbnVtLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb2JqZWN0IElEXG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkT2JqLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBzZWxlY3Rpb24gZXZlbnRzXG4gICAgICovXG4gICAgdG9TZWxTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIiBcIiArIHRoaXMuX251bS50b1N0cmluZygpICsgXCIgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBkcmFnIGV2ZW50c1xuICAgICovXG4gICAgdG9EcmFnU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX251bS50b1N0cmluZygpICsgXCIgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgZnJvbSBcIiArIHRoaXMuX3ggKyBcIiwgXCIgKyB0aGlzLl95ICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gXCIgKyB0aGlzLl9udW0udG9TdHJpbmcoKSArIFwiIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG59XG5leHBvcnRzLk51bWJlckVmZmVjdCA9IE51bWJlckVmZmVjdDtcbi8qKlxuICogR2V0J3MgdGhlIG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZXMgaW4gcmVsYXRpb24gdG8gdGhlIGNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB0aGUgY2FudmFzIG9iamVjdFxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0TW91c2VQb3MoY2FudmFzLCBldmVudCkge1xuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB4MSB4IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB5MSB5IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB4MiB4IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKiBAcGFyYW0geTIgeSBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MiwgMikgKyBNYXRoLnBvdyh5MSAtIHkyLCAyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OdW1iZXJFZmZlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IFBhaW50RXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1BhaW50RXZlbnRcIik7XG5jb25zdCBSZXNpemVFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUmVzaXplRXZlbnRcIik7XG5jb25zdCBDbGlja0V2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9DbGlja0V2ZW50XCIpO1xuY2xhc3MgUmVjdGFuZ2xlRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihyZWN0KSB7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTsgLy8gcHJpdmF0ZSBib29sc1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yYXRpbyA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSAwO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9tb3VzZSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gZXZhbHVhdGluZyBub2RlcyAoU3RyaW5nTm9kZSwgRWxsaXBzZU5vZGUsIGV0YylcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3NpZ25zIGFsbCBwYXJhbXMgdG8gcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIGRyYXdzIHRoZSBpbml0aWFsIG9iamVjdCB0byB0aGUgY2FudmFzXG4gICAgICogYnkgY2FsbGluZyB1cGRhdGUoKVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBwYXJlbnQgU2NvcGUgdGhhdCBjb250YWlucyB0aGUgY2FudmFzIGFtb25nIG90aGVyIHRoaW5nc1xuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBvYmplY3QncyBkaW1lbnNpb25zIGluY2x1ZGluZyB4IGFuZCB5IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGFzdCBVbm5lY2Vzc2FyeSBub3csIHVzZWQgdG8gYmUgdGhlIHBhcmVudCBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBpZiAoY29udGV4dC5jYW52YXMuaXNEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMgPSBkaW1zO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gY29udGV4dC5jYW52YXMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0LmNhbnZhcy5nZXQoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUGFpbnQoKSk7XG4gICAgICAgIGNvbnRleHQuZWZmZWN0cy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBpbiBvcmRlciB0byBkcmF3IGFuZCByZWRyYXcgdGhlIG9iamVjdCB3aGVuIG1hbmlwdWxhdGlvbnMgYXJlIG1hZGVcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy53O1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5oO1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvL3RoaXMuX2N0eC5zdHJva2VTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgLy90aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBcIiNkNWI4ZmZcIjtcbiAgICAgICAgdGhpcy5fY3R4LnNoYWRvd0NvbG9yID0gXCIjNkM2QzZDXCI7XG4gICAgICAgIHRoaXMuX2N0eC5zaGFkb3dCbHVyID0gMTU7XG4gICAgICAgIC8vdGhpcy5fY3R4LnNoYWRvd09mZnNldFggPSAyO1xuICAgICAgICAvL3RoaXMuX2N0eC5zaGFkb3dPZmZzZXRZID0gMjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGwoKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0d1aWRlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0aGlzLl9jb3JuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIG9uZSBmZWxsIHN3b29wXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpOyAvLyBiaW5kIGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBtZWFuaW5nIG9mICd0aGlzJ1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uU2hpZnREb3duLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uU2hpZnRVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaXNNb3VzZU91dHNpZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vbWFrZXMgaXQgc28gdGhhdCBkb3VibGUgY2xpY2tpbmcgZG9lc24ndCBzZWxlY3QgdGV4dCBvbiB0aGUgcGFnZVxuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBmdW5jdGlvbiAoZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IHJldHVybiBmYWxzZTsgfSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBhbm90aGVyIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb2YgdGhlIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSwgZmFsc2UgaWYgb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgaWYgKG14ID4geCAmJiBteCA8IHggKyB3ICYmIG15ID4geSAmJiBteSA8IHkgKyBoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgPiAwIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb25lIG9mIHRoZSBjb3JuZXIvc2lkZSBndWlkZXMsIHJldHVybnMgMCBpZiBub3RcbiAgICAgKiBUaGUgY29ybmVyIGd1aWRlcyBhcmUgbnVtYmVyZWQgMS00IHdpdGggMSBiZWluZyB0aGUgdG9wIGxlZnQsIDIgYmVpbmcgdGhlIHRvcCByaWdodCwgYW5kIHNvIG9uLlxuICAgICAqIFRoZSBtaWRkbGUgZ3VpZGVzIGFyZSBudW1iZXJlZCA1LTgsIHdpdGggNSBiZWluZyB0aGUgdG9wIG1pZGRsZSwgNiBiZWluZyB0aGUgcmlnaHQgbWlkZGxlLCBhbmQgc28gb24uXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGd1aWRlQ29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBsZXQgeGRpZiA9IG14IC0geDtcbiAgICAgICAgbGV0IHlkaWYgPSBteSAtIHk7XG4gICAgICAgIC8qIENvcm5lciBHdWlkZXMgKi9cbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGgpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSB4O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICB9XG4gICAgICAgIC8qIE1pZGRsZSBHdWlkZXMgKi9cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3IC8gMik7XG4gICAgICAgIHlkaWYgPSBteSAtIHk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGggLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3IC8gMik7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSB4O1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGggLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBhbmQgZ3VpZGVzIGZvciB0aGUgb2JqZWN0IHdoZW4gdGhlIG9iamVjdCBpcyBzZWxlY3RlZFxuICAgICAqIElmIG9uZSBvZiB0aGUgZ3VpZGVzIGlzIHNlbGVjdGVkLCBpdCBjb2xvcnMgdGhhdCBndWlkZSBibHVlXG4gICAgICogQHBhcmFtIHggdGhlIHggY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHkgdGhlIHkgY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHcgdGhlIHdpZHRoIG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29ybmVyIHRoZSBudW1iZXIgb2YgdGhlIGNvcm5lciB0byBiZSBjb2xvcmVkIGJsdWUgKGlmIGFueSBhdCBhbGwsIGlmIDAsIGFsbCBhcmUgd2hpdGUpXG4gICAgICovXG4gICAgZHJhd0d1aWRlcyh4LCB5LCB3LCBoLCBjb3JuZXIpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmIChjb3JuZXIgIT09IDAgJiYgY29ybmVyIDw9IDQpIHsgLy8gYSBjb3JuZXIgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29ybmVyICE9PSAwKSB7IC8vIGEgbWlkZGxlIGd1aWRlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgY29ycmVjdCBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvL2lmIG5vIGd1aWRlcyBhcmUgc2VsZWN0ZWQsIGNvbG9ycyBldmVyeXRoaW5nIHdoaXRlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgbWV0aG9kIHRoYXQgZHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geCB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5IHkgY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHcgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIGNvbG9yIG9mIHRoZSByZWN0YW5nbGUncyBmaWxsXG4gICAgICovXG4gICAgZHJhd1NxdWFyZSh4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgd2l0aGluIHRoZSBjYW52YXMuXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24sIGNhbGxzIHRoZSBtb2RpZnkgbWV0aG9kcyBpZiB0aGUgYm9vbGVhbnMgc2F0aXNmeSB0aGVtLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRNb3VzZVBvc2l0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5RHJhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemUodGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0NoYW5naW5nRGltcyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXModGhpcy53IDwgMTAsIHRoaXMuaCA8IDEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIGNsaWNrcyBpbnNpZGUgdGhlIGNhbnZhcy5cbiAgICAgKiBNb2RpZmllcyB0aGUgc3RhdGUgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGd1aWRlcyBjb250YWluIHRoZSBtb3VzZSBvciB0aGUgYm91bmRpbmcgcmVjdCBjb250YWlucyB0aGUgbW91c2UuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVN0YXRlKHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSwgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgdW5jbGlja3MuXG4gICAgICogQ2FsbHMgbW9kaWZ5UmVzZXQgdG8gcmVzZXQgZHJhZ2dpbmcgYW5kIHJlc2l6aW5nIGJvb2xlYW5zIGFtb25nIG90aGVycy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNldXAgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlSZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcHJlc3NlZCBkb3duXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcHJlc3NlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdERvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHJlbGVhc2VkXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcmVsZWFzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnRVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogTW9kaWZpY2F0aW9uIGZ1bmN0aW9ucyAqL1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBpbiBvcmRlciB0byBkcmFnIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgbW9kaWZ5RHJhZygpIHtcbiAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueCAtIHRoaXMuX2RyYWdvZmZ4O1xuICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy5fZHJhZ29mZnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHNpemUgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZCAod2hlbiBhIGNvcm5lciBndWlkZSBpcyBjbGlja2VkIGFuZCBkcmFnZ2VkKS5cbiAgICAgKlxuICAgICAqIElmIGFueSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgdG9vIHNtYWxsLCBpdCBzZXRzIHRoZW0gZXF1YWwgdG8gMTAgYW5kIHRoZSBvdGhlciBlcXVhbCB0b1xuICAgICAqIDEwIGRpdmlkZWQgb3IgbXVsdGlwbGllZCBieSB0aGUgcmF0aW8gb2Ygd2lkdGgvaGVpZ2h0IHRvIGtlZXAgaXQgdGhlIHNhbWUuXG4gICAgICpcbiAgICAgKiBUaGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBpcyBkb25lIGJ5IGNhbGxpbmcgdGhlIGhlbHBlciBtZXRob2QgbW9kaWZ5UmVzaXplSGVscGVyLlxuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZSh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBpZiAod2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fcmVjdC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7IC8vIHNldCBmb3IgdGhlIHByb2RpcmVjdCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX3JlY3QuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTAgLyB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fcmVjdC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApOyAvLyBzZXQgZm9yIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgKiB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX3JlY3Qud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyAxLCAyLCBvciA0IGFyZSBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0Rpc3RhbmNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBtb3VzZSBhbmQgdGhlIGxvY2F0aW9uIG9wcG9zaXRlIHRvIGl0XG4gICAgICogKGlmIHRvcCByaWdodCBndWlkZSBpcyBjbGlja2VkLCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGFuZCB0aGUgYm90dG9tIGxlZnQgZ3VpZGUgaXMgbmV3RGlzdGFuY2UpXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgdGhpcy5fcmVjdC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW87XG4gICAgICAgIHRoaXMuX3JlY3QuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQuXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMC5cbiAgICAgKiBDYWxscyBtb2RpZnlDaGFuZ2VEaW1zSGVscGVyIHRvIGFjdHVhbGx5IGRvIHRoZSB3b3JrXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5Q2hhbmdlRGltcyh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBpZiAod2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fcmVjdC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fcmVjdC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyA1IG9yIDggYXJlIHNlbGVjdGVkXG4gICAgICovXG4gICAgbW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oID4gMTApIHsgLy9hcyBsb25nIGFzIHRoZSBoZWlnaHQgaXMgPiAxMFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0LndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53ID4gMTApIHsgLy8gYXMgbG9uZyBhcyB3aWR0aCBpcyA+IDEwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0LndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgZGVwZW5kaW5nIG9uIHRoZSBtb3VzZSBwb3NpdGlvbiB3aGVuIGNhbGxlZCAob25Nb3VzZURvd24pXG4gICAgICogZS5nLiBpZiB0aGUgbW91c2UgaXMgd2l0aGluIHRoZSBib3VuZGluZyByZWN0YW5nbGUgd2hlbiB0aGlzIGlzIGNhbGxlZCwgaXNTZWxlY3RlZCA9IHRydWVcbiAgICAgKiBAcGFyYW0gZ3VpZGVDb250YWluc1xuICAgICAqIEBwYXJhbSBjb250YWluc1xuICAgICAqL1xuICAgIG1vZGlmeVN0YXRlKGd1aWRlQ29udGFpbnMsIGNvbnRhaW5zKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkgeyAvL3ByZXBhcmVzIHRoZSBvYmplY3QgZm9yIGRyYWdnaW5nIHdoZXRoZXIgaXQgaXMgcGVyc29uYWxseSBzZWxlY3RlZCBvciBub3RcbiAgICAgICAgICAgIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kxID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gMCAmJiBndWlkZUNvbnRhaW5zIDw9IDQpIHsgLy9yZXNpemluZ1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gdGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0MSA9IHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoMSA9IHRoaXMudztcbiAgICAgICAgICAgIC8vdGhpcy5fc2l6ZTEgPSBNYXRoLnNxcnQoTWF0aC5wb3codywyKSArIE1hdGgucG93KGgsMikpOyAvLyBzaXplIGlzIGRpYWdvbmFsIGxlbmd0aFxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHsgLy8gc2V0cyB0aGUgb2Zmc2V0cyBkZXBlbmRpbmcgb24gd2hpY2ggY29ybmVyIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgY2FzZSAxOiAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3OyAvLyBvZmZzZXQgaXMgYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoOyAvLyBvZmZzZXQgaXMgYm90dG9tIGxlZnQsIGV0Y1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucyA+IDQpIHsgLy9jaGFuZ2luZyBzaGFwZSBkaW1lbnNpb25zXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IGd1aWRlQ29udGFpbnM7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikgeyAvLyBzZXRzIHRoZSBvZmZzZXRzIGRlcGVuZGluZyBvbiB3aGljaCBtaWRkbGUgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIDU6IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyOyAvLyBvZmZzZXQgaXMgYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6IC8vcmlnaHQgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaCAvIDI7IC8vIG9mZnNldCBpcyBsZWZ0IG1pZGRsZSBldGNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdyAvIDIsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5ICsgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbnMpIHsgLy8gZHJhZ2dpbmdcbiAgICAgICAgICAgIHRoaXMuX3gxID0geDsgLy8gU2F2aW5nIG9yaWdpbmFsIHggYW5kIHlcbiAgICAgICAgICAgIHRoaXMuX3kxID0geTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHg7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7IC8vIG5vdCBzZWxlY3RlZFxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgdG8gZmFsc2UgKGxpa2UgZHJhZ2dpbmcsIHJlc2l6aW5nLCBldGMpIHdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkXG4gICAgICovXG4gICAgbW9kaWZ5UmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl94MSAtIHRoaXMueCkgPiAxIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0gdGhpcy55KSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHRoaXMuX2lzUmVzaXppbmcgfHwgdGhpcy5faXNDaGFuZ2luZ0RpbXMpICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBzaXplMiA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLncsIDIpICsgTWF0aC5wb3codGhpcy5oLCAyKSk7XG4gICAgICAgICAgICBpZiAoKE1hdGguYWJzKHRoaXMuX3dpZHRoMSAtIHRoaXMudykgPiAwKSB8fCAoTWF0aC5hYnModGhpcy5faGVpZ2h0MSAtIHRoaXMuaCkgPiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1Jlc2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqL1xuICAgIGdldE1vdXNlUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuX21vdXNlLnggPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS54O1xuICAgICAgICB0aGlzLl9tb3VzZS55ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0NoYW5naW5nRGltcywgYW5kIGlzU2VsZWN0ZWQgdG8gZmFsc2UgaWYgdGhlIG1vdXNlIGNsaWNrcyBvdXRzaWRlIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIGlzTW91c2VPdXRzaWRlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgICAgICBsZXQgbW91c2VZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtb3VzZVggPCByZWN0LmxlZnQgfHwgbW91c2VYID4gcmVjdC5yaWdodCB8fCBtb3VzZVkgPCByZWN0LnRvcCB8fCBtb3VzZVkgPiByZWN0LmJvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlY3RhbmdsZSBwYWludCBldmVudFxuICAgICAqL1xuICAgIGxvZ1BhaW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhaW50RXZlbnRfMS5QYWludEV2ZW50KFwicmVjdGFuZ2xlXCIsIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlY3RhbmdsZSByZXNpemUgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dSZXNpemUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplRXZlbnRfMS5SZXNpemVFdmVudChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIE1hdGgucm91bmQodGhpcy5fd2lkdGgxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLl9oZWlnaHQxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLncgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuaCAqIDEwMCkgLyAxMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIGNsaWNrIGV2ZW50XG4gICAgICovXG4gICAgbG9nQ2xpY2soKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xpY2tFdmVudF8xLkNsaWNrRXZlbnQoXCJyZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCBhc3NpZ25zIGFuIElEIHRvIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSBpZCBUaGUgSUQgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBpbml0SUQoaWQpIHtcbiAgICAgICAgdGhpcy5pZE9iaiA9IHsgX2lkOiBpZCB9O1xuICAgIH1cbiAgICBhc3QoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERpbWVuc2lvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRPYmouX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqL1xuICAgIGdldEp1c3REcmFnZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fanVzdERyYWdnZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBzZXRKdXN0RHJhZ2dlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaXMgZHJhZ2dpbmdcbiAgICAgKi9cbiAgICBnZXQgaXNEcmFnZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRHJhZ2dpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3Igc2VsZWN0aW9uIGV2ZW50c1xuICAgICAqL1xuICAgIHRvU2VsU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCIgcmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgZHJhZyBldmVudHNcbiAgICAqL1xuICAgIHRvRHJhZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBmcm9tIFwiICsgdGhpcy5feDEgKyBcIiwgXCIgKyB0aGlzLl95MSArIFwiIHRvIFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBJRCBhc3NpZ25tZW50IGV2ZW50c1xuICAgICAqL1xuICAgIHRvSURTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pZE9iai5faWQudG9TdHJpbmcoKSArIFwiIHRvIHJlY3RhbmdsZSBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWN0YW5nbGVFZmZlY3QgPSBSZWN0YW5nbGVFZmZlY3Q7XG4vKipcbiAqIEdldHMgdGhlIG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZXMgaW4gcmVsYXRpb24gdG8gdGhlIGNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB0aGUgY2FudmFzIG9iamVjdFxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0TW91c2VQb3MoY2FudmFzLCBldmVudCkge1xuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB4MSB4IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB5MSB5IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB4MiB4IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKiBAcGFyYW0geTIgeSBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MiwgMikgKyBNYXRoLnBvdyh5MSAtIHkyLCAyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWN0YW5nbGVFZmZlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBQYWludEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9QYWludEV2ZW50XCIpO1xuY29uc3QgUmVzaXplRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1Jlc2l6ZUV2ZW50XCIpO1xuY29uc3QgQ2xpY2tFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvQ2xpY2tFdmVudFwiKTtcbmNsYXNzIFN0cmluZ0VmZmVjdCB7XG4gICAgY29uc3RydWN0b3Ioc3RyKSB7XG4gICAgICAgIHRoaXMuX2ZvbnRTaXplID0gMjA7XG4gICAgICAgIC8vcHJpdmF0ZSBfc2l6ZTI6IG51bWJlcjtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBQcml2YXRlIGJvb2xzXG4gICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0xpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlOyAvLyBIYXMgdGhpcyBvYmplY3QganVzdCBiZWVuIGRyYWdnZWQ/XG4gICAgICAgIC8vcHJpdmF0ZSBfbG9nOiBzdHJpbmdbXTtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnggPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IDA7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX21vdXNlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MgPSB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGludGVydmFsOiAwLFxuICAgICAgICAgICAgc3RyOiBcIlwiLFxuICAgICAgICAgICAgaW5pdE1vdXNlUG9zOiAwLFxuICAgICAgICAgICAgY3Vyc29yUG9zOiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3N0ciA9IHN0cjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIGV2YWx1YXRpbmcgbm9kZXMgKFN0cmluZ05vZGUsIEVsbGlwc2VOb2RlLCBldGMpXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyBhbGwgcGFyYW1zIHRvIHByaXZhdGUgdmFyaWFibGVzIGFuZCBkcmF3cyB0aGUgaW5pdGlhbCBvYmplY3QgdG8gdGhlIGNhbnZhc1xuICAgICAqIGJ5IGNhbGxpbmcgdXBkYXRlKClcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgcGFyZW50IFNjb3BlIHRoYXQgY29udGFpbnMgdGhlIGNhbnZhcyBhbW9uZyBvdGhlciB0aGluZ3NcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgb2JqZWN0J3MgZGltZW5zaW9ucyBpbmNsdWRpbmcgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBhc3QgVW5uZWNlc3Nhcnkgbm93LCB1c2VkIHRvIGJlIHRoZSBwYXJlbnQgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY2FudmFzICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBjb250ZXh0LmNhbnZhcy5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMgPSBkaW1zO1xuICAgICAgICAgICAgbGV0IGN0eCA9IGNvbnRleHQuY2FudmFzLmdldCgpLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAvLyBsb2dnaW5nXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dQYWludCgpKTsgLy8gdGhpcy5jb250ZXh0IG9yIGNvbnRleHQ/XG4gICAgICAgICAgICBjb250ZXh0LmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2FudmFzIGlzIE5PVCBkZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBpbiBvcmRlciB0byBkcmF3IGFuZCByZWRyYXcgdGhlIG9iamVjdCB3aGVuIG1hbmlwdWxhdGlvbnMgYXJlIG1hZGVcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCBmb250RGVldHMgPSB0aGlzLl9mb250U2l6ZSArIFwicHggQ291cmllciBOZXdcIjtcbiAgICAgICAgdGhpcy5fY3R4LmZvbnQgPSBmb250RGVldHM7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBcIiM2NzNBQjdcIjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxUZXh0KHRoaXMuX3N0ci52YWwsIHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgbGV0IHRleHREaW1zID0gdGhpcy5fY3R4Lm1lYXN1cmVUZXh0KHRoaXMuX3N0ci52YWwpO1xuICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy53aWR0aCA9IHRleHREaW1zLndpZHRoO1xuICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5oZWlnaHQgPSB0aGlzLl9mb250U2l6ZTtcbiAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3Muc3RyID0gdGhpcy5fc3RyLnZhbDtcbiAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuaW50ZXJ2YWwgPSB0aGlzLl90ZXh0TWV0cmljcy53aWR0aCAvIHRoaXMuX3RleHRNZXRyaWNzLnN0ci5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdUZXh0R3VpZGVzKHRoaXMueCwgdGhpcy55IC0gdGhpcy5fZm9udFNpemUsIHRoaXMuX3RleHRNZXRyaWNzLndpZHRoLCB0aGlzLl90ZXh0TWV0cmljcy5oZWlnaHQsIHRoaXMuX2Nvcm5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lzRWRpdGluZykge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gb25lIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7IC8vIGJpbmQgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIG1lYW5pbmcgb2YgJ3RoaXMnXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25TaGlmdERvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25TaGlmdFVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy9tYWtlcyBpdCBzbyB0aGF0IGRvdWJsZSBjbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0ZXh0IG9uIHRoZSBwYWdlXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uIChlKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGZhbHNlOyB9LCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIGFub3RoZXIgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvZiB0aGUgb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgY29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIHJldHVybiAodGhpcy54IDw9IG14KSAmJiAodGhpcy54ICsgdGhpcy5fdGV4dE1ldHJpY3Mud2lkdGggPj0gbXgpICYmXG4gICAgICAgICAgICAodGhpcy55IC0gdGhpcy5fZm9udFNpemUgPD0gbXkpICYmICh0aGlzLnkgPj0gbXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbnVtYmVyID4gMCBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9uZSBvZiB0aGUgY29ybmVyL3NpZGUgZ3VpZGVzLCByZXR1cm5zIDAgaWYgbm90XG4gICAgICogVGhlIGNvcm5lciBndWlkZXMgYXJlIG51bWJlcmVkIDEtNCB3aXRoIDEgYmVpbmcgdGhlIHRvcCBsZWZ0LCAyIGJlaW5nIHRoZSB0b3AgcmlnaHQsIGFuZCBzbyBvbi5cbiAgICAgKiBUaGUgbWlkZGxlIGd1aWRlcyBhcmUgbnVtYmVyZWQgNS04LCB3aXRoIDUgYmVpbmcgdGhlIHRvcCBtaWRkbGUsIDYgYmVpbmcgdGhlIHJpZ2h0IG1pZGRsZSwgYW5kIHNvIG9uLlxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBndWlkZUNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeGRpZiA9IG14IC0gKHRoaXMueCArIHRoaXMuX3RleHRNZXRyaWNzLndpZHRoKTtcbiAgICAgICAgbGV0IHlkaWYgPSBteSAtICh0aGlzLnkgLSB0aGlzLl9mb250U2l6ZSk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBib3VuZGluZyByZWN0YW5nbGUgYW5kIGd1aWRlcyBmb3IgdGhlIG9iamVjdCB3aGVuIHRoZSBvYmplY3QgaXMgc2VsZWN0ZWRcbiAgICAgKiBJZiBvbmUgb2YgdGhlIGd1aWRlcyBpcyBzZWxlY3RlZCwgaXQgY29sb3JzIHRoYXQgZ3VpZGUgYmx1ZVxuICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB5IHRoZSB5IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB3IHRoZSB3aWR0aCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggdGhlIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvcm5lciB0aGUgbnVtYmVyIG9mIHRoZSBjb3JuZXIgdG8gYmUgY29sb3JlZCBibHVlIChpZiBhbnkgYXQgYWxsLCBpZiAwLCBhbGwgYXJlIHdoaXRlKVxuICAgICAqL1xuICAgIGRyYXdUZXh0R3VpZGVzKHgsIHksIHcsIGgsIGNvcm5lcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKGNvcm5lciAhPT0gMCkge1xuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGd1aWRlIGJsdWUgaWYgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBtZXRob2QgdGhhdCBkcmF3cyBhIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB4IHggY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHkgeSBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gdyB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29sb3IgY29sb3Igb2YgdGhlIHJlY3RhbmdsZSdzIGZpbGxcbiAgICAgKi9cbiAgICBkcmF3U3F1YXJlKHgsIHksIHcsIGgsIGNvbG9yKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgLyogRXZlbnQgbGlzdGVuZXIgZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBtb3ZlcyB3aXRoaW4gdGhlIGNhbnZhcy5cbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiwgY2FsbHMgdGhlIG1vZGlmeSBtZXRob2RzIGlmIHRoZSBib29sZWFucyBzYXRpc2Z5IHRoZW0uXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICB0aGlzLmdldE1vdXNlUG9zaXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQgJiYgdGhpcy5faXNEcmFnZ2luZykge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLl9zdHIudmFsICsgXCIgaXMgYmVpbmcgZHJhZ2dlZC5cIik7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeURyYWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jlc2l6aW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplKHRoaXMuX2ZvbnRTaXplIDwgMTUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSAmJiB0aGlzLl9pc1NlbGVjdGVkICYmIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpIHsgLy90ZXh0IGVkaXRpbmdcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMubW9kaWZ5VGV4dC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2lzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX3N0ci52YWwgKyBcIiBpcyBzZXR0aW5nIGRyYWdnaW5nIHRvIGZhbHNlXCIpO1xuICAgICAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuaW5pdE1vdXNlUG9zID0gdGhpcy5fbW91c2UueDtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kaWZ5U3RhdGUodGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpID4gMCwgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgdW5jbGlja3MuXG4gICAgICogQ2FsbHMgbW9kaWZ5UmVzZXQgdG8gcmVzZXQgZHJhZ2dpbmcgYW5kIHJlc2l6aW5nIGJvb2xlYW5zIGFtb25nIG90aGVycy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNldXAgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlSZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcHJlc3NlZCBkb3duXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcHJlc3NlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdERvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHJlbGVhc2VkXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcmVsZWFzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnRVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogTW9kaWZpY2F0aW9uIGZ1bmN0aW9ucyAqL1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBpbiBvcmRlciB0byBkcmFnIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgbW9kaWZ5RHJhZygpIHtcbiAgICAgICAgLy8oXCJzdHJpbmcgZHJhZ29mZng6IFwiICsgdGhpcy5fZHJhZ29mZngpO1xuICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS54IC0gdGhpcy5fZHJhZ29mZng7XG4gICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLl9kcmFnb2ZmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgbW92ZXMgdGhlIHRleHQgZWRpdCBjdXJzb3IgYmFzZWQgb24gd2hlcmUgdGhlIG1vdXNlIGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBtb2RpZnlUZXh0Q3Vyc29yKCkge1xuICAgICAgICBsZXQgbGVmdFdhbGwgPSB0aGlzLng7IC8vIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBsZWZ0IG1vc3Qgc2lkZSBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICAgIGxldCB4RGlmID0gdGhpcy5fdGV4dE1ldHJpY3MuaW5pdE1vdXNlUG9zIC0gbGVmdFdhbGw7IC8vIGRpZmZlcmVuY2UgYmV0d2VlbiBtb3VzZSB4IGFuZCBsZWZ0IHdhbGxcbiAgICAgICAgbGV0IGludGVydmFsID0gdGhpcy5fdGV4dE1ldHJpY3MuaW50ZXJ2YWw7IC8vIHRoZSB0ZXh0IHdpZHRoIGRpdmlkZWQgYnkgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nXG4gICAgICAgIGxldCBtb3ZlRmFjdG9yID0gMDtcbiAgICAgICAgaWYgKHhEaWYgPj0gaW50ZXJ2YWwgLyAyICYmIHhEaWYgPD0gaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIG1vdmVGYWN0b3IgPSBsZWZ0V2FsbCArIGludGVydmFsO1xuICAgICAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuY3Vyc29yUG9zID0gaW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeERpZiA8PSBpbnRlcnZhbCAvIDIpIHtcbiAgICAgICAgICAgIG1vdmVGYWN0b3IgPSBsZWZ0V2FsbDtcbiAgICAgICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmN1cnNvclBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeERpZiAlIGludGVydmFsID49IGludGVydmFsIC8gMikge1xuICAgICAgICAgICAgbW92ZUZhY3RvciA9IGxlZnRXYWxsICsgaW50ZXJ2YWwgKiBNYXRoLmNlaWwoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmN1cnNvclBvcyA9IGludGVydmFsICogTWF0aC5jZWlsKHhEaWYgLyBpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeERpZiAlIGludGVydmFsIDwgaW50ZXJ2YWwgLyAyKSB7XG4gICAgICAgICAgICBtb3ZlRmFjdG9yID0gbGVmdFdhbGwgKyBpbnRlcnZhbCAqIE1hdGguZmxvb3IoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmN1cnNvclBvcyA9IGludGVydmFsICogTWF0aC5mbG9vcih4RGlmIC8gaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N0eC5tb3ZlVG8obW92ZUZhY3RvciwgdGhpcy55IC0gdGhpcy5fZm9udFNpemUpO1xuICAgICAgICB0aGlzLl9jdHgubGluZVRvKG1vdmVGYWN0b3IsIHRoaXMueSk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9IFwiZ3JleVwiO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZWRpdHMgdGhlIHN0cmluZyB3aGVuIGVkaXRpbmcgdGV4dFxuICAgICAqIEBwYXJhbSBldmVudCBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgbW9kaWZ5VGV4dChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5faXNFZGl0aW5nKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3RIYWxmO1xuICAgICAgICAgICAgbGV0IHNlY29uZEhhbGY7XG4gICAgICAgICAgICBsZXQgYnJlYWtQb2ludCA9IHRoaXMuX3RleHRNZXRyaWNzLmN1cnNvclBvcyAvIHRoaXMuX3RleHRNZXRyaWNzLmludGVydmFsO1xuICAgICAgICAgICAgZmlyc3RIYWxmID0gdGhpcy5fc3RyLnZhbC5zdWJzdHJpbmcoMCwgYnJlYWtQb2ludCk7XG4gICAgICAgICAgICBzZWNvbmRIYWxmID0gdGhpcy5fc3RyLnZhbC5zdWJzdHJpbmcoYnJlYWtQb2ludCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNyAmJiB0aGlzLl90ZXh0TWV0cmljcy5pbml0TW91c2VQb3MgPiB0aGlzLnggKyB0aGlzLl90ZXh0TWV0cmljcy5pbnRlcnZhbCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5pbml0TW91c2VQb3MgLT0gdGhpcy5fdGV4dE1ldHJpY3MuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDM5ICYmIHRoaXMuX3RleHRNZXRyaWNzLmluaXRNb3VzZVBvcyA8IHRoaXMueCArIHRoaXMuX3RleHRNZXRyaWNzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuaW5pdE1vdXNlUG9zICs9IHRoaXMuX3RleHRNZXRyaWNzLmludGVydmFsO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSA4ICYmIHRoaXMuX3N0ci52YWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpcnN0SGFsZiA9IGZpcnN0SGFsZi5zdWJzdHJpbmcoMCwgZmlyc3RIYWxmLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0ci5zdHIgPSBmaXJzdEhhbGYgKyBzZWNvbmRIYWxmO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmluaXRNb3VzZVBvcyAtPSB0aGlzLl90ZXh0TWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBrZXlOYW1lID0gZXZlbnQua2V5O1xuICAgICAgICAgICAgICAgIGlmIChrZXlOYW1lLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0SGFsZiArPSBrZXlOYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHIuc3RyID0gZmlyc3RIYWxmICsgc2Vjb25kSGFsZjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuaW5pdE1vdXNlUG9zICs9IHRoaXMuX3RleHRNZXRyaWNzLmludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9kaWZpZXMgdGhlIGZvbnQgc2l6ZSBvZiB0aGUgdGV4dFxuICAgICAqIElmIHRoZSB0ZXh0IGZvbnQgaXMgc21hbGxlciB0aGFuIDE1cHQsIGl0IHNldCdzIGl0IGVxdWFsIHRvIDE1cHRcbiAgICAgKiBAcGFyYW0gaXNUb29TbWFsbCB0cnVlIGlmIHRoZSBmb250IHNpemUgaXMgPCAxNVxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZShpc1Rvb1NtYWxsKSB7XG4gICAgICAgIGlmIChpc1Rvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9mb250U2l6ZSA9IDE1O1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250U2l6ZSArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMC4yO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAwLjI7XG4gICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyBkZXBlbmRpbmcgb24gdGhlIG1vdXNlIHBvc2l0aW9uIHdoZW4gY2FsbGVkIChvbk1vdXNlRG93bilcbiAgICAgKiBlLmcuIGlmIHRoZSBtb3VzZSBpcyB3aXRoaW4gdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSB3aGVuIHRoaXMgaXMgY2FsbGVkLCBpc1NlbGVjdGVkID0gdHJ1ZVxuICAgICAqIEBwYXJhbSBndWlkZUNvbnRhaW5zXG4gICAgICogQHBhcmFtIGNvbnRhaW5zXG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGUoZ3VpZGVDb250YWlucywgY29udGFpbnMpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy9wcmVwYXJlcyB0aGUgb2JqZWN0IGZvciBkcmFnZ2luZyB3aGV0aGVyIGl0IGlzIHBlcnNvbmFsbHkgc2VsZWN0ZWQgb3Igbm90XG4gICAgICAgICAgICBpZiAoY29udGFpbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94MSA9IHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl95MSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmKHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQubXVsU2VsKXtcbiAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcInN0cmluZyBlZmZlY3QgbXVsU2VsZWN0ZWQ6IFwiICsgdGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC5tdWxTZWwpO1xuICAgICAgICAgICAgLy8gICAgIC8vaWYodGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC52YWwpe1xuICAgICAgICAgICAgLy8gICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1NlbGVjdGVkKCkpO1xuICAgICAgICAgICAgLy8gICAgIC8vdGhpcy5sb2dTZWxlY3RlZCgpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMpIHsgLy9pZiB0aGUgY29ybmVyIGd1aWRlcyBjb250YWluIHRoZSBtb3VzZSB3ZSBhcmUgcmVzaXppbmdcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gdGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX3N0ci52YWwgKyBcImlzIHNlbGVjdGVkP1wiICsgdGhpcy5fc2VsZWN0ZWQpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInN0YXRlIHNlbGVjdGlvbiBpcyBcIiArIHRoaXMuX3N0ci52YWwpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLng7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMueTtcbiAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZTEgPSB0aGlzLl9mb250U2l6ZTsgLy8gc2F2aW5nIG9sZCBmb250IHNpemVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLng7IC8vIFNhdmluZyBvcmlnaW5hbCB4IGFuZCB5XG4gICAgICAgICAgICB0aGlzLl95MSA9IHRoaXMueTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX3N0ci52YWwgKyBcImlzIHNlbGVjdGVkP1wiICsgdGhpcy5fc2VsZWN0ZWQpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInN0YXRlIHNlbGVjdGlvbiBpcyBcIiArIHRoaXMuX3N0ci52YWwpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX3N0ci52YWwgKyBcIiBpcyBkcmFnZ2luZz8gXCIgKyB0aGlzLl9pc0RyYWdnaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyB0byBmYWxzZSAobGlrZSBkcmFnZ2luZywgcmVzaXppbmcsIGV0Yykgd2hlbiB0aGUgbW91c2UgaXMgcmVsZWFzZWRcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLl9zdHIudmFsICsgXCIgbG9nZ2luZyBkcmFnXCIpO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0gdGhpcy54KSA+IDEgfHwgTWF0aC5hYnModGhpcy5feTEgLSB0aGlzLnkpID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvL3RoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ01vdmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZXNpemluZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX3N0ci52YWwgKyBcIiBsb2dnaW5nIHJlc2l6ZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl9zaXplMSAtIHRoaXMuX2ZvbnRTaXplKSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dSZXNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3RyaW5nIGVmZmVjdCBtdWxTZWxlY3RlZDogXCIgKyB0aGlzLl9jb250ZXh0Lm11bFNlbGVjdGVkLnZhbCk7XG4gICAgICAgIC8vIGlmKHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQudmFsKXtcbiAgICAgICAgLy8gICAgIHRoaXMubG9nU2VsZWN0ZWQoKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZih0aGlzLmlzTXVsdGlwbGVTZWxlY3RlZCl7XG4gICAgICAgIC8vICAgICBjb250ZXh0LmV2ZW50TG9nLnB1c2gobmV3IFNlbGVjdEV2ZW50KHNlbGVjdGVkRWxlbXMpKTtcbiAgICAgICAgLy8gICAgIG1hc3RlckxvZy5wdXNoKGNvbnRleHQuZXZlbnRMb2dbY29udGV4dC5ldmVudExvZy5sZW5ndGggLSAxXSk7XG4gICAgICAgIC8vICAgICAvL2NvbnNvbGUubG9nKFwibXVsdGlwbGUgc2VsZWN0ZWRcIik7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gLy90aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dNb3ZlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICovXG4gICAgZ2V0TW91c2VQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbW91c2UueCA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLng7XG4gICAgICAgIHRoaXMuX21vdXNlLnkgPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzQ2hhbmdpbmdEaW1zLCBhbmQgaXNTZWxlY3RlZCB0byBmYWxzZSBpZiB0aGUgbW91c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgaXNNb3VzZU91dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1vdXNlWCA8IHJlY3QubGVmdCB8fCBtb3VzZVggPiByZWN0LnJpZ2h0IHx8IG1vdXNlWSA8IHJlY3QudG9wIHx8IG1vdXNlWSA+IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHBhaW50IGV2ZW50XG4gICAgICovXG4gICAgbG9nUGFpbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpbnRFdmVudF8xLlBhaW50RXZlbnQodGhpcy5fc3RyLnZhbCwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVzaXplIGV2ZW50XG4gICAgICovXG4gICAgbG9nUmVzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZUV2ZW50XzEuUmVzaXplRXZlbnQodGhpcy5fc3RyLnZhbCArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgTWF0aC5yb3VuZCh0aGlzLl9zaXplMSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5fZm9udFNpemUgKiAxMDApIC8gMTAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIGNsaWNrIGV2ZW50XG4gICAgICovXG4gICAgbG9nQ2xpY2soKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xpY2tFdmVudF8xLkNsaWNrRXZlbnQodGhpcy5fc3RyLnZhbCArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgYXNzaWducyBhbiBJRCB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgaW5pdElEKGlkKSB7XG4gICAgICAgIHRoaXMuaWRPYmogPSB7IF9pZDogaWQsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIGdldCBjYW52YXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBjYW52YXMgVGhlIGNhbnZhcyB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldCBjYW52YXMoY2FudmFzKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgICB9XG4gICAgYXN0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgZWxsaXBzZVxuICAgICAqL1xuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBlbGxpcHNlXG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERpbWVuc2lvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVsbGlwc2UgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgKi9cbiAgICBnZXRKdXN0RHJhZ2dlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1c3REcmFnZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgc2V0SnVzdERyYWdnZWQodmFsKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlbGxpcHNlIGlzIGRyYWdnaW5nXG4gICAgICovXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXQgc3RyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RyLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb2JqZWN0IElEXG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkT2JqLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBzZWxlY3Rpb24gZXZlbnRzXG4gICAgICovXG4gICAgdG9TZWxTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIiBcIiArIHRoaXMuX3N0ci52YWwgKyBcIiB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIGRyYWcgZXZlbnRzXG4gICAgKi9cbiAgICB0b0RyYWdTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fc3RyLnZhbCArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94MSArIFwiLCBcIiArIHRoaXMuX3kxICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gXCIgKyB0aGlzLl9zdHIudmFsICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaW5nRWZmZWN0ID0gU3RyaW5nRWZmZWN0O1xuLyoqXG4gKiBHZXQncyB0aGUgbW91c2UgeCBhbmQgeSBjb29yZGluYXRlcyBpbiByZWxhdGlvbiB0byB0aGUgY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHRoZSBjYW52YXMgb2JqZWN0XG4gKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICovXG5mdW5jdGlvbiBnZXRNb3VzZVBvcyhjYW52YXMsIGV2ZW50KSB7XG4gICAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHgxIHggY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHkxIHkgY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHgyIHggY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSB5MiB5IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgyLCAyKSArIE1hdGgucG93KHkxIC0geTIsIDIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmluZ0VmZmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFJldHVybkVycm9yXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9SZXR1cm5FcnJvclwiKTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xuLy8gQXBwbGljYXRpb24gb2YgYSBmdW5jdGlvbi4gQXNzdW1lcyBhcmcgdmFsdWVzIHBhc3NlZCBpbiBzYW1lIG9yZGVyIGFzIEZ1bkRlZiBhcmdzXG5jbGFzcyBGdW5BcHAge1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYSBmdW5jdGlvbiBhcHBsaWNhdGlvblxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBhcmdzIEZ1bmN0aW9uIGFyZ3VtZW50cywgaWYgYXBwbGljYWJsZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiwgaWYgYW55XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgYXJncywgd3MsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX2FyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGZ1bmRlZiA9IGNvbnRleHQubG9va3VwKHRoaXMuX25hbWUsIGNvbnRleHQpOyAvLyBsb29raW5nIHVwIGZ1bmN0aW9uXG4gICAgICAgIC8vbGV0IGNoaWxkID0gbmV3IFNjb3BlKGZ1bmRlZi5zY29wZSk7IC8vIGF2b2lkaW5nIG92ZXJ3cml0ZTsgbmVlZCB0byB0b3NzIGFmdGVyIHJldHVybmluZ1xuICAgICAgICBsZXQgY2hpbGQgPSBmdW5kZWYuc2NvcGUuY29weSgpOyAvLyBDb3B5aW5nIGRlZmluaXRpb24gc2NvcGVcbiAgICAgICAgLy8gQXNzaWducyBhcmcgdmFsdWVzIHRvIGRlZmluaXRpb24gYXJndW1lbnRzXG4gICAgICAgIGlmICh0aGlzLl9hcmdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXJncy5sZW5ndGg7IGkrKykgeyAvL2xvb2t1cHM/XG4gICAgICAgICAgICAgICAgLy9jaGlsZC5kZWNsYXJlKHRoaXMuX2Z1bmN0LmFyZ3NbaV0pOyAvLyByZWRlY2xhcmU/XG4gICAgICAgICAgICAgICAgY2hpbGQuYXNzaWduKGZ1bmRlZi5hcmdzW2ldLCB0aGlzLl9hcmdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaWQgPSBjb250ZXh0Lmdsb2JhbEZ1bklEOyAvLyBBc3NpZ25zIGFuIElEIHRvIHRoZSBmdW5jdGlvblxuICAgICAgICBjb250ZXh0Lmdsb2JhbEZ1bklEKys7XG4gICAgICAgIGNoaWxkLnJldFZhbElEID0gc3BhY2VfbGlmdF8xLlNvbWUoaWQpOyAvLyBuZXcgbWV0aG9kXG4gICAgICAgIC8vIHdlIG9ubHkgcmV0dXJuIGEgdmFsdWUgd2l0aCBmdW5jdGlvbiBhcHBsaWNhdGlvblxuICAgICAgICAvLyBpZiBpdCBpcyBleHBsaWNpdGx5IHJldHVybmVkIHVzaW5nIGEgcmV0dXJuIHN0YXRlbWVudDtcbiAgICAgICAgLy8gd2UgYWJ1c2UgSlMgZXhjZXB0aW9ucyBmb3IgdGhpcyBwdXJwb3NlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGlsZC5oYWRGdW5FdmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIGZ1bmRlZi5ib2R5LmV2YWwoY2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgd2UgY2F0Y2ggb25seSB0aGUgZXJyb3IgaW50ZW5kZWQgZm9yIHVzXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJldHVybkVycm9yXzEuUmV0dXJuRXJyb3IgJiYgcGFyc2VJbnQoZS5JRCkgPT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5yZXRWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlcnJvciB3YXMgbm90IGludGVuZGVkIGZvciB1czsgcmV0aHJvd1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICAvL3JldHVybiBmdW5kZWYuYm9keS5ldmFsKGNoaWxkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZnVuY3Rpb24gYXBwbGljYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGFyZ3NMaXN0ID0gJyc7XG4gICAgICAgIGlmICh0aGlzLl9hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXJncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzTGlzdCArPSB0aGlzLl9hcmdzW2ldLnRvU3RyaW5nKCkgKyBcIiwgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzTGlzdCArPSB0aGlzLl9hcmdzW3RoaXMuX2FyZ3MubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLm5hbWUgKyAnKCcgKyBhcmdzTGlzdCArIFwiKVwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGFwcGxpY2F0aW9ucyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBmdW5jdGlvbiBhcHBsaWNhdGlvblxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gZnVuY3Rpb25zXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXJndW1lbnRzIG9mIHRoZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldCBhcmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXJncztcbiAgICB9XG59XG5leHBvcnRzLkZ1bkFwcCA9IEZ1bkFwcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZ1bkFwcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNsYXNzIEZ1bkRlZiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgYm9keSwgYXJncywgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5fYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLy8gQmluZHMgYXJncyBpbiBjb250ZXh0IG9mIGRlZmluaXRpb247IG5vIHZhbHVlc1xuICAgIC8vIEJpbmRzIG5hbWUgdG8gcGFyZW50IGNvbnRleHQgKGN1ciBjb250ZXh0IGlzIG5ldyBjb250ZXh0KVxuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICB0aGlzLl9mdW5TY29wZSA9IG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpOyAvLyAqKioqKioqKioqKioqIGNvcHk/Pz8/XG4gICAgICAgIHRoaXMuX2Z1blNjb3BlLmNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgICAgICB0aGlzLl9mdW5TY29wZS5ldmVudExvZyA9IGNvbnRleHQuZXZlbnRMb2c7XG4gICAgICAgIHRoaXMuX2Z1blNjb3BlLmVmZmVjdHMgPSBjb250ZXh0LmVmZmVjdHM7XG4gICAgICAgIC8qXG4gICAgICAgIGlmKHRoaXMuX2FyZ3MgIT0gbnVsbCl7XG4gICAgICAgICAgICBmb3IobGV0IGVudHJ5IG9mIHRoaXMuX2FyZ3Mpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1blNjb3BlLmRlY2xhcmUoZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIGNvbnRleHQuZGVjbGFyZSh0aGlzLl9uYW1lKTsgLy8gYXNzaWduIHdpdGggdmFsIGZ1bmN0aW9uXG4gICAgICAgIGNvbnRleHQuYXNzaWduKHRoaXMuX25hbWUsIHRoaXMpOyAvLyBwYXJlbnQgb3IgY3VycmVudD9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGFyZ3NMaXN0ID0gJyc7XG4gICAgICAgIGlmICh0aGlzLl9hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXJncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzTGlzdCArPSB0aGlzLl9hcmdzW2ldICsgXCIsIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnc0xpc3QgKz0gdGhpcy5fYXJnc1t0aGlzLl9hcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwiZnVuIFwiICsgdGhpcy5fbmFtZSArIFwiKFwiICsgYXJnc0xpc3QgKyAnKScgKyAnIHtcXG4gJyArIHRoaXMuX2JvZHkudG9TdHJpbmcoKSArICd9JztcbiAgICB9XG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGZ1bmN0aW9uc1wiKTtcbiAgICB9XG4gICAgLy8gR2V0IG1ldGhvZHNcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIGdldCBib2R5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9keTtcbiAgICB9XG4gICAgZ2V0IGFyZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcmdzO1xuICAgIH1cbiAgICBnZXQgc2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mdW5TY29wZTtcbiAgICB9XG59XG5leHBvcnRzLkZ1bkRlZiA9IEZ1bkRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZ1bkRlZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIExpc3ROb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYW4gYXJyYXktbGlrZSBsaXN0XG4gICAgICogQHBhcmFtIGxpc3QgVGhlIGxpc3QsIHN0b3JlZCBpbiBhIFRTIGFycmF5XG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGlzdCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9saXN0ID0gbGlzdDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyBlYWNoIGVsZW1lbnQgb2YgdGhlIGxpc3QgYW5kIHB1c2hlcyBpdCBvbnRvIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBldmFsTGlzdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBleHByIG9mIHRoaXMuX2xpc3QpIHtcbiAgICAgICAgICAgIGV2YWxMaXN0LnB1c2goZXhwci5ldmFsKGNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpc3ROb2RlKGV2YWxMaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGlzdFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgbGlzdCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2xpc3QubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0ICs9IHRoaXMuX2xpc3RbaV0udG9TdHJpbmcoKSArIFwiLCBcIjtcbiAgICAgICAgfVxuICAgICAgICBsaXN0ICs9IHRoaXMuX2xpc3RbdGhpcy5fbGlzdC5sZW5ndGggLSAxXS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyAnWycgKyBsaXN0ICsgJ10nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGxpc3QgZXF1YWxzIGFub3RoZXIgbGlzdFxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHkgKG11c3QgYmUgYSBMaXN0Tm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgTGlzdE5vZGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcy5saXN0W2ldLmVxdWFsc1ZhbChyaWdodC5saXN0W2ldKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhdyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgbGlzdFxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkcmF3IGEgTGlzdE5vZGVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxpc3RcbiAgICAgKi9cbiAgICBnZXQgbGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0Tm9kZSA9IExpc3ROb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlzdE5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMb2dFdmVudF8xID0gcmVxdWlyZShcIi4vTG9nRXZlbnRcIik7XG5jbGFzcyBDbGVhckV2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBDbGVhciBFdmVudCwgd2hpY2ggbG9ncyB3aGVuIHRoZSBjYW52YXMgaXMgY2xlYXJlZFxuICAgICAqIEBwYXJhbSB0b0xvZyBXaGF0IHRvIGxvZyAoc3BvaWxlcjogbm90aGluZylcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b0xvZykge1xuICAgICAgICBzdXBlcih0b0xvZyk7XG4gICAgICAgIHRoaXMudGFnID0gXCJjbGVhclwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYW5kIHJldHVybnMgbWVzc2FnZSBcIkNvbnNvbGUgY2xlYXJlZFwiIHdpdGggZGF0ZSBhbmQgdGltZSBhdHRhY2hlZFxuICAgICAqL1xuICAgIGFzc2VtYmxlTG9nKCkge1xuICAgICAgICBsZXQgdG9QcmludCA9IFwiQ29uc29sZSBjbGVhcmVkXCI7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0l0ZW0odG9QcmludCk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGVhckV2ZW50ID0gQ2xlYXJFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNsZWFyRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMb2dFdmVudF8xID0gcmVxdWlyZShcIi4vTG9nRXZlbnRcIik7XG5jbGFzcyBDbGlja0V2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgQ2xpY2sgRXZlbnQsIHdoaWNoIGxvZ3Mgd2hlbiBhbiBvYmplY3Qgb24gdGhlIGNhbnZhcyBpcyBjbGlja2VkXG4gICAgICogQHBhcmFtIHRvTG9nIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCB0byBsb2dcbiAgICAgKiBAcGFyYW0geDEgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0IHRvIGxvZ1xuICAgICAqIEBwYXJhbSB5MSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3QgdG8gbG9nXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9Mb2csIHgxLCB5MSkge1xuICAgICAgICBzdXBlcih0b0xvZywgeDEsIHkxKTtcbiAgICAgICAgdGhpcy50YWcgPSBcImNsaWNrXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhbmQgcmV0dXJucyBtZXNzYWdlIG9mIGZvcm0gXCJDbGlja2VkIG9uIG9iaiBhdCB4LCB5XCIgd2l0aCBkYXRlIGFuZCB0aW1lIGF0dGFjaGVkXG4gICAgICovXG4gICAgYXNzZW1ibGVMb2coKSB7XG4gICAgICAgIGxldCB0b1ByaW50ID0gXCJDbGlja2VkIG9uIFwiICsgdGhpcy50b0xvZyArIFwiIGF0IFwiICsgdGhpcy54MS50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy55MS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dJdGVtKHRvUHJpbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpY2tFdmVudCA9IENsaWNrRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DbGlja0V2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0xvZ0V2ZW50XCIpO1xuY2xhc3MgRHJhZ0V2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgRHJhZyBFdmVudCwgd2hpY2ggbG9ncyB3aGVuIGFuIG9iamVjdCBvbiB0aGUgY2FudmFzIGlzIGRyYWdnZWRcbiAgICAgKiBAcGFyYW0gdG9Mb2cgVGhlIGVmZmVjdCB0byBsb2dcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b0xvZykge1xuICAgICAgICBzdXBlcih0b0xvZyk7XG4gICAgICAgIHRoaXMudGFnID0gXCJkcmFnXCI7XG4gICAgICAgIHRoaXMuX3RvUHJpbnQgPSB0aGlzLmFzc2VtYmxlU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIGxvZyBzdHJpbmcgdXNpbmcgdGhlIEVmZmVjdCdzIHRvRHJhZ1N0cmluZygpIG1ldGhvZFxuICAgICAqL1xuICAgIGFzc2VtYmxlU3RyaW5nKCkge1xuICAgICAgICB0aGlzLl90b1ByaW50ID0gdGhpcy50b0xvZy50b0RyYWdTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvUHJpbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhbmQgcmV0dXJucyBmaW5hbCBsb2cgbWVzc2FnZSBvZiBmb3JtIFwiRHJhZ2dlZCBvYmogZnJvbSB4MSwgeTEgdG8geDIsIHkyXCJcbiAgICAgKiB3aXRoIGRhdGUgYW5kIHRpbWUgYXR0YWNoZWRcbiAgICAgKi9cbiAgICBhc3NlbWJsZUxvZygpIHtcbiAgICAgICAgbGV0IHByaW50ID0gXCJEcmFnZ2VkIFwiICsgdGhpcy5fdG9QcmludDtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nSXRlbShwcmludCk7XG4gICAgfVxufVxuZXhwb3J0cy5EcmFnRXZlbnQgPSBEcmFnRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EcmFnRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMb2dFdmVudF8xID0gcmVxdWlyZShcIi4vTG9nRXZlbnRcIik7XG5jbGFzcyBJREV2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQSBjb25zdHJ1Y3RvciBmb3IgYW4gSUQgZXZlbnQsIHVzZWQgd2hlbiBhbiBvYmplY3QgZ2V0cyBhc3NpZ25lZCBhbiBJRFxuICAgICAqIEBwYXJhbSB0b0xvZyBUaGUgZWZmZWN0IHRvIGxvZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRvTG9nKSB7XG4gICAgICAgIHN1cGVyKHRvTG9nKTtcbiAgICAgICAgdGhpcy50YWcgPSBcIklEXCI7XG4gICAgICAgIHRoaXMuX3RvUHJpbnQgPSB0aGlzLmFzc2VtYmxlU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBzdHJpbmcgdXNpbmcgdGhlIGVmZmVjdCdzIHRvSURTdHJpbmcoKSBtZXRob2RcbiAgICAgKi9cbiAgICBhc3NlbWJsZVN0cmluZygpIHtcbiAgICAgICAgdGhpcy5fdG9QcmludCA9IHRoaXMudG9Mb2cudG9JRFN0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9QcmludDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIG1lc3NhZ2Ugb2YgZm9ybSBcIkFzc2lnbmVkIElEICMgdG8gb2JqIGF0IHgsIHlcIiB3aXRoIGRhdGUgYW5kIHRpbWUgYXR0YWNoZWRcbiAgICAgKi9cbiAgICBhc3NlbWJsZUxvZygpIHtcbiAgICAgICAgbGV0IHByaW50ID0gXCJBc3NpZ25lZCBJRCBcIiArIHRoaXMuX3RvUHJpbnQ7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0l0ZW0ocHJpbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuSURFdmVudCA9IElERXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JREV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgTG9nRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IGNsYXNzIGNvbnN0cnVjdG9yIGZvciBhIExvZyBFdmVudC4gUmVnaXN0ZXJzIGV2ZW50IHRpbWUuXG4gICAgICogQHBhcmFtIHRvTG9nIFRoZSBzdHJpbmcsIG9iamVjdCwgb3IgYXJyYXkgb2Ygb2JqZWN0cyB0byBiZSBsb2dnZWRcbiAgICAgKiBAcGFyYW0geDEgSW5pdGlhbCB4IHBvc2l0aW9uLCBpZiBhcHBsaWNhYmxlXG4gICAgICogQHBhcmFtIHkxIEluaXRpYWwgeSBwb3NpdGlvbiwgaWYgYXBwbGljYWJsZVxuICAgICAqIEBwYXJhbSB4MiBGaW5hbCB4IHBvc2l0aW9uLCBpZiBhcHBsaWNhYmxlXG4gICAgICogQHBhcmFtIHkyIEZpbmFsIHkgcG9zaXRpb24sIGlmIGFwcGxpY2FibGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b0xvZywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgbGV0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5fZGF0ZSA9IHRvZGF5LmdldEZ1bGxZZWFyKCkgKyAnLScgKyAodG9kYXkuZ2V0TW9udGgoKSArIDEpICsgJy0nICsgdG9kYXkuZ2V0RGF0ZSgpO1xuICAgICAgICB0aGlzLl90aW1lID0gdG9kYXkuZ2V0SG91cnMoKSArIFwiOlwiICsgdG9kYXkuZ2V0TWludXRlcygpICsgXCI6XCIgKyB0b2RheS5nZXRTZWNvbmRzKCk7XG4gICAgICAgIHRoaXMuX2RhdGVUaW1lID0gdGhpcy5fZGF0ZSArICcgJyArIHRoaXMuX3RpbWU7XG4gICAgICAgIHRoaXMuX3RvTG9nID0gdG9Mb2c7XG4gICAgICAgIC8vdGhpcy5fdG9Mb2dBcnJheSA9IHRvTG9nQXJyYXk7XG4gICAgICAgIHRoaXMuX3gxID0geDE7XG4gICAgICAgIHRoaXMuX3kxID0geTE7XG4gICAgICAgIHRoaXMuX3gyID0geDI7XG4gICAgICAgIHRoaXMuX3kyID0geTI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGRhdGUgYW5kIHRpbWUgdG8gbG9nIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gdG9Mb2cgVGhlIGxvZyBtZXNzYWdlXG4gICAgICovXG4gICAgbG9nSXRlbSh0b0xvZykge1xuICAgICAgICByZXR1cm4gXCIgXCIgKyB0aGlzLl9kYXRlVGltZSArIFwiOiBcIiArIHRvTG9nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRhdGUtdGltZSBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXQgZGF0ZVRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgb3IgZWZmZWN0KHMpIHRvIGJlIGxvZ2dlZFxuICAgICAqL1xuICAgIGdldCB0b0xvZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvTG9nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGV2ZW50IHRhZ1xuICAgICAqL1xuICAgIGdldCB0YWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGFnIHN0cmluZ1xuICAgICAqL1xuICAgIHNldCB0YWcodGFnKSB7XG4gICAgICAgIHRoaXMuX3RhZyA9IHRhZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB4MVxuICAgICAqL1xuICAgIGdldCB4MSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3gxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHkxXG4gICAgICovXG4gICAgZ2V0IHkxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgeDJcbiAgICAgKi9cbiAgICBnZXQgeDIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94MjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB5MlxuICAgICAqL1xuICAgIGdldCB5MigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3kyO1xuICAgIH1cbn1cbmV4cG9ydHMuTG9nRXZlbnQgPSBMb2dFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvZ0V2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0xvZ0V2ZW50XCIpO1xuY2xhc3MgUGFpbnRFdmVudCBleHRlbmRzIExvZ0V2ZW50XzEuTG9nRXZlbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIFBhaW50IEV2ZW50LCB1c2VkIHdoZW4gYW4gb2JqZWN0IGlzIHBhaW50ZWQgb24gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB0b0xvZyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QgdG8gYmUgbG9nZ2VkXG4gICAgICogQHBhcmFtIHgxIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0geTEgVGhlIHkgcG9zaXRpb24gb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRvTG9nLCB4MSwgeTEpIHtcbiAgICAgICAgc3VwZXIodG9Mb2csIHgxLCB5MSk7XG4gICAgICAgIHRoaXMudGFnID0gXCJwYWludFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYW5kIHJldHVybnMgbWVzc2FnZSBvZiBmb3JtIFwiUGFpbnRlZCBvYmogYXQgeCwgeVwiIHdpdGggZGF0ZSBhbmQgdGltZSBhdHRhY2hlZFxuICAgICAqL1xuICAgIGFzc2VtYmxlTG9nKCkge1xuICAgICAgICBsZXQgdG9QcmludCA9IFwiUGFpbnRlZCBcIiArIHRoaXMudG9Mb2cgKyBcIiBhdCBcIiArIHRoaXMueDEudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMueTEudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nSXRlbSh0b1ByaW50KTtcbiAgICB9XG59XG5leHBvcnRzLlBhaW50RXZlbnQgPSBQYWludEV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFpbnRFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ0V2ZW50XzEgPSByZXF1aXJlKFwiLi9Mb2dFdmVudFwiKTtcbmNsYXNzIFJlc2l6ZUV2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIFJlc2l6ZSBFdmVudCwgdXNlZCB3aGVuIGFuIG9iamVjdCBvbiB0aGUgY2FudmFzIGlzIHJlc2l6ZWRcbiAgICAgKiBAcGFyYW0gdG9Mb2cgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QgdG8gYmUgbG9nZ2VkXG4gICAgICogQHBhcmFtIHgxIEluaXRpYWwgeCBkaW1lbnNpb24gb2YgdGhlIG9iamVjdCwgb3IgaW5pdGlhbCBmb250IHNpemVcbiAgICAgKiBAcGFyYW0geTEgSW5pdGlhbCB5IGRpbWVuc2lvbiBvZiB0aGUgb2JqZWN0LCBvciBmaW5hbCBmb250IHNpemVcbiAgICAgKiBAcGFyYW0geDIgRmluYWwgeCBkaW1lbnNpb24gb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB5MiBGaW5hbCB5IGRpbWVuc2lvbiBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9Mb2csIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHN1cGVyKHRvTG9nLCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgIHRoaXMudGFnID0gXCJyZXNpemVcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGxvZyBtZXNzYWdlIG9mIGZvcm0gXCJSZXNpemVkIG9iaiBmcm9tIHNpemUgeDEsIHkxIHRvIHNpemUgeDEsIHkyXCIgZm9yIHJlY3RzIGFuZCBlbGxpcHNlc1xuICAgICAqIG9yIG9mIGZvcm0gXCJSZXNpemVkIG9iaiBmcm9tIHNpemUgeDEgdG8gc2l6ZSB5MVwiIGZvciBzdHJpbmdzXG4gICAgICogSGFzIGRhdGUgYW5kIHRpbWUgYXR0YWNoZWRcbiAgICAgKi9cbiAgICBhc3NlbWJsZUxvZygpIHtcbiAgICAgICAgaWYgKHRoaXMueDIgIT0gdW5kZWZpbmVkICYmIHRoaXMueTIgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnRvUHJpbnQgPSBcIlJlc2l6ZWQgXCIgKyB0aGlzLnRvTG9nICsgXCIgZnJvbSBzaXplIFwiICsgdGhpcy54MS50b1N0cmluZygpICsgXCIgYnkgXCIgKyB0aGlzLnkxLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICArIFwiIHRvIHNpemUgXCIgKyB0aGlzLngyLnRvU3RyaW5nKCkgKyBcIiBieSBcIiArIHRoaXMueTIudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9QcmludCA9IFwiUmVzaXplZCBcIiArIHRoaXMudG9Mb2cgKyBcIiBmcm9tIHNpemUgXCIgKyB0aGlzLngxLnRvU3RyaW5nKCkgKyBcIiB0byBzaXplIFwiICsgdGhpcy55MS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0l0ZW0odGhpcy50b1ByaW50KTtcbiAgICB9XG59XG5leHBvcnRzLlJlc2l6ZUV2ZW50ID0gUmVzaXplRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNpemVFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ0V2ZW50XzEgPSByZXF1aXJlKFwiLi9Mb2dFdmVudFwiKTtcbmNsYXNzIFNlbGVjdEV2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgU2VsZWN0aW9uIEV2ZW50LCB1c2VkIHdoZW4gbXVsdGlwbGUgb2JqZWN0cyBvbiB0aGUgY2FudmFzIGFyZSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB0b0xvZyBUaGUgYXJyYXkgb2Ygb2JqZWN0cyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRvTG9nKSB7XG4gICAgICAgIHN1cGVyKHRvTG9nKTtcbiAgICAgICAgdGhpcy50YWcgPSBcInNlbGVjdFwiO1xuICAgICAgICB0aGlzLl90b1ByaW50ID0gdGhpcy5hc3NlbWJsZVN0cmluZ3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGFuZCByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFsbCB0aGUgb2JqZWN0cyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGFzc2VtYmxlU3RyaW5ncygpIHtcbiAgICAgICAgbGV0IGxvZ1N0cmluZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWxlbSBvZiB0aGlzLnRvTG9nKSB7XG4gICAgICAgICAgICBsb2dTdHJpbmdzLnB1c2goZWxlbS50b1NlbFN0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJTZWxlY3RlZFwiICsgbG9nU3RyaW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSB3aXRoIGRhdGUgYW5kIHRpbWUgYXR0YWNoZWRcbiAgICAgKi9cbiAgICBhc3NlbWJsZUxvZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nSXRlbSh0aGlzLl90b1ByaW50KTtcbiAgICB9XG59XG5leHBvcnRzLlNlbGVjdEV2ZW50ID0gU2VsZWN0RXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZWxlY3RFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jbGFzcyBBbmQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBsb2dpY2FsICdhbmQnICgmJikgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgc2lkZSBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBvcGVyYXRpb24gYW5kIHJldHVybnMgYSBib29sZWFuIG9mIHRoZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlICYmIHJocyBpbnN0YW5jZW9mIEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMudmFsICYmIHJocy52YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50cyB0byB0aGUgJ2FuZCcgb3BlcmF0b3IgbXVzdCBiZSBib29sZWFucy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArICcgYW5kICcgKyB0aGlzLl9yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIHRoZSAnYW5kJyBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSAnYW5kJyBvcGVyYXRpb24gY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVmdCBzaWRlIG9mIHRoZSBvcFxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgb3BcbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLkFuZCA9IEFuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFuZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jbGFzcyBFcXVhbHMge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBlcXVhbGl0eSAoPT0pIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IHNpZGUgb2YgdGhlIGVxdWFsaXR5XG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIGNvbXBhcmlzb24gYW5kIGV2YWx1YXRlcyB0byBhIEJvb2xlYW5Ob2RlXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMuZXF1YWxzVmFsKHJocykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcXVhbGl0eSBvcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLl9sZWZ0LnRvU3RyaW5nKCkgKyAnIGVxdWFscyAnICsgdGhpcy5fcmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2FuJ3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGFuIGVxdWFsaXR5IG9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIndlbGwgdGhpcyBpcyBtZXRhXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbGl0eSBvcHMgY2FuJ3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLkVxdWFscyA9IEVxdWFscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVxdWFscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIEdyZWF0ZXJUaGFuIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgR3JlYXRlclRoYW4gKD4pIG9wXG4gICAgICogQHBhcmFtIGxlZnQgTGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSByaWdodCBSaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgR3JlYXRlclRoYW4gY29tcGFyaXNvbiBhbmQgcmV0dXJucyBCb29sZWFuTm9kZSByZXByZXNlbnRhdGlvbiBvZiByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSAmJiByaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMudmFsID4gcmhzLnZhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50cyB0byB0aGUgPiBvcGVyYXRvciBtdXN0IGJlIG51bWVyaWMuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLl9sZWZ0LnRvU3RyaW5nKCkgKyBcIiA+IFwiICsgdGhpcy5fcmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBHcmVhdGVyVGhhbiBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyZWF0ZXJUaGFuIG9wIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbn1cbmV4cG9ydHMuR3JlYXRlclRoYW4gPSBHcmVhdGVyVGhhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyZWF0ZXJUaGFuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgR3JlYXRlclRoYW5FcSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIEdyZWF0ZXJUaGFuRXEgKGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0bywgPj0pIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IExlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gcmlnaHQgUmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIEdyZWF0ZXJUaGFuRXEgb3BlcmF0aW9uIGFuZCByZXR1cm5zIEJvb2xlYW5Ob2RlIHdpdGggcmVzdWx0XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSAmJiByaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMudmFsID49IHJocy52YWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudHMgdG8gdGhlID49IG9wZXJhdG9yIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArICcgPj0gJyArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gR3JlYXRlclRoYW5FcSBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyZWF0ZXJUaGFuRXEgb3AgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG4gICAgfVxufVxuZXhwb3J0cy5HcmVhdGVyVGhhbkVxID0gR3JlYXRlclRoYW5FcTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyZWF0ZXJUaGFuRXEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jbGFzcyBMZXNzVGhhbiB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIExlc3NUaGFuICg8KSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBMZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0IFJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgTGVzc1RoYW4gY29tcGFyaXNvbiBhbmQgcmV0dXJucyBCb29sZWFuTm9kZSB3aXRoIHJlc3VsdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KSArIFwiIGlzIGxlc3MgdGhhbiBcIiArIHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCkpO1xuICAgICAgICBsZXQgbGhzID0gdGhpcy5fbGVmdC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBsZXQgcmhzID0gdGhpcy5fcmlnaHQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgaWYgKGxocyBpbnN0YW5jZW9mIE51bWJlck5vZGVfMS5OdW1iZXJOb2RlICYmIHJocyBpbnN0YW5jZW9mIE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiVGhleSdyZSBib3RoIG51bWJlciBub2Rlc1wiKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cobGhzLnZhbCArIFwiPFwiICsgcmhzLnZhbCk7XG4gICAgICAgICAgICAvL2xldCBib29sOiBib29sZWFuID0gbGhzLnZhbCA8IHJocy52YWw7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiYm9vbDogXCIgKyBib29sKTtcbiAgICAgICAgICAgIHJldHVybiAobmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLnZhbCA8IHJocy52YWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50cyB0byBsZXNzIHRoYW4gbXVzdCBwcm9kdWNlIG51bWVyaWMgdmFsdWVzLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArICcgPCAnICsgdGhpcy5fcmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBMZXNzVGhhbiBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlc3NUaGFuIG9wIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc1RoYW4gPSBMZXNzVGhhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NUaGFuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgTGVzc1RoYW5FcSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIExlc3NUaGFuRXEgKGxlc3MgdGhhbiBvciBlcXVhbCB0bywgPD0pIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IHNpZGUgb2YgdGhlIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgTGVzc1RoYW5FcSBjb21wYXJpc29uIGFuZCByZXR1cm5zIEJvb2xlYW5Ob2RlIHdpdGggcmVzdWx0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsaHMgPSB0aGlzLl9sZWZ0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGxldCByaHMgPSB0aGlzLl9yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUgJiYgcmhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLnZhbCA8PSByaHMudmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJndW1lbnRzIHRvIHRoZSA8PSBvcGVyYXRvciBtdXN0IGJlIG51bWVyaWMuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLl9sZWZ0LnRvU3RyaW5nKCkgKyBcIiA8PSBcIiArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gTGVzc1RoYW5FcSBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlc3NUaGFuRXEgb3BzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc1RoYW5FcSA9IExlc3NUaGFuRXE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzVGhhbkVxLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNsYXNzIE5vdCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBsb2dpY2FsIE5vdCAoISkgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGV4cHIgVGhlIGV4cHJlc3Npb24gdG8gYmUgb3BlcmF0ZWQgb24gKG11c3QgYmUgYSBCb29sZWFuTm9kZSlcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihleHByLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2V4cHIgPSBleHByO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIE5vdCBvcGVyYXRpb24gYW5kIHJldHVybnMgQm9vbGVhbk5vZGUgd2l0aCByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGUgPSB0aGlzLl9leHByLmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKCFlLnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJndW1lbnQgdG8gdGhlICEgb3BlcmF0b3IgbXVzdCBiZSBib29sZWFuLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJub3QgXCIgKyB0aGlzLl9leHByLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBOb3Qgb3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3Qgb3BlcmF0aW9ucyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGV4cHJlc3Npb24gdG8gYmUgb3BlcmF0ZWQgb25cbiAgICAgKi9cbiAgICBnZXQgZXhwcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHI7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3QgPSBOb3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jbGFzcyBOb3RFcXVhbCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIE5vdEVxdWFsICghPSkgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgTGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSByaWdodCBSaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgTm90RXF1YWwgb3BlcmF0aW9uIGFuZCByZXR1cm5zIEJvb2xlYW5Ob2RlIHdpdGggcmVzdWx0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsaHMgPSB0aGlzLl9sZWZ0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGxldCByaHMgPSB0aGlzLl9yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUgJiYgcmhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLnZhbCAhPT0gcmhzLnZhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50cyB0byB0aGUgIT0gb3BlcmF0b3IgbXVzdCBiZSBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5fbGVmdC50b1N0cmluZygpICsgXCIgbm90IGVxdWFscyBcIiArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBOb3RFcXVhbCBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdEVxdWFsIG9wcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLk5vdEVxdWFsID0gTm90RXF1YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob3RFcXVhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jbGFzcyBPciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGxvZ2ljYWwgJ29yJyAofHwpIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IExlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gcmlnaHQgUmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIE9yIG9wZXJhdGlvbiBhbmQgcmV0dXJucyBCb29sZWFuTm9kZSB3aXRoIHJlc3VsdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IEN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsaHMgPSB0aGlzLl9sZWZ0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGxldCByaHMgPSB0aGlzLl9yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZSAmJiByaHMgaW5zdGFuY2VvZiBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUobGhzLnZhbCB8fCByaHMudmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudHMgdG8gdGhlICdvcicgb3BlcmF0b3IgbXVzdCBiZSBib29sZWFucy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArICcgb3IgJyArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gT3Igb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3Igb3BlcmF0aW9ucyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLk9yID0gT3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Pci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jb25zdCBzcGFjZV9saWZ0XzEgPSByZXF1aXJlKFwic3BhY2UtbGlmdFwiKTtcbmNsYXNzIEZvck5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIEZvciBsb29wXG4gICAgICogQHBhcmFtIGluaXQgSW5pdGlhbGl6ZXMgdGhlIHZhcmlhYmxlIHVzZWQgaW4gdGhlIGNvbmRpdGlvblxuICAgICAqIEBwYXJhbSBjb25kIFRoZSBjb25kaXRpb24gKG11c3QgZXZhbHVhdGUgdG8gQm9vbGVhbk5vZGUpXG4gICAgICogQHBhcmFtIHBvc3QgVGhlIHBvc3RldmFsdWF0aW9uIGNvbmRpdGlvblxuICAgICAqIEBwYXJhbSBib2R5IFRoZSBib2R5IG9mIHRoZSBsb29wXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW5pdCwgY29uZCwgcG9zdCwgYm9keSwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2luaXQgPSBpbml0O1xuICAgICAgICB0aGlzLl9jb25kID0gY29uZDtcbiAgICAgICAgdGhpcy5fcG9zdCA9IHBvc3Q7XG4gICAgICAgIHRoaXMuX2JvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBGb3IgbG9vcFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgY2hpbGRDdHggPSBuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0LCBjb250ZXh0LmVmZmVjdHMsIGNvbnRleHQuZXZlbnRMb2cpO1xuICAgICAgICBjaGlsZEN0eC5jYW52YXMgPSBzcGFjZV9saWZ0XzEuU29tZShjb250ZXh0LmNhbnZhcy5nZXQoKSk7XG4gICAgICAgIHRoaXMuX2luaXQuZXZhbChjaGlsZEN0eCk7IC8vIGluaXRpYWxpemUgdmFyXG4gICAgICAgIGxldCByZXMgPSB0aGlzLl9jb25kLmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICBpZiAoIShyZXMgaW5zdGFuY2VvZiBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbmRpdGlvbiBtdXN0IGJlIGEgYm9vbGVhbiBleHByZXNzaW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV0O1xuICAgICAgICB3aGlsZSAocmVzLnZhbCkge1xuICAgICAgICAgICAgcmV0ID0gdGhpcy5fYm9keS5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgICAgIHRoaXMuX3Bvc3QuZXZhbChjaGlsZEN0eCk7XG4gICAgICAgICAgICByZXMgPSB0aGlzLl9jb25kLmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIEZvck5vZGVcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIEZvciBsb29wXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JOb2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHJldHVybiBcIkNhbm5vdCBjYWxsIGRyYXcgb24gRm9yIGxvb3BcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZm9yIGxvb3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgJ2ZvcignICsgdGhpcy5faW5pdC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5fY29uZC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5fcG9zdC50b1N0cmluZygpICsgXCIpIHtcXG4gXCJcbiAgICAgICAgICAgICsgdGhpcy5fYm9keS50b1N0cmluZygpICsgXCJ9XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkZvck5vZGUgPSBGb3JOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Rm9yTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jb25zdCBzcGFjZV9saWZ0XzEgPSByZXF1aXJlKFwic3BhY2UtbGlmdFwiKTtcbmNsYXNzIFdoaWxlTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgV2hpbGUgbG9vcFxuICAgICAqIEBwYXJhbSBjb25kIFRoZSBXaGlsZSBsb29wIGNvbmRpdGlvblxuICAgICAqIEBwYXJhbSBib2R5IFRoZSBib2R5IG9mIHRoZSBsb29wXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZCwgYm9keSwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NvbmQgPSBjb25kO1xuICAgICAgICB0aGlzLl9ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyB0aGUgYm9keSBvZiB0aGUgbG9vcCB3aGlsZSB0aGUgY29uZGl0aW9uIGlzIHRydWVcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgY2hpbGRDdHggPSBuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0LCBjb250ZXh0LmVmZmVjdHMsIGNvbnRleHQuZXZlbnRMb2cpO1xuICAgICAgICBjaGlsZEN0eC5jYW52YXMgPSBzcGFjZV9saWZ0XzEuU29tZShjb250ZXh0LmNhbnZhcy5nZXQoKSk7XG4gICAgICAgIGxldCByZXMgPSB0aGlzLl9jb25kLmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICBpZiAoIShyZXMgaW5zdGFuY2VvZiBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbmRpdGlvbiBtdXN0IGJlIGEgYm9vbGVhbiBleHByZXNzaW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV0O1xuICAgICAgICB3aGlsZSAocmVzLnZhbCkge1xuICAgICAgICAgICAgcmV0ID0gdGhpcy5fYm9keS5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgICAgIHJlcyA9IHRoaXMuX2NvbmQuZXZhbChjaGlsZEN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gV2hpbGVOb2Rlc1xuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gV2hpbGUgbG9vcFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hpbGVOb2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHJldHVybiBcIkNhbm5vdCBjYWxsIGRyYXcgb24gV2hpbGUgbG9vcFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBXaGlsZSBsb29wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwid2hpbGUoXCIgKyB0aGlzLl9jb25kLnRvU3RyaW5nKCkgKyBcIikge1xcbiBcIiArIHRoaXMuX2JvZHkudG9TdHJpbmcoKSArIFwifVwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5XaGlsZU5vZGUgPSBXaGlsZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XaGlsZU5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBJbnN0cnVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IobG9jYXRpb24sIGNvbnRlbnQsIHRvcCwgbGVmdCkge1xuICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5fdG9wID0gdG9wO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICB9XG59XG5leHBvcnRzLkluc3RydWN0aW9uID0gSW5zdHJ1Y3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnN0cnVjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25Gb3VyQ3BPbmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsNGMxXCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDRjMic7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gWW91J3ZlIG1hZGUgaXQgdG8gdGhlIEZJTkFMIENIQUxMRU5HRVMhIENvbXBsZXRlIHRoZXNlIGNoYWxsZW5nZXMgdG8gZWFybiBFVEVSTkFMIEdMT1JZISA8L3A+XG4gICAgPHA+IFRocm91Z2hvdXQgdGhpcyBIb3VyIG9mIENvZGUsIHlvdSBoYXZlIGxlYXJuZWQ6IDwvcD5cbiAgICA8cD4gLSBIb3cgdG8gcHJpbnQgYSB3b3JkLCBjaXJjbGUsIHJlY3RhbmdsZSwgYW5kIGN1cnZlLiA8L3A+XG4gICAgPHA+IC0gSG93IHRvIHN0b3JlIGFueSBvZiB0aGUgdmFsdWUgYWJvdmUgaW4gYSB2YXJpYWJsZS4gPC9wPlxuICAgIDxwPiAtIEhvdyB0byB1c2UgaWYvZWxzZSBzdGF0ZW1lbnQgdG8gY2hlY2sgYSBjb25kaXRpb24gYWJvdXQgYSB2YXJpYWJsZS4gPC9wPlxuICAgIDxwPiBFYWNoIG9mIHRoZSBmb2xsb3dpbmcgY2hhbGxlbmdlcyB3aWxsIHRlc3QgdGhlc2UgY29uY2VwdHMuIExldCdzIGRpdmUgcmlnaHQgaW4hIDwvcD5cbiAgICA8cD4gUHJpbnQgYSBjaXJjbGUgYW5kIHB1dCBpdHMgaGVpZ2h0IGFuZCB3aWR0aCBpbiBvbmUgb2YgdGhlIGJveGVzIHRvIHRoZSBzaWRlLiBUaGVuIHByaW50IGEgcmVjdGFuZ2xlIGFuZCBwdXQgaXRzIGhlaWdodCBhbmQgd2lkdGggaW4gdGhlIGJveC4gPC9wPlxuICAgIDxwPiBDSEFMTEVOR0U6IFByaW50IGEgY2lyY2xlIGFuZCByZWN0YW5nbGUuIFB1dCB0aGVpciByZXNwZWN0aXZlIHdpZHRoIGFuZCBoZWlnaHQgaW4gdGhlIGJveGVzIHByb3ZpZGVkLiA8L3A+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gbGVhZGluZyBpbnRvIGNvbmRpdGlvbmFsc1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dFwiKS52YWx1ZTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gL3ByaW50XFxzKlxcKFxccyplbGxpcHNlXFxzKlxcKFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKVxccyosXFxzKlsxLTldWzAtOV0qXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqXFwpOy87XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBjb2RlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSBtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICBsZXQgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBFbGxpcHNlRWZmZWN0XzEuRWxsaXBzZUVmZmVjdCkge1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uRm91ckNwT25lID0gTGVzc29uRm91ckNwT25lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uRm91ckNwT25lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvbkZvdXJDcFR3byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImw0YzJcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsNGMyJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBZZXMhIFlvdSBnb3QgdGhpcyEgPC9wPlxuICAgIDxwPiBOb3cgbGV0J3MgcHV0IHRob3NlIHNraWxscyBpbiBpZi9lbHNlIHN0YXRlbWVudHMgdG8gd29yayEgPC9wPlxuICAgIDxwPiBDcmVhdGUgYSBwYWlyIG9mIGlmL2Vsc2Ugc3RhdGVtZW50cyB0byBwcmludCBvdXQgdG8gdGhlIENBTlZBUyBhIGNsYWltIG9mIHdoZXRoZXIgdGhlIGNpcmNsZSBpcyBwb3NpdGlvbmVkIEFCT1ZFIG9yIEJFTE9XIHRoZSByZWN0YW5nbGUuIDwvcD5cbiAgICA8cD4gQ0hBTExFTkdFOiBQcmludCBhIGNsYWltIHRoYXQgc3RhdGVzIHdoZXRoZXIgY2lyY2xlIGlzIEFCT1ZFIG9yIEJFTE9XIHRoZSByZWN0YW5nbGUuIDwvcD5cbiAgICA8cD4gSElOVDogUmVtZW1iZXIgdGhhdCB0aGUgbnVtYmVycyBpbiB0aGUgcHJpbnQoKSBzdGF0ZW1lbnRzIGRldGVybWluZSB0aGUgcG9zaXRpb24gb2YgdGhlIHNoYXBlcyBiZWluZyBwcmludGVkLiA8L3A+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gbGVhZGluZyBpbnRvIGNvbmRpdGlvbmFsc1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dFwiKS52YWx1ZTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gL3ByaW50XFxzKlxcKFxccyplbGxpcHNlXFxzKlxcKFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKVxccyosXFxzKlsxLTldWzAtOV0qXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqXFwpOy87XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBjb2RlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSBtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICBsZXQgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBFbGxpcHNlRWZmZWN0XzEuRWxsaXBzZUVmZmVjdCkge1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uRm91ckNwVHdvID0gTGVzc29uRm91ckNwVHdvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uRm91ckNwVHdvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3RyaW5nRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9TdHJpbmdFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25PbmVDcEZvdXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMWM0XCI7XG4gICAgICAgIHRoaXMuX3ByZXZNb2R1bGUgPSAnbDFjMic7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDJjMSc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnY2FudmFzJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBOb3RlIHRoYXQgY2hhbmdpbmcgdGhlIGZpcnN0IG51bWJlciBpbiB0aGUgcHJpbnQgc3RhdGVtZW50IG1vdmVzIHRoZSB3b3JkcyBsZWZ0IG9yIHJpZ2h0LCB3aGlsZSBjaGFuZ2luZyB0aGUgc2Vjb25kIG51bWJlciBtb3ZlIHRoZW0gdXAgb3IgZG93bi4gPC9wPlxuICAgIDxwPiBOb3cgdGltZSBmb3IgYSBjaGFsbGVuZ2UhIFByaW50IHRoZSB3b3JkIFwibW9vXCIgb24gdGhlIENBTlZBUywgYW5kIHB1dCBpdCByaWdodCBpbiB0aGUgY2VudGVyIG9mIHRoZSBlbnRpcmUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IENIQUxMRU5HRTogUHJpbnQgdGhlIHdvcmQgXCJtb29cIiBpbiB0aGUgY2VudGVyIG9mIHRoZSBDQU5WQVMuIDwvcD5cbiAgICA8cD4gSElOVDogV3JpdGUgcHJpbnQoXCJtb29cIiwgNTAsIDUwKSBpbiB0aGUgQ09ERSBhcmVhIGZpcnN0LCB0aGVuIGNoYW5nZSB0aGUgbnVtYmVycyBpbnNpZGUgdGhhdCBwcmludCBzdGF0ZW1lbnQuIDwvcD5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyID09PSBcIm1vb1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKChlZmZlY3QueCA+IDIwMCAmJiBlZmZlY3QueCA8IDMwMCkgJiYgKGVmZmVjdC55ID4gMjAwICYmIGVmZmVjdC55IDwgMzAwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25PbmVDcEZvdXIgPSBMZXNzb25PbmVDcEZvdXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25PbmVDcEZvdXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBJbnN0cnVjdGlvbl8xID0gcmVxdWlyZShcIi4vSW5zdHJ1Y3Rpb25cIik7XG5jbGFzcyBMZXNzb25PbmVDcE9uZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwxYzFcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsMWMyJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBDb21wdXRlcnMgY2FuIGRvIHdvbmRlcmZ1bCB0aGluZ3MsIGJ1dCB0aGV5IHVuZm9ydHVuYXRlbHkgZG9uJ3QgdW5kZXJzdGFuZCBFbmdsaXNoLiA8L3A+XG4gICAgPHA+IEhvd2V2ZXIsIHRoZXkgdW5kZXJzdGFuZCBjb21wdXRlciBjb2RlLCBzbyBsZXQncyBsZWFybiBob3cgdG8gd3JpdGUgY29kZSB0aGF0IGluc3RydWN0IHRoZSBjb21wdXRlciB0byBkbyB0aGluZ3MhIDwvcD5cbiAgICA8cD4gT24gdGhlIENPREUgYXJlYSBhYm92ZSwgd3JpdGUgcHJpbnQoXCJIZWxsb1wiKSA8L3A+XG4gICAgPHA+IEdPQUw6IFdyaXRlICdIZWxsbycgb24gdGhlIENBTlZBUy4gPC9wPmA7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5zdHJJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXggPSAwO1xuICAgICAgICBsZXQgY29udGVudCA9IFwiRmlyc3QsIGxldCdzIHRlbGwgdGhlIGNvbXB1dGVyIHRvIHByaW50IHNvbWV0aGluZyBvbiB0aGUgQ0FOVkFTLiBDbGljayBvbiB0aGUgQ09ERSBib3guXCI7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZScsIGNvbnRlbnQsIFwiMzAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9ICdOb3cgdHlwZSBgcHJpbnQoXCJIZWxsb1wiKWAgaW4gdGhpcyBDT0RFIGJveC4nO1xuICAgICAgICB0aGlzLl9pbnN0ckJveGVzLnB1c2gobmV3IEluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oJ2NvZGUnLCBjb250ZW50LCBcIjMwJVwiLCBcIjEwJVwiKSk7XG4gICAgICAgIGNvbnRlbnQgPSAnTm90aWNlIHRoYXQgd2hhdCB5b3UgdHlwZWQgY2F1c2VzIHRoZSBjb21wdXRlciB0byBwcmludCB0aGUgd29yZCBcIkhlbGxvXCIgb24gdGhlIENBTlZBUyBoZXJlLiBDb25ncmF0dWxhdGlvbnMhIFlvdSBqdXN0IHdyb3RlIHlvdXIgZmlyc3QgbGluZSBvZiBjb2RlISc7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY2FudmFzJywgY29udGVudCwgXCI2NSVcIiwgXCIxMCVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiB3cml0ZSBhbnkgc3RyaW5nIG9uIENBTlZBU1xuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBsZXQgaW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5wdXQnKTtcbiAgICAgICAgbGV0IHJlZ2V4ID0gL3ByaW50XFxzKlxcKFxccypcXFwiSGVsbG9cXFwiXFxzKlxcKS87XG4gICAgICAgIGxldCBtYXRjaCA9IGlucHV0LnZhbHVlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgaWYgKG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvKlxuICAgICAgICBjb25zb2xlLmxvZyhcImluc3RySW5kZXggaW4gY2hlY2tHb2FsOiBcIiArIHRoaXMuX2luc3RySW5kZXgpO1xuICAgICAgICBzd2l0Y2godGhpcy5faW5zdHJJbmRleCkge1xuXG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGlucHV0ICYmIHRoaXMuX2xhdGVzdEluc3RySW5kZXggPT0gMCkge1xuICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RJbnN0ckluZGV4Kys7XG4gICAgICAgICAgICAgIHRoaXMubmV4dEluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgbGV0IHJlZ2V4OiBSZWdFeHAgPSAvcHJpbnRcXHMqXFwoXFxzKlxcXCJIZWxsb1xcXCJcXHMqXFwpLztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGlucHV0LnZhbHVlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDAgJiYgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCA9PSAxKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXgrKztcbiAgICAgICAgICAgICAgdGhpcy5uZXh0SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgKi9cbiAgICB9XG4gICAgbmV4dEluc3RydWN0aW9uKGRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMuX2luc3RySW5kZXggPSAodGhpcy5faW5zdHJJbmRleCArIDEgPCB0aGlzLl9pbnN0ckJveGVzLmxlbmd0aCkgPyB0aGlzLl9pbnN0ckluZGV4ICsgMSA6IHRoaXMuX2luc3RySW5kZXg7XG4gICAgICAgIHRoaXMucmVuZGVySW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgIH1cbiAgICBwcmV2SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5faW5zdHJJbmRleCA9ICh0aGlzLl9pbnN0ckluZGV4IC0gMSA+PSAwKSA/IHRoaXMuX2luc3RySW5kZXggLSAxIDogdGhpcy5faW5zdHJJbmRleDtcbiAgICAgICAgdGhpcy5yZW5kZXJJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlbmRlciB0aGUgY3VycmVudCBpbnN0cnVjdGlvbiBvZiB0aGlzIGNoZWNrcG9pbnRcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKi9cbiAgICByZW5kZXJJbnN0cnVjdGlvbihkb2N1bWVudCkge1xuICAgICAgICBsZXQgY3VySW5zdHJ1Y3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluc3RydWN0aW9uXCIpO1xuICAgICAgICBpZiAoY3VySW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgY3VySW5zdHJ1Y3Rpb24ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluc3RydWN0aW9uID0gdGhpcy5faW5zdHJCb3hlc1t0aGlzLl9pbnN0ckluZGV4XTtcbiAgICAgICAgbGV0IGluc3RyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaW5zdHJEaXYuY2xhc3NOYW1lID0gXCJpbnN0cnVjdGlvblwiO1xuICAgICAgICBpbnN0ckRpdi5pZCA9ICdpbnN0cnVjdGlvbic7XG4gICAgICAgIGluc3RyRGl2LmlubmVyVGV4dCA9IGluc3RydWN0aW9uLl9jb250ZW50O1xuICAgICAgICBpbnN0ckRpdi5zdHlsZS50b3AgPSBpbnN0cnVjdGlvbi5fdG9wO1xuICAgICAgICBpbnN0ckRpdi5zdHlsZS5sZWZ0ID0gaW5zdHJ1Y3Rpb24uX2xlZnQ7XG4gICAgICAgIGluc3RyRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIGxldCBwcmV2SW5zdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICBwcmV2SW5zdHIuaWQgPSAncHJldmlvdXMtaW5zdHJ1Y3Rpb24nO1xuICAgICAgICBwcmV2SW5zdHIuaW5uZXJUZXh0ID0gXCI8XCI7XG4gICAgICAgIGxldCB0aGlzTW9kdWxlID0gdGhpcztcbiAgICAgICAgcHJldkluc3RyLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImluc3RySW5kZXggXCIgKyB0aGlzTW9kdWxlLl9pbnN0ckluZGV4KTtcbiAgICAgICAgICAgIHRoaXNNb2R1bGUucHJldkluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RySW5kZXggPT0gMCkge1xuICAgICAgICAgICAgcHJldkluc3RyLnN0eWxlLmJhY2tncm91bmQgPSBcIiNEOEQ4RDhcIjtcbiAgICAgICAgICAgIHByZXZJbnN0ci5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdHJEaXYuYXBwZW5kQ2hpbGQocHJldkluc3RyKTtcbiAgICAgICAgbGV0IG5leHRJbnN0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIG5leHRJbnN0ci5pZCA9ICduZXh0LWluc3RydWN0aW9uJztcbiAgICAgICAgbmV4dEluc3RyLmlubmVyVGV4dCA9IFwiPlwiO1xuICAgICAgICBuZXh0SW5zdHIub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW5zdHJJbmRleCBcIiArIHRoaXNNb2R1bGUuX2luc3RySW5kZXgpO1xuICAgICAgICAgICAgdGhpc01vZHVsZS5uZXh0SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5faW5zdHJJbmRleCA9PSB0aGlzLl9pbnN0ckJveGVzLmxlbmd0aCB8fCB0aGlzLl9pbnN0ckluZGV4ID09IHRoaXMuX2xhdGVzdEluc3RySW5kZXgpIHtcbiAgICAgICAgICAgIG5leHRJbnN0ci5zdHlsZS5iYWNrZ3JvdW5kID0gXCIjRDhEOEQ4XCI7XG4gICAgICAgICAgICBuZXh0SW5zdHIuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluc3RyRGl2LmFwcGVuZENoaWxkKG5leHRJbnN0cik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGluc3RydWN0aW9uLl9sb2NhdGlvbikuYXBwZW5kQ2hpbGQoaW5zdHJEaXYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25PbmVDcE9uZSA9IExlc3Nvbk9uZUNwT25lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uT25lQ3BPbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3Nvbk9uZUNwVGhyZWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMWMzXCI7XG4gICAgICAgIHRoaXMuX3ByZXZNb2R1bGUgPSAnbDFjMic7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDFjNCc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnY2FudmFzJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBZZXAhIE1vdmluZyB0aGUgd29yZHMgYWN0dWFsbHkgY2hhbmdlIHRoZSBudW1iZXJzIGluIHlvdXIgQ09ERS4gPC9wPlxuICAgIDxwPiBOb3cgdGhlIENBTlZBUyBoYXMgYmVlbiBmcm96ZW4hIFRyeSBjaGFuZ2luZyB5b3VyIENPREUgdG8gc2VlIGlmIHlvdSBjYW4gbW92ZSB0aGUgd29yZHMgdG8gdGhlIGJvdHRvbSByaWdodCBjb3JuZXIuIDwvcD5cbiAgICA8cD4gR09BTDogTW92ZSB0aGUgd29yZHMgdG8gdGhlIGJvdHRvbSByaWdodCBvZiB0aGUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IEhJTlQ6IENoYW5nZSBvbmUgb2YgdGhlIDIgbnVtYmVycyBhdCBhIHRpbWUsIHRoZW4gY2xpY2sgUlVOIHRvIHNlZSBob3cgdGhhdCBjaGFuZ2VzIHRoZSBDQU5WQVMuYDtcbiAgICAgICAgdGhpcy54ID0gMTA7XG4gICAgICAgIHRoaXMueSA9IDQzMDtcbiAgICB9XG4gICAgZHJhd0d1aWRlcyhjdHgpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucmVjdCh0aGlzLngsIHRoaXMueSwgMTAwLCAxMDApO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmZvbnQgPSAyMCArIFwicHggQ291cmllciBOZXdcIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgY3R4LmZpbGxUZXh0KFwiUHV0IHRleHRcIiwgdGhpcy54LCAzOTApO1xuICAgICAgICBjdHguZmlsbFRleHQoXCJpbiBoZXJlXCIsIHRoaXMueCwgNDEwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QueCA+IHRoaXMueCAmJiBlZmZlY3QueCA8IHRoaXMueCArIDEwMCAmJiBlZmZlY3QueSA+IHRoaXMueSAmJiBlZmZlY3QueSA8IHRoaXMueSArIDEwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25PbmVDcFRocmVlID0gTGVzc29uT25lQ3BUaHJlZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3Nvbk9uZUNwVGhyZWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3Nvbk9uZUNwVHdvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDFjMlwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wxYzMnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ2NvZGUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFlvdSBqdXN0IHRvbGQgdGhlIGNvbXB1dGVyIHRvIHdyaXRlIHdvcmRzIG9uIHRoZSBDQU5WQVMhIDwvcD5cbiAgICA8cD4gTm93IGxldCdzIGRvIHNvbWV0aGluZyBtb3JlIGludGVyZXN0aW5nOiBjbGljayBvbiB0aGUgd29yZHMgb24gdGhlIENBTlZBUywgdGhlbiBkcmFnIGl0IGluc2lkZSB0aGUgYm94IGF0IHRoZSB0b3AtcmlnaHQgY29ybmVyLiBPYnNlcnZlIHdoYXQgaGFwcGVucyB0byB5b3VyIGNvZGUuIDwvcD5cbiAgICA8cD4gR09BTDogTW92ZSB0aGUgd29yZHMgeW91IGp1c3QgY3JlYXRlZCBpbnNpZGUgdGhlIHRvcC1yaWdodCBib3guIDwvcD5gO1xuICAgICAgICB0aGlzLnggPSAzOTA7XG4gICAgICAgIHRoaXMueSA9IDEwO1xuICAgIH1cbiAgICBkcmF3R3VpZGVzKGN0eCkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5yZWN0KHRoaXMueCwgdGhpcy55LCAxMDAsIDEwMCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguZm9udCA9IDIwICsgXCJweCBDb3VyaWVyIE5ld1wiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICBjdHguZmlsbFRleHQoXCJQdXQgdGV4dFwiLCAzOTAsIDEzMCk7XG4gICAgICAgIGN0eC5maWxsVGV4dChcImluIGhlcmVcIiwgMzkwLCAxNTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC54ID4gdGhpcy54ICYmIGVmZmVjdC54IDwgdGhpcy54ICsgMTAwICYmIGVmZmVjdC55ID4gdGhpcy55ICYmIGVmZmVjdC55IDwgdGhpcy55ICsgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3Nvbk9uZUNwVHdvID0gTGVzc29uT25lQ3BUd287XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25PbmVDcFR3by5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVGhyZWVDcEZpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsM2M1XCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDNjNic7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gU28gd2UgcHJpbnQgYSBtZXNzYWdlIHRvIHRoZSBDQU5WQVMgYW55dGltZSBjIGlzIGV4YWN0bHkgZXF1YWwgdG8gOC4gPC9wPlxuICAgIDxwPiBXaGF0IGlmIHdlIHdhbnQgdG8gcHJpbnQgYW5vdGhlciBtZXNzYWdlLCBcImMgaXMgbm90IGVxdWFsIHRvIDhcIiBhbnkgdGltZSBjIGlzIG5vdCBlcXVhbCB0byA4PyA8L3A+XG4gICAgPHA+IFdlIGRvIHNvIGJ5IHVzaW5nIGFuIGVsc2Ugc3RhdGVtZW50LiBPYnNlcnZlIHRoZSBDT0RFIGFib3ZlLiA8L3A+XG4gICAgPHA+IFdoZW4gdGhlIGNvbmRpdGlvbiBpbnNpZGUgdGhlIGlmKCkgc3RhdGVtZW50IGlzIHNhdGlzZmllZCwgdGhlIGNvZGUgYmxvY2sgaW5zaWRlIHRoZSB7fSByaWdodCBhZnRlciBpdCB3b3VsZCBydW4uIDwvcD5cbiAgICA8cD4gV2hlbiB0aGF0IGNvbmRpdGlvbiBpcyBub3Qgc2F0aXNmaWVkLCB0aGUgY29kZSBibG9jayBpbnNpZGUgdGhlIHt9IGFmdGVyIHRoZSBlbHNlIHN0YXRlbWVudCB3b3VsZCBydW4uIDwvcD5cbiAgICA8cD4gR09BTDogQ2hhbmdlIHRoZSB2YWx1ZSBvZiBjIHNvIHRoYXQgdGhlIGxpbmUgXCJjIGlzIE5PVCBlcXVhbCB0byA4LlwiIGlzIHByaW50ZWQgb24gdGhlIENBTlZBUy4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYGMgPSA4O1xuaWYoYyA9PSA4KSB7XG4gIHByaW50KFwiYyBpcyBlcXVhbCB0byA4LlwiLCAxMDMsIDE0Myk7XG59IGVsc2Uge1xuICBwcmludChcImMgaXMgTk9UIGVxdWFsIHRvIDguXCIsIDEwMywgMTQzKTtcbn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiBsZWFkaW5nIGludG8gY29uZGl0aW9uYWxzXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvY1xccyo9XFxzKlteOF1cXHMqLztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciA9PT0gXCJjIGlzIE5PVCBlcXVhbCB0byA4LlwiKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblRocmVlQ3BGaXZlID0gTGVzc29uVGhyZWVDcEZpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25UaHJlZUNwRml2ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVGhyZWVDcEZvdXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsM2M0XCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDNjNSc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gWW91IGNhbiBwdXQgYW4gaW5lcXVhbGl0eSBjb25kaXRpb24gaW4gdGhlIGlmKCkgY2xhdXNlLCBzdWNoIGFzIFwiYSA8IDVcIiBvciBcImIgPiAyMFwiLiA8L3A+XG4gICAgPHA+IFlvdSBjYW4gYWxzbyB1c2UgYW4gZXF1YWxpdHkgY29uZGl0aW9uLiBPYnNlcnZlIHRoZSBDT0RFIGFib3ZlIHdpdGggXCJjID09IDhcIi4gVGhlIDIgZXF1YWwgc2lnbnMgbWVhbiB0aGF0IHlvdSBhcmUgY2hlY2tpbmcgd2hldGhlciBjIGlzIGV4YWN0bHkgZXF1YWwgdG8gOCBvciBub3QuIDwvcD5cbiAgICA8cD4gQ2hhbmdlIHRoZSB2YWx1ZSBvZiBjIHNvIHRoYXQgdGhlIGxpbmUgXCJjIGlzIGVxdWFsIHRvIDguXCIgaXMgcHJpbnRlZCBvbiB0aGUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IEdPQUw6IENoYW5nZSB0aGUgdmFsdWUgb2YgYyBzbyB0aGF0IHRoZSBsaW5lIFwiYyBpcyBlcXVhbCB0byA4LlwiIGlzIHByaW50ZWQgb24gdGhlIENBTlZBUy4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYGMgPSAxMDA7XG5pZihjID09IDgpIHtcbiAgcHJpbnQoXCJjIGlzIGVxdWFsIHRvIDguXCIsIDEwMywgMTQzKTtcbn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiBsZWFkaW5nIGludG8gY29uZGl0aW9uYWxzXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvY1xccyo9XFxzKjhcXHMqLztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciA9PT0gXCJjIGlzIGVxdWFsIHRvIDguXCIpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVGhyZWVDcEZvdXIgPSBMZXNzb25UaHJlZUNwRm91cjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblRocmVlQ3BGb3VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3RyaW5nRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9TdHJpbmdFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25UaHJlZUNwT25lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDNjMVwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wzYzInO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFdlIGxlYXJuZWQgdG8gdGVsbCB0aGUgY29tcHV0ZXIgdG8gcHJpbnQgYSBsb3Qgb2YgdGhpbmdzLiBVbmZvcnR1bmF0ZWx5LCB0aGUgY29tcHV0ZXIgaXMga2luZGEgYmFkIGF0IG1hdGguIDwvcD5cbiAgICA8cD4gTG9vayBhdCB0aGUgQ09ERSBhYm92ZS4gV2UgbGV0IGEgPSA1LCB0aGVuIHdlIHByaW50IHRoZSB2YWx1ZSBvZiBhIHRvIHRoZSBDQU5WQVMuIFRoZW4gd2UgcHJpbnQgdGhlIGxpbmUgXCJhIGlzIGxlc3MgdGhhbiAxMFwiLiA8L3A+XG4gICAgPHA+IFNpbmNlIGEgPSA1LCBhbmQgNSA8IDEwLCB3ZSBrbm93IHRoYXQgYSBpcyBsZXNzIHRoYW4gMTAuIEJ1dCB3aGF0IHdvdWxkIGhhcHBlbiBpZiB3ZSBjaGFuZ2UgdGhlIHZhbHVlIG9mIGEgdG8sIHNheSwgMTI/IDwvcD5cbiAgICA8cD4gR09BTDogY2hhbmdlIHRoZSB2YWx1ZSBvZiBhIHRvIDEyLiA8L3A+XG4gICAgPHA+IEhJTlQ6IFlvdSBjYW4gZG8gdGhpcyBieSBjaGFuZ2luZyB0aGUgbGluZSBhID0gNSBpbiB0aGUgQ09ERSBhcmVhLCBvciB5b3UgY2FuIGNsaWNrIG9uIHRoZSBudW1iZXIgNSBvbiB0aGUgQ0FOVkFTLiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgYSA9IDU7XG5wcmludChhLCAxMTgsIDYzKTtcbnByaW50KFwiYSBpcyBsZXNzIHRoYW4gMTBcIiwgMTAzLCAxNDMpO2A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIGxlYWRpbmcgaW50byBjb25kaXRpb25hbHNcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRcIikudmFsdWU7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZWdleCA9IC9hXFxzKj1cXHMqMTJcXHMqLztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyID09PSBcImEgaXMgbGVzcyB0aGFuIDEwXCIpIHtcbiAgICAgICAgICAgICAgICAvL2NhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy9icmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblRocmVlQ3BPbmUgPSBMZXNzb25UaHJlZUNwT25lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVGhyZWVDcE9uZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3NvblRocmVlQ3BTaXgge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsM2M2XCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDRjMSc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gTm93IHRoYXQgeW91IGtub3cgaG93IHRvIHVzZSBpZi9lbHNlIHN0YXRlbWVudHMsIGxldCdzIHB1dCB0aGVtIGFsbCB0b2dldGhlciEgPC9wPlxuICAgIDxwPiBBYm92ZSB3ZSBoYXZlIHRoZSBDT0RFIHRvIGRyYXcgMiBjaXJjbGVzOiBjaXJjbGUgQSBoYXMgaGVpZ2h0IGFuZCB3aWR0aCBhLCBhbmQgY2lyY2xlIEIgaGFzIGhlaWdodCBhbmQgd2lkdGggYi4gPC9wPlxuICAgIDxwPiBIb3dldmVyLCBjdXJyZW50bHkgdGhlIGNsYWltIHRoYXQgXCJDaXJjbGUgQSBpcyBzbWFsbGVyIHRoYW4gY2lyY2xlIEIuXCIgcmVnYXJkbGVzcyBvZiB0aGUgY2lyY2xlcycgYWN0dWFsIHNpemVzLiA8L3A+XG4gICAgPHA+IENyZWF0ZSBhbiBpZi9lbHNlIHN0YXRlbWVudCB0byBwcmludCBcIkNpcmNsZSBBIGlzIHNtYWxsZXIgdGhhbiBjaXJjbGUgQi5cIiB3aGVuIGl0IGlzIGFjdHVhbGx5IHNvLCBhbmQgcHJpbnQgXCJDaXJjbGUgQSBpcyBiaWdnZXIgdGhhbiBjaXJjbGUgQlwiIG90aGVyd2lzZS4gPC9wPlxuICAgIDxwPiBDSEFMTEVOR0U6IENyZWF0ZSBhbiBpZi9lbHNlIHN0YXRlbWVudCB0byBwcmludCB0aGUgY29ycmVjdCBjbGFpbSBhYm91dCB0aGUgc2l6ZXMgb2YgdGhlIDIgY2lyY2xlcy4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYGEgPSAyMDA7XG5wcmludChhLCAxMTEsIDEwMyk7XG5wcmludChlbGxpcHNlKGEsIGEpLCAxMzEsIDI2Myk7XG5iID0gMTAwO1xucHJpbnQoYiwgMzM3LCAxMDQpO1xucHJpbnQoZWxsaXBzZShiLCBiKSwgMzcxLCAyNDgpO1xucHJpbnQoXCJDaXJjbGUgQSBpcyBzbWFsbGVyIHRoYW4gY2lyY2xlIEIuXCIsIDQ1LCA0NTMpO1xuYDtcbiAgICAgICAgdGhpcy54QSA9IDIwO1xuICAgICAgICB0aGlzLnlBID0gMTUwO1xuICAgICAgICB0aGlzLnhCID0gdGhpcy54QSArIDIyNSArIDEwO1xuICAgICAgICB0aGlzLnlCID0gMTUwO1xuICAgIH1cbiAgICBkcmF3R3VpZGVzKGN0eCkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5yZWN0KHRoaXMueEEsIHRoaXMueUEsIDIyNSwgMjI1KTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5mb250ID0gMjAgKyBcInB4IENvdXJpZXIgTmV3XCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgIGN0eC5maWxsVGV4dChcIkNpcmNsZSBBXCIsIHRoaXMueEEsIHRoaXMueUEgLSAyMCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3QodGhpcy54QiwgdGhpcy55QiwgMjI1LCAyMjUpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5maWxsVGV4dChcIkNpcmNsZSBCXCIsIHRoaXMueEIsIHRoaXMueUIgLSAyMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIGxlYWRpbmcgaW50byBjb25kaXRpb25hbHNcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRcIikudmFsdWU7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBpZihhIDwgYikge1xuICAgICAgICAgICAgICBwcmludChcIkNpcmNsZSBBIGlzIHNtYWxsZXIgdGhhbiBjaXJjbGUgQi5cIiwgNDUsIDQ1Myk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcmludChcIkNpcmNsZSBBIGlzIGJpZ2dlciB0aGFuIGNpcmNsZSBCLlwiLCA0NSwgNDUzKTtcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgbGV0IHJlZ2V4MSA9IC9pZlxccypcXChcXHMqYVxccypbPD5dXFxzKmJcXHMqXFwpLztcbiAgICAgICAgICAgIGxldCByZWdleDIgPSAvaWZcXHMqXFwoXFxzKmJcXHMqWzw+XVxccyphXFxzKlxcKS87XG4gICAgICAgICAgICBsZXQgbWF0Y2gxID0gY29kZS5tYXRjaChyZWdleDEpO1xuICAgICAgICAgICAgbGV0IG1hdGNoMiA9IGNvZGUubWF0Y2gocmVnZXgyKTtcbiAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSAobWF0Y2gxICE9IG51bGwgJiYgbWF0Y2gxLmxlbmd0aCA+IDApIHx8IChtYXRjaDIgIT0gbnVsbCAmJiBtYXRjaDIubGVuZ3RoID4gMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICBsZXQgY2FudmFzSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjaXJjbGVBID0gbnVsbDtcbiAgICAgICAgbGV0IGNpcmNsZUIgPSBudWxsO1xuICAgICAgICAvL2xvb2sgZm9yIGNpcmNsZXMgQSBhbmQgQlxuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC54ID4gdGhpcy54QSAmJiBlZmZlY3QueCA8IHRoaXMueEEgKyAyMjUgJiYgZWZmZWN0LnkgPiB0aGlzLnlBICYmIGVmZmVjdC55IDwgdGhpcy55QSArIDIyNSkge1xuICAgICAgICAgICAgICAgICAgICBjaXJjbGVBID0gZWZmZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QueCA+IHRoaXMueEIgJiYgZWZmZWN0LnggPCB0aGlzLnhCICsgMjI1ICYmIGVmZmVjdC55ID4gdGhpcy55QiAmJiBlZmZlY3QueSA8IHRoaXMueUIgKyAyMjUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2lyY2xlQiA9IGVmZmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNpcmNsZUEgIT0gbnVsbCAmJiBjaXJjbGVCICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RyID0gZWZmZWN0LnN0cjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChzdHIgPT09IFwiQ2lyY2xlIEEgaXMgc21hbGxlciB0aGFuIGNpcmNsZSBCLlwiICYmIGNpcmNsZUEudyA8IGNpcmNsZUIudyAmJiBjaXJjbGVBLmggPCBjaXJjbGVCLmgpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAoc3RyID09PSBcIkNpcmNsZSBBIGlzIGJpZ2dlciB0aGFuIGNpcmNsZSBCLlwiICYmIGNpcmNsZUEudyA+IGNpcmNsZUIudyAmJiBjaXJjbGVBLmggPiBjaXJjbGVCLmgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25UaHJlZUNwU2l4ID0gTGVzc29uVGhyZWVDcFNpeDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblRocmVlQ3BTaXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3NvblRocmVlQ3BUaHJlZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwzYzNcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsM2M0JztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBpZiBzdGF0ZW1lbnRzIGFsbG93IHlvdSB0byBydW4gYSBibG9jayBvZiBjb2RlIGluc2lkZSB0aGUgY3VybHkgYnJhY2VzIHt9IE9OTFkgd2hlbiB0aGUgY29uZGl0aW9uIGluc2lkZSB0aGUgaWYoKSBjbGF1c2UgaXMgdHJ1ZS4gPC9wPlxuICAgIDxwPiBMZXQncyBoYXZlIGEgcXVpY2sgY2hhbGxlbmdlOiBvYnNlcnZlIHRoZSBDT0RFIGFib3ZlLiBNYWtlIGl0IHNvIHRoYXQgdGhlIGxpbmUgXCJiIGlzIGdyZWF0ZXIgdGhhbiAyMFwiIGlzIG9ubHkgcHJpbnRlZCBvbiB0aGUgQ0FOVkFTIHdoZW4gYiBpcyBhY3R1YWxseSBncmVhdGVyIHRoYW4gMjAuIDwvcD5cbiAgICA8cD4gR09BTDogTWFrZSB0aGUgbGluZSBcImIgaXMgZ3JlYXRlciB0aGFuIDIwXCIgb25seSBiZSBwcmludGVkIG9uIHRoZSBDQU5WQVMgd2hlbiBiIGlzIGFjdHVhbGx5IGdyZWF0ZXIgdGhhbiAyMC4gQ2hhbmdlIGIgdG8gdGVzdCB0aGUgaWYoKSBzdGF0ZW1lbnQuIDwvcD5gO1xuICAgICAgICB0aGlzLl9zdGFydGVyQ29kZSA9IGBiID0gODtcbmlmKGIgPCAxMCkge1xuICBwcmludChcImIgaXMgZ3JlYXRlciB0aGFuIDIwLlwiLCAxMDMsIDE0Myk7XG59YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gbGVhZGluZyBpbnRvIGNvbmRpdGlvbmFsc1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dFwiKS52YWx1ZTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gL2lmXFxzKlxcKFxccypiXFxzKj5cXHMqMjBcXHMqXFwpLztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QgJiYgZWZmZWN0LnN0ciA9PT0gXCJiIGlzIGdyZWF0ZXIgdGhhbiAyMC5cIikge1xuICAgICAgICAgICAgICAgIGNhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25UaHJlZUNwVGhyZWUgPSBMZXNzb25UaHJlZUNwVGhyZWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25UaHJlZUNwVGhyZWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3NvblRocmVlQ3BUd28ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsM2MyXCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDNjMyc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gRGlkIHlvdSBub3RpY2UgdGhlIGNsYWltIHRoYXQgXCJhIGlzIGxlc3MgdGhhbiAxMFwiIGRpZCBub3QgY2hhbmdlPyBhIGlzIG5vdyAxMiBhbmQgY2xlYXJseSBncmVhdGVyIHRoYW4gMTAhIDwvcD5cbiAgICA8cD4gV2hhdCB3ZSB3YW50IGlzIGZvciB0aGUgY29tcHV0ZXIgdG8gb25seSBwcmludCBcImEgaXMgbGVzcyB0aGFuIDEwXCIgT05MWSB3aGVuIHRoZSB2YWx1ZSBvZiBhIGlzIHRydWx5IGxlc3MgdGhhbiAxMC4gPC9wPlxuICAgIDxwPiBUbyBkbyBzbywgd2UgdXNlIGFuIGlmIHN0YXRlbWVudC4gT2JzZXJ2ZSB0aGUgQ09ERSBhYm92ZS4gQWxsIHdlIGNoYW5nZWQgd2FzIHRvIHB1dCBpbiBhbiBpZiBzdGF0ZW1lbnQgdGhhdCBjaGVja3Mgd2hldGhlciBhIDwgMTAuIElmIGEgaXMsIHRoZSBjb2RlIGluc2lkZSB0aGUgY3VybHkgYnJhY2VzIHt9IGFyZSBleGVjdXRlZC4gPC9wPlxuICAgIDxwPiBDaGFuZ2UgdGhlIHZhbHVlIG9mIGEgdG8gMTIsIDEwLCA4IGFuZCBvYnNlcnZlIHdoYXQgaGFwcGVucy4gPC9wPlxuICAgIDxwPiBHT0FMOiBSVU4gdGhlIENPREUgd2l0aCBhID0gMTIgb3IgMTAgb3IgOC4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYGEgPSAxMjtcbnByaW50KGEsIDExOCwgNjMpO1xuaWYoYSA8IDEwKSB7XG4gIHByaW50KFwiYSBpcyBsZXNzIHRoYW4gMTBcIiwgMTAzLCAxNDMpO1xufWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIGxlYWRpbmcgaW50byBjb25kaXRpb25hbHNcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRcIikudmFsdWU7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZWdleCA9IC9hXFxzKj1cXHMqOFxccyovO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gY29kZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgbGV0IGNhbnZhc0lzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyID09PSBcImEgaXMgbGVzcyB0aGFuIDEwXCIpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVGhyZWVDcFR3byA9IExlc3NvblRocmVlQ3BUd287XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25UaHJlZUNwVHdvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwRml2ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwyYzVcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsMmM2JztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBEaWQgeW91IHNlZSB0aGUgQ0FOVkFTIGNoYW5nZWQ/IDwvcD5cbiAgICA8cD4gSW4gb3VyIGNvZGUsIHdlIG1ha2UgdmFyaWFibGUgYSByZWZlciB0byB0aGUgd29yZHMgXCJtb28gbW9vXCIsIGFuZCB2YXJpYWJsZSBiIHJlZmVyIHRvIGFuIGVsbGlwc2UoMTAwLCAxMDApLiA8L3A+XG4gICAgPHA+IEFzIGEgcmVzdWx0LCB3aGVuIHdlIHRlbGwgdGhlIGNvbXB1dGVyIHRvIHByaW50IGEsIGl0IHdpbGwgcHJpbnQgXCJtb28gbW9vXCIsIGFuZCB3aGVuIHdlIHRlbGwgdGhlIGNvbXB1dGVyIHRvIHByaW50IGIsIGl0IHdpbGwgcHJpbnQgYSBjaXJjbGUuIDwvcD5cbiAgICA8cD4gTGV0J3MgdGFrZSB0aGlzIG9uZSBzdGVwIGZ1cnRoZXI6IENyZWF0ZSBhIG5ldyB2YXJpYWJsZSBjLCBhbmQgbWFrZSBpdCByZWZlciB0byBhbiBlbGxpcHNlKDEwMCwgMTAwKS4gVGhlbiB3cml0ZSAyIHN0YXRlbWVudHMgdG8gcHJpbnQgYy4gV2hhdCBkbyB5b3UgdGhpbmsgd291bGQgaGFwcGVuPyA8L3A+XG4gICAgPHA+IEdPQUw6IENyZWF0ZSBhIHZhcmlhYmxlIGMgcmVmZXJyaW5nIHRvIGFuIGVsbGlwc2UoMTAwLCAxMDApLCB0aGVuIHdyaXRlIDIgcHJpbnQgc3RhdGVtZW50cyB0byBwcmludCBjLiA8L3A+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRcIikudmFsdWU7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBhc3NpZ25tZW50ID0gL2NcXHMqPVxccyplbGxpcHNlXFxzKlxcKFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKVxccyovZztcbiAgICAgICAgICAgIGxldCBtYXRjaEFzc2lnbiA9IGNvZGUubWF0Y2goYXNzaWdubWVudCk7XG4gICAgICAgICAgICBsZXQgcHJpbnQgPSAvcHJpbnRcXHMqXFwoXFxzKmNcXHMqLFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKS9nO1xuICAgICAgICAgICAgbGV0IG1hdGNoUHJpbnQgPSBjb2RlLm1hdGNoKHByaW50KTtcbiAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSBtYXRjaEFzc2lnbiAhPSBudWxsICYmIG1hdGNoQXNzaWduLmxlbmd0aCA+IDAgJiYgbWF0Y2hQcmludCAhPSBudWxsICYmIG1hdGNoUHJpbnQubGVuZ3RoID49IDI7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICBsZXQgY2lyY2xlQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgY2lyY2xlQ291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjaXJjbGVDb3VudCA+PSAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Ud29DcEZpdmUgPSBMZXNzb25Ud29DcEZpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Ud29DcEZpdmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFbGxpcHNlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9FbGxpcHNlRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVHdvQ3BGb3VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDJjNFwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wyYzUnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFRoZXJlJ3Mgbm8gbGltaXQgdG8gaG93IG1hbnkgcHJpbnQgc3RhdGVtZW50cyB0aGUgY29tcHV0ZXIgY2FuIHVuZGVyc3RhbmQsIHNvIHlvdSBjYW4gd3JpdGUgMTAwMCBwcmludCBzdGF0ZW1lbnRzLCBhbmQgdGhlIGNvbXB1dGVyIHdpbGwgZHJhdyAxMDAwIHRoaW5ncyBvbiB0aGUgQ0FOVkFTIGZvciB5b3UhIDwvcD5cbiAgICA8cD4gVGltZSB0byB0YWtlIHlvdXIgY29kaW5nIHRvIHRoZSBuZXh0IGxldmVsLiBMZXQncyBsZWFybiBhYm91dCB2YXJpYWJsZXMuIDwvcD5cbiAgICA8cD4gVmFyaWFibGVzIGFyZSBzaW1wbHkgbmFtZXMgeW91IGdpdmUgdG8gdGhlIHRoaW5ncyB0aGF0IHlvdSBkcmF3LiA8L3A+XG4gICAgPHA+IEZvciBleGFtcGxlLCB0YWtlIGEgbG9vayBhdCB0aGUgY29kZSBhYm92ZS4gQ2hhbmdlIHRoZSBhIGluIHRoZSBwcmludCBzdGF0ZW1lbnQgdG8gYiwgYW5kIG9ic2VydmUgd2hhdCBoYXBwZW5lZCBvbiB0aGUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IEdPQUw6IENoYW5nZSBhIHRvIGIgaW4gdGhlIHByaW50IHN0YXRlbWVudC4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYGEgPSBcIm1vbyBtb29cIjtcXG5iID0gZWxsaXBzZSgxMDAsIDEwMCk7XFxucHJpbnQoYSwgNTAsIDcwKTtgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dFwiKS52YWx1ZTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gL3ByaW50XFxzKlxcKFxccypiXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqLFxccypbMS05XVswLTldKlxccypcXCk7LztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKCFjYW52YXNJc0NvcnJlY3QgJiYgZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVHdvQ3BGb3VyID0gTGVzc29uVHdvQ3BGb3VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVHdvQ3BGb3VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwT25lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDJjMVwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wyYzInO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFByaW50aW5nIG9ubHkgd29yZHMgaXMga2luZGEgYm9yaW5nLCBzbyBsZXQncyBsZWFybiB0byBwcmludCBzb21lIHNoYXBlcyBvbiB0aGUgQ0FOVkFTISA8L3A+XG4gICAgPHA+IEluIHRoZSBwcmludCBzdGF0ZW1lbnQsIHJlcGxhY2UgXCJtb29cIiB3aXRoIGVsbGlwc2UoMTAwLDEwMCkuIEhpdCB0aGUgUlVOIGJ1dHRvbiB0byBzZWUgd2hhdCBoYXBwZW5zLiA8L3A+XG4gICAgPHA+IEdPQUw6IHJlcGxhY2UgXCJtb29cIiB3aXRoIGVsbGlwc2UoMTAwLDEwMCkgaW4gdGhlIHByaW50IHN0YXRlbWVudCBhYm92ZS4gPC9wPlxuICAgIDxwPiBISU5UOiBIaWdobGlnaHQgXCJtb29cIiAtIGluY2x1ZGluZyB0aGUgZG91YmxlIHF1b3RlcyBcIiwgYW5kIHJlcGxhY2UgdGhhdCB3aXRoIGVsbGlwc2UoMTAwLCAxMDApLiBLRUVQIEVWRVJZVEhJTkcgRUxTRSBUSEUgU0FNRS4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYFxuICAgIHByaW50KFwibW9vXCIsIDUwLCA3MClgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dFwiKS52YWx1ZTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gL3ByaW50XFxzKlxcKFxccyplbGxpcHNlXFxzKlxcKFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKVxccyosXFxzKlsxLTldWzAtOV0qXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqXFwpLztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBFbGxpcHNlRWZmZWN0XzEuRWxsaXBzZUVmZmVjdCkge1xuICAgICAgICAgICAgICAgIGNhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Ud29DcE9uZSA9IExlc3NvblR3b0NwT25lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVHdvQ3BPbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL051bWJlckVmZmVjdFwiKTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25Ud29DcFNldmVuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDJjN1wiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wzYzEnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IENoYW5naW5nIG9uZSBjaXJjbGUgY2hhbmdlcyBjLCB3aGljaCB3aWxsIHRoZW4gaW4gdHVybiBjaGFuZ2UgdGhlIG90aGVyIGNpcmNsZSEgPC9wPlxuICAgIDxwPiBOb3cgbGV0J3MgcHV0IGFsbCB3ZSBoYXZlIGxlYXJuZWQgdG8gcHJhY3RpY2UuIDwvcD5cbiAgICA8cD4gQ3JlYXRlIGEgY2lyY2xlLCBhbmQgcHJpbnQgb3V0IHRoZSBzaXplIG9mIHRoYXQgY2lyY2xlIGluIHRoZSBnaXZlbiBib3guIDwvcD5cbiAgICA8cD4gSUYgd2UgZXZlciBjaGFuZ2UgdGhlIGNpcmNsZSwgd2Ugd2FudCB0aGUgbnVtYmVyIGluIHRoZSBib3ggdG8gY2hhbmdlLCB0b28hIDwvcD5cbiAgICA8cD4gQ0hBTExFTkdFOiBDcmVhdGUgYSBjaXJjbGUgYW5kIHByaW50IGl0cyBzaXplIGluIHRoZSBnaXZlbiBib3guIDwvcD5gO1xuICAgICAgICB0aGlzLnggPSAxMDtcbiAgICAgICAgdGhpcy55ID0gNDMwO1xuICAgIH1cbiAgICBkcmF3R3VpZGVzKGN0eCkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5yZWN0KHRoaXMueCwgdGhpcy55LCAxMDAsIDEwMCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguZm9udCA9IDIwICsgXCJweCBDb3VyaWVyIE5ld1wiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICBjdHguZmlsbFRleHQoXCJQdXQgY2lyY2xlJ3Mgc2l6ZVwiLCB0aGlzLngsIDM5MCk7XG4gICAgICAgIGN0eC5maWxsVGV4dChcImluIGhlcmVcIiwgdGhpcy54LCA0MTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QgaW5zdGFuY2VvZiBOdW1iZXJFZmZlY3RfMS5OdW1iZXJFZmZlY3QgJiYgZWZmZWN0Lm51bSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC54ID4gdGhpcy54ICYmIGVmZmVjdC54IDwgdGhpcy54ICsgMTAwICYmIGVmZmVjdC55ID4gdGhpcy55ICYmIGVmZmVjdC55IDwgdGhpcy55ICsgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBlZmZlY3QubnVtO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBlZmZlY3QyIG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QyIGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QgJiYgKHZhbCA9PSBlZmZlY3QyLncgfHwgdmFsID09IGVmZmVjdDIuaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblR3b0NwU2V2ZW4gPSBMZXNzb25Ud29DcFNldmVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVHdvQ3BTZXZlbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25Ud29DcFNpeCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwyYzZcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsMmM3JztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdjb2RlJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBOb3cgdGhhdCB5b3UgaGF2ZSBkcmF3biAyIGNpcmNsZXMgYm90aCBhcmUgY2FsbGVkIGMsIGxldCdzIHNlZSB3aGF0IGhhcHBlbnMgd2hlbiB5b3UgdHJ5IHRvIG1vZGlmeSBvbmUgb2YgdGhlbS4gPC9wPlxuICAgIDxwPiBDbGljayBvbiBvbmUgb2YgdGhlIGNpcmNsZXMgb24gdGhlIENBTlZBUywgYW5kIHRyeSBtYWtlIGl0IGJpZ2dlci4gT2JzZXJ2ZSB3aGF0IGhhcHBlbnMgdG8geW91ciBkZWNsYXJhdGlvbiBvZiBjLiA8L3A+XG4gICAgPHA+IEdPQUw6IEVubGFyZ2Ugb25lIG9mIHRoZSBjaXJjbGVzIHJlZmVycmVkIHRvIGJ5IGMgb24gdGhlIENBTlZBUy4gPC9wPmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC53ID4gMjUwICYmIGVmZmVjdC5oID4gMjUwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblR3b0NwU2l4ID0gTGVzc29uVHdvQ3BTaXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Ud29DcFNpeC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwVGhyZWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMmMzXCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDJjNCc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gU28gd2UgY2FuIGRyYXcgYSBjaXJjbGUgYW5kIGNoYW5nZSBpdC4gQnV0IHdoYXQgaWYgd2Ugd2FudCB0byBkcmF3IGJvdGggY2lyY2xlcyBhbmQgd29yZHM/IDwvcD5cbiAgICA8cD4gV2VsbCwgc2ltcGxlISBKdXN0IHdyaXRlIG1vcmUgcHJpbnQgc3RhdGVtZW50cyBpbiB0aGUgQ09ERSBhcmVhISA8L3A+XG4gICAgPHA+IEdPQUw6IERyYXcgMiBjaXJjbGVzIGFuZCBhIHdvcmQgb24gdGhlIENBTlZBUy4gPC9wPlxuICAgIDxwPiBISU5UOiBSZW1lbWJlciB0aGF0IHRoZSBudW1iZXJzIHJpZ2h0IGluc2lkZSB0aGUgZWxsaXBzZShfLF8pIHN0YXRlbWVudCBjaGFuZ2UgdGhlIGNpcmNsZSdzIHNpemVzLmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBsZXQgc3RyaW5nRXhpc3RzID0gZmFsc2U7XG4gICAgICAgIGxldCBjaXJjbGVDb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoIXN0cmluZ0V4aXN0cykge1xuICAgICAgICAgICAgICAgIHN0cmluZ0V4aXN0cyA9IGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyICE9PSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgY2lyY2xlQ291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nRXhpc3RzICYmIGNpcmNsZUNvdW50ID49IDI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblR3b0NwVGhyZWUgPSBMZXNzb25Ud29DcFRocmVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVHdvQ3BUaHJlZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25Ud29DcFR3byB7XG4gICAgLypcbiAgICBgPHA+IFNvIHdlIGNhbiBkcmF3IGEgY2lyY2xlIGFuZCBjaGFuZ2UgaXQuIEJ1dCB3aGF0IGlmIHdlIHdhbnQgdG8gZHJhdyBib3RoIGEgY2lyY2xlIGFuZCBhIHdvcmQ/IDwvcD5cbiAgICA8cD4gV2VsbCwgc2ltcGxlISBKdXN0IHdyaXRlIGFub3RoZXIgcHJpbnQgc3RhdGVtZW50IGluIHRoZSBDT0RFIGFyZWEhIDwvcD5cbiAgICA8cD4gR09BTDogRHJhdyAyIGNpcmNsZXMgYW5kIGEgd29yZCBvbiB0aGUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IEhJTlQ6IFJlbWVtYmVyIHRoYXQgdGhlIG51bWJlcnMgcmlnaHQgaW5zaWRlIHRoZSBlbGxpcHNlKF8sXykgc3RhdGVtZW50IGNoYW5nZSB0aGUgY2lyY2xlJ3Mgc2l6ZXMuYDtcbiovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwyYzJcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsMmMzJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdjb2RlJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBXZSBjYW4gd3JpdGUgZWxsaXBzZSgxMDAsIDEwMCkgaW4gdGhlIHByaW50IHN0YXRlbWVudCB0byBkcmF3IGEgY2lyY2xlIG9uIHRoZSBDQU5WQVMuIDwvcD5cbiAgICA8cD4gV2hhdCBhcmUgdGhlIG51bWJlcnMgKDEwMCwgMTAwKSBmb3I/IEknbSBnbGFkIHlvdSBhc2tlZC4uLiA8L3A+XG4gICAgPHA+IEJlY2F1c2UgdGhlIENPREUgYXJlYSBpcyBmcm96ZW4gYWdhaW4hIERyYWcgb25lIG9mIHRoZSA5IHdoaXRlIHRpcHMgYXJvdW5kIHRoZSBjaXJjbGUgb24gdGhlIENBTlZBUyB0byBzZWUgaG93IHRoZSBudW1iZXIgY2hhbmdlcyEgPC9wPlxuICAgIDxwPiBHT0FMOiBNYWtlIHRoZSBjaXJjbGUgd2lkZXIgYnV0IHNob3J0ZXIuIDwvcD5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC53ID4gMjAwICYmIGVmZmVjdC5oIDwgODApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVHdvQ3BUd28gPSBMZXNzb25Ud29DcFR3bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblR3b0NwVHdvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi8uLi9pbmRleFwiKTtcbmNvbnN0IGluZGV4XzIgPSByZXF1aXJlKFwiLi4vLi4vaW5kZXhcIik7XG5jb25zdCBpbmRleF8zID0gcmVxdWlyZShcIi4uLy4uL2luZGV4XCIpO1xuY29uc3QgaW5kZXhfNCA9IHJlcXVpcmUoXCIuLi8uLi9pbmRleFwiKTtcbmNsYXNzIE1vZHVsZUdlbmVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoaXNETSkge1xuICAgICAgICB0aGlzLmRtQ29uc3RydWN0b3JzID0gbmV3IE1hcChbXG4gICAgICAgICAgICBbJ2wxYzEnLCAoKSA9PiBuZXcgaW5kZXhfMS5MZXNzb25PbmVDcE9uZSgpXSxcbiAgICAgICAgICAgIFsnbDFjMicsICgpID0+IG5ldyBpbmRleF8xLkxlc3Nvbk9uZUNwVHdvKCldLFxuICAgICAgICAgICAgWydsMWMzJywgKCkgPT4gbmV3IGluZGV4XzEuTGVzc29uT25lQ3BUaHJlZSgpXSxcbiAgICAgICAgICAgIFsnbDFjNCcsICgpID0+IG5ldyBpbmRleF8xLkxlc3Nvbk9uZUNwRm91cigpXSxcbiAgICAgICAgICAgIFsnbDJjMScsICgpID0+IG5ldyBpbmRleF8yLkxlc3NvblR3b0NwT25lKCldLFxuICAgICAgICAgICAgWydsMmMyJywgKCkgPT4gbmV3IGluZGV4XzIuTGVzc29uVHdvQ3BUd28oKV0sXG4gICAgICAgICAgICBbJ2wyYzMnLCAoKSA9PiBuZXcgaW5kZXhfMi5MZXNzb25Ud29DcFRocmVlKCldLFxuICAgICAgICAgICAgWydsMmM0JywgKCkgPT4gbmV3IGluZGV4XzIuTGVzc29uVHdvQ3BGb3VyKCldLFxuICAgICAgICAgICAgWydsMmM1JywgKCkgPT4gbmV3IGluZGV4XzIuTGVzc29uVHdvQ3BGaXZlKCldLFxuICAgICAgICAgICAgWydsMmM2JywgKCkgPT4gbmV3IGluZGV4XzIuTGVzc29uVHdvQ3BTaXgoKV0sXG4gICAgICAgICAgICBbJ2wyYzcnLCAoKSA9PiBuZXcgaW5kZXhfMi5MZXNzb25Ud29DcFNldmVuKCldLFxuICAgICAgICAgICAgWydsM2MxJywgKCkgPT4gbmV3IGluZGV4XzMuTGVzc29uVGhyZWVDcE9uZSgpXSxcbiAgICAgICAgICAgIFsnbDNjMicsICgpID0+IG5ldyBpbmRleF8zLkxlc3NvblRocmVlQ3BUd28oKV0sXG4gICAgICAgICAgICBbJ2wzYzMnLCAoKSA9PiBuZXcgaW5kZXhfMy5MZXNzb25UaHJlZUNwVGhyZWUoKV0sXG4gICAgICAgICAgICBbJ2wzYzQnLCAoKSA9PiBuZXcgaW5kZXhfMy5MZXNzb25UaHJlZUNwRm91cigpXSxcbiAgICAgICAgICAgIFsnbDNjNScsICgpID0+IG5ldyBpbmRleF8zLkxlc3NvblRocmVlQ3BGaXZlKCldLFxuICAgICAgICAgICAgWydsM2M2JywgKCkgPT4gbmV3IGluZGV4XzMuTGVzc29uVGhyZWVDcFNpeCgpXSxcbiAgICAgICAgICAgIFsnbDRjMScsICgpID0+IG5ldyBpbmRleF80Lkxlc3NvbkZvdXJDcE9uZSgpXSxcbiAgICAgICAgICAgIFsnbDRjMicsICgpID0+IG5ldyBpbmRleF80Lkxlc3NvbkZvdXJDcFR3bygpXVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5ub25EbUNvbnN0cnVjdG9ycyA9IG5ldyBNYXAoW1xuICAgICAgICAgICAgWydsMWMxJywgKCkgPT4gbmV3IGluZGV4XzEuTGVzc29uT25lQ3BPbmUoKV0sXG4gICAgICAgICAgICBbJ2wxYzInLCAoKSA9PiBuZXcgaW5kZXhfMS5MZXNzb25PbmVDcFRocmVlKCldLFxuICAgICAgICAgICAgWydsMWMzJywgKCkgPT4gbmV3IGluZGV4XzEuTGVzc29uT25lQ3BGb3VyKCldLFxuICAgICAgICAgICAgWydsMmMxJywgKCkgPT4gbmV3IGluZGV4XzIuTGVzc29uVHdvQ3BPbmUoKV0sXG4gICAgICAgICAgICBbJ2wyYzInLCAoKSA9PiBuZXcgaW5kZXhfMi5MZXNzb25Ud29DcFRocmVlKCldLFxuICAgICAgICAgICAgWydsMmMzJywgKCkgPT4gbmV3IGluZGV4XzIuTGVzc29uVHdvQ3BGb3VyKCldLFxuICAgICAgICAgICAgWydsMmM0JywgKCkgPT4gbmV3IGluZGV4XzIuTGVzc29uVHdvQ3BGaXZlKCldLFxuICAgICAgICAgICAgWydsMmM1JywgKCkgPT4gbmV3IGluZGV4XzIuTGVzc29uVHdvQ3BTZXZlbigpXSxcbiAgICAgICAgICAgIFsnbDNjMScsICgpID0+IG5ldyBpbmRleF8zLkxlc3NvblRocmVlQ3BPbmUoKV0sXG4gICAgICAgICAgICBbJ2wzYzInLCAoKSA9PiBuZXcgaW5kZXhfMy5MZXNzb25UaHJlZUNwVHdvKCldLFxuICAgICAgICAgICAgWydsM2MzJywgKCkgPT4gbmV3IGluZGV4XzMuTGVzc29uVGhyZWVDcFRocmVlKCldLFxuICAgICAgICAgICAgWydsM2M0JywgKCkgPT4gbmV3IGluZGV4XzMuTGVzc29uVGhyZWVDcEZvdXIoKV0sXG4gICAgICAgICAgICBbJ2wzYzUnLCAoKSA9PiBuZXcgaW5kZXhfMy5MZXNzb25UaHJlZUNwRml2ZSgpXSxcbiAgICAgICAgICAgIFsnbDNjNicsICgpID0+IG5ldyBpbmRleF8zLkxlc3NvblRocmVlQ3BTaXgoKV0sXG4gICAgICAgICAgICBbJ2w0YzEnLCAoKSA9PiBuZXcgaW5kZXhfNC5MZXNzb25Gb3VyQ3BPbmUoKV0sXG4gICAgICAgICAgICBbJ2w0YzInLCAoKSA9PiBuZXcgaW5kZXhfNC5MZXNzb25Gb3VyQ3BUd28oKV1cbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuY2hlY2twb2ludHMgPSBuZXcgTWFwKFtcbiAgICAgICAgICAgIFsnbDFjMScsIG51bGxdLFxuICAgICAgICAgICAgWydsMWMyJywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wxYzMnLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDFjNCcsIG51bGxdLFxuICAgICAgICAgICAgWydsMmMxJywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wyYzInLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDJjMycsIG51bGxdLFxuICAgICAgICAgICAgWydsMmM0JywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wyYzUnLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDJjNicsIG51bGxdLFxuICAgICAgICAgICAgWydsMmM3JywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wzYzEnLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDNjMicsIG51bGxdLFxuICAgICAgICAgICAgWydsM2MzJywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wzYzQnLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDNjNScsIG51bGxdLFxuICAgICAgICAgICAgWydsM2M2JywgbnVsbF0sXG4gICAgICAgICAgICBbJ2w0YzEnLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDRjMicsIG51bGxdXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoaXNETSkge1xuICAgICAgICAgICAgdGhpcy5jdXJDb25zdHJ1Y3RvcnMgPSB0aGlzLmRtQ29uc3RydWN0b3JzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJDb25zdHJ1Y3RvcnMgPSB0aGlzLm5vbkRtQ29uc3RydWN0b3JzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdlbmVyYXRlQ2hlY2twb2ludChjcCkge1xuICAgICAgICBsZXQgY2hlY2twb2ludCA9IHRoaXMuY2hlY2twb2ludHMuZ2V0KGNwKTtcbiAgICAgICAgaWYgKGNoZWNrcG9pbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrcG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2twb2ludCA9IHRoaXMuY3VyQ29uc3RydWN0b3JzLmdldChjcCkoKTtcbiAgICAgICAgdGhpcy5jaGVja3BvaW50cy5zZXQoY3AsIGNoZWNrcG9pbnQpO1xuICAgICAgICByZXR1cm4gY2hlY2twb2ludDtcbiAgICB9XG59XG5leHBvcnRzLk1vZHVsZUdlbmVyYXRvciA9IE1vZHVsZUdlbmVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1vZHVsZUdlbmVyYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHBhbnRzXzEgPSByZXF1aXJlKFwicGFudHNcIik7XG5jb25zdCBpbmRleF8xID0gcmVxdWlyZShcIi4uLy4uL2luZGV4XCIpO1xuY29uc3Qgc3BhY2VfbGlmdF8xID0gcmVxdWlyZShcInNwYWNlLWxpZnRcIik7XG52YXIgUGFyc2VyO1xuKGZ1bmN0aW9uIChQYXJzZXIpIHtcbiAgICAvKipcbiAgICAgKiB0byBiZSBtb3ZlZCB0byBQYW50c1xuICAgICAqIG51bWJlciBwYXJzZXMgbnVtYmVycyBieSByZXBlYXRlZGx5IGFwcGx5aW5nIHRoZSBkaWdpdCBwYXJzZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudW1iZXIoKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55MShwYW50c18xLlByaW1pdGl2ZXMuZGlnaXQoKSkoaXN0cmVhbSk7XG4gICAgICAgICAgICBzd2l0Y2ggKG8udGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBkaWdpdCBvZiBvLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBkaWdpdC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGFudHNfMS5QcmltaXRpdmVzLlN1Y2Nlc3Moby5pbnB1dHN0cmVhbSwgcGFyc2VGbG9hdChzKSk7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFBhcnNlci5udW1iZXIgPSBudW1iZXI7XG4gICAgLyoqXG4gICAgICogdG8gYmUgbW92ZWQgdG8gUGFudHNcbiAgICAgKiBzdHJpbmcgaXMgYW4gYXJiaXRyYXJ5IHN0cmluZyBwYXJzZXIgdGhhdCByZXBlYXRlZGx5IGFwcGxpZXMgdGhlIGxldHRlciBwcmltaXRpdmVcbiAgICAgKiByZXR1cm5zIGEgQ2hhclN0cmVhbSByZXByZXNlbnRpbmcgdGhlIGVudGlyZSBwYXJzZWQgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyaW5nKCkge1xuICAgICAgICBsZXQgcCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLm1hbnkxKHBhbnRzXzEuUHJpbWl0aXZlcy5sZXR0ZXIoKSkpO1xuICAgICAgICBsZXQgZiA9ICh4cykgPT4gcGFudHNfMS5DaGFyVXRpbC5DaGFyU3RyZWFtLmNvbmNhdCh4cyk7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHApKGYpO1xuICAgIH1cbiAgICBQYXJzZXIuc3RyaW5nID0gc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIHRvIGJlIG1vdmVkIHRvIFBhbnRzXG4gICAgICogcHVuY3R1YXRpb24gcGFyc2VzIGFsbCBwb3NzaWJsZSBwdW5jdHVhdGlvbiBjaGFyYWN0ZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVuY3R1YXRpb24oKSB7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuc2F0KHggPT4geCA9PSBcIiFcIlxuICAgICAgICAgICAgfHwgeCA9PSBcIi5cIlxuICAgICAgICAgICAgfHwgeCA9PSAnLCdcbiAgICAgICAgICAgIHx8IHggPT0gXCI7XCJcbiAgICAgICAgICAgIHx8IHggPT0gJz8nXG4gICAgICAgICAgICB8fCB4ID09IFwiLVwiXG4gICAgICAgICAgICB8fCB4ID09IFwiJlwiXG4gICAgICAgICAgICB8fCB4ID09ICckJ1xuICAgICAgICAgICAgfHwgeCA9PSAnOidcbiAgICAgICAgICAgIHx8IHggPT0gJy8nXG4gICAgICAgICAgICB8fCB4ID09ICd8J1xuICAgICAgICAgICAgfHwgeCA9PSAnJSdcbiAgICAgICAgICAgIHx8IHggPT0gJyMnXG4gICAgICAgICAgICB8fCB4ID09IFwiQFwiXG4gICAgICAgICAgICB8fCB4ID09IFwiflwiXG4gICAgICAgICAgICB8fCB4ID09ICdgJ1xuICAgICAgICAgICAgfHwgeCA9PSAnKidcbiAgICAgICAgICAgIHx8IHggPT0gJ14nXG4gICAgICAgICAgICB8fCB4ID09ICd7J1xuICAgICAgICAgICAgfHwgeCA9PSAnfSdcbiAgICAgICAgICAgIHx8IHggPT0gXCJbXCJcbiAgICAgICAgICAgIHx8IHggPT0gJ10nXG4gICAgICAgICAgICB8fCB4ID09ICcoJ1xuICAgICAgICAgICAgfHwgeCA9PSBcIilcIlxuICAgICAgICAgICAgfHwgeCA9PSBcIidcIlxuICAgICAgICAgICAgfHwgeCA9PSBcIl9cIik7XG4gICAgfVxuICAgIFBhcnNlci5wdW5jdHVhdGlvbiA9IHB1bmN0dWF0aW9uO1xuICAgIGxldCBpZCA9ICh4KSA9PiB4O1xuICAgIC8vbGV0IGVmZmVjdHM6IEVmZmVjdDxhbnk+W10gPSBbXTtcbiAgICAvKipcbiAgICAgKiBwYXJzZSBpcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgdGhlIGlucHV0IHRleHQgaW4gYSBDaGFyU3RyZWFtXG4gICAgICogYW5kIHBhc3NlcyBpdCB0byB0aGUgdXBwZXItbGV2ZWwgcGFyc2UgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gcHJvZ3JhbSBhIHN0cmluZyByZXByZXNlbnRpbmcgcHJvZ3JhbSB0ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2UocHJvZ3JhbSkge1xuICAgICAgICBwcm9ncmFtICs9IFwiXFxuXCI7XG4gICAgICAgIC8vcHJpbnRPZmZzZXQgPSAtMTtcbiAgICAgICAgLy90aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICBsZXQgbyA9IFBhcnNlci5FeHByZXNzaW9uUGFyc2VyKG5ldyBwYW50c18xLkNoYXJVdGlsLkNoYXJTdHJlYW0ocHJvZ3JhbSkpO1xuICAgICAgICBzd2l0Y2ggKG8udGFnKSB7XG4gICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzcGFjZV9saWZ0XzEuU29tZShvLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzcGFjZV9saWZ0XzEuTm9uZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQYXJzZXIucGFyc2UgPSBwYXJzZTtcbiAgICAvKipcbiAgICAgKiBFeHByZXNzaW9uIHBhcnNlciBmaXJzdCBzZWFyY2hlcyBmb3IgdGhlIGZpcnN0IGV4cHJlc3Npb24gb2YgYSBzZXF1ZW5jZSBhbmQgZWl0aGVyXG4gICAgICogYW5vdGhlciBleHByZXNzaW9uIG9yIHRoZSBlbmQgb2YgdGhlIHByb2dyYW0gKE5PUCkgYW5kIHJldHVybnMgYSBzZXF1ZW5jZSBub2RlXG4gICAgICogQHBhcmFtIGkgYSBub25zZW5zZSBwYXJhbWV0ZXIgdXNlZCB0byBhdm9pZCBidWcgb2YgZWFnZXIgcGFyc2luZ1xuICAgICAqL1xuICAgIFBhcnNlci5FeHByZXNzaW9uUGFyc2VyID0gaSA9PiB7XG4gICAgICAgIGxldCBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLlNlcXVlbmNlTm9kZSh0dXBbMF0sIHR1cFsxXSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwID0gcGFudHNfMS5QcmltaXRpdmVzLnNlcShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignOycpKShwYW50c18xLlByaW1pdGl2ZXMubmwoKSkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UocGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlcikpKHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKF8gPT4gbmV3IGluZGV4XzEuTk9QKCkpKSkpKGYpO1xuICAgICAgICByZXR1cm4gcChpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIHRocm91Z2ggYWxsIHBvc3NpYmxlIGV4cHJlc3Npb25zIGV4Y2VwdCBmb3Igc2VxdWVuY2VzXG4gICAgICogdXNlZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIGluIHVwcGVyIGxldmVsIHBhcnNlXG4gICAgICogQHBhcmFtIGkgYSBub25zZW5zZSBwYXJhbWV0ZXIgdXNlZCB0byBhdm9pZCBidWcgb2YgZWFnZXIgcGFyc2luZ1xuICAgICAqL1xuICAgIFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9TZXEgPSBpID0+IHtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShsTnVtYmVyKCkpKGxzdHJpbmcyKCkpO1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHZhck5hbWVQYXJzZSgpKShwMSk7XG4gICAgICAgIGxldCBwMyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoQm9vbFBhcnNlKCkpKHAyKTtcbiAgICAgICAgbGV0IHA0ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZSh2YXJEZWNQYXJzZSgpKShwMyk7XG4gICAgICAgIGxldCBwNSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLnVuT3BzRXhwcikocDQpO1xuICAgICAgICBsZXQgcDYgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKERlY2xhcmUoKSkocDUpO1xuICAgICAgICBsZXQgcDcgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5iaW5PcEV4cHIpKHA2KTtcbiAgICAgICAgbGV0IHA4ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShMb2dpY0V4cHIoKSkocDcpO1xuICAgICAgICBsZXQgcDkgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5MaXN0SGVhZCkocDgpO1xuICAgICAgICBsZXQgcDEwID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuZnVuQXBwKShwOSk7XG4gICAgICAgIGxldCBwMTEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5yZXR1cm5QYXJzZXIpKHAxMCk7XG4gICAgICAgIGxldCBwMTIgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5jb25kUGFyc2UpKHAxMSk7XG4gICAgICAgIGxldCBwMTMgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5XaGlsZUxvb3ApKHAxMik7XG4gICAgICAgIGxldCBwMTQgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5Gb3JMb29wKShwMTMpO1xuICAgICAgICBsZXQgcDE1ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuZnVuRGVmKShwMTQpO1xuICAgICAgICByZXR1cm4gcDE1KGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhyb3VnaCBhbGwgcG9zc2libGUgZXhwcmVzc2lvbnMgZXhjZXB0IGZvciBiaW5PcCBleHByZXNzaW9uc1xuICAgICAqIHVzZWQgdG8gYXZvaWQgaW5maW5pdGUgbG9vcGluZyBpbiB0aGUgYmluYXJ5IGV4cHJlc3Npb24gcGFyc2VyXG4gICAgICogQHBhcmFtIGkgYSBub25zZW5zZSBwYXJhbWV0ZXIgdXNlZCB0byBhdm9pZCBidWcgb2YgZWFnZXIgcGFyc2luZ1xuICAgICAqL1xuICAgIFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9CaW5PcCA9IGkgPT4ge1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKGxOdW1iZXIoKSkobHN0cmluZzIoKSk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UodmFyTmFtZVBhcnNlKCkpKHAxKTtcbiAgICAgICAgbGV0IHAzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShCb29sUGFyc2UoKSkocDIpO1xuICAgICAgICBsZXQgcDQgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHZhckRlY1BhcnNlKCkpKHAzKTtcbiAgICAgICAgbGV0IHA1ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIudW5PcHNFeHByKShwNCk7XG4gICAgICAgIGxldCBwNiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoRGVjbGFyZSgpKShwNSk7XG4gICAgICAgIGxldCBwNyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLkxpc3RIZWFkKShwNik7XG4gICAgICAgIGxldCBwOCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmZ1bkFwcCkocDcpO1xuICAgICAgICBsZXQgcDkgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5yZXR1cm5QYXJzZXIpKHA4KTtcbiAgICAgICAgbGV0IHAxMCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmNvbmRQYXJzZSkocDkpO1xuICAgICAgICBsZXQgcDExID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuV2hpbGVMb29wKShwMTApO1xuICAgICAgICBsZXQgcDEyID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuRm9yTG9vcCkocDExKTtcbiAgICAgICAgbGV0IHAxMyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmZ1bkRlZikocDEyKTtcbiAgICAgICAgcmV0dXJuIHAxMyhpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIHRocm91Z2ggYWxsIHBvc3NpYmxlIGV4cHJlc3Npb25zIGV4Y2VwdCBmb3IgbG9naWNhbCBleHByZXNzaW9uc1xuICAgICAqIHVzZWQgdG8gYXZvaWQgaW5maW5pdGUgbG9vcGluZyBpbiB0aGUgbG9naWNhbCBleHByZXNzaW9uIHBhcnNlclxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgYnVnIG9mIGVhZ2VyIHBhcnNpbmdcbiAgICAgKi9cbiAgICBQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vTG9naWMgPSBpID0+IHtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShsTnVtYmVyKCkpKGxzdHJpbmcyKCkpO1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHZhck5hbWVQYXJzZSgpKShwMSk7XG4gICAgICAgIGxldCBwMyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoQm9vbFBhcnNlKCkpKHAyKTtcbiAgICAgICAgbGV0IHA0ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZSh2YXJEZWNQYXJzZSgpKShwMyk7XG4gICAgICAgIGxldCBwNSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLnVuT3BzRXhwcikocDQpO1xuICAgICAgICBsZXQgcDYgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKERlY2xhcmUoKSkocDUpO1xuICAgICAgICBsZXQgcDcgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5iaW5PcEV4cHIpKHA2KTtcbiAgICAgICAgbGV0IHA4ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuTGlzdEhlYWQpKHA3KTtcbiAgICAgICAgbGV0IHA5ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuZnVuQXBwKShwOCk7XG4gICAgICAgIGxldCBwMTAgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5yZXR1cm5QYXJzZXIpKHA5KTtcbiAgICAgICAgbGV0IHAxMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmNvbmRQYXJzZSkocDEwKTtcbiAgICAgICAgbGV0IHAxMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLldoaWxlTG9vcCkocDExKTtcbiAgICAgICAgbGV0IHAxMyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLkZvckxvb3ApKHAxMik7XG4gICAgICAgIGxldCBwMTQgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5mdW5EZWYpKHAxMyk7XG4gICAgICAgIHJldHVybiBwMTQoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBsTnVtYmVyIGlzIHVzZWQgdG8gd3JhcCBwYXJzZWQgbnVtYmVycyBpbiBOdW1iZXJOb2RlcyBmb3IgdGhlIEFTVFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgbGV0IG8gPSBudW1iZXIoKShpc3RyZWFtKTtcbiAgICAgICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHBhbnRzXzEuUHJpbWl0aXZlcy5TdWNjZXNzKG8uaW5wdXRzdHJlYW0sIG5ldyBpbmRleF8xLk51bWJlck5vZGUoby5yZXN1bHQpKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgUGFyc2VyLmxOdW1iZXIgPSBsTnVtYmVyO1xuICAgIC8qKlxuICAgICAqIGJpbk9wc0NoYXIgcGFyc2VzIGFsbCBwb3NzaWJsZSBiaW5hcnkgb3BlcmF0b3JzLCBzdWNoIGFzICsgb3IgLVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbk9wc0NoYXIoKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLnNhdCh4ID0+IHggPT0gXCIrXCJcbiAgICAgICAgICAgICAgICB8fCB4ID09IFwiLVwiXG4gICAgICAgICAgICAgICAgfHwgeCA9PSBcIi9cIlxuICAgICAgICAgICAgICAgIHx8IHggPT0gXCI9XCJcbiAgICAgICAgICAgICAgICB8fCB4ID09IFwiKlwiKSkoaXN0cmVhbSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFBhcnNlci5iaW5PcHNDaGFyID0gYmluT3BzQ2hhcjtcbiAgICAvKipcbiAgICAgKiBiaW5PcHNTaG9ydCByZXR1cm5zIGEgdHVwbGUgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIGJpbmFyeSBvcGVyYXRvciAoQ2hhclN0cmVhbSlcbiAgICAgKiBhbmQgdGhlIHNlY29uZCBlbGVtZW50IGlzIHRoZSBleHByZXNzaW9uIHRvIHRoZSByaWdodCBvZiB0aGUgb3BlcmF0b3IgKEV4cHJlc3Npb248e30+KVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbk9wU2hvcnQoKSB7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuc2VxKGJpbk9wc0NoYXIoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSkoKHgpID0+IHgpO1xuICAgIH1cbiAgICBQYXJzZXIuYmluT3BTaG9ydCA9IGJpbk9wU2hvcnQ7XG4gICAgLyoqXG4gICAgICogYmluT3BFeHByIHBhcnNlcyBhbGwgcG9zc2libGUgYmluYXJ5IG9wZXJhdGlvbiBleHByZXNzaW9ucyBhbmQgcmV0dXJucyB0aGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIEFTVCBub2RlIGNvbnN0cnVjdCAoYWxzbyBwYXJzZXMgcG9zdGZpeCBpbmNyZW1lbnRzL2RlY3JlbWVudHMgbGlrZSBpKyspXG4gICAgICogQHBhcmFtIGkgYSBub25zZW5zZSBwYXJhbWV0ZXIgdXNlZCB0byBhdm9pZCB0aGUgYnVnIHdpdGggZWFnZXIgZXZhbHVhdGlvblxuICAgICAqL1xuICAgIFBhcnNlci5iaW5PcEV4cHIgPSBpID0+IHtcbiAgICAgICAgdmFyIGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICBsZXQgbGhzID0gdHVwWzBdO1xuICAgICAgICAgICAgbGV0IG9wID0gdHVwWzFdWzBdO1xuICAgICAgICAgICAgbGV0IHJocyA9IHR1cFsxXVsxXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3AudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5QbHVzT3AobGhzLCByaHMsIHdzKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuTWludXNPcChsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5EaXZPcChsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5NdWxPcChsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5Bc3NpZ25PcChsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJpbmFyeSBPcGVyYXRpb24gbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vQmluT3ApKHZhckRlY1BhcnNlKCkpO1xuICAgICAgICBsZXQgcDIgPSBiaW5PcFNob3J0KCk7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgcG9zdFBsdXMgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb0Jpbk9wKSkocGFudHNfMS5QcmltaXRpdmVzLnN0cignKysnKSkodHVwID0+IHsgcmV0dXJuIG5ldyBpbmRleF8xLkluY3JlbWVudCh0dXBbMF0sIHdzKTsgfSk7XG4gICAgICAgIGxldCBwb3N0TWludXMgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb0Jpbk9wKSkocGFudHNfMS5QcmltaXRpdmVzLnN0cignLS0nKSkodHVwID0+IHsgcmV0dXJuIG5ldyBpbmRleF8xLkRlY3JlbWVudCh0dXBbMF0sIHdzKTsgfSk7XG4gICAgICAgIGxldCBiaW5PcCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShwMSkpKHAyKShmKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoYmluT3ApKHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UocG9zdFBsdXMpKHBvc3RNaW51cykpKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogdW5PcHNDaGFyIHBhcnNlcyBhbGwgcG9zc2libGUgdW5hcnkgb3BlcmF0b3JzXG4gICAgICogT25seSBuZWdhdGlvbnMgYXJlIHN1cHBvcnRlZCwgYnV0IG1vcmUgY2FuIGJlIGFkZGVkIGFzIG5lZWRlZFxuICAgICAqIEBwYXJhbSBpIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIHRoZSBidWcgd2l0aCBlYWdlciBldmFsdWF0aW9uXG4gICAgICovXG4gICAgUGFyc2VyLnVuT3BzQ2hhciA9IGkgPT4ge1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcihcIi1cIikpKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogdW5PcHNFeHByIHdyYXBzIGEgdW5hcnkgb3BlcmF0aW9uIGV4cHJlc3Npb24gaW4gdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiBBU1Qgbm9kZSBhbmQgcmV0dXJucyBpdFxuICAgICAqIEBwYXJhbSBpIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIHRoZSBidWcgd2l0aCBlYWdlciBldmFsdWF0aW9uXG4gICAgICovXG4gICAgUGFyc2VyLnVuT3BzRXhwciA9IGkgPT4ge1xuICAgICAgICB2YXIgZiA9ICh0dXApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5OZWdPcCh0dXBbMV0sIHdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykoUGFyc2VyLnVuT3BzQ2hhcikpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9TZXEpKGYpKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogbHN0cmluZyBwYXJzZXMgdmFsaWQgc3RyaW5ncyBpbiB0aGUgU1dFTEwgbGFuZ3VhZ2VcbiAgICAgKiBhIHZhbGlkIHN0cmluZyBpcyBzdXJyb3VuZGVkIGJ5IHF1b3RhdGlvbnMgYW5kIGNvbnNpc3RzIG9mIGxldHRlcnMsIG51bWJlcnMsIHB1bmN0dWF0aW9uLCBhbmQvb3Igd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxzdHJpbmcoKSB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwYW50c18xLlByaW1pdGl2ZXMubGV0dGVyKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53czEoKSkpKHBhbnRzXzEuUHJpbWl0aXZlcy5kaWdpdCgpKTtcbiAgICAgICAgLy9sZXQgcDEgPSBQcmltaXRpdmVzLmNob2ljZShQcmltaXRpdmVzLmxldHRlcigpKShQcmltaXRpdmVzLndzMSgpKTtcbiAgICAgICAgbGV0IHAgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMuc3RyKFwiXFxcIlwiKSkocGFudHNfMS5QcmltaXRpdmVzLnN0cihcIlxcXCJcIikpKHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55KHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UocDEpKHB1bmN0dWF0aW9uKCkpKSk7XG4gICAgICAgIGxldCBmID0gKHhzKSA9PiBwYW50c18xLkNoYXJVdGlsLkNoYXJTdHJlYW0uY29uY2F0KHhzKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocCkoZik7XG4gICAgfVxuICAgIFBhcnNlci5sc3RyaW5nID0gbHN0cmluZztcbiAgICAvKipcbiAgICAgKiBsc3RyaW5nMiB3cmFwcyBzdHJpbmdzIHBhcnNlZCBieSBsc3RyaW5nIGluIFN0cmluTm9kZSBvYmplY3RzIGFuZCByZXR1cm5zIHRoZW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsc3RyaW5nMigpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgd3MgPSBcIlwiO1xuICAgICAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBsZXQgbyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykobHN0cmluZygpKShpc3RyZWFtKTtcbiAgICAgICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHBhbnRzXzEuUHJpbWl0aXZlcy5TdWNjZXNzKG8uaW5wdXRzdHJlYW0sIG5ldyBpbmRleF8xLlN0cmluZ05vZGUoby5yZXN1bHQudG9TdHJpbmcoKSwgd3MpKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgUGFyc2VyLmxzdHJpbmcyID0gbHN0cmluZzI7XG4gICAgLyoqXG4gICAgICogdmFyTmFtZVBhcnNlIHBhcnNlcyB2YWxpZCB2YXJpYWJsZSBuYW1lc1xuICAgICAqIHZhcmlhYmxlIG5hbWVzIGluIFNXRUxMIGJlZ2luIHdpdGggYSBsb3dlcmNhc2UgY2hhciBhbmQgYXJlIGZvbGxvd2VkXG4gICAgICogYnkgbGV0dGVycyBvciBkaWdpdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YXJOYW1lUGFyc2UoKSB7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLlZhcmlhYmxlTm9kZSh0dXBbMF0udG9TdHJpbmcoKSArIHBhbnRzXzEuQ2hhclV0aWwuQ2hhclN0cmVhbS5jb25jYXQodHVwWzFdKS50b1N0cmluZygpLCB3cyk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgZmlyc3RDaGFyID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShwYW50c18xLlByaW1pdGl2ZXMubG93ZXIoKSk7XG4gICAgICAgIGxldCBuZXh0Q2hhcnMgPSBwYW50c18xLlByaW1pdGl2ZXMubWFueShwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHBhbnRzXzEuUHJpbWl0aXZlcy5kaWdpdCgpKShwYW50c18xLlByaW1pdGl2ZXMubGV0dGVyKCkpKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEoZmlyc3RDaGFyKShuZXh0Q2hhcnMpKGYpO1xuICAgIH1cbiAgICBQYXJzZXIudmFyTmFtZVBhcnNlID0gdmFyTmFtZVBhcnNlO1xuICAgIC8qKlxuICAgICAqIHZhckRlY1BhcnNlIHBhcnNlcyB2YWxpZCB2YXJpYWJsZSBkZWNsYXJhdGlvbnMgaW4gdGhlIGZvcm0gXCJ2YXIgeFwiXG4gICAgICogdGhlIHBhcnNlciB0aGVuIHdyYXBzIHRoZSBwYXJzZWQgdmFsdWUgaW4gYSB2YXJpYWJsZSBub2RlIGZvciB0aGUgQVNUXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFyRGVjUGFyc2UoKSB7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoXCJ2YXJcIikpO1xuICAgICAgICBsZXQgdmFyTmFtZSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53czEoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHZhck5hbWVQYXJzZSgpKTtcbiAgICAgICAgbGV0IHAgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHAxKSh2YXJOYW1lKSh0dXAgPT4gdHVwWzFdKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIFBhcnNlci52YXJEZWNQYXJzZSA9IHZhckRlY1BhcnNlO1xuICAgIC8qKlxuICAgICAqIERlY2xhcmUgcGFyc2VzIHZhcmlhYmxlIGRlY2xhcmF0aW9ucyBpbiB0aGUgZm9ybSBcInZhciB4ID0gMlwiXG4gICAgICogYW5kIHJldHVybnMgYSBEZWNsYXJlT3Agbm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlY2xhcmUoKSB7XG4gICAgICAgIGxldCBlcSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJz0nKSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5sZWZ0KHZhckRlY1BhcnNlKCkpKGVxKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocDEpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9TZXEpKHR1cCA9PiB7IHJldHVybiBuZXcgaW5kZXhfMS5EZWNsYXJlT3AodHVwWzBdLCB0dXBbMV0pOyB9KTtcbiAgICB9XG4gICAgUGFyc2VyLkRlY2xhcmUgPSBEZWNsYXJlO1xuICAgIC8qKlxuICAgICAqIExpc3RIZWFkIHBhcnNlcyBhbGwgbGlzdHMgaW4gdGhlIFNXRUxMIGxhbmd1YWdlLCBpbmNsdWRpbmcgZW1wdHkgbGlzdHNcbiAgICAgKiBMaXN0cyBhcmUgc3Vycm91bmRlZCBieSBzcXVhcmUgYnJhY2tldHMgYW5kIGVhY2ggZWxlbWVudCBpcyBzZXBhcmF0ZWQgYnkgYSBjb21tYVxuICAgICAqIHJldHVybnMgYSBsaXN0Tm9kZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIHRoZSBidWcgd2l0aCBlYWdlciBldmFsdWF0aW9uXG4gICAgICovXG4gICAgUGFyc2VyLkxpc3RIZWFkID0gaSA9PiB7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgcDAgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9TZXEpO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignWycpKSkocDApO1xuICAgICAgICB2YXIgZiA9ICh0dXApID0+IHtcbiAgICAgICAgICAgIGxldCBoZCA9IHR1cFswXTtcbiAgICAgICAgICAgIGxldCByZXMgPSBbaGRdO1xuICAgICAgICAgICAgbGV0IHRhaWwgPSB0dXBbMV07XG4gICAgICAgICAgICBmb3IgKGxldCBlbGVtIG9mIHRhaWwpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5MaXN0Tm9kZShyZXMsIHdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwMSkoTGlzdFRhaWwoKSkoZik7XG4gICAgICAgIGxldCBwMyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCdbXScpKSkoXyA9PiBuZXcgaW5kZXhfMS5MaXN0Tm9kZShbXSwgd3MpKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UocDMpKHAyKShpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3QgVGFpbCBwYXJzZXMgc2Vjb25kIHRocm91Z2ggbGFzdCBlbGVtZW50cyBvZiBhIGxpc3QsIGVhY2ggc2VwYXJhdGVkIGJ5IGEgY29tbWFcbiAgICAgKiByZXR1cm5zIGFuIGFycmF5IG9mIEV4cHJlc3Npb25zIHRoYXQgd2lsbCBiZSBhY2Nlc3NlZCBieSBMaXN0SGVhZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpc3RUYWlsKCkge1xuICAgICAgICBsZXQgcDAgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9TZXEpO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJywnKSkocDApO1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMubGVmdChwYW50c18xLlByaW1pdGl2ZXMubWFueShwMSkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCddJykpO1xuICAgICAgICByZXR1cm4gcDI7XG4gICAgfVxuICAgIFBhcnNlci5MaXN0VGFpbCA9IExpc3RUYWlsO1xuICAgIC8qKlxuICAgICAqIGZ1bkRlZkFyZ0xpc3QgcGFyc2VzIGFyZ3VtZW50IGxpc3RzIGZvciBmdW5jdGlvbiBkZWZpbml0aW9ucyxcbiAgICAgKiBzdXJyb3VuZGVkIGJ5IHBhcmVucyBhbmQgc2VwYXJhdGVkIGJ5IGNvbW1hc1xuICAgICAqIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5EZWZBcmdMaXN0KCkge1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJygnKSkoc3RyaW5nKCkpO1xuICAgICAgICB2YXIgZiA9ICh0dXApID0+IHtcbiAgICAgICAgICAgIGxldCBoZCA9IHR1cFswXS50b1N0cmluZygpO1xuICAgICAgICAgICAgbGV0IHJlcyA9IFtoZF07XG4gICAgICAgICAgICBsZXQgdGFpbCA9IHR1cFsxXTtcbiAgICAgICAgICAgIGZvciAobGV0IGVsZW0gb2YgdGFpbCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGVsZW0udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHAxKShmdW5EZWZBcmdMaXN0VGFpbCgpKShmKTtcbiAgICAgICAgbGV0IHAzID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMuc3RyKCcoKScpKShfID0+IFtdKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UocDMpKHAyKTtcbiAgICB9XG4gICAgUGFyc2VyLmZ1bkRlZkFyZ0xpc3QgPSBmdW5EZWZBcmdMaXN0O1xuICAgIC8qKlxuICAgICAqIGZ1bkRlZkFyZ0xpc3RUYWlsIHBhcnNlcyB0aGUgc2Vjb25kIHRocm91Z2ggbGFzdCBlbGVtZW50cyBvZiBhIGZ1bmN0aW9uIGRlZmluaXRpb24gcGFyYW1ldGVyIGxpc3RcbiAgICAgKiBwYXJhbWV0ZXJzIGFyZSBzZXBhcmF0ZWQgYnkgY29tbWFzIGFuZCBlbmQgd2l0aCBhIGNsb3NpbmcgcGFyZW5zXG4gICAgICogcmV0dXJucyBhbiBhcnJheSBvZiBwYXJhbWV0ZXJzLCB3aGljaCBpcyBhY2Nlc3NlZCBieSBmdW5EZWZBcmdMaXN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuRGVmQXJnTGlzdFRhaWwoKSB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMuY2hhcignLCcpKShzdHJpbmcoKSk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5sZWZ0KHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55KHAxKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJyknKSk7XG4gICAgICAgIHJldHVybiBwMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZnVuQXBwQXJnTGlzdCBwYXJzZXMgYXJndW1lbnQgbGlzdHMgZm9yIGZ1bmN0aW9uIGFwcGxpY2F0aW9ucywgaW5jbHVkaW5nIGVtcHR5IGFyZ3MgbGlzdHNcbiAgICAgKiB0aGUgcGFyc2VyIHJldHVybnMgYW4gYXJyYXkgb2YgRXhwcmVzc2lvbiBvYmplY3RzIHRoYXQgcmVwcmVzZW50IHRoZSBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5BcHBBcmdMaXN0KCkge1xuICAgICAgICBsZXQgZXhwciA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKCcpKShleHByKTtcbiAgICAgICAgdmFyIGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICBsZXQgaGQgPSB0dXBbMF07XG4gICAgICAgICAgICBsZXQgcmVzID0gW2hkXTtcbiAgICAgICAgICAgIGxldCB0YWlsID0gdHVwWzFdO1xuICAgICAgICAgICAgZm9yIChsZXQgZWxlbSBvZiB0YWlsKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHAxKShmdW5BcHBBcmdMaXN0VGFpbCgpKShmKTtcbiAgICAgICAgbGV0IHAzID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMuc3RyKCcoKScpKShfID0+IFtdKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UocDMpKHAyKTtcbiAgICB9XG4gICAgUGFyc2VyLmZ1bkFwcEFyZ0xpc3QgPSBmdW5BcHBBcmdMaXN0O1xuICAgIC8qKlxuICAgICAqIGZ1bkFwcEFyZ0xpc3RUYWlsIHBhcnNlcyB0aGUgc2Vjb25kIHRocm91Z2ggbGFzdCBlbGVtZW50cyBvZiBhbiBhcmd1bWVudCBsaXN0XG4gICAgICogZWFjaCBlbGVtZW50IGlzIHNlcGFyYXRlZCBieSBhIGNvbW1hXG4gICAgICogcmV0dXJucyBhbiBhcnJheSBvZiBFeHByZXNzaW9uIG9iamVjdHMsIGxhdGVyIGFjY2Vzc2VkIGJ5IGZ1bkFwcEFyZ3NMaXN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuQXBwQXJnTGlzdFRhaWwoKSB7XG4gICAgICAgIGxldCBjb21tYSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJywnKSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChjb21tYSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5sZWZ0KHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55KHAxKSkocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKScpKSk7XG4gICAgICAgIHJldHVybiBwMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0dXJuUGFyc2VyIHBhcnNlcyB2YWxpZCByZXR1cm4gc3RhdGVtZW50cyBpbiB0aGUgZm9ybSBcInJldHVybiB4XCJcbiAgICAgKiB3cmFwcyB0aGUgcGFyc2VkIHZhbHVlIGluIGEgUmV0dXJuIG5vZGUgZm9yIHRoZSBBU1RcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIHRoZSBidWcgd2l0aCBlYWdlciBldmFsdWF0aW9uXG4gICAgICovXG4gICAgUGFyc2VyLnJldHVyblBhcnNlciA9IGkgPT4ge1xuICAgICAgICBsZXQgZXhwciA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgcCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ3JldHVybicpKSkoZXhwcik7XG4gICAgICAgIHZhciBmID0gKGUpID0+IHsgcmV0dXJuIG5ldyBpbmRleF8xLlJldHVybihlLCB3cyk7IH07XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHApKGYpKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZnVuRGVmIHBhcnNlcyB2YWxpZCBmdW5jdGlvbiBkZWZpbml0aW9ucyBpbiB0aGUgZm9ybSBcImZ1biBmdW5jdGlvbk5hbWUoYXJnTGlzdCl7IGJvZHk7fVwiXG4gICAgICogdGhlIHBhcnNlciByZXR1cm5zIGEgZnVuRGVmIG5vZGUgZm9yIHRoZSBBU1RcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIHRoZSBidWcgd2l0aCBlYWdlciBldmFsdWF0aW9uXG4gICAgICovXG4gICAgUGFyc2VyLmZ1bkRlZiA9IGkgPT4ge1xuICAgICAgICBsZXQgd3MgPSBcIlwiO1xuICAgICAgICBsZXQgcHJlY2VkaW5nV1MgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKSh4ID0+IHdzID0geC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ2Z1bicpKSkocGFudHNfMS5QcmltaXRpdmVzLnNlcShcbiAgICAgICAgLyogZnVuY3Rpb24gbmFtZSAqL1xuICAgICAgICBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHN0cmluZygpKShjcyA9PiBjcy50b1N0cmluZygpKSkocGFudHNfMS5QcmltaXRpdmVzLnNlcShcbiAgICAgICAgLyogZnVuY3Rpb24gYXJndW1lbnRzICovXG4gICAgICAgIGZ1bkRlZkFyZ0xpc3QoKSkocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KFxuICAgICAgICAvKiBmdW5jdGlvbiBib2R5ICovXG4gICAgICAgIHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ3snKSkpKHBhbnRzXzEuUHJpbWl0aXZlcy5sZWZ0KHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignfScpKSkpKGlkKSkoXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgQVNUIG5vZGVcbiAgICAgICAgKHR1cCkgPT4ge1xuICAgICAgICAgICAgbGV0IGZuYW1lID0gdHVwWzBdO1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSB0dXBbMV1bMF07XG4gICAgICAgICAgICBsZXQgYm9keSA9IHR1cFsxXVsxXTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5GdW5EZWYoZm5hbWUsIGJvZHksIGFyZ3MsIHdzKTtcbiAgICAgICAgfSkpKGkpO1xuICAgIH07XG4gICAgbGV0IHByaW50T2Zmc2V0ID0gLTE7XG4gICAgbGV0IGJvdW5kaW5nUmVjdHMgPSBbXTtcbiAgICAvL1RPRE9cbiAgICBmdW5jdGlvbiBnZXROb25PdmVybGFwcGluZ0Nvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9XG4gICAgUGFyc2VyLmdldE5vbk92ZXJsYXBwaW5nQ29vcmRzID0gZ2V0Tm9uT3ZlcmxhcHBpbmdDb29yZHM7XG4gICAgLyoqXG4gICAgICogZnVuQXBwIHBhcnNlcyB2YWxpZCBmdW5jdGlvbiBhcHBsaWNhdGlvbnMgaW4gdGhlIGZvcm0gXCJmdW5jdGlvbk5hbWUoYXJnc0xpc3QpXCIgYW5kIHJldHVybnMgYSBmdW5BcHAgbm9kZVxuICAgICAqIHBhcnNlciBjaGVja3MgZm9yIGJ1aWx0LWluIGZ1bmN0aW9ucywgbGlrZSBwcmludCwgZWxsaXBzZSwgYW5kIHJlY3Q7IGFuZCByZXR1cm5zIHRoZSB2YWxpZCBBU1Qgbm9kZVxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIuZnVuQXBwID0gaSA9PiB7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHN0cmluZygpKSkoZnVuQXBwQXJnTGlzdCgpKSh0dXAgPT4ge1xuICAgICAgICAgICAgbGV0IGZuYW1lID0gdHVwWzBdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInByaW50XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0dXBbMV0ubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYm91bmRpbmdSZWN0cy5wdXNoKFt0dXBbMV1bMF0ud2lkdGgsIHR1cFsxXVswXS5oZWlnaHQsIHR1cFsxXVsxXSwgdHVwWzFdWzJdXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuUHJpbnROb2RlKHR1cFsxXVswXSwgbmV3IGluZGV4XzEuRGltZW5zaW9ucyh0dXBbMV1bMV0sIHR1cFsxXVsyXSwgbmV3IGluZGV4XzEuTnVtYmVyTm9kZSgxKSksIHdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcmludE9mZnNldCA9IChwcmludE9mZnNldCArIDEpICUgMTI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHJpbnRPZmZzZXQ6IFwiICsgcHJpbnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuUHJpbnROb2RlKHR1cFsxXVswXSwgbmV3IGluZGV4XzEuRGltZW5zaW9ucyhuZXcgaW5kZXhfMS5OdW1iZXJOb2RlKDEwMCArIDEwMCAqIChwcmludE9mZnNldCAlIDMpKSwgbmV3IGluZGV4XzEuTnVtYmVyTm9kZSgxMDAgKyAxMDAgKiAocHJpbnRPZmZzZXQgLyA0KSksIG5ldyBpbmRleF8xLk51bWJlck5vZGUoMSkpLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVsbGlwc2VcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1cFsxXS5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkVsbGlwc2VOb2RlKHR1cFsxXVswXSwgdHVwWzFdWzFdLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwicmVjdFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHVwWzFdLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuUmVjdGFuZ2xlTm9kZSh0dXBbMV1bMF0sIHR1cFsxXVsxXSwgd3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1cFsxXS5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkxpbmVOb2RlKHR1cFsxXVswXSwgdHVwWzFdWzFdLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiY3VydmVcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1cFsxXS5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkN1cnZlTm9kZSh0dXBbMV1bMF0sIHR1cFsxXVsxXSwgdHVwWzFdWzJdLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZXBoXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0dXBbMV0ubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5FcGhOb2RlKHR1cFsxXVswXSwgdHVwWzFdWzFdLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhcmdzID0gdHVwWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkZ1bkFwcChmbmFtZSwgYXJncywgd3MpO1xuICAgICAgICB9KShpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJvb2xQYXJzZSBwYXJzZXMgdmFsaWQgYm9vbGVhbnMsIHRydWUgYW5kIGZhbHNlLCBhbmQgcmV0dXJucyBhIEJvb2xlYW5Ob2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gQm9vbFBhcnNlKCkge1xuICAgICAgICBsZXQgd3MgPSBcIlwiO1xuICAgICAgICBsZXQgcHJlY2VkaW5nV1MgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKSh4ID0+IHdzID0geC50b1N0cmluZygpKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ3RydWUnKSkpKF8gPT4gbmV3IGluZGV4XzEuQm9vbGVhbk5vZGUodHJ1ZSwgd3MpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ2ZhbHNlJykpKShfID0+IG5ldyBpbmRleF8xLkJvb2xlYW5Ob2RlKGZhbHNlLCB3cykpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMSkocDIpO1xuICAgIH1cbiAgICBQYXJzZXIuQm9vbFBhcnNlID0gQm9vbFBhcnNlO1xuICAgIC8qKlxuICAgICAqIGxvZ2ljQ2hhciBwYXJzZXMgYWxsIGxvZ2ljYWwgb3BlcmF0b3JzIGluIHRoZSBTV0VMTCBsYW5ndWFnZSBhbmQgcmV0dXJucyB0aGUgY29uc3VtZWQgb3BlcmF0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2dpY0NoYXIoKSB7XG4gICAgICAgIHZhciBsb2dpY0NoYXIgPSBbXCJlcXVhbHNcIiwgJz09JywgJ2FuZCcsICc+JywgJzwnLCAnbm90IGVxdWFscycsICdvciddO1xuICAgICAgICB2YXIgbG9naWNDaGFyMiA9IFsnPj0nLCAnPD0nXTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuc3RyU2F0KGxvZ2ljQ2hhcikpO1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHJTYXQobG9naWNDaGFyMikpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMikocDEpO1xuICAgIH1cbiAgICBQYXJzZXIubG9naWNDaGFyID0gbG9naWNDaGFyO1xuICAgIC8qKlxuICAgICAqIGxvZ2ljU2hvcnQgcmV0dXJucyBhIHR1cGxlLCB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCByZXByZXNlbnRzIHRoZSBsb2dpY2FsIG9wZXJhdG9yIGFuZFxuICAgICAqIHRoZSBzZWNvbmQgZWxlbWVudCBpcyB0aGUgZXhwcmVzc2lvbiB0byB0aGUgcmlnaHQgb2YgdGhlIG9wZXJhdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9naWNTaG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEobG9naWNDaGFyKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9TZXEpKCh4KSA9PiB4KTtcbiAgICB9XG4gICAgUGFyc2VyLmxvZ2ljU2hvcnQgPSBsb2dpY1Nob3J0O1xuICAgIC8qKlxuICAgICAqIGxvZ2ljRXhwciBwYXJzZXMgbG9naWNhbCBleHByZXNzaW9ucyBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBBU1Qgbm9kZVxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2dpY0V4cHIoKSB7XG4gICAgICAgIC8vIFRPRE86IERhbiAoMjAxOC0xMS0xOSksIHNob3VsZG4ndCBwYXJhbWV0ZXJpemVkIHR5cGUgYmUgQm9vbGVhbk5vZGU/XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxocyA9IHR1cFswXTtcbiAgICAgICAgICAgIGxldCBvcCA9IHR1cFsxXVswXTtcbiAgICAgICAgICAgIGxldCByaHMgPSB0dXBbMV1bMV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXF1YWxzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5FcXVhbHMobGhzLCByaHMsIHdzKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiPT1cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkVxdWFscyhsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkFuZChsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5HcmVhdGVyVGhhbihsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5MZXNzVGhhbihsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuR3JlYXRlclRoYW5FcShsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuTGVzc1RoYW5FcShsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvclwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuT3IobGhzLCByaHMsIHdzKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwibm90IGVxdWFsc1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuTm90RXF1YWwobGhzLCByaHMsIHdzKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2dpY2FsIGV4cHJlc3Npb24gbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBub3QgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ25vdCcpKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KG5vdCkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBub3RFeHByID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwMSkoeCA9PiBuZXcgaW5kZXhfMS5Ob3QoeCwgd3MpKTtcbiAgICAgICAgbGV0IGxvZ2ljRXhwciA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vTG9naWMpKShsb2dpY1Nob3J0KCkpKGYpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShub3RFeHByKShsb2dpY0V4cHIpO1xuICAgIH1cbiAgICBQYXJzZXIuTG9naWNFeHByID0gTG9naWNFeHByO1xuICAgIC8qKlxuICAgICAqIElmUGFyc2UgcGFyc2VzIHZhbGlkIGlmIHN0YXRlbWVudHMgaW4gdGhlIGZvcm0gXCJpZihjb25kaXRpb24peyBib2R5OyB9XCJcbiAgICAgKiByZXR1cm5zIGFuIGFycmF5IHdoZXJlIHRoZSBmaXJzdCBlbGVtIGlzIHRoZSBjb25kaXRpb24gYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGJvZHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJZlBhcnNlKCkge1xuICAgICAgICBsZXQgZXhwciA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBib2R5UGFyc2UgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCdpZicpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKCcpKSh4ID0+IHgpO1xuICAgICAgICBsZXQgY29uZCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHAxKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKScpKShleHByKTtcbiAgICAgICAgbGV0IGN1cmx5ID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcigneycpKTtcbiAgICAgICAgbGV0IGJvZHkgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihjdXJseSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ30nKSkoYm9keVBhcnNlKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEoY29uZCkoYm9keSkoeCA9PiB4KTtcbiAgICB9XG4gICAgUGFyc2VyLklmUGFyc2UgPSBJZlBhcnNlO1xuICAgIC8qKlxuICAgICAgKiBJZkVsc2VQYXJzZSBwYXJzZXMgdmFsaWQgaWYgZWxzZSBzdGF0ZW1lbnRzIGluIHRoZSBmb3JtIFwiaWYoY29uZGl0aW9uKXsgYm9keTsgfSBlbHNleyBib2R5Mjt9XCJcbiAgICAgICogcmV0dXJucyBhbiBhcnJheSB3aGVyZSB0aGUgZmlyc3QgZWxlbSBpcyB0aGUgY29uZGl0aW9uIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSBmaXJzdCBib2R5IGFuZCB0aGUgdGhpcmQgaXMgYm9keTJcbiAgICAgICovXG4gICAgZnVuY3Rpb24gSWZFbHNlUGFyc2UoKSB7XG4gICAgICAgIGxldCBlID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCdlbHNlJykpO1xuICAgICAgICBsZXQgYm9keSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIpO1xuICAgICAgICBsZXQgYm9keTIgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMuc3RyKCd7JykpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ30nKSkoYm9keSk7XG4gICAgICAgIGxldCBlbHNlUGFyc2UgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQoZSkoYm9keTIpO1xuICAgICAgICB2YXIgZiA9ICh0dXApID0+IHtcbiAgICAgICAgICAgIHR1cFswXS5wdXNoKHR1cFsxXSk7XG4gICAgICAgICAgICByZXR1cm4gdHVwWzBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShJZlBhcnNlKCkpKGVsc2VQYXJzZSkoZik7XG4gICAgfVxuICAgIFBhcnNlci5JZkVsc2VQYXJzZSA9IElmRWxzZVBhcnNlO1xuICAgIC8qKlxuICAgICAqIGNvbmRQYXJzZSBwYXJzZXMgcG9zc2libGUgY29uZGl0aW9uYWwgc3RhdGVtZW50cywgaW5jbHVkaW5nIGlmIGFuZCBpZi9lbHNlIHN0YXRlbWVudHNcbiAgICAgKiByZXR1cm5zIGEgQ29uZGl0aW9uYWwgbm9kZVxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIuY29uZFBhcnNlID0gaSA9PiB7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR1cC5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5Db25kaXRpb25hbCh0dXBbMF0sIHR1cFsxXSwgdHVwWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5Db25kaXRpb25hbCh0dXBbMF0sIHR1cFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoSWZFbHNlUGFyc2UoKSkoSWZQYXJzZSgpKSkoZikoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGlsZUxvb3AgcGFyc2VzIHZhbGlkIHdoaWxlIGxvb3BzIGluIHRoZSBmb3JtIFwid2hpbGUoY29uZGl0aW9uKSB7IGJvZHk7fVwiXG4gICAgICogcmV0dXJucyBhIFdoaWxlTm9kZSBmb3IgdGhlIEFTVFxuICAgICAqL1xuICAgIFBhcnNlci5XaGlsZUxvb3AgPSBpID0+IHtcbiAgICAgICAgbGV0IGV4cHIgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9TZXEpO1xuICAgICAgICBsZXQgYm9keVBhcnNlID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlcik7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cihcIndoaWxlXCIpKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJygnKSkoeCA9PiB4KTtcbiAgICAgICAgbGV0IGNvbmQgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwMSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJyknKSkoZXhwcik7XG4gICAgICAgIGxldCBjdXJseSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ3snKSk7XG4gICAgICAgIGxldCBib2R5ID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4oY3VybHkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCd9JykpKGJvZHlQYXJzZSk7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4geyByZXR1cm4gbmV3IGluZGV4XzEuV2hpbGVOb2RlKHR1cFswXSwgdHVwWzFdLCB3cyk7IH07XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuc2VxKGNvbmQpKGJvZHkpKGYpKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9yTG9vcCBwYXJzZXMgdmFsaWQgZm9yIGxvb3BzIGluIHRoZSBmb3JtIFwiZm9yKGluaXRpYWwsIGNvbmRpdGlvbiwgcG9zdCkgeyBib2R5O31cIiBhbmQgcmV0dXJucyBhIEZvck5vZGVcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIHRoZSBidWcgd2l0aCBlYWdlciBldmFsdWF0aW9uXG4gICAgICovXG4gICAgUGFyc2VyLkZvckxvb3AgPSBpID0+IHtcbiAgICAgICAgbGV0IGFyZ3MgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKGZ1bkFwcEFyZ0xpc3QoKSk7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCdmb3InKSkpKGFyZ3MpO1xuICAgICAgICBsZXQgY3VybHkgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCd7JykpO1xuICAgICAgICBsZXQgZXhwciA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5ubCgpKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyKTtcbiAgICAgICAgbGV0IGJvZHkgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihjdXJseSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ30nKSkoZXhwcik7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgbGV0IGluaXQgPSB0dXBbMF1bMF07XG4gICAgICAgICAgICBsZXQgY29uZCA9IHR1cFswXVsxXTtcbiAgICAgICAgICAgIGxldCBwb3N0ID0gdHVwWzBdWzJdO1xuICAgICAgICAgICAgbGV0IGJvZHkgPSB0dXBbMV07XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuRm9yTm9kZShpbml0LCBjb25kLCBwb3N0LCBib2R5LCB3cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHAxKShib2R5KShmKShpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHNpbmdsZUNvbW1lbnQoKSB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55MShwYW50c18xLlByaW1pdGl2ZXMuaXRlbSgpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwMSkoeHMgPT4gcGFudHNfMS5DaGFyVXRpbC5DaGFyU3RyZWFtLmNvbmNhdCh4cykpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLnN0cignLy8nKSkocGFudHNfMS5QcmltaXRpdmVzLm5sKCkpKHAyKTtcbiAgICAgICAgLy9yZXR1cm4gUHJpbWl0aXZlcy5zZXE8Q2hhclV0aWwuQ2hhclN0cmVhbSwgQ2hhclV0aWwuQ2hhclN0cmVhbSwgQ2hhclV0aWwuQ2hhclN0cmVhbVtdPihQcmltaXRpdmVzLnN0cignLy8nKSkoUHJpbWl0aXZlcy5ubCgpKSh4PT54KTtcbiAgICB9XG4gICAgUGFyc2VyLnNpbmdsZUNvbW1lbnQgPSBzaW5nbGVDb21tZW50O1xuICAgIGZ1bmN0aW9uIG11bHRpTGluZUNvbW1lbnQoKSB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55MShwYW50c18xLlByaW1pdGl2ZXMuaXRlbSgpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwMSkoeHMgPT4gcGFudHNfMS5DaGFyVXRpbC5DaGFyU3RyZWFtLmNvbmNhdCh4cykpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLnN0cignXFwvKionKSkocGFudHNfMS5QcmltaXRpdmVzLnN0cignKlxcLycpKShwMik7XG4gICAgfVxuICAgIFBhcnNlci5tdWx0aUxpbmVDb21tZW50ID0gbXVsdGlMaW5lQ29tbWVudDtcbn0pKFBhcnNlciA9IGV4cG9ydHMuUGFyc2VyIHx8IChleHBvcnRzLlBhcnNlciA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBCb29sZWFuTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIEJvb2xlYW5Ob2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgYm9vbGVhblxuICAgICAqIEBwYXJhbSB2YWwgVGhlIGJvb2xlYW4gdmFsdWUgb2YgdGhlIEJvb2xlYW5Ob2RlXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZSBzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl92YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQm9vbGVhbk5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJvb2xlYW5Ob2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgQm9vbGVhbk5vZGUgZXF1YWxzIGFub3RoZXJcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIEJvb2xlYW5Ob2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWwgPT09IHJpZ2h0LnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEJvb2xlYW5Ob2RlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX3ZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYm9vbGVhbiB2YWx1ZVxuICAgICAqL1xuICAgIGdldCB2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvb2xlYW4gdmFsdWVcbiAgICAgKi9cbiAgICBzZXQgdmFsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5Cb29sZWFuTm9kZSA9IEJvb2xlYW5Ob2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm9vbGVhbk5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBOT1Age1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKiBBIE5PUCBpcyBhIHBsYWNlaG9sZGVyIG9wZXJhdGlvbiB0aGF0IGV2YWx1YXRlcyB0byBub3RoaW5nICovXG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBOT1BcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTk9QcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5PUHMgY2Fubm90IGJlIGRyYXduLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgTk9QXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBOT1AgZXF1YWxzIGFub3RoZXIgKHNwb2lsZXI6IGl0IGRvZXNuJ3QpXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuTk9QID0gTk9QO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tk9QLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9OdW1iZXJFZmZlY3RcIik7XG4vLyBOb2RlcyByZXByZXNlbnRpbmcgbnVtYmVyc1xuLy8gU2hvdWxkIGFic3RyYWN0IE5vZGUgY2xhc3MgaW1wbGVtZW50IEV4cHJlc3Npb24/XG5jbGFzcyBOdW1iZXJOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBOdW1iZXJOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgbnVtYmVyXG4gICAgICogQHBhcmFtIHZhbCBUaGUgbnVtYmVyIHZhbHVlXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFsLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTnVtYmVyTm9kZXMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBsZXQgZSA9IG5ldyBOdW1iZXJFZmZlY3RfMS5OdW1iZXJFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBOdW1iZXJOb2RlIGVxdWFscyBhbm90aGVyIE51bWJlck5vZGVcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5IChtdXN0IGJlIGEgTnVtYmVyTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgTnVtYmVyTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsID09PSByaWdodC52YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBOdW1iZXJOb2RlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX3ZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIHN0b3JlZCBpbiB0aGUgbm9kZVxuICAgICAqL1xuICAgIGdldCB2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBudW1iZXIgc3RvcmVkIGluIHRoZSBub2RlXG4gICAgICovXG4gICAgc2V0IHZhbCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWwgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuTnVtYmVyTm9kZSA9IE51bWJlck5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OdW1iZXJOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3RyaW5nRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9TdHJpbmdFZmZlY3RcIik7XG5jbGFzcyBTdHJpbmdOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBTdHJpbmdOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHN0b3JlZCBpbiB0aGUgbm9kZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0ciwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdHIgPSBzdHI7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgU3RyaW5nTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIFN0cmluZyB1c2luZyBTdHJpbmdFZmZlY3RcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgc3RyaW5nIHRvIGJlIGRyYXduXG4gICAgICogQHBhcmFtIGFzdCBUaGUgcHJvZ3JhbSBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBsZXQgZSA9IG5ldyBTdHJpbmdFZmZlY3RfMS5TdHJpbmdFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBTdHJpbmdOb2RlIGVxdWFscyBhbm90aGVyIFN0cmluZ05vZGVcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5LCBtdXN0IGJlIGEgU3RyaW5nTm9kZVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBTdHJpbmdOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWwgPT09IHJpZ2h0LnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFN0cmluZ05vZGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgJ1xcXCInICsgdGhpcy5fc3RyICsgJ1xcXCInO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJpbmcgc3RvcmVkIGluIHRoZSBub2RlXG4gICAgICovXG4gICAgc2V0IHN0cih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zdHIgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nIHN0b3JlZCBpbiB0aGUgbm9kZVxuICAgICAqL1xuICAgIGdldCB2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLlN0cmluZ05vZGUgPSBTdHJpbmdOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RyaW5nTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIENvbG9yTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgQ29sb3JOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGFuIFJHQiBjb2xvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZWQgPSByZWQ7XG4gICAgICAgIHRoaXMuX2dyZWVuID0gZ3JlZW47XG4gICAgICAgIHRoaXMuX2JsdWUgPSBibHVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIGludG8gYSBzdHJpbmcgUkdCIHZhbHVlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWQgKyBcIiBcIiArIHRoaXMuX2dyZWVuICsgXCIgXCIgKyB0aGlzLl9ibHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb2xvck5vZGVzIGNhbm5vdCBjdXJyZW50bHkgYmUgZHJhd25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgQ29sb3JOb2RlIGVxdWFscyBhbm90aGVyIENvbG9yTm9kZVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHkgKG11c3QgYmUgYSBCb29sZWFuTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgQ29sb3JOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucmVkID09PSByaWdodC5yZWQgJiYgdGhpcy5ncmVlbiA9PT0gcmlnaHQuZ3JlZW4gJiYgdGhpcy5ibHVlID09PSByaWdodC5ibHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIENvbG9yTm9kZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVkIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IHJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmVkIHZhbHVlXG4gICAgICovXG4gICAgc2V0IHJlZChyZWQpIHtcbiAgICAgICAgdGhpcy5fcmVkID0gcmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBncmVlbiB2YWx1ZVxuICAgICAqL1xuICAgIGdldCBncmVlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyZWVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBncmVlbiB2YWx1ZVxuICAgICAqL1xuICAgIHNldCBncmVlbihncmVlbikge1xuICAgICAgICB0aGlzLl9ncmVlbiA9IGdyZWVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBibHVlIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IGJsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBibHVlIHZhbHVlXG4gICAgICovXG4gICAgc2V0IGJsdWUoYmx1ZSkge1xuICAgICAgICB0aGlzLl9ibHVlID0gYmx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29sb3JOb2RlID0gQ29sb3JOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sb3JOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBDdXJ2ZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvQ3VydmVFZmZlY3RcIik7XG5jbGFzcyBDdXJ2ZU5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIEN1cnZlTm9kZSwgYSBub2RlIHJlcHJlc2VudGluZyBhIGN1cnZlXG4gICAgICogQHBhcmFtIGR4IHRoZSBydW4gb2YgdGhlIGN1cnZlXG4gICAgICogQHBhcmFtIGR5IHRoZSByaXNlIG9mIHRoZSBjdXJ2ZVxuICAgICAqIEBwYXJhbSBjdXJ2YXR1cmUgaG93IG11Y2ggdGhlIGN1cnZlLCB1bW0sIGN1cnZlc1xuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGR4LCBkeSwgY3VydmF0dXJlLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2R4ID0gZHg7XG4gICAgICAgIHRoaXMuX2R5ID0gZHk7XG4gICAgICAgIHRoaXMuX2N1cnZhdHVyZSA9IGN1cnZhdHVyZTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBDdXJ2ZU5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBjdXJ2ZSB1c2luZyBDdXJ2ZUVmZmVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBsaW5lIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGRpbXMud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5fZHguZXZhbChjb250ZXh0KS52YWwsIFwiXCIpO1xuICAgICAgICBkaW1zLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl9keS5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGRpbXMuY3VydmF0dXJlID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMuX2N1cnZhdHVyZS5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGxldCBlID0gbmV3IEN1cnZlRWZmZWN0XzEuQ3VydmVFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBDdXJ2ZU5vZGUgZXF1YWxzIGFub3RoZXIgKGlmIHRoZWlyIGR4LCBkeSwgYW5kIGN1cnZhdHVyZSBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhIEN1cnZlTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgQ3VydmVOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZHguZXF1YWxzVmFsKHJpZ2h0LmR4KSAmJiB0aGlzLmR5LmVxdWFsc1ZhbChyaWdodC5keSkgJiYgdGhpcy5jdXJ2YXR1cmUuZXF1YWxzVmFsKHJpZ2h0LmN1cnZhdHVyZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW92ZSgpIHsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnZlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwiY3VydmUoXCIgKyB0aGlzLl9keC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5fZHkudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuX2N1cnZhdHVyZS50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJ1biBvZiB0aGUgY3VydmVcbiAgICAgKi9cbiAgICBnZXQgZHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9keDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcnVuIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIHNldCBkeChkeCkge1xuICAgICAgICB0aGlzLl9keCA9IGR4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByaXNlIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIGdldCBkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByaXNlIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIHNldCBkeShkeSkge1xuICAgICAgICB0aGlzLl9keSA9IGR5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJ2YXR1cmUgb2YgdGhlIGN1cnZlXG4gICAgICovXG4gICAgZ2V0IGN1cnZhdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnZhdHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VydmF0dXJlIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIHNldCBjdXJ2YXR1cmUoY3VydmF0dXJlKSB7XG4gICAgICAgIHRoaXMuX2N1cnZhdHVyZSA9IGN1cnZhdHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuQ3VydmVOb2RlID0gQ3VydmVOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3VydmVOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIEVsbGlwc2VOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYW4gRWxsaXBzZU5vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYW4gZWxsaXBzZVxuICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIGVsbGlwc2VcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGVsbGlwc2VcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBFbGxpcHNlTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGVsbGlwc2Ugb24gdGhlIGNhbnZhcyB1c2luZyBFbGxpcHNlRWZmZWN0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXMgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGVsbGlwc2VcbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGRpbXMud2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgZGltcy5oZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIGxldCBlID0gbmV3IEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KHRoaXMpO1xuICAgICAgICBlLmRyYXcoY29udGV4dCwgZGltcywgYXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgRWxsaXBzZU5vZGUgZXF1YWxzIGFub3RoZXIgRWxsaXBzZU5vZGUgKGlmIHRoZWlyIHdpZHRocyBhbmQgaGVpZ2h0cyBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhbiBFbGxpcHNlTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgRWxsaXBzZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy53aWR0aC5lcXVhbHNWYWwocmlnaHQud2lkdGgpICYmIHRoaXMuaGVpZ2h0LmVxdWFsc1ZhbChyaWdodC5oZWlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVsbGlwc2VcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJlbGxpcHNlKFwiICsgdGhpcy5fd2lkdGgudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuX2hlaWdodC50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIG1vdmUoKSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGxpcHNlIHdpZHRoXG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGVsbGlwc2Ugd2lkdGhcbiAgICAgKi9cbiAgICBzZXQgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBlbGxpcHNlIGhlaWdodFxuICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZWxsaXBzZSBoZWlnaHRcbiAgICAgKi9cbiAgICBzZXQgaGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkVsbGlwc2VOb2RlID0gRWxsaXBzZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbGxpcHNlTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgRXBoRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9FcGhFZmZlY3RcIik7XG5jbGFzcyBFcGhOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYW4gRXBoTm9kZSwgYSBub2RlIHJlcHJlc2VudGluZyBzb21ldGhpbmcgdmVyeSBzcGVjaWFsXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgRXBoTm9kZVxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgRXBoTm9kZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgLy90aGlzLl9pbWFnZSA9IGltYWdlO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgRXBoTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIHJlY3RhbmdsZSB1c2luZyBFcGhFZmZlY3RcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgcmVjdGFuZ2xlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGRpbXMud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5fd2lkdGguZXZhbChjb250ZXh0KS52YWwsIFwiXCIpO1xuICAgICAgICBkaW1zLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl9oZWlnaHQuZXZhbChjb250ZXh0KS52YWwsIFwiXCIpO1xuICAgICAgICBsZXQgZSA9IG5ldyBFcGhFZmZlY3RfMS5FcGhFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBFcGhOb2RlIGVxdWFscyBhbm90aGVyIChpZiB0aGVpciB3aWR0aHMgYW5kIGhlaWdodHMgYXJlIGVxdWFsKVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHkgKG11c3QgYmUgYW4gRXBoTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgRXBoTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoLmVxdWFsc1ZhbChyaWdodC53aWR0aCkgJiYgdGhpcy5oZWlnaHQuZXF1YWxzVmFsKHJpZ2h0LmhlaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW92ZSgpIHsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEVwaE5vZGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJlcGgoXCIgKyB0aGlzLl93aWR0aC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5faGVpZ2h0LnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIEVwaE5vZGVcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd2lkdGggb2YgdGhlIEVwaE5vZGVcbiAgICAgKi9cbiAgICBzZXQgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBFcGhOb2RlXG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBFcGhOb2RlXG4gICAgICovXG4gICAgc2V0IGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5FcGhOb2RlID0gRXBoTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVwaE5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IExpbmVFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0xpbmVFZmZlY3RcIik7XG5jbGFzcyBMaW5lTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgTGluZU5vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYSBsaW5lXG4gICAgICogQHBhcmFtIGR4IHRoZSBydW4gb2YgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0gZHkgdGhlIHJpc2Ugb2YgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkeCwgZHksIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZHggPSBkeDtcbiAgICAgICAgdGhpcy5fZHkgPSBkeTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMaW5lTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGxpbmUgdXNpbmcgTGluZUVmZmVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBsaW5lIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGRpbXMud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5fZHguZXZhbChjb250ZXh0KS52YWwsIFwiXCIpO1xuICAgICAgICBkaW1zLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl9keS5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGxldCBlID0gbmV3IExpbmVFZmZlY3RfMS5MaW5lRWZmZWN0KHRoaXMpO1xuICAgICAgICBlLmRyYXcoY29udGV4dCwgZGltcywgYXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgTGluZU5vZGUgZXF1YWxzIGFub3RoZXIgKGlmIHRoZWlyIGR4IGFuZCBkeSBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhIExpbmVOb2RlKVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBMaW5lTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmR4LmVxdWFsc1ZhbChyaWdodC5keCkgJiYgdGhpcy5keS5lcXVhbHNWYWwocmlnaHQuZHkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vdmUoKSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsaW5lXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwibGluZShcIiArIHRoaXMuX2R4LnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLl9keS50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJ1biBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIGdldCBkeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBydW4gb2YgdGhlIGxpbmVcbiAgICAgKi9cbiAgICBzZXQgZHgoZHgpIHtcbiAgICAgICAgdGhpcy5fZHggPSBkeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmlzZSBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIGdldCBkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByaXNlIG9mIHRoZSBsaW5lXG4gICAgICovXG4gICAgc2V0IGR5KGR5KSB7XG4gICAgICAgIHRoaXMuX2R5ID0gZHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkxpbmVOb2RlID0gTGluZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgUmVjdGFuZ2xlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9SZWN0YW5nbGVFZmZlY3RcIik7XG5jbGFzcyBSZWN0YW5nbGVOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBSZWN0YW5nbGVOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBSZWN0YW5nbGVOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgcmVjdGFuZ2xlIHVzaW5nIFJlY3RhbmdsZUVmZmVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSByZWN0YW5nbGUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSBhc3QgVGhlIHByb2dyYW0gQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgZGltcy53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl93aWR0aC5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGRpbXMuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMuX2hlaWdodC5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGxldCBlID0gbmV3IFJlY3RhbmdsZUVmZmVjdF8xLlJlY3RhbmdsZUVmZmVjdCh0aGlzKTtcbiAgICAgICAgZS5kcmF3KGNvbnRleHQsIGRpbXMsIGFzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIFJlY3RhbmdsZU5vZGUgZXF1YWxzIGFub3RoZXIgKGlmIHRoZWlyIHdpZHRocyBhbmQgaGVpZ2h0cyBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhIFJlY3RhbmdsZU5vZGUpXG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIFJlY3RhbmdsZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy53aWR0aC5lcXVhbHNWYWwocmlnaHQud2lkdGgpICYmIHRoaXMuaGVpZ2h0LmVxdWFsc1ZhbChyaWdodC5oZWlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vdmUoKSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJyZWN0KFwiICsgdGhpcy5fd2lkdGgudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuX2hlaWdodC50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIHNldCB3aWR0aCh3aWR0aCkge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICovXG4gICAgc2V0IGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5SZWN0YW5nbGVOb2RlID0gUmVjdGFuZ2xlTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlY3RhbmdsZU5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIERpbWVuc2lvbnMge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBEaW1lbnNpb25zLCB3aGljaCBzdG9yZXMgb2JqZWN0IGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0geCBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0geSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gc2NhbGUgVGhlIHNjYWxlIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gcmFkaXVzIFRoZSByYWRpdXMgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHNjYWxlLCByYWRpdXMpIHtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICB0aGlzLl9zY2FsZSA9IHNjYWxlO1xuICAgICAgICB0aGlzLl9yYWRpdXMgPSByYWRpdXMgfHwgbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDMwLCBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGltZW5zaW9uc1xuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy54LnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLnkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgc2V0IHgodmFsKSB7XG4gICAgICAgIHRoaXMuX3ggPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIHNldCB5KHZhbCkge1xuICAgICAgICB0aGlzLl95ID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByYWRpdXMgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGdldCByYWRpdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJhZGl1cyBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgc2V0IHJhZGl1cyh2YWwpIHtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzY2FsZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IHNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjYWxlIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgc2NhbGUodmFsKSB7XG4gICAgICAgIHRoaXMuX3NjYWxlID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHdpZHRoIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgd2lkdGgodmFsKSB7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgc2V0IGhlaWdodCh2YWwpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJ2YXR1cmUgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBjdXJ2YXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJ2YXR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnZhdHVyZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgc2V0IGN1cnZhdHVyZSh2YWwpIHtcbiAgICAgICAgdGhpcy5fY3VydmF0dXJlID0gdmFsO1xuICAgIH1cbn1cbmV4cG9ydHMuRGltZW5zaW9ucyA9IERpbWVuc2lvbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaW1lbnNpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgUHJpbnROb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBQcmludE5vZGUsIHJlcHJlc2VudGluZyBhbiBvYmplY3QgdG8gYmUgcHJpbnRlZFxuICAgICAqIEBwYXJhbSB0b1ByaW50IFRoZSBvYmplY3QgdG8gYmUgcHJpbnRlZFxuICAgICAqIEBwYXJhbSBkaW1lbnNpb25zIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3QgdG8gYmUgcHJpbnRlZFxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRvUHJpbnQsIGRpbWVuc2lvbnMsIHdzKSB7XG4gICAgICAgIHRoaXMuX3NjYWxlID0gMTtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90b1ByaW50ID0gdG9QcmludDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RpbXMgPSBkaW1lbnNpb25zIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCB0byBiZSBwcmludGVkXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwicHJpbnQoXCIgKyB0aGlzLnRvUHJpbnQudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuZGltcy50b1N0cmluZygpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgUHJpbnROb2RlXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBQcmludE5vZGVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW50Tm9kZXMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3KCkgb24gcHJpbnRPcFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBvYmplY3QgdG8gYmUgcHJpbnRlZCBhbmQgZHJhd3MgaXRcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5fdG9QcmludC5ldmFsKGNvbnRleHQpO1xuICAgICAgICByZXMuZHJhdyhjb250ZXh0LCB0aGlzLl9kaW1zLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb2JqZWN0IHRvIGJlIHByaW50ZWRcbiAgICAgKi9cbiAgICBnZXQgdG9QcmludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvUHJpbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9iamVjdCB0byBiZSBwcmludGVkXG4gICAgICovXG4gICAgZ2V0IGRpbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5QcmludE5vZGUgPSBQcmludE5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QcmludE5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBSZXR1cm5FcnJvcl8xID0gcmVxdWlyZShcIi4vUmV0dXJuRXJyb3JcIik7XG5jbGFzcyBSZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIFJldHVybiBvYmplY3QsIHJlcHJlc2VudGluZyBzb21ldGhpbmcgdG8gYmUgcmV0dXJuZWQgaW4gYSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBleHByIFRoZSBleHByZXNzaW9uIHRvIGJlIHJldHVybmVkXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZXhwciwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9leHByID0gZXhwcjtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyB0aGUgZXhwcmVzc2lvbiB0byBiZSByZXR1cm5lZCBhbmQgcmV0dXJucyB2aWEgYSBSZXR1cm5FcnJvXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIC8vIElmIHJldHVybiB2YWwgaXMgYSB2YXIsIHJldHVybnMgdGhhdCB2YXIncyB2YWx1ZVxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fZXhwci5ldmFsKGNvbnRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgUmV0dXJuRXJyb3JfMS5SZXR1cm5FcnJvcihyZXN1bHQsIGNvbnRleHQucmV0SURMb29rdXAoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIFJldHVybiBub2Rlc1xuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gUmV0dXJuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBSZXR1cm4gbm9kZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyBcInJldHVybiBcIiArIHRoaXMuX2V4cHIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbm9kZXMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIFJldHVyblwiKTtcbiAgICB9XG59XG5leHBvcnRzLlJldHVybiA9IFJldHVybjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJldHVybi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFJldHVybkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBSZXR1cm5FcnJvciwgYSBjdXN0b20gZXJyb3IgY2xhc3MgdGhhdCB3ZSBhYnVzZSB0byByZXR1cm4gdmFsdWVzXG4gICAgICogQHBhcmFtIHJldFZhbCBUaGUgdmFsdWUgdG8gYmUgcmV0dXJuZWRcbiAgICAgKiBAcGFyYW0gSUQgVGhlIElEIG9mIHRoZSB2YWx1ZSB0byBiZSByZXR1cm5lZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJldFZhbCwgSUQpIHtcbiAgICAgICAgc3VwZXIoSUQpO1xuICAgICAgICB0aGlzLnJldFZhbCA9IHJldFZhbDtcbiAgICAgICAgdGhpcy5JRCA9IElEO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUmV0dXJuRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLlJldHVybkVycm9yID0gUmV0dXJuRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXR1cm5FcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xuY2xhc3MgU2NvcGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBTY29wZSwgYW4gb2JqZWN0IGtlZXBpbmcgdHJhY2sgb2Ygb2JqZWN0cyB3aXRoaW4gYSBwYXJ0aWN1bGFyIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gcGFyZW50IFRoZSBwYXJlbnQgU2NvcGVcbiAgICAgKiBAcGFyYW0gZWZmZWN0cyBFZmZlY3RzIHdpdGhpbiB0aGlzIFNjb3BlXG4gICAgICogQHBhcmFtIG15U3RhdGUgVGhlIHNjb3BlIHN0YXRlXG4gICAgICogQHBhcmFtIGV2ZW50TG9nIFRoZSBsb2cgb2YgZXZlbnRzIHRoYXQgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGVmZmVjdHMsIGV2ZW50TG9nKSB7XG4gICAgICAgIHRoaXMuX3JldFZhbElEID0gc3BhY2VfbGlmdF8xLk5vbmU7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IHNwYWNlX2xpZnRfMS5Ob25lO1xuICAgICAgICB0aGlzLl9ldmVudExvZyA9IFtdOyAvLyBUaGUgZXZlbnQgbG9nXG4gICAgICAgIHRoaXMuX2hhZEZ1bkV2YWwgPSBmYWxzZTsgLy8gV2FzIHRoaXMgY3JlYXRlZCBpbiBhIGZ1bmN0aW9uP1xuICAgICAgICAvL3B1YmxpYyBnbG9iYWxGdW5JRCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHRoaXMuZ2xvYmFsRnVuSUQgPSAxMDAwMDAwMDsgLy8gVGhlIGdsb2JhbCBJRCBmb3IgZnVuY3Rpb25zIGluIHRoaXMgY29udGV4dFxuICAgICAgICB0aGlzLl92YXJCaW5kaW5ncyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLl9lZmZlY3RzID0gZWZmZWN0cyB8fCBudWxsO1xuICAgICAgICB0aGlzLl9ldmVudExvZyA9IGV2ZW50TG9nO1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50ICE9IG51bGwgJiYgdGhpcy5fcGFyZW50Ll9oYWRGdW5FdmFsKVxuICAgICAgICAgICAgdGhpcy5faGFkRnVuRXZhbCA9IHRydWU7IC8vIGNvcHkgZnVuY3Rpb24gZXZhbCBmbGFnIGZyb20gcGFyZW50XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyBpbmZvcm1hdGlvbiBmcm9tIHRoaXMgU2NvcGUgaW50byBhbm90aGVyIFNjb3BlIGFuZCByZXR1cm5zIHRoZSBuZXcgU2NvcGVcbiAgICAgKi9cbiAgICBjb3B5KCkge1xuICAgICAgICBsZXQgcyA9IG5ldyBTY29wZSh0aGlzLl9wYXJlbnQsIHRoaXMuX2VmZmVjdHMsIHRoaXMuX2V2ZW50TG9nKTtcbiAgICAgICAgcy52YXJCaW5kaW5ncyA9IG5ldyBNYXAodGhpcy5fdmFyQmluZGluZ3MpO1xuICAgICAgICBzLmNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgICBzLmV2ZW50TG9nID0gdGhpcy5ldmVudExvZztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY2xhcmVzIGEgbmV3IHZhcmlhYmxlXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGJlIGRlY2xhcmVkXG4gICAgICovXG4gICAgZGVjbGFyZShuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl92YXJCaW5kaW5ncy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjb3BlIGFscmVhZHkgaGFzIHZhciB3aXRoIG5hbWUgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92YXJCaW5kaW5ncy5zZXQobmFtZSwgc3BhY2VfbGlmdF8xLk5vbmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIGEgdmFsdWUgdG8gYSB2YXJpYWJsZSBpbiB0aGlzIENvbnRleHRcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGVcbiAgICAgKi9cbiAgICBhc3NpZ24obmFtZSwgdmFsKSB7XG4gICAgICAgIHRoaXMuX3ZhckJpbmRpbmdzLnNldChuYW1lLCBzcGFjZV9saWZ0XzEuU29tZSh2YWwpKTsgLy9Tb21lKHZhbCk/XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIGEgdmFsdWUgd2l0aGluIHRoZSBTY29wZSBhbmQgYWxsIGl0cyBhbmNlc3RvciBTY29wZXNcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB0byBzZWFyY2ggd2l0aGluXG4gICAgICovXG4gICAgbG9va3VwKG5hbWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQudmFyQmluZGluZ3MuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC52YXJCaW5kaW5ncy5nZXQobmFtZSkuaXNEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNvbnRleHQudmFyQmluZGluZ3MuZ2V0KG5hbWUpLmdldCgpKTsgLy9leHRyYSBnZXQgdG8gbWFuYWdlIFNvbWUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghKGNvbnRleHQucGFyZW50ID09IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb29rdXAobmFtZSwgY29udGV4dC5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhcmlhYmxlIGNvdWxkIG5vdCBiZSBmb3VuZC5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIGFuZCByZXR1cm5zIHRoZSByZXR1cm4gSUQgdmFsdWVcbiAgICAgKi9cbiAgICByZXRJRExvb2t1cCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JldFZhbElELmlzRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0VmFsSUQuZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudC5yZXRJRExvb2t1cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjYWxsZXIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE1hcCBvZiB2YXJpYWJsZSBiaW5kaW5nc1xuICAgICAqL1xuICAgIGdldCB2YXJCaW5kaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhckJpbmRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBNYXAgb2YgdmFyaWFibGUgYmluZGluZ3NcbiAgICAgKi9cbiAgICBzZXQgdmFyQmluZGluZ3MobSkge1xuICAgICAgICB0aGlzLl92YXJCaW5kaW5ncyA9IG07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhcmVudCBTY29wZVxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJldHVybiB2YWx1ZSBJRFxuICAgICAqL1xuICAgIGdldCByZXRWYWxJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldFZhbElEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByZXR1cm4gdmFsdWUgSURcbiAgICAgKi9cbiAgICBzZXQgcmV0VmFsSUQodmFsKSB7XG4gICAgICAgIHRoaXMuX3JldFZhbElEID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBIVE1MIGNhbnZhc1xuICAgICAqL1xuICAgIGdldCBjYW52YXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIEhUTUwgY2FudmFzXG4gICAgICovXG4gICAgc2V0IGNhbnZhcyh2YWwpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlZmZlY3RzIGFycmF5XG4gICAgICovXG4gICAgZ2V0IGVmZmVjdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lZmZlY3RzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBlZmZlY3RzIGFycmF5XG4gICAgICovXG4gICAgc2V0IGVmZmVjdHMoYXJyKSB7XG4gICAgICAgIHRoaXMuX2VmZmVjdHMgPSBhcnI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV2ZW50IGxvZ1xuICAgICAqL1xuICAgIGdldCBldmVudExvZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50TG9nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBldmVudCBsb2dcbiAgICAgKi9cbiAgICBzZXQgZXZlbnRMb2codXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50TG9nID0gdXBkYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBlZmZlY3RzXG4gICAgICovXG4gICAgZ2V0IG11bFNlbEFycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbXVsU2VsQXJyYXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFycmF5IG9mIGVmZmVjdHNcbiAgICAgKi9cbiAgICBzZXQgbXVsU2VsQXJyYXkodXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX211bFNlbEFycmF5ID0gdXBkYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBTY29wZSB3YXMgY3JlYXRlZCBpbiBhIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZ2V0IGhhZEZ1bkV2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYWRGdW5FdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhpcyBTY29wZSB3YXMgY3JlYXRlZCBpbiBhIGZ1bmN0aW9uXG4gICAgICovXG4gICAgc2V0IGhhZEZ1bkV2YWwodmFsKSB7XG4gICAgICAgIHRoaXMuX2hhZEZ1bkV2YWwgPSB2YWw7XG4gICAgfVxufVxuZXhwb3J0cy5TY29wZSA9IFNjb3BlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2NvcGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTY29wZV8xID0gcmVxdWlyZShcIi4vU2NvcGVcIik7XG5jb25zdCBzcGFjZV9saWZ0XzEgPSByZXF1aXJlKFwic3BhY2UtbGlmdFwiKTtcbmNsYXNzIFNlcXVlbmNlTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgU2VxdWVuY2VOb2RlLCB0aGUgYnVpbGRpbmcgYmxvY2sgb2YgdGhlIEFTVFxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IHNpZGUgb2YgdGhlIFNlcXVlbmNlXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBTZXF1ZW5jZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBjaGlsZHJlbiBpbiBwb3N0b3JkZXIgKGxlZnQsIHJpZ2h0LCBwYXJlbnQpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBsZWZ0U2NvcGUgPSBuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0LCBjb250ZXh0LmVmZmVjdHMsIGNvbnRleHQuZXZlbnRMb2cpO1xuICAgICAgICBsZWZ0U2NvcGUuY2FudmFzID0gc3BhY2VfbGlmdF8xLlNvbWUoY29udGV4dC5jYW52YXMuZ2V0KCkpO1xuICAgICAgICAvL3Rocm93aW5nIGF3YXkgYWZ0ZXIgZXZhbGluZ1xuICAgICAgICB0aGlzLl9sZWZ0VmFsID0gdGhpcy5fbGVmdC5ldmFsKGxlZnRTY29wZSk7XG4gICAgICAgIHRoaXMuX3JpZ2h0VmFsID0gdGhpcy5fcmlnaHQuZXZhbChsZWZ0U2NvcGUpOyAvLyBsZWZ0U2NvcGUgbWF5IGJlIG1vZGlmaWVkIG5vd1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXF1ZW5jZU5vZGVzIGNhbm5vdCBiZSBkaXJlY3RseSBkcmF3blxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdygpIG9uIFNlcXVlbmNlTm9kZXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgZGlyZWN0bHkgY2FsbGVkIG9uIFNlcXVlbmNlTm9kZXNcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIFNlcXVlbmNlTm9kZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQVNUXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9sZWZ0LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLl9sZWZ0Lm5ld0xpbmUoKSA9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCI7XFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JpZ2h0Lm5ld0xpbmUoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCkgKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLl9yaWdodC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxlZnQgY2hpbGRcbiAgICAgKi9cbiAgICBzZXQgbGVmdChsZWZ0KSB7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsZWZ0IGNoaWxkXG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByaWdodCBjaGlsZFxuICAgICAqL1xuICAgIHNldCByaWdodChyaWdodCkge1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByaWdodCBjaGlsZFxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbGVmdCBjaGlsZVxuICAgICAqL1xuICAgIGdldCBsZWZ0VmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdFZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHJpZ2h0IGNoaWxlXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0VmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHRWYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLlNlcXVlbmNlTm9kZSA9IFNlcXVlbmNlTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlcXVlbmNlTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi4vLi4vaW5kZXhcIik7XG5jb25zdCBpbmRleF8yID0gcmVxdWlyZShcIi4uLy4uL2luZGV4XCIpO1xuY29uc3Qgc3BhY2VfbGlmdF8xID0gcmVxdWlyZShcInNwYWNlLWxpZnRcIik7XG5sZXQgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG5sZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbmxldCBpbnB1dEJveCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnB1dCcpO1xubGV0IGxhc3RXb3JraW5nSW5wdXRUZXh0ID0gXCJcIjtcbmxldCBzdGFyQ291bnQgPSAwO1xuLy90aGUgZWZmZWN0cyBhcnJheSB0aGF0IGhvbGRzIGFsbCB0aGUgdGV4dCwgZWxsaXBzZXMsIGFuZCByZWN0YW5nbGVzXG5sZXQgZWZmZWN0cyA9IFtdO1xubGV0IGFzdDtcbmxldCBjb250ZXh0O1xubGV0IHNob3dEZWJ1ZyA9IHRydWU7IC8vIGZsYWcgdG8gc2hvdyBvciBoaWRlIGRlYnVnIGJ1dHRvblxubGV0IG1hc3RlckxvZyA9IFtdO1xubGV0IHNlbGVjdGVkRWxlbXMgPSBbXTtcbmxldCBjaGVja3BvaW50ID0gbnVsbDtcbmxldCBtb2RHZW4gPSBuZXcgaW5kZXhfMi5Nb2R1bGVHZW5lcmF0b3IodHJ1ZSk7XG5sZXQgY2hlY2twb2ludElzQWN0aXZlID0gZmFsc2U7XG5sZXQgdGV4dEJveFNlbGVjdGVkOyAvL3NlZXMgaWYgdGhlIHRleHQgYm94IGlzIHNlbGVjdGVkXG5sZXQgY2FudmFzSXNEaXNhYmxlZCA9IGZhbHNlO1xubGV0IHNlbGVjdGVkID0gMDsgLy90aGUgbnVtYmVyIG9mIHNlbGVjdGVkIGVmZmVjdHMgaWYgbXVsdGlwbHkgc2VsZWN0aW5nXG5sZXQgYWxyZWFkeUxvZ2dlZCA9IGZhbHNlO1xubGV0IG51bUxvZ2dlZCA9IDA7XG5sZXQgZ2xvYmFsSUQgPSAxO1xubGV0IGVwaDtcbi8qXG5sZXQgYnVnQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlYnVnJyk7XG5pZighc2hvd0RlYnVnKXtcbiAgICBidWdCdXR0b24uc3R5bGUudmlzaWJpbGl0eT0naGlkZGVuJztcbn1cblxuYnVnQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbigpe1xuICAgIHByaW50TG9nKCk7XG59XG4qL1xuLyoqXG4gKiA8ZGl2IGNsYXNzPVwiY29sLWl0ZW1cIj5cbiAqICA8YnV0dG9uIGlkPSdwYWludCcgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiNERkI1MzRcIj4gUnVuIDwvYnV0dG9uPlxuICogPC9kaXY+XG4gKlxuICogUHV0IHRoaXMgaW4gaHRtbCBmaWxlIGZvciBSdW4gYnV0dG9uJ3Mgc3R5bGluZ1xuICovXG4vL2xldCBwYWludEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYWludCcpO1xuLyoqXG4gKiBtYWtlcyB0aGUgcGFpbnQgYnV0dG9uIHBhaW50IHRleHQgZnJvbSB0aGUgdGV4dGFyZWEgdG8gdGhlIGNhbnZhcyFcbiAqL1xuLypcbnBhaW50QnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWZmZWN0cy5sZW5ndGggPSAwOyAvLyBzbGlnaHRseSBza2V0Y2ggY2xlYXJpbmcgbWV0aG9kIHRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBhcnJheVxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgIGlzUGFpbnRpbmcgPSB0cnVlO1xuICAgIGxldCBpbnB1dFRleHQgPSBpbnB1dEJveC52YWx1ZTtcblxuICAgIGxldCBhc3RPcHQgPSBQYXJzZXIucGFyc2UoaW5wdXRUZXh0KTtcbiAgICBpZihhc3RPcHQuaXNEZWZpbmVkKCkpe1xuICAgICAgICBhc3QgPSBhc3RPcHQuZ2V0KCk7XG4gICAgICAgIGNvbnRleHQgPSBuZXcgU2NvcGUobnVsbCwgZWZmZWN0cywgbWFzdGVyTG9nKTtcbiAgICAgICAgY29udGV4dC5jYW52YXMgPSBTb21lKGNhbnZhcyk7XG4gICAgICAgIGFzdC5ldmFsKGNvbnRleHQpOyAvL3RoaXMgaXMgd2hlcmUgd2UgZHJhdyB0aGUgb2JqZWN0cyB0byB0aGUgc2NyZWVuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGVycm9yID0gXCJlcnJvciB0ZXh0XCI7XG4gICAgICAgIGFsZXJ0KFwiUXVhbjogc28gc29tZXRoaW5nIHdpdGggdGhpcyBzeW50YXggZXJyb3I6IFwiICsgZXJyb3IpO1xuICAgIH1cblxuICAgIC8vbGV0IHBhaW50RXZ0ID0gbmV3IFBhaW50RXZlbnQoaW5wdXRUZXh0KTsgLy8gd2lsbCBuZWVkIHRvIGdldCBmcm9tIGFzdCB3aGVuIHRoYXQncyBpbXBsZW1lbnRlZFxuXG4gICAgLy8gQWRkaW5nIGNvbnRleHQgbG9nIHRvIG1hc3RlciBsb2dcbiAgICAvL2xvZ0V2ZW50LnB1c2gocGFpbnRFdnQuYXNzZW1ibGVMb2coKSk7XG4gICAgcHJpbnRMb2coKTtcbiAgICAvL2V2ZW50MS5sb2dJdGVtKCk7XG4gICAgLy8gfVxufTtcbiovXG4vL2NsZWFycyB0aGUgY2FudmFzIVxubGV0IHJlc2V0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlc2V0Jyk7XG5yZXNldEJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjaGVja3BvaW50Ll9zdGFydGVyQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHRleHRCb3hTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlucHV0Qm94LnZhbHVlID0gY2hlY2twb2ludC5fc3RhcnRlckNvZGU7XG4gICAgfVxuICAgIGNvbnRleHQuZXZlbnRMb2cucHVzaChuZXcgaW5kZXhfMi5DbGVhckV2ZW50KCkpO1xuICAgIG1hc3RlckxvZy5wdXNoKGNvbnRleHQuZXZlbnRMb2dbY29udGV4dC5ldmVudExvZy5sZW5ndGggLSAxXSk7IC8vIERvZXMgdGhpcyBhY3R1YWxseSB3b3JrP1xuICAgIHByaW50TG9nKCk7XG4gICAgLy9sZXQgY2xlYXJFdnQgPSBuZXcgQ2xlYXJFdmVudCgpO1xuICAgIC8vbG9nRXZlbnQucHVzaChjbGVhckV2dC5hc3NlbWJsZUxvZygpKTtcbiAgICAvL2NvbnNvbGUubG9nKFwiTG9nOiBcIiArIGxvZ0V2ZW50KTtcbn07XG5sZXQgdGltZXIgPSBudWxsO1xuaW5wdXRCb3gub25rZXlkb3duID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aW1lciAhPSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgfVxuICAgIHRpbWVyID0gc2V0VGltZW91dChwYXJzZSwgMjAwKTtcbn07XG5mdW5jdGlvbiBwYXJzZSgpIHtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgbGV0IGlucHV0VGV4dCA9IGlucHV0Qm94LnZhbHVlO1xuICAgIGxldCBhc3RPcHQgPSBpbmRleF8xLlBhcnNlci5wYXJzZShpbnB1dFRleHQpO1xuICAgIGVmZmVjdHMubGVuZ3RoID0gMDsgLy8gc2xpZ2h0bHkgc2tldGNoIGNsZWFyaW5nIG1ldGhvZCB0byBtYWludGFpbiByZWZlcmVuY2UgdG8gb3JpZ2luYWwgYXJyYXlcbiAgICBpZiAoYXN0T3B0LmlzRGVmaW5lZCgpKSB7XG4gICAgICAgIGFzdCA9IGFzdE9wdC5nZXQoKTtcbiAgICAgICAgY29udGV4dCA9IG5ldyBpbmRleF8yLlNjb3BlKG51bGwsIGVmZmVjdHMsIG1hc3RlckxvZyk7XG4gICAgICAgIGNvbnRleHQuY2FudmFzID0gc3BhY2VfbGlmdF8xLlNvbWUoY2FudmFzKTtcbiAgICAgICAgYXN0LmV2YWwoY29udGV4dCk7IC8vdGhpcyBpcyB3aGVyZSB3ZSBkcmF3IHRoZSBvYmplY3RzIHRvIHRoZSBzY3JlZW5cbiAgICAgICAgbGFzdFdvcmtpbmdJbnB1dFRleHQgPSBpbnB1dFRleHQ7XG4gICAgfVxuICAgIC8vbGV0IHBhaW50RXZ0ID0gbmV3IFBhaW50RXZlbnQoaW5wdXRUZXh0KTsgLy8gd2lsbCBuZWVkIHRvIGdldCBmcm9tIGFzdCB3aGVuIHRoYXQncyBpbXBsZW1lbnRlZFxuICAgIC8vIEFkZGluZyBjb250ZXh0IGxvZyB0byBtYXN0ZXIgbG9nXG4gICAgLy9sb2dFdmVudC5wdXNoKHBhaW50RXZ0LmFzc2VtYmxlTG9nKCkpO1xuICAgIHByaW50TG9nKCk7XG4gICAgLy9ldmVudDEubG9nSXRlbSgpO1xuICAgIC8vIH1cbn1cbi8qKlxuICogVGhlIGFuaW1hdGlvbiBmdW5jdGlvbiB0aGF0IGJhc2ljYWxseSByZWN1cnNpdmVseSBjYWxscyBpdHNlbGYsIGNsZWFyaW5nIGFuZFxuICogcmVkcmF3aW5nIHRvIHRoZSBjYW52YXMgYXQgNjBmcHMuXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsgLy9jbGVhcnMgY2FudmFzXG4gICAgc2VsZWN0ZWQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWZmZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlZmZlY3RzW2ldLnVwZGF0ZSgpO1xuICAgICAgICBpZiAoZWZmZWN0c1tpXS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRFbGVtcy5wdXNoKGVmZmVjdHNbaV0pO1xuICAgICAgICAgICAgc2VsZWN0ZWQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0c1tpXS5nZXRKdXN0RHJhZ2dlZCgpKSB7IC8vIExvZ3MgZHJhZyBldmVudFxuICAgICAgICAgICAgY29udGV4dC5ldmVudExvZy5wdXNoKG5ldyBpbmRleF8yLkRyYWdFdmVudChlZmZlY3RzW2ldKSk7XG4gICAgICAgICAgICBtYXN0ZXJMb2cucHVzaChjb250ZXh0LmV2ZW50TG9nW2NvbnRleHQuZXZlbnRMb2cubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgZWZmZWN0c1tpXS5zZXRKdXN0RHJhZ2dlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdHNbaV0uaWRPYmogPT0gdW5kZWZpbmVkKSB7IC8vIEdpdmVzIG9iamVjdCBhbiBJRCBpZiBpdCBkb2Vzbid0IGhhdmUgb25lXG4gICAgICAgICAgICBlZmZlY3RzW2ldLmluaXRJRChnbG9iYWxJRCk7XG4gICAgICAgICAgICBjb250ZXh0LmV2ZW50TG9nLnB1c2gobmV3IGluZGV4XzIuSURFdmVudChlZmZlY3RzW2ldKSk7IC8vIExvZ3MgSURcbiAgICAgICAgICAgIGdsb2JhbElEKys7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVmZmVjdHNbaV0uZ2V0SUQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYoKChlZmZlY3RzW2ldIGFzIEVsbGlwc2VFZmZlY3QpLmp1c3REcmFnZ2VkKSl7XG4gICAgICAgIC8vICAgICAvL2NvbnRleHQuZXZlbnRMb2cucHVzaChuZXcgRHJhZ0V2ZW50KGVmZmVjdHNbaV0pKTtcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBoYXZlIGl0ZXJhdGVkIHRocm91Z2ggYWxsIGVmZmVjdHMgYW5kIGhhdmUgY29tcGxldGUgbGlzdCB0byBsb2dcbiAgICBpZiAoc2VsZWN0ZWQgIT0gbnVtTG9nZ2VkKSB7IC8vIGlmIHNlbGVjdGlvbnMgaGF2ZSBjaGFuZ2VkLCBzaG91bGQgbG9nIGFnYWluXG4gICAgICAgIGFscmVhZHlMb2dnZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFhbHJlYWR5TG9nZ2VkICYmIHNlbGVjdGVkID49IDIpIHsgLy8gbG9ncyBpZiBoYXNuJ3QgYWxyZWFkeVxuICAgICAgICBudW1Mb2dnZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgY29udGV4dC5ldmVudExvZy5wdXNoKG5ldyBpbmRleF8yLlNlbGVjdEV2ZW50KHNlbGVjdGVkRWxlbXMpKTtcbiAgICAgICAgbWFzdGVyTG9nLnB1c2goY29udGV4dC5ldmVudExvZ1tjb250ZXh0LmV2ZW50TG9nLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgYWxyZWFkeUxvZ2dlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vVGhpcyBkb2VzIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uLCBwYXNzaW5nIHRoZSBuZXcgc3RyaW5ncyB0byB0aGUgdGV4dCBib3hcbiAgICBpZiAoYXN0ICE9IHVuZGVmaW5lZCAmJiAhdGV4dEJveFNlbGVjdGVkKSB7XG4gICAgICAgIGxldCBuZXdJbnB1dCA9IGFzdC50b1N0cmluZygpO1xuICAgICAgICBpbnB1dEJveC52YWx1ZSA9IG5ld0lucHV0O1xuICAgIH1cbiAgICBpZiAoY2hlY2twb2ludElzQWN0aXZlKSB7XG4gICAgICAgIGNoZWNrcG9pbnRDaGVja3NHb2FsKCk7XG4gICAgfVxuICAgIGlmIChjaGVja3BvaW50ICE9IG51bGwgJiYgY2hlY2twb2ludC5kcmF3R3VpZGVzICE9IG51bGwpIHtcbiAgICAgICAgY2hlY2twb2ludC5kcmF3R3VpZGVzKGN0eCk7XG4gICAgICAgIC8qXG4gICAgICAgICAgICAgIGlmIChjaGVja3BvaW50Ll9uYW1lID09IFwibDFjM1wiKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZWN0KDEwLCA0MzAsIDEwMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IDIwICsgXCJweCBDb3VyaWVyIE5ld1wiO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFwiUHV0IHRleHRcIiwgMTAsIDM5MCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFwiaW4gaGVyZVwiLCAxMCwgNDEwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAqL1xuICAgIH1cbiAgICBzZWxlY3RlZEVsZW1zID0gW107XG59XG4vL2NoZWNrcyB0byBzZWUgd2hldGhlciB0aGUgdGV4dCBib3ggaXMgc2VsZWN0ZWRcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBpc0lucHV0Qm94U2VsZWN0ZWQpO1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIG1hbmFnZXMgdGhlIHN0YXRlIG9mIHRoZSBVSSB3aGVuIHRoZSB0ZXh0IGJveCBpcyBzZWxlY3RlZCBhbmQgd2hlbiBpdCBpc24ndC5cbiAqIElmIGl0IGlzIGluc2lkZSB0aGUgdGV4dCBib3gsIGlzUGFpbnRpbmcgaXMgZmFsc2UgYW5kIHRleHRCb3hTZWxlY3RlZCBpcyB0cnVlLlxuICogSWYgaXQncyBub3QsIGlmIGl0J3MgaW5zaWRlIHRoZSBwYWludCBidXR0b24sIHRoZW4gaXNQYWludGluZyA9IHRydWUuXG4gKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlIGRvd24gZXZlbnRcbiAqL1xuZnVuY3Rpb24gaXNJbnB1dEJveFNlbGVjdGVkKGV2ZW50KSB7XG4gICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgbGV0IG1vdXNlWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgbGV0IHJlY3QgPSBpbnB1dEJveC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAobW91c2VYID4gcmVjdC5sZWZ0ICYmIG1vdXNlWCA8IHJlY3QucmlnaHQgJiYgbW91c2VZID4gcmVjdC50b3AgJiYgbW91c2VZIDwgcmVjdC5ib3R0b20pIHtcbiAgICAgICAgdGV4dEJveFNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRleHRCb3hTZWxlY3RlZCA9IGZhbHNlO1xuICAgIH1cbn1cbi8vY2hlY2tzIHRvIHNlZSB3aGV0aGVyIHRoZSB0ZXh0IGJveCBpcyBzZWxlY3RlZFxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGRpc2FibGVkQ2FudmFzSXNTZWxlY3RlZCk7XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyB0aGUgY2FzZSB3aGVuIGEgZGlzYWJsZWQgY2FudmFzIGlzIHNlbGVjdGVkLlxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZSBkb3duIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVkQ2FudmFzSXNTZWxlY3RlZChldmVudCkge1xuICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBwb3BVcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwb3B1cCcpO1xuICAgIGlmIChjYW52YXNJc0Rpc2FibGVkICYmIG1vdXNlWCA+IHJlY3QubGVmdCAmJiBtb3VzZVggPCByZWN0LnJpZ2h0ICYmIG1vdXNlWSA+IHJlY3QudG9wICYmIG1vdXNlWSA8IHJlY3QuYm90dG9tKSB7XG4gICAgICAgIHBvcFVwLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9wVXAuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG59XG5mdW5jdGlvbiBwcmludExvZygpIHtcbiAgICBjb25zb2xlLmxvZyhcIkxvZzogXCIpO1xuICAgIGZvciAobGV0IGVsZW0gb2YgbWFzdGVyTG9nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVsZW0uYXNzZW1ibGVMb2coKSk7XG4gICAgfVxufVxubGV0IHBhbGV0dGVCdXR0b25zID0gW1xuICAgIFwiZWxsaXBzZVwiLCBcInJlY3RcIiwgXCJzdHJpbmdcIiwgXCJudW1iZXJcIixcbiAgICBcImxpbmVcIiwgXCJjdXJ2ZVwiXG5dO1xuZm9yIChsZXQgYnV0dG9uTmFtZSBvZiBwYWxldHRlQnV0dG9ucykge1xuICAgIGxldCBwYWxldHRlQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYnV0dG9uTmFtZSk7XG4gICAgcGFsZXR0ZUJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0ZXh0Qm94U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBwcmludE5ld05vZGUoYnV0dG9uTmFtZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHByaW50TmV3Tm9kZShidXR0b25OYW1lKSB7XG4gICAgbGV0IHByaW50TGluZSA9IFwiXCI7XG4gICAgc3dpdGNoIChidXR0b25OYW1lKSB7XG4gICAgICAgIGNhc2UgXCJlbGxpcHNlXCI6XG4gICAgICAgICAgICBwcmludExpbmUgPSBcInByaW50KGVsbGlwc2UoMTAwLDEwMCkpO1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWN0XCI6XG4gICAgICAgICAgICBwcmludExpbmUgPSBcInByaW50KHJlY3QoMTAwLDEwMCkpO1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHByaW50TGluZSA9ICdwcmludChcIm5ld1dvcmRcIik7JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBwcmludExpbmUgPSBcInByaW50KDEwKTtcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICAgICAgcHJpbnRMaW5lID0gXCJwcmludChsaW5lKDEwMCwxMDApKTtcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY3VydmVcIjpcbiAgICAgICAgICAgIHByaW50TGluZSA9IFwicHJpbnQoY3VydmUoMTAwLDEwMCwxMDApKTtcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQcm9ibGVtIHdpdGggXCIgKyBidXR0b25OYW1lKTtcbiAgICB9XG4gICAgaW5wdXRCb3gudmFsdWUgKz0gcHJpbnRMaW5lO1xuICAgIHBhcnNlKCk7XG59XG5sZXQgaW5zdHJ1Y3Rpb25zID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dvYWwnKTtcbmxldCByZXdhcmRCb3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmV3YXJkLWNvbnRhaW5lcicpO1xubGV0IGluc3RyTGFiZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5zdHItbGFiZWwnKTtcbi8vTWFwIG1haW50YWluaW5nIGNvZGUgbGFzdCB1c2VkIGF0IGEgY2hlY2twb2ludFxubGV0IGNwQ29kZSA9IG5ldyBNYXAoW1xuICAgIFsnbDFjMScsIFwiXCJdLFxuICAgIFsnbDFjMicsIFwiXCJdLFxuICAgIFsnbDFjMycsIFwiXCJdLFxuICAgIFsnbDFjNCcsIFwiXCJdLFxuICAgIFsnbDJjMScsIFwiXCJdLFxuICAgIFsnbDJjMicsIFwiXCJdLFxuICAgIFsnbDJjMycsIFwiXCJdLFxuICAgIFsnbDJjNCcsIFwiXCJdLFxuICAgIFsnbDJjNScsIFwiXCJdLFxuICAgIFsnbDJjNicsIFwiXCJdLFxuICAgIFsnbDJjNycsIFwiXCJdLFxuICAgIFsnbDNjMScsIFwiXCJdLFxuICAgIFsnbDNjMicsIFwiXCJdLFxuICAgIFsnbDNjMycsIFwiXCJdLFxuICAgIFsnbDNjNCcsIFwiXCJdLFxuICAgIFsnbDNjNScsIFwiXCJdLFxuICAgIFsnbDNjNicsIFwiXCJdLFxuICAgIFsnbDRjMScsIFwiXCJdLFxuICAgIFsnbDRjMicsIFwiXCJdXG5dKTtcbi8vTWFwIG1haW50YWluaW5nIHdoZXRoZXIgYSBjaGVja3BvaW50IGhhcyBiZWVuIGNvbXBsZXRlZFxubGV0IGNwQ29tcGxldGlvbiA9IG5ldyBNYXAoW1xuICAgIFsnbDFjMScsIGZhbHNlXSxcbiAgICBbJ2wxYzInLCBmYWxzZV0sXG4gICAgWydsMWMzJywgZmFsc2VdLFxuICAgIFsnbDFjNCcsIGZhbHNlXSxcbiAgICBbJ2wyYzEnLCBmYWxzZV0sXG4gICAgWydsMmMyJywgZmFsc2VdLFxuICAgIFsnbDJjMycsIGZhbHNlXSxcbiAgICBbJ2wyYzQnLCBmYWxzZV0sXG4gICAgWydsMmM1JywgZmFsc2VdLFxuICAgIFsnbDJjNicsIGZhbHNlXSxcbiAgICBbJ2wyYzcnLCBmYWxzZV0sXG4gICAgWydsM2MxJywgZmFsc2VdLFxuICAgIFsnbDNjMicsIGZhbHNlXSxcbiAgICBbJ2wzYzMnLCBmYWxzZV0sXG4gICAgWydsM2M0JywgZmFsc2VdLFxuICAgIFsnbDNjNScsIGZhbHNlXSxcbiAgICBbJ2wzYzYnLCBmYWxzZV0sXG4gICAgWydsNGMxJywgZmFsc2VdLFxuICAgIFsnbDRjMicsIGZhbHNlXVxuXSk7XG5sZXQgY3BOYW1lcyA9IFtcbiAgICAnbDFjMScsICdsMWMyJywgJ2wxYzMnLCAnbDFjNCcsXG4gICAgJ2wyYzEnLCAnbDJjMicsICdsMmMzJywgJ2wyYzQnLCAnbDJjNScsICdsMmM2JywgJ2wyYzcnLFxuICAgICdsM2MxJywgJ2wzYzInLCAnbDNjMycsICdsM2M0JywgJ2wzYzUnLCAnbDNjNicgLyosXG4gICAgJ2w0YzEnLCAnbDRjMicqL1xuXTtcbmZvciAobGV0IGNwIG9mIGNwTmFtZXMpIHtcbiAgICBsZXQgY3BCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjcCk7XG4gICAgY3BCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5pdENoZWNrcG9pbnQoY3ApO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtb2R1bGUgY29ycmVzcG9uZGluZyB0byBhIGNoZWNrcG9pbnQgcGFzc2VkIGluLlxuICogU2V0cyB1cCB0aGUgaW5zdHJ1Y3Rpb24sIENPREUgYXJlYSwgYW5kIGdvYWwgYm94IGFjY29yZGluZ2x5LlxuICogQHBhcmFtIGNwOiB0aGUgbmFtZSBvZiB0aGUgY2hlY2twb2ludFxuICovXG5mdW5jdGlvbiBpbml0Q2hlY2twb2ludChjcCkge1xuICAgIC8vc3RvcmUgQ09ERSBvZiBvbGQgY2hlY2twb2ludFxuICAgIGlmIChjaGVja3BvaW50ICE9IG51bGwpIHtcbiAgICAgICAgY3BDb2RlLnNldChjaGVja3BvaW50Ll9uYW1lLCBpbnB1dEJveC52YWx1ZSk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFwiSW5pdGlhdGluZyBjaGVja3BvaW50IFwiICsgY3ApO1xuICAgIGNoZWNrcG9pbnQgPSBtb2RHZW4uZ2VuZXJhdGVDaGVja3BvaW50KGNwKTtcbiAgICBpbnN0ckxhYmVsLmlubmVySFRNTCA9IGNwICsgXCIgLSBHT0FMXCI7XG4gICAgaW5zdHJ1Y3Rpb25zLmlubmVySFRNTCA9IGNoZWNrcG9pbnQuX2luc3RydWN0aW9ucztcbiAgICAvL3NldCB1cCB0aGUgQ09ERSBhbmQgQ0FOVkFTIGFyZWFzXG4gICAgaWYgKGNoZWNrcG9pbnQuX2NvbnN0cmFpbnQgPT0gJ2NvZGUnKSB7XG4gICAgICAgIGlucHV0Qm94LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgaW5wdXRCb3guc3R5bGUub3BhY2l0eSA9ICcwLjUnO1xuICAgICAgICBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgICAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9ICcjRUJFQkVCJztcbiAgICAgICAgY2FudmFzSXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGVja3BvaW50Ll9jb25zdHJhaW50ID09ICdjYW52YXMnKSB7XG4gICAgICAgIGlucHV0Qm94LnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgaW5wdXRCb3guc3R5bGUub3BhY2l0eSA9ICcxLjAnO1xuICAgICAgICBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9ICcjQzBDMEMwJztcbiAgICAgICAgY2FudmFzSXNEaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbnB1dEJveC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgIGlucHV0Qm94LnN0eWxlLm9wYWNpdHkgPSAnMS4wJztcbiAgICAgICAgY2FudmFzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSAnI0VCRUJFQic7XG4gICAgICAgIGNhbnZhc0lzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHBvcFVwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BvcHVwJyk7XG4gICAgcG9wVXAuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZiAoY3BDb2RlLmdldChjaGVja3BvaW50Ll9uYW1lKSAhPT0gXCJcIikge1xuICAgICAgICB0ZXh0Qm94U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpbnB1dEJveC52YWx1ZSA9IGNwQ29kZS5nZXQoY2hlY2twb2ludC5fbmFtZSk7XG4gICAgfVxuICAgIC8vc2V0IHVwIHRoZSBpbnN0cnVjdGlvbiBhbmQgZ29hbCBib3hlc1xuICAgIGlmIChjcENvbXBsZXRpb24uZ2V0KGNwKSkge1xuICAgICAgICB1cGRhdGVSZXdhcmRCb3goKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChjaGVja3BvaW50Ll9zdGFydGVyQ29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0ZXh0Qm94U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaW5wdXRCb3gudmFsdWUgPSBjaGVja3BvaW50Ll9zdGFydGVyQ29kZTtcbiAgICAgICAgICAgIHBhcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1ckluc3RydWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnN0cnVjdGlvblwiKTtcbiAgICAgICAgaWYgKGN1ckluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN1ckluc3RydWN0aW9uLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAgICAgIGlmIChjaGVja3BvaW50Ll9uYW1lID09PSBcImwxYzFcIikge1xuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnQucmVuZGVySW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIHJld2FyZEJveC5zdHlsZS5iYWNrZ3JvdW5kID0gJyNDMEMwQzAnO1xuICAgICAgICBsZXQgcmV3YXJkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jld2FyZC10ZXh0Jyk7XG4gICAgICAgIHJld2FyZC5zdHlsZS5jb2xvciA9ICdibGFjayc7XG4gICAgICAgIHJld2FyZC5pbm5lckhUTUwgPSAnQ29tcGxldGUgZ29hbCB0byBlYXJuIGEgc3RhciEnO1xuICAgICAgICBsZXQgcmV3YXJkSW1nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jld2FyZC1pbWFnZScpO1xuICAgICAgICByZXdhcmRJbWcuc3JjID0gJ3BpY3MvZ3JleXN0YXIuc3ZnJztcbiAgICAgICAgcmV3YXJkSW1nLmFsdCA9ICdhIHN0YXIgdG8gYmUgZWFybmVkJztcbiAgICAgICAgbGV0IG5leHRCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmV4dCcpO1xuICAgICAgICBuZXh0QnRuLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGluc3RydWN0aW9ucy5zY3JvbGxUb3AgPSAwO1xuICAgICAgICBjaGVja3BvaW50SXNBY3RpdmUgPSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrcG9pbnRDaGVja3NHb2FsKCkge1xuICAgIGlmIChjaGVja3BvaW50LmNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykpIHtcbiAgICAgICAgdXBkYXRlUmV3YXJkQm94KCk7XG4gICAgICAgIGNwQ29tcGxldGlvbi5zZXQoY2hlY2twb2ludC5fbmFtZSwgdHJ1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlUmV3YXJkQm94KCkge1xuICAgIHJld2FyZEJveC5zdHlsZS5iYWNrZ3JvdW5kID0gJyM2NzNBQjcnO1xuICAgIGNvbnNvbGUubG9nKGRvY3VtZW50KTtcbiAgICBsZXQgcmV3YXJkVGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXdhcmQtdGV4dCcpO1xuICAgIHJld2FyZFRleHQuc3R5bGUuY29sb3IgPSAnI0Q4RDhEOCc7XG4gICAgcmV3YXJkVGV4dC5pbm5lckhUTUwgPSBcIkdvYWwgbWV0ISBDbGljayAnTmV4dCcgdG8gZ28gdG8gbmV4dCBjaGVja3BvaW50IVwiO1xuICAgIGxldCByZXdhcmRJbWcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmV3YXJkLWltYWdlJyk7XG4gICAgcmV3YXJkSW1nLnNyYyA9ICdwaWNzL3N0YXIuc3ZnJztcbiAgICByZXdhcmRJbWcuYWx0ID0gJ3N0YXIgZWFybmVkJztcbiAgICBsZXQgbmV4dEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZXh0Jyk7XG4gICAgbmV4dEJ0bi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBpbnN0cnVjdGlvbnMuc2Nyb2xsVG9wID0gaW5zdHJ1Y3Rpb25zLnNjcm9sbEhlaWdodDtcbiAgICBjaGVja3BvaW50SXNBY3RpdmUgPSBmYWxzZTtcbn1cbmxldCBuZXh0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25leHQnKTtcbm5leHRCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgbmV4dE1vZHVsZSA9IGNoZWNrcG9pbnQuX25leHRNb2R1bGU7XG4gICAgaWYgKG5leHRNb2R1bGUgIT0gJycpIHtcbiAgICAgICAgaW5pdENoZWNrcG9pbnQobmV4dE1vZHVsZSk7XG4gICAgfVxufTtcbmxldCBwcmV2QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ByZXYnKTtcbnByZXZCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcHJldk1vZHVsZSA9IGNoZWNrcG9pbnQuX3ByZXZNb2R1bGU7XG4gICAgaWYgKHByZXZNb2R1bGUgIT0gJycpIHtcbiAgICAgICAgaW5pdENoZWNrcG9pbnQocHJldk1vZHVsZSk7XG4gICAgfVxufTtcbi8vY2FsbCB0byBhbmltYXRlXG5hbmltYXRlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11aS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFVuYXJ5T3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9VbmFyeU9wZXJhdGlvblwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgTmVnT3AgZXh0ZW5kcyBVbmFyeU9wZXJhdGlvbl8xLlVuYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBOZWdhdGlvbk9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGJlIG5lZ2F0ZWQgKG11c3QgYmUgYSBOdW1iZXJOb2RlKVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgd3MpIHtcbiAgICAgICAgc3VwZXIodmFsKTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyB0aGUgdmFsdWUgaW50byB0aGUgbmVnYXRpdmUgdmVyc2lvblxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgdiA9IHRoaXMudmFsLmV2YWwoY29udGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoLXYudmFsLCBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmVnT3BzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmVnYXRpb24gb3BzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBOZWdPcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gTmVnT3BcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIE5lZ09wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwiLVwiICsgdGhpcy52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5OZWdPcCA9IE5lZ09wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmVnT3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBVbmFyeU9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogQWJzdHJhY3QgY2xhc3MgY29uc3RydWN0b3IgZm9yIFVuYXJ5IE9wZXJhdGlvbnNcbiAgICAgKiBAcGFyYW0gX3ZhbCBUaGUgb2JqZWN0IHRvIGJlIG9wZXJhdGVkIG9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX3ZhbCkge1xuICAgICAgICB0aGlzLl92YWwgPSBfdmFsO1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBYnN0cmFjdCBkcmF3IG1ldGhvZCBmb3IgdW5kcmF3YWJsZSBVbmFyeU9wc1xuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hcnkgT3BlcmF0aW9ucyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIFVuYXJ5T3BzXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBVbmFyeU9wXCIpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBVbmFyeU9wIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IHZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgVW5hcnlPcCB2YWx1ZVxuICAgICAqL1xuICAgIHNldCB2YWwodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFsID0gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5VbmFyeU9wZXJhdGlvbiA9IFVuYXJ5T3BlcmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5hcnlPcGVyYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBWYXJpYWJsZU5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIFZhcmlhYmxlTm9kZSwgYSBub2RlIHJlcHJlc2VudGluZyBhIHZhcmlhYmxlXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIHZhcmlhYmxlIG5hbWVcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3MgdXAgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSBpbiB0aGUgY29udGV4dFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5sb29rdXAodGhpcy5fbmFtZSwgY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhcmlhYmxlTm9kZXMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIHZhcmlhYmxlIG5vZGVzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBWYXJpYWJsZU5vZGVzXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkaXJlY3RseSBjb21wYXJlIHZhcnMsIGV2YWwgZmlyc3RcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFZhcmlhYmxlTm9kZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFyaWFibGVOb2RlID0gVmFyaWFibGVOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFyaWFibGVOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gIFNoYWxsb3cgdXBkYXRlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuLyoqIFBlcmZvcm1zIGEgc2hhbGxvdyB1cGRhdGUgb2YgYW4gb2JqZWN0IHVzaW5nIGEgcGFydGlhbCBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUuIEEgbmV3IG9iamVjdCBpcyByZXR1cm5lZC4gKi9cbmZ1bmN0aW9uIHVwZGF0ZShob3N0LCBzcGVjKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNsb25lKGhvc3QpO1xuICAgIGZvciAodmFyIGtleSBpbiBzcGVjKSB7XG4gICAgICAgIHZhciBzcGVjVmFsdWUgPSBzcGVjW2tleV07XG4gICAgICAgIGlmIChzcGVjVmFsdWUgPT09IGV4cG9ydHMuREVMRVRFKSB7XG4gICAgICAgICAgICBkZWxldGUgcmVzdWx0W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHNwZWNWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy51cGRhdGUgPSB1cGRhdGU7XG4vLyBXZSBsaWUgYWJvdXQgdGhlIHB1YmxpYyB0eXBlIHNvIHRoYXQgb25seSBhIHByb3BlcnR5IHRoYXQgaXMgb3B0aW9uYWwgb3IgdGhhdCBjYW4gYmUgYXNzaWduZWQgdG8gdW5kZWZpbmVkIGNhbiBiZSBERUxFVEUnZFxuLyoqIE1hcmtlciB1c2VkIHRvIGRlbGV0ZSBhIGtleSAqL1xuZXhwb3J0cy5ERUxFVEUgPSB7fTtcbnZhciBfVXBkYXRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfVXBkYXRlcihkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIF9VcGRhdGVyLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChrZXlPckluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgX1VwZGF0ZXIoeyB0eXBlOiAnYXQnLCBwYXJlbnQ6IHRoaXMsIGZpZWxkOiBrZXlPckluZGV4IH0pO1xuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZG9TZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMuY2xvbmVGb3JVcGRhdGUodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubmFtZSA9PT0gJ2Fib3J0ZWQnKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB2YXIgY2xvbmVkVGFyZ2V0ID0gcmVzdWx0LmNsb25lZFRhcmdldCwgbGVhZkhvc3QgPSByZXN1bHQubGVhZkhvc3QsIGZpZWxkID0gcmVzdWx0LmZpZWxkO1xuICAgICAgICAgICAgdmFsdWUgPT09IGV4cG9ydHMuREVMRVRFID8gZGVsZXRlIGxlYWZIb3N0W2ZpZWxkXSA6IGxlYWZIb3N0W2ZpZWxkXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lZFRhcmdldDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJvdW5kVGFyZ2V0ID0gdGhpcy5maW5kQm91bmRUYXJnZXQoKTtcbiAgICAgICAgcmV0dXJuIGJvdW5kVGFyZ2V0XG4gICAgICAgICAgICA/IGRvU2V0KGJvdW5kVGFyZ2V0KVxuICAgICAgICAgICAgOiBkb1NldDtcbiAgICB9O1xuICAgIF9VcGRhdGVyLnByb3RvdHlwZS5tb2RpZnkgPSBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRvTW9kaWZ5ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLmNsb25lRm9yVXBkYXRlKHRhcmdldCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lm5hbWUgPT09ICdhYm9ydGVkJylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGNsb25lZFRhcmdldCA9IHJlc3VsdC5jbG9uZWRUYXJnZXQsIGxlYWZIb3N0ID0gcmVzdWx0LmxlYWZIb3N0LCBmaWVsZCA9IHJlc3VsdC5maWVsZDtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1vZGlmaWVyKGxlYWZIb3N0W2ZpZWxkXSk7XG4gICAgICAgICAgICB2YWx1ZSA9PT0gZXhwb3J0cy5ERUxFVEUgPyBkZWxldGUgbGVhZkhvc3RbZmllbGRdIDogbGVhZkhvc3RbZmllbGRdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkVGFyZ2V0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYm91bmRUYXJnZXQgPSB0aGlzLmZpbmRCb3VuZFRhcmdldCgpO1xuICAgICAgICByZXR1cm4gYm91bmRUYXJnZXRcbiAgICAgICAgICAgID8gZG9Nb2RpZnkoYm91bmRUYXJnZXQpXG4gICAgICAgICAgICA6IGRvTW9kaWZ5O1xuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLndpdGhEZWZhdWx0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1VwZGF0ZXIoeyB0eXBlOiAnd2l0aERlZmF1bHQnLCBwYXJlbnQ6IHRoaXMsIGRlZmF1bHRWYWx1ZTogdmFsdWUgfSk7XG4gICAgfTtcbiAgICBfVXBkYXRlci5wcm90b3R5cGUuYWJvcnRJZlVuZGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IF9VcGRhdGVyKHsgdHlwZTogJ2Fib3J0SWZVbmRlZicsIHBhcmVudDogdGhpcyB9KTtcbiAgICB9O1xuICAgIF9VcGRhdGVyLnByb3RvdHlwZS5maW5kQm91bmRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmRhdGEudHlwZSA9PT0gJ3Jvb3QnKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50LmRhdGEuYm91bmRUYXJnZXQ7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5kYXRhLnBhcmVudDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLnBhcmVudFVwZGF0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXBkYXRlcnMgPSBbdGhpc107XG4gICAgICAgIHZhciBwYXJlbnRVcGRhdGVyID0gdGhpcy5kYXRhLnBhcmVudDtcbiAgICAgICAgLy8gSWdub3JlIHRoZSByb290IHVwZGF0ZXJcbiAgICAgICAgd2hpbGUgKHBhcmVudFVwZGF0ZXIgJiYgcGFyZW50VXBkYXRlci5kYXRhLnBhcmVudCkge1xuICAgICAgICAgICAgdXBkYXRlcnMudW5zaGlmdChwYXJlbnRVcGRhdGVyKTtcbiAgICAgICAgICAgIHBhcmVudFVwZGF0ZXIgPSBwYXJlbnRVcGRhdGVyLmRhdGEucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cGRhdGVycztcbiAgICB9O1xuICAgIF9VcGRhdGVyLnByb3RvdHlwZS5nZXROZXh0VmFsdWUgPSBmdW5jdGlvbiAocHJldmlvdXNIb3N0LCBob3N0LCBmaWVsZCwgaXNMYXN0KSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEudHlwZSA9PT0gJ2F0Jykge1xuICAgICAgICAgICAgdmFyIG5ld0ZpZWxkID0gdGhpcy5kYXRhLmZpZWxkO1xuICAgICAgICAgICAgdmFyIHZhbHVlXzEgPSBob3N0W25ld0ZpZWxkXTtcbiAgICAgICAgICAgIHZhciBuZXh0VmFsdWUgPSBpc09iamVjdE9yQXJyYXkodmFsdWVfMSkgPyBjbG9uZSh2YWx1ZV8xKSA6IHZhbHVlXzE7XG4gICAgICAgICAgICB2YXIgbmV3SG9zdF8xID0gaXNMYXN0ID8gaG9zdCA6IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIGhvc3RbdGhpcy5kYXRhLmZpZWxkXSA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB7IGhvc3Q6IG5ld0hvc3RfMSwgZmllbGQ6IG5ld0ZpZWxkIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gcHJldmlvdXNIb3N0W2ZpZWxkXTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS50eXBlID09PSAnYWJvcnRJZlVuZGVmJyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBob3N0OiBob3N0LCBmaWVsZDogZmllbGQsIGFib3J0ZWQ6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhLnR5cGUgPT09ICd3aXRoRGVmYXVsdCcgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IHRoaXMuZGF0YS5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB2YXIgbmV3SG9zdF8yID0gaXNMYXN0ID8gcHJldmlvdXNIb3N0IDogbmV4dFZhbHVlO1xuICAgICAgICAgICAgcHJldmlvdXNIb3N0W2ZpZWxkXSA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB7IGhvc3Q6IG5ld0hvc3RfMiwgZmllbGQ6IGZpZWxkIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0hvc3QgPSBpc0xhc3QgPyBwcmV2aW91c0hvc3QgOiBob3N0O1xuICAgICAgICByZXR1cm4geyBob3N0OiBuZXdIb3N0LCBmaWVsZDogZmllbGQgfTtcbiAgICB9O1xuICAgIF9VcGRhdGVyLnByb3RvdHlwZS5jbG9uZUZvclVwZGF0ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIHVwZGF0ZXJzID0gdGhpcy5wYXJlbnRVcGRhdGVycygpO1xuICAgICAgICB2YXIgb2JqID0gY2xvbmUodGFyZ2V0KTtcbiAgICAgICAgdmFyIHByZXZpb3VzSG9zdCA9IG9iajtcbiAgICAgICAgdmFyIGhvc3QgPSBvYmo7XG4gICAgICAgIHZhciBmaWVsZCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdXBkYXRlcnNbaV0uZ2V0TmV4dFZhbHVlKHByZXZpb3VzSG9zdCwgaG9zdCwgZmllbGQsIGkgPT09IHVwZGF0ZXJzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdhYm9ydGVkJyB9O1xuICAgICAgICAgICAgcHJldmlvdXNIb3N0ID0gaG9zdDtcbiAgICAgICAgICAgIGhvc3QgPSByZXN1bHQuaG9zdDtcbiAgICAgICAgICAgIGZpZWxkID0gcmVzdWx0LmZpZWxkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiAncmVzdWx0JyxcbiAgICAgICAgICAgIGNsb25lZFRhcmdldDogb2JqLFxuICAgICAgICAgICAgbGVhZkhvc3Q6IGhvc3QsXG4gICAgICAgICAgICBmaWVsZDogZmllbGRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBfVXBkYXRlcjtcbn0oKSk7XG5mdW5jdGlvbiBpc09iamVjdE9yQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcbn1cbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpXG4gICAgICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgICB2YXIgY2xvbmVkID0ge307XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgY2xvbmVkW2tleV0gPSBvYmpba2V5XTsgfSk7XG4gICAgcmV0dXJuIGNsb25lZDtcbn1cbmZ1bmN0aW9uIGRlZXBVcGRhdGUodGFyZ2V0KSB7XG4gICAgcmV0dXJuIG5ldyBfVXBkYXRlcih7IHR5cGU6ICdyb290JywgYm91bmRUYXJnZXQ6IHRhcmdldCB9KTtcbn1cbmV4cG9ydHMuZGVlcFVwZGF0ZSA9IGRlZXBVcGRhdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDaGFyVXRpbDtcbihmdW5jdGlvbiAoQ2hhclV0aWwpIHtcbiAgICBjbGFzcyBDaGFyU3RyZWFtIHtcbiAgICAgICAgY29uc3RydWN0b3Iocywgc3RhcnRwb3MsIGVuZHBvcywgaGFzRU9GKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0VPRiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gcztcbiAgICAgICAgICAgIGlmIChoYXNFT0YgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNFT0YgPSBoYXNFT0Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnRwb3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydHBvcyA9IDA7IC8vIG5vdCBzcGVjaWZpZWQ7IHNldCBkZWZhdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydHBvcyA+IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydHBvcyA9IHMubGVuZ3RoOyAvLyBzZWVrIHRvbyBmYXI7IHNldCBFT0ZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRwb3MgPSBzdGFydHBvczsgLy8gc3BlY2lmaWVkIGFuZCBpbiBib3VuZHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmRwb3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRwb3MgPSBzLmxlbmd0aDsgLy8gbm90IHNwZWNpZmllZDsgc2V0IGRlZmF1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZHBvcyA+IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRwb3MgPSBzLmxlbmd0aDsgLy8gc2VlayB0b28gZmFyOyBzZXQgRU9GXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvcyA9IGVuZHBvczsgLy8gc3BlY2lmaWVkIGFuZCBpbiBib3VuZHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0cG9zID4gdGhpcy5lbmRwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0cG9zID0gdGhpcy5lbmRwb3M7IC8vIGlmIHRoZSB1c2VyIGZsaXBwZWQgcG9zaXRpb25zXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBvZiB0aGUgZW5kIG9mIHRoZSBpbnB1dCBoYXMgYmVlbiByZWFjaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNFT0YoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNFT0YgJiYgdGhpcy5zdGFydHBvcyA9PSB0aGlzLmlucHV0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIEphdnNjcmlwdCBwcmltaXRpdmUgc3RyaW5nIG9mIHRoZSBzbGljZSBvZiBpbnB1dFxuICAgICAgICAgKiByZXByZXNlbnRlZCBieSB0aGlzIENoYXJTdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0LnN1YnN0cmluZyh0aGlzLnN0YXJ0cG9zLCB0aGlzLmVuZHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgQ2hhclN0cmVhbSByZXByZXNlbnRpbmcgdGhlIGlucHV0IGZyb20gdGhlXG4gICAgICAgICAqIGN1cnJlbnQgc3RhcnQgcG9zaXRpb24gdG8gYW4gZW5kIHBvc2l0aW9uIG51bSBjaGFycyBmcm9tXG4gICAgICAgICAqIHRoZSBjdXJyZW50IHN0YXJ0IHBvc2l0aW9uLiAgSWYgc3RhcnRwb3MgKyBudW0gPiBlbmRwb3MsXG4gICAgICAgICAqIHRoZSBjdXJyZW50IENoYXJTdHJlYW0gaXMgcmV0dXJuZWQuXG4gICAgICAgICAqIEBwYXJhbSBudW1cbiAgICAgICAgICovXG4gICAgICAgIHBlZWsobnVtKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydHBvcyArIG51bSA+IHRoaXMuZW5kcG9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3SGFzRU9GID0gdGhpcy5zdGFydHBvcyArIG51bSA9PSB0aGlzLmVuZHBvcyAmJiB0aGlzLmhhc0VPRjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENoYXJTdHJlYW0odGhpcy5pbnB1dCwgdGhpcy5zdGFydHBvcywgdGhpcy5zdGFydHBvcyArIG51bSwgbmV3SGFzRU9GKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBDaGFyU3RyZWFtIHJlcHJlc2VudGluZyB0aGUgc3RyaW5nIGFmdGVyXG4gICAgICAgICAqIHNlZWtpbmcgbnVtIGNoYXJhY3RlcnMgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICogQHBhcmFtIG51bVxuICAgICAgICAgKi9cbiAgICAgICAgc2VlayhudW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0cG9zICsgbnVtID4gdGhpcy5lbmRwb3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENoYXJTdHJlYW0odGhpcy5pbnB1dCwgdGhpcy5lbmRwb3MsIHRoaXMuZW5kcG9zLCB0aGlzLmhhc0VPRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENoYXJTdHJlYW0odGhpcy5pbnB1dCwgdGhpcy5zdGFydHBvcyArIG51bSwgdGhpcy5lbmRwb3MsIHRoaXMuaGFzRU9GKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBDaGFyU3RyZWFtIHJlcHJlc2VudGluZyB0aGUgaGVhZCBvZiB0aGUgaW5wdXQgYXRcbiAgICAgICAgICogdGhlIGN1cnJlbnQgcG9zaXRpb24uICBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBDaGFyU3RyZWFtIGlzXG4gICAgICAgICAqIGVtcHR5LlxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdIYXNFT0YgPSB0aGlzLnN0YXJ0cG9zICsgMSA9PSB0aGlzLmVuZHBvcyAmJiB0aGlzLmhhc0VPRjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENoYXJTdHJlYW0odGhpcy5pbnB1dCwgdGhpcy5zdGFydHBvcywgdGhpcy5zdGFydHBvcyArIDEsIG5ld0hhc0VPRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBoZWFkIG9mIGFuIGVtcHR5IHN0cmluZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgQ2hhclN0cmVhbSByZXByZXNlbnRpbmcgdGhlIHRhaWwgb2YgdGhlIGlucHV0IGF0XG4gICAgICAgICAqIHRoZSBjdXJyZW50IHBvc2l0aW9uLiAgVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgQ2hhclN0cmVhbSBpc1xuICAgICAgICAgKiBlbXB0eS5cbiAgICAgICAgICovXG4gICAgICAgIHRhaWwoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFyU3RyZWFtKHRoaXMuaW5wdXQsIHRoaXMuc3RhcnRwb3MgKyAxLCB0aGlzLmVuZHBvcywgdGhpcy5oYXNFT0YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgdGFpbCBvZiBhbiBlbXB0eSBzdHJpbmcuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIGlzIGVtcHR5LiBOb3RlXG4gICAgICAgICAqIHRoYXQgYSBDaGFyU3RyZWFtIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGNvbnRhaW5zIGFuIGVtcHR5XG4gICAgICAgICAqIHN0cmluZyBidXQgdGhhdCBhbiBlbXB0eSBzdHJpbmcgbWF5IG5vdCBiZSB0aGUgZW5kLW9mLWZpbGUgKGkuZS4sXG4gICAgICAgICAqIGlzRU9GIGlzIGZhbHNlKS5cbiAgICAgICAgICovXG4gICAgICAgIGlzRW1wdHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydHBvcyA9PSB0aGlzLmVuZHBvcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgcmVtYWluaW5nIGF0XG4gICAgICAgICAqIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgbGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5kcG9zIC0gdGhpcy5zdGFydHBvcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgc3Vic3RyaW5nIGJldHdlZW4gc3RhcnQgYW5kIGVuZCBhdCB0aGVcbiAgICAgICAgICogY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHN0YXJ0IHRoZSBzdGFydCBpbmRleCBvZiB0aGUgc3Vic3RyaW5nLCBpbmNsdXNpdmVcbiAgICAgICAgICogQHBhcmFtIGVuZCB0aGUgZW5kIGluZGV4IG9mIHRoZSBzdWJzdHJpbmcsIGV4Y2x1c2l2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc3Vic3RyaW5nKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0MiA9IHRoaXMuc3RhcnRwb3MgKyBzdGFydDtcbiAgICAgICAgICAgIGNvbnN0IGVuZDIgPSB0aGlzLnN0YXJ0cG9zICsgZW5kO1xuICAgICAgICAgICAgY29uc3QgbmV3SGFzRU9GID0gdGhpcy5lbmRwb3MgPT0gZW5kMiAmJiB0aGlzLmhhc0VPRjtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbSh0aGlzLmlucHV0LCBzdGFydDIsIGVuZDIsIG5ld0hhc0VPRik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIGN1cnJlbnQgQ2hhclN0cmVhbSB3aXRoXG4gICAgICAgICAqIHRoZSBnaXZlbiBDaGFyU3RyZWFtLiBOb3RlOiByZXR1cm5lZCBvYmplY3QgZG9lcyBub3RcbiAgICAgICAgICogcmV1c2Ugb3JpZ2luYWwgaW5wdXQgc3RyaW5nLCBhbmQgc3RhcnRwb3MgYW5kIGVuZHBvc1xuICAgICAgICAgKiBhcmUgcmVzZXQuIElmIHRoZSBnaXZlbiBDaGFyU3RyZWFtIGNvbnRhaW5zIEVPRiwgdGhlXG4gICAgICAgICAqIGNvbmNhdGVuYXRlZCBDaGFyU3RyZWFtIHdpbGwgYWxzbyBjb250YWluIEVPRi5cbiAgICAgICAgICogQHBhcmFtIGNzIHRoZSBDaGFyU3RyZWFtIHRvIGNvbmNhdCB0byB0aGlzIENoYXJTdHJlYW1cbiAgICAgICAgICovXG4gICAgICAgIGNvbmNhdChjcykge1xuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMudG9TdHJpbmcoKSArIGNzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYXJTdHJlYW0ocywgMCwgcy5sZW5ndGgsIGNzLmhhc0VPRik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmNhdGVuYXRlIGFuIGFycmF5IG9mIENoYXJTdHJlYW0gb2JqZWN0cyBpbnRvIGEgc2luZ2xlXG4gICAgICAgICAqIENoYXJTdHJlYW0gb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0gY3NzIGEgQ2hhclN0cmVhbVtdXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY29uY2F0KGNzcykge1xuICAgICAgICAgICAgaWYgKGNzcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbShcIlwiLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY3MgPSBjc3NbMF07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY3MgPSBjcy5jb25jYXQoY3NzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIENoYXJVdGlsLkNoYXJTdHJlYW0gPSBDaGFyU3RyZWFtO1xufSkoQ2hhclV0aWwgPSBleHBvcnRzLkNoYXJVdGlsIHx8IChleHBvcnRzLkNoYXJVdGlsID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYXJzdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJpbWl0aXZlc18xID0gcmVxdWlyZShcIi4vcHJpbWl0aXZlc1wiKTtcbmV4cG9ydHMuUHJpbWl0aXZlcyA9IHByaW1pdGl2ZXNfMS5QcmltaXRpdmVzO1xudmFyIGNoYXJzdHJlYW1fMSA9IHJlcXVpcmUoXCIuL2NoYXJzdHJlYW1cIik7XG5leHBvcnRzLkNoYXJVdGlsID0gY2hhcnN0cmVhbV8xLkNoYXJVdGlsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjaGFyc3RyZWFtXzEgPSByZXF1aXJlKFwiLi9jaGFyc3RyZWFtXCIpO1xudmFyIFByaW1pdGl2ZXM7XG4oZnVuY3Rpb24gKFByaW1pdGl2ZXMpIHtcbiAgICBjbGFzcyBFT0ZNYXJrIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAgICAgc3RhdGljIGdldCBJbnN0YW5jZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZSB8fCAodGhpcy5faW5zdGFuY2UgPSBuZXcgdGhpcygpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQcmltaXRpdmVzLkVPRk1hcmsgPSBFT0ZNYXJrO1xuICAgIFByaW1pdGl2ZXMuRU9GID0gRU9GTWFyay5JbnN0YW5jZTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3VjY2Vzc2Z1bCBwYXJzZS5cbiAgICAgKi9cbiAgICBjbGFzcyBTdWNjZXNzIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIHN1Y2Nlc3NmdWwgcGFyc2UuXG4gICAgICAgICAqIEBwYXJhbSBpc3RyZWFtIFRoZSByZW1haW5pbmcgc3RyaW5nLlxuICAgICAgICAgKiBAcGFyYW0gcmVzIFRoZSByZXN1bHQgb2YgdGhlIHBhcnNlXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcihpc3RyZWFtLCByZXMpIHtcbiAgICAgICAgICAgIHRoaXMudGFnID0gXCJzdWNjZXNzXCI7XG4gICAgICAgICAgICB0aGlzLmlucHV0c3RyZWFtID0gaXN0cmVhbTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gcmVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuU3VjY2VzcyA9IFN1Y2Nlc3M7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGZhaWxlZCBwYXJzZS5cbiAgICAgKi9cbiAgICBjbGFzcyBGYWlsdXJlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIGZhaWxlZCBwYXJzZS5cbiAgICAgICAgICogQHBhcmFtIGlzdHJlYW0gVGhlIHN0cmluZywgdW5tb2RpZmllZCwgdGhhdCB3YXMgZ2l2ZW4gdG8gdGhlIHBhcnNlci5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKGlzdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMudGFnID0gXCJmYWlsdXJlXCI7XG4gICAgICAgICAgICB0aGlzLmlucHV0c3RyZWFtID0gaXN0cmVhbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQcmltaXRpdmVzLkZhaWx1cmUgPSBGYWlsdXJlO1xuICAgIC8qKlxuICAgICAqIHJlc3VsdCBzdWNjZWVkcyB3aXRob3V0IGNvbnN1bWluZyBhbnkgaW5wdXQsIGFuZCByZXR1cm5zIHYuXG4gICAgICogQHBhcmFtIHYgVGhlIHJlc3VsdCBvZiB0aGUgcGFyc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KHYpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiBuZXcgU3VjY2Vzcyhpc3RyZWFtLCB2KTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgLyoqXG4gICAgICogemVybyBmYWlscyB3aXRob3V0IGNvbnN1bWluZyBhbnkgaW5wdXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gemVybygpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiBuZXcgRmFpbHVyZShpc3RyZWFtKTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy56ZXJvID0gemVybztcbiAgICAvKipcbiAgICAgKiBpdGVtIHN1Y2Nlc3NmdWxseSBjb25zdW1lcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGlmIHRoZSBpbnB1dFxuICAgICAqIHN0cmluZyBpcyBub24tZW1wdHksIG90aGVyd2lzZSBpdCBmYWlscy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpdGVtKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpc3RyZWFtLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFpbHVyZShpc3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2Vzcyhpc3RyZWFtLnRhaWwoKSwgaXN0cmVhbS5oZWFkKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLml0ZW0gPSBpdGVtO1xuICAgIC8qKlxuICAgICAqIGJpbmQgaXMgYSBjdXJyaWVkIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBwYXJzZXIgcCBhbmQgcmV0dXJuc1xuICAgICAqIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHBhcnNlciBmIHdoaWNoIHJldHVybnMgdGhlIGNvbXBvc2l0aW9uXG4gICAgICogb2YgcCBhbmQgZi4gIElmIF9hbnlfIG9mIHRoZSBwYXJzZXJzIGZhaWwsIHRoZSBvcmlnaW5hbCBpbnB1dHN0cmVhbVxuICAgICAqIGlzIHJldHVybmVkIGluIHRoZSBGYWlsdXJlIG9iamVjdCAoaS5lLiwgYmluZCBiYWNrdHJhY2tzKS5cbiAgICAgKiBAcGFyYW0gcCBBIHBhcnNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmQocCkge1xuICAgICAgICByZXR1cm4gKGYpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByID0gcChpc3RyZWFtKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHIudGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbyA9IGYoci5yZXN1bHQpKHIuaW5wdXRzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6IHJldHVybiBvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGU6IGJhY2t0cmFja3MsIHJldHVybmluZyBvcmlnaW5hbCBpc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFpbHVyZShpc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjogcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuYmluZCA9IGJpbmQ7XG4gICAgZnVuY3Rpb24gZGVsYXkocCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gcDtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5kZWxheSA9IGRlbGF5O1xuICAgIC8qKlxuICAgICAqIHNlcSBpcyBhIGN1cnJpZWQgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHBhcnNlciBwLCBhIHBhcnNlciBxLFxuICAgICAqIGFuZCBhIGZ1bmN0aW9uIGYuIEl0IGFwcGxpZXMgcCB0byB0aGUgaW5wdXQsIHBhc3NpbmcgdGhlXG4gICAgICogcmVtYWluaW5nIGlucHV0IHN0cmVhbSB0byBxOyBxIGlzIHRoZW4gYXBwbGllZC4gIFRoZSBmdW5jdGlvblxuICAgICAqIGYgdGFrZXMgdGhlIHJlc3VsdCBvZiBwIGFuZCBxLCBhcyBhIHR1cGxlLCBhbmQgcmV0dXJuc1xuICAgICAqIGEgc2luZ2xlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gcCBBIHBhcnNlclxuICAgICAqL1xuICAgIC8vIGV4cG9ydCBsZXQgc2VxID0gZnVuY3Rpb248VCxVLFY+KHA6IElQYXJzZXI8VD4pIHtcbiAgICAvLyAgICAgcmV0dXJuIChxOiBJUGFyc2VyPFU+KSA9PiB7XG4gICAgLy8gICAgICAgICByZXR1cm4gKGY6IChlOiBbVCxVXSkgPT4gVikgPT4ge1xuICAgIC8vICAgICAgICAgICAgIHJldHVybiBiaW5kPFQsVj4ocCkoKHgpID0+IHtcbiAgICAvLyAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQ8VSxWPihxKSgoeSkgPT4ge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgbGV0IHR1cCA6IFtULFVdID0gW3gseV07XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0PFY+KGYodHVwKSk7XG4gICAgLy8gICAgICAgICAgICAgICAgIH0pO1xuICAgIC8vICAgICAgICAgICAgIH0pO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9O1xuICAgIC8vIH1cbiAgICBmdW5jdGlvbiBzZXEocCkge1xuICAgICAgICByZXR1cm4gKHEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoZikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiaW5kKHApKCh4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kKHEpKCh5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHVwID0gW3gsIHldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdChmKHR1cCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuc2VxID0gc2VxO1xuICAgIC8qKlxuICAgICAqIHNhdCB0YWtlcyBhIHByZWRpY2F0ZSBhbmQgeWllbGRzIGEgcGFyc2VyIHRoYXQgY29uc3VtZXMgYVxuICAgICAqIHNpbmdsZSBjaGFyYWN0ZXIgaWYgdGhlIGNoYXJhY3RlciBzYXRpc2ZpZXMgdGhlIHByZWRpY2F0ZSxcbiAgICAgKiBvdGhlcndpc2UgaXQgZmFpbHMuXG4gICAgICogQHBhcmFtIHByZWQgYSBjaGFyYWN0ZXIgcHJlZGljYXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2F0KHByZWQpIHtcbiAgICAgICAgbGV0IHByZWQyID0gKGNzKSA9PiBwcmVkKGNzLnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgYSA9IGl0ZW0oKTtcbiAgICAgICAgbGV0IGIgPSAoeCkgPT4ge1xuICAgICAgICAgICAgaWYgKHByZWQyKHgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCh4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBiaW5kKGEpKGIpO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnNhdCA9IHNhdDtcbiAgICAvKipcbiAgICAgKiBjaGFyIHRha2VzIGEgY2hhcmFjdGVyIGFuZCB5aWVsZHMgYSBwYXJzZXIgdGhhdCBjb25zdW1lXG4gICAgICogdGhhdCBjaGFyYWN0ZXIuIFRoZSByZXR1cm5lZCBwYXJzZXIgc3VjY2VlZHMgaWYgdGhlIG5leHRcbiAgICAgKiBjaGFyYWN0ZXIgaW4gdGhlIGlucHV0IHN0cmVhbSBpcyBjLCBvdGhlcndpc2UgaXQgZmFpbHMuXG4gICAgICogQHBhcmFtIGNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFyKGMpIHtcbiAgICAgICAgaWYgKGMubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoYXIgcGFyc2VyIHRha2VzIGEgc3RyaW5nIG9mIGxlbmd0aCAxIChpLmUuLCBhIGNoYXIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYXQoeCA9PiB4ID09IGMpO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmNoYXIgPSBjaGFyO1xuICAgIC8qKlxuICAgICAqIGxldHRlciByZXR1cm5zIGEgcGFyc2VyIHRoYXQgY29uc3VtZXMgYSBzaW5nbGUgYWxwaGFiZXRpY1xuICAgICAqIGNoYXJhY3RlciwgZnJvbSBhLXosIHJlZ2FyZGxlc3Mgb2YgY2FzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZXR0ZXIoKSB7XG4gICAgICAgIGxldCBjb250YWluc19sZXR0ZXIgPSAoeCkgPT4ge1xuICAgICAgICAgICAgbGV0IGFfbGV0dGVyID0gL1tBLVphLXpdLztcbiAgICAgICAgICAgIHJldHVybiB4Lm1hdGNoKGFfbGV0dGVyKSAhPSB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzYXQoY29udGFpbnNfbGV0dGVyKTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5sZXR0ZXIgPSBsZXR0ZXI7XG4gICAgLyoqXG4gICAgICogZGlnaXQgcmV0dXJucyBhIHBhcnNlciB0aGF0IGNvbnN1bWVzIGEgc2luZ2xlIG51bWVyaWNcbiAgICAgKiBjaGFyYWN0ZXIsIGZyb20gMC05LiAgTm90ZSB0aGF0IHRoZSB0eXBlIG9mIHRoZSByZXN1bHRcbiAgICAgKiBpcyBhIHN0cmluZywgbm90IGEgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpZ2l0KCkge1xuICAgICAgICByZXR1cm4gc2F0KHggPT4geCA9PSBcIjBcIlxuICAgICAgICAgICAgfHwgeCA9PSBcIjFcIlxuICAgICAgICAgICAgfHwgeCA9PSBcIjJcIlxuICAgICAgICAgICAgfHwgeCA9PSBcIjNcIlxuICAgICAgICAgICAgfHwgeCA9PSBcIjRcIlxuICAgICAgICAgICAgfHwgeCA9PSBcIjVcIlxuICAgICAgICAgICAgfHwgeCA9PSBcIjZcIlxuICAgICAgICAgICAgfHwgeCA9PSBcIjdcIlxuICAgICAgICAgICAgfHwgeCA9PSBcIjhcIlxuICAgICAgICAgICAgfHwgeCA9PSBcIjlcIik7XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuZGlnaXQgPSBkaWdpdDtcbiAgICAvKipcbiAgICAgKiB1cHBlciByZXR1cm5zIGEgcGFyc2VyIHRoYXQgY29uc3VtZXMgYSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgICogaWYgdGhhdCBjaGFyYWN0ZXIgaXMgdXBwZXJjYXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwcGVyKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGxldCBvMSA9IGxldHRlcigpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvMS50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICBsZXQgbzIgPSBzYXQoeCA9PiB4ID09IHgudG9VcHBlckNhc2UoKSkobzEucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvMi50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhaWx1cmUoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmV2ZXIgaGFwcGVuc1wiKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy51cHBlciA9IHVwcGVyO1xuICAgIC8qKlxuICAgICAqIGxvd2VyIHJldHVybnMgYSBwYXJzZXIgdGhhdCBjb25zdW1lcyBhIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICAgKiBpZiB0aGF0IGNoYXJhY3RlciBpcyBsb3dlcmNhc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG93ZXIoKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgbGV0IG8xID0gbGV0dGVyKCkoaXN0cmVhbSk7XG4gICAgICAgICAgICBzd2l0Y2ggKG8xLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIGxldCBvMiA9IHNhdCh4ID0+IHggPT0geC50b0xvd2VyQ2FzZSgpKShvMS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG8yLnRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFpbHVyZShpc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZXZlciBoYXBwZW5zXCIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmxvd2VyID0gbG93ZXI7XG4gICAgLyoqXG4gICAgICogY2hvaWNlIHNwZWNpZmllcyBhbiBvcmRlcmVkIGNob2ljZSBiZXR3ZWVuIHR3byBwYXJzZXJzLFxuICAgICAqIHAxIGFuZCBwMi4gVGhlIHJldHVybmVkIHBhcnNlciB3aWxsIGZpcnN0IGFwcGx5XG4gICAgICogcGFyc2VyIHAxLiAgSWYgcDEgc3VjY2VlZHMsIHAxJ3MgT3V0Y29tZSBpcyByZXR1cm5lZC5cbiAgICAgKiBJZiBwMSBmYWlscywgcDIgaXMgYXBwbGllZCBhbmQgdGhlIE91dGNvbWUgb2YgcDIgaXMgcmV0dXJuZWQuXG4gICAgICogTm90ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gZ2l2ZW4gdG8gcDEgYW5kIHAyIGlzIGV4YWN0bHlcbiAgICAgKiB0aGUgc2FtZSBpbnB1dCBzdHJlYW0uXG4gICAgICogQHBhcmFtIHAxIEEgcGFyc2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNob2ljZShwMSkge1xuICAgICAgICByZXR1cm4gKHAyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbyA9IHAxKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAyKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuY2hvaWNlID0gY2hvaWNlO1xuICAgIC8qKlxuICAgICAqIGFwcGZ1biBhbGxvd3MgdGhlIHVzZXIgdG8gYXBwbHkgYSBmdW5jdGlvbiBmIHRvXG4gICAgICogdGhlIHJlc3VsdCBvZiBhIHBhcnNlciBwLCBhc3N1bWluZyB0aGF0IHAgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKiBAcGFyYW0gcCBBIHBhcnNlci4gIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIHw+PlxuICAgICAqIGZ1bmN0aW9uIGZyb20gRlBhcnNlYy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcHBmdW4ocCkge1xuICAgICAgICByZXR1cm4gKGYpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBvID0gcChpc3RyZWFtKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG8udGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN1Y2Nlc3Moby5pbnB1dHN0cmVhbSwgZihvLnJlc3VsdCkpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5hcHBmdW4gPSBhcHBmdW47XG4gICAgLyoqXG4gICAgICogbWFueSByZXBlYXRlZGx5IGFwcGxpZXMgdGhlIHBhcnNlciBwIHVudGlsIHAgZmFpbHMuIG1hbnkgYWx3YXlzXG4gICAgICogc3VjY2VlZHMsIGV2ZW4gaWYgaXQgbWF0Y2hlcyBub3RoaW5nLiAgbWFueSB0cmllcyB0byBndWFyZFxuICAgICAqIGFnYWluc3QgYW4gaW5maW5pdGUgbG9vcCBieSByYWlzaW5nIGFuIGV4Y2VwdGlvbiBpZiBwIHN1Y2NlZWRzXG4gICAgICogd2l0aG91dCBjaGFuZ2luZyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAqIEBwYXJhbSBwXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFueShwKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgbGV0IGlzdHJlYW0yID0gaXN0cmVhbTtcbiAgICAgICAgICAgIGxldCBvdXRwdXRzID0gW107XG4gICAgICAgICAgICBsZXQgc3VjY2VlZHMgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKCFpc3RyZWFtMi5pc0VtcHR5KCkgJiYgc3VjY2VlZHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgbyA9IHAoaXN0cmVhbTIpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3RyZWFtMiA9PSBvLmlucHV0c3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyc2VyIGxvb3BzIGluZmluaXRlbHkuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaXN0cmVhbTIgPSBvLmlucHV0c3RyZWFtO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKG8ucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VlZHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2Vzcyhpc3RyZWFtMiwgb3V0cHV0cyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMubWFueSA9IG1hbnk7XG4gICAgLyoqXG4gICAgICogbWFueTEgcmVwZWF0ZWRseSBhcHBsaWVzIHRoZSBwYXJzZXIgcCB1bnRpbCBwIGZhaWxzLiBtYW55MSBtdXN0XG4gICAgICogc3VjY2VlZCBhdCBsZWFzdCBvbmNlLiAgbWFueTEgdHJpZXMgdG8gZ3VhcmQgYWdhaW5zdCBhbiBpbmZpbml0ZVxuICAgICAqIGxvb3AgYnkgcmFpc2luZyBhbiBleGNlcHRpb24gaWYgcCBzdWNjZWVkcyB3aXRob3V0IGNoYW5naW5nIHRoZVxuICAgICAqIHBhcnNlciBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gcFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hbnkxKHApIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc2VxKHApKG1hbnkocCkpKHR1cCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGhkID0gdHVwW1wiMFwiXTtcbiAgICAgICAgICAgICAgICBsZXQgdGwgPSB0dXBbXCIxXCJdO1xuICAgICAgICAgICAgICAgIHRsLnVuc2hpZnQoaGQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0bDtcbiAgICAgICAgICAgIH0pKGlzdHJlYW0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLm1hbnkxID0gbWFueTE7XG4gICAgLyoqXG4gICAgICogc3RyIHlpZWxkcyBhIHBhcnNlciBmb3IgdGhlIGdpdmVuIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gcyBBIHN0cmluZ1xuICAgICAqL1xuICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGFjdHVhbGx5IGJlIGEgc2VxdWVuY2Ugb2YgcGFyc2VycyBjb25zdHJ1Y3RlZFxuICAgIC8vIGZyb20gdGhlIHN0cmluZyBzXG4gICAgZnVuY3Rpb24gc3RyKHMpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2NhcGUgcmVnZXggbWV0YWNoYXJhY3RlcnNcbiAgICAgICAgICAgIC8vICh0aGlzIGxpa2VseSBuZWVkcyB3b3JrKVxuICAgICAgICAgICAgbGV0IHMyID0gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuICAgICAgICAgICAgbGV0IHJlID0gbmV3IFJlZ0V4cChcIl5cIiArIHMyKTtcbiAgICAgICAgICAgIGlmIChpc3RyZWFtLnRvU3RyaW5nKCkubWF0Y2gocmUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtID0gaXN0cmVhbS5zdWJzdHJpbmcocy5sZW5ndGgsIGlzdHJlYW0ubGVuZ3RoKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGlzdHJlYW0uc3Vic3RyaW5nKDAsIHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN1Y2Nlc3MocmVtLCByZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnN0ciA9IHN0cjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGFyc2VyIHRoYXQgc3VjY2VlZHMgb25seSBpZiB0aGUgZW5kIG9mIHRoZVxuICAgICAqIGlucHV0IGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW9mKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpc3RyZWFtLmlzRU9GKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN1Y2Nlc3MoaXN0cmVhbSwgUHJpbWl0aXZlcy5FT0YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmVvZiA9IGVvZjtcbiAgICAvKipcbiAgICAgKiBmcmVzdWx0IHJldHVybnMgYSBwYXJzZXIgdGhhdCBhcHBsaWVzIHRoZSBwYXJzZXIgcCxcbiAgICAgKiBhbmQgaWYgcCBzdWNjZWVkcywgcmV0dXJucyB0aGUgdmFsdWUgeC5cbiAgICAgKiBAcGFyYW0gcCBhIHBhcnNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyZXN1bHQocCkge1xuICAgICAgICByZXR1cm4gKHgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiaW5kKHApKCh0KSA9PiByZXN1bHQoeCkpKGlzdHJlYW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5mcmVzdWx0ID0gZnJlc3VsdDtcbiAgICAvKipcbiAgICAgKiBsZWZ0IHJldHVybnMgYSBwYXJzZXIgdGhhdCBhcHBsaWVzIHRoZSBwYXJzZXIgcCxcbiAgICAgKiB0aGVuIHRoZSBwYXJzZXIgcSwgYW5kIGlmIGJvdGggYXJlIHN1Y2Nlc3NmdWwsXG4gICAgICogcmV0dXJucyB0aGUgcmVzdWx0IG9mIHAuXG4gICAgICogQHBhcmFtIHAgYSBwYXJzZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZWZ0KHApIHtcbiAgICAgICAgcmV0dXJuIChxKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluZChwKSgodCkgPT4gZnJlc3VsdChxKSh0KSkoaXN0cmVhbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmxlZnQgPSBsZWZ0O1xuICAgIC8qKlxuICAgICAqIHJpZ2h0IHJldHVybnMgYSBwYXJzZXIgdGhhdCBhcHBsaWVzIHRoZSBwYXJzZXIgcCxcbiAgICAgKiB0aGVuIHRoZSBwYXJzZXIgcSwgYW5kIGlmIGJvdGggYXJlIHN1Y2Nlc3NmdWwsXG4gICAgICogcmV0dXJucyB0aGUgcmVzdWx0IG9mIHEuXG4gICAgICogQHBhcmFtIHAgYSBwYXJzZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByaWdodChwKSB7XG4gICAgICAgIHJldHVybiAocSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQocCkoXyA9PiBxKShpc3RyZWFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMucmlnaHQgPSByaWdodDtcbiAgICAvKipcbiAgICAgKiBiZXR3ZWVuIHJldHVybnMgYSBwYXJzZXIgdGhhdCBhcHBsaWVzIHRoZSBwYXJzZXJcbiAgICAgKiBwb3BlbiwgcCwgYW5kIHBjbG9zZSBpbiBzZXF1ZW5jZSwgYW5kIGlmIGFsbCBhcmVcbiAgICAgKiBzdWNjZXNzZnVsLCByZXR1cm5zIHRoZSByZXN1bHQgb2YgcC5cbiAgICAgKiBAcGFyYW0gcG9wZW4gdGhlIGZpcnN0IHBhcnNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJldHdlZW4ocG9wZW4pIHtcbiAgICAgICAgcmV0dXJuIChwY2xvc2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBsID0gbGVmdChwKShwY2xvc2UpO1xuICAgICAgICAgICAgICAgIGxldCByID0gcmlnaHQocG9wZW4pKGwpO1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5iZXR3ZWVuID0gYmV0d2VlbjtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVidWcgcGFyc2VyIHRha2VzIGEgcGFyc2VyIHAgYW5kIGEgZGVidWcgc3RyaW5nLFxuICAgICAqIHByaW50aW5nIHRoZSBkZWJ1ZyBzdHJpbmcgYXMgYSBzaWRlLWVmZmVjdCBiZWZvcmVcbiAgICAgKiBhcHBseWluZyBwIHRvIHRoZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0gcCBhIHBhcnNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYnVnKHApIHtcbiAgICAgICAgcmV0dXJuIChsYWJlbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhcHBseTogXCIgKyBsYWJlbCk7XG4gICAgICAgICAgICAgICAgbGV0IG8gPSBwKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3VjY2VzczogXCIgKyBsYWJlbCArIFwiLCBzdGFydHBvczogXCIgKyBpc3RyZWFtLnN0YXJ0cG9zICsgXCIsIGVuZHBvczogXCIgKyBpc3RyZWFtLmVuZHBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZmFpbHVyZTogXCIgKyBsYWJlbCArIFwiLCBzdGFydHBvczogXCIgKyBpc3RyZWFtLnN0YXJ0cG9zICsgXCIsIGVuZHBvczogXCIgKyBpc3RyZWFtLmVuZHBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmRlYnVnID0gZGVidWc7XG4gICAgbGV0IHdzY2hhcnMgPSBjaG9pY2Uoc2F0KGMgPT4gYyA9PSAnICcgfHwgYyA9PSAnXFx0JykpKG5sKCkpO1xuICAgIC8qKlxuICAgICAqIHdzIG1hdGNoZXMgemVybyBvciBtb3JlIG9mIHRoZSBmb2xsb3dpbmcgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzOlxuICAgICAqICcgJywgJ1xcdCcsICdcXG4nLCBvciAnXFxyXFxuJ1xuICAgICAqIHdzIHJldHVybnMgbWF0Y2hlZCB3aGl0ZXNwYWNlIGluIGEgc2luZ2xlIENoYXJTdHJlYW0gcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdzKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGxldCBvID0gbWFueSh3c2NoYXJzKShpc3RyZWFtKTtcbiAgICAgICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN1Y2Nlc3Moby5pbnB1dHN0cmVhbSwgY2hhcnN0cmVhbV8xLkNoYXJVdGlsLkNoYXJTdHJlYW0uY29uY2F0KG8ucmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgLy8gd3MgbmV2ZXIgZmFpbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy53cyA9IHdzO1xuICAgIC8qKlxuICAgICAqIHdzMSBtYXRjaGVzIG9uZSBvciBtb3JlIG9mIHRoZSBmb2xsb3dpbmcgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzOlxuICAgICAqICcgJywgJ1xcdCcsICdcXG4nLCBvciAnXFxyXFxuJ1xuICAgICAqIHdzMSByZXR1cm5zIG1hdGNoZWQgd2hpdGVzcGFjZSBpbiBhIHNpbmdsZSBDaGFyU3RyZWFtIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3czEoKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgbGV0IG8gPSBtYW55MSh3c2NoYXJzKShpc3RyZWFtKTtcbiAgICAgICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN1Y2Nlc3Moby5pbnB1dHN0cmVhbSwgY2hhcnN0cmVhbV8xLkNoYXJVdGlsLkNoYXJTdHJlYW0uY29uY2F0KG8ucmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMud3MxID0gd3MxO1xuICAgIC8qKlxuICAgICAqIG5sIG1hdGNoZXMgYW5kIHJldHVybnMgYSBuZXdsaW5lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5sKCkge1xuICAgICAgICByZXR1cm4gUHJpbWl0aXZlcy5jaG9pY2UoUHJpbWl0aXZlcy5zdHIoXCJcXG5cIikpKFByaW1pdGl2ZXMuc3RyKFwiXFxyXFxuXCIpKTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5ubCA9IG5sO1xuICAgIGZ1bmN0aW9uIGdyb3VwQnkobGlzdCwga2V5R2V0dGVyKSB7XG4gICAgICAgIGxldCBtID0gbmV3IE1hcCgpO1xuICAgICAgICBsaXN0LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleUdldHRlcihpdGVtKTtcbiAgICAgICAgICAgIGlmICghbS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIG0uc2V0KGtleSwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvbGxlY3Rpb24gPSBtLmdldChrZXkpO1xuICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0clNhdChzdHJzKSB7XG4gICAgICAgIC8vIHNvcnQgc3RyaW5ncyBmaXJzdCBieSBsZW5ndGgsIGFuZCB0aGVuIGxleGljb2dyYXBpY2FsbHk7XG4gICAgICAgIC8vIHNsaWNlKCkgY2FsbGVkIGhlcmUgc28gYXMgbm90IHRvIG1vZGlmeSBvcmlnaW5hbCBhcnJheVxuICAgICAgICBsZXQgc21hcCA9IGdyb3VwQnkoc3RycywgcyA9PiBzLmxlbmd0aCk7XG4gICAgICAgIGxldCBzaXplcyA9IFtdO1xuICAgICAgICAvLyBmaW5kIHNpemUgY2xhc3NlcztcbiAgICAgICAgLy8gYWxzbyBzb3J0IGVhY2ggc2V0IG9mIGVxdWl2YWxlbnQtbGVuZ3RoIHZhbHVlc1xuICAgICAgICBzbWFwLmZvckVhY2goKHZhbHMsIGtleSwgbSkgPT4ge1xuICAgICAgICAgICAgc2l6ZXMucHVzaChrZXkpO1xuICAgICAgICAgICAgdmFscy5zb3J0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaXplcy5zb3J0KCk7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgLy8gc3RhcnQgd2l0aCB0aGUgc21hbGxlc3Qgc2l6ZSBjbGFzcyAgICAgICBcbiAgICAgICAgICAgIGZvciAobGV0IHBlZWtJbmRleCA9IDA7IHBlZWtJbmRleCA8IHNpemVzLmxlbmd0aDsgcGVla0luZGV4KyspIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCBzaXplIGNsYXNzLCB0cnkgbWF0Y2hpbmcgYWxsIG9mXG4gICAgICAgICAgICAgICAgLy8gdGhlIHN0cmluZ3M7IGlmIG9uZSBpcyBmb3VuZCwgcmV0dXJuIHRoZVxuICAgICAgICAgICAgICAgIC8vIGFwcHJvcHJpYXRlIENoYXJTdHJlYW07IGlmIG5vdCwgZmFpbC5cbiAgICAgICAgICAgICAgICBsZXQgcGVlayA9IGlzdHJlYW0ucGVlayhzaXplc1twZWVrSW5kZXhdKTtcbiAgICAgICAgICAgICAgICBsZXQgdGFpbCA9IGlzdHJlYW0uc2VlayhzaXplc1twZWVrSW5kZXhdKTtcbiAgICAgICAgICAgICAgICBsZXQgY2FuZGlkYXRlcyA9IHNtYXAuZ2V0KHNpemVzW3BlZWtJbmRleF0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNJbmRleCA9IDA7IGNJbmRleCA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBjSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlc1tjSW5kZXhdID09PSBwZWVrLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2Vzcyh0YWlsLCBwZWVrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFpbHVyZShpc3RyZWFtKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5zdHJTYXQgPSBzdHJTYXQ7XG59KShQcmltaXRpdmVzID0gZXhwb3J0cy5QcmltaXRpdmVzIHx8IChleHBvcnRzLlByaW1pdGl2ZXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJpbWl0aXZlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbGlmdF8xID0gcmVxdWlyZShcIi4uL2xpZnRcIik7XG4vKipcbiAqIENvbnZlcnRzIGFuIEFycmF5LWxpa2Ugb2JqZWN0IChzdWNoIGFzIGFuIGFyZ3VtZW50cyBvciBOb2RlTGlzdCBpbnN0YW5jZSkgdG8gYSByZWd1bGFyIEFycmF5XG4gKi9cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UoYXJyYXlMaWtlKSB7XG4gICAgcmV0dXJuIG5ldyBsaWZ0XzEuQXJyYXlPcHMoW10uc2xpY2UuY2FsbChhcnJheUxpa2UpKTtcbn1cbmV4cG9ydHMuZnJvbUFycmF5TGlrZSA9IGZyb21BcnJheUxpa2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbGlmdF8xID0gcmVxdWlyZShcIi4uL2xpZnRcIik7XG4vKlxuKiBSZXR1cm5zIGEgbnVtYmVyW10gd3JhcHBlciB3aXRoIGFsbCBudW1iZXJzIGZyb20gc3RhcnQgdG8gc3RvcCAoaW5jbHVzaXZlKSxcbiogaW5jcmVtZW50ZWQgb3IgZGVjcmVtZW50ZWQgYnkgc3RlcC5cbiovXG5mdW5jdGlvbiByYW5nZShzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0b3AgPSBhcmd1bWVudHNbMF0gLSAxO1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpbmNyZWFzaW5nID0gc3RlcCA+IDA7XG4gICAgdmFyIG5leHQgPSBzdGFydDtcbiAgICB3aGlsZSAoKGluY3JlYXNpbmcgJiYgbmV4dCA8PSBzdG9wKSB8fCAoIWluY3JlYXNpbmcgJiYgbmV4dCA+PSBzdG9wKSkge1xuICAgICAgICByZXN1bHQucHVzaChuZXh0KTtcbiAgICAgICAgbmV4dCA9IG5leHQgKyBzdGVwO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGxpZnRfMS5BcnJheU9wcyhyZXN1bHQpO1xufVxuZXhwb3J0cy5yYW5nZSA9IHJhbmdlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZnVuY3Rpb24gdHVwbGUoYXJyKSB7XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydHMudHVwbGUgPSB0dXBsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBpc18xID0gcmVxdWlyZShcIi4uL29iamVjdC9pc1wiKTtcbnZhciBjdXJyZW50TWVtb0lkID0gMDtcbi8qKlxuICogTWVtb2l6ZXMgYSBmdW5jdGlvbiBvZiBhcmJpdHJhcnkgYXJpdHkuXG4gKiBUaGlzIGhhcyB0d28gbWFpbiB1c2VzOlxuICogICAxKSBSZWR1Y2luZyB0aGUgQ1BVIHRpbWUgdGFrZW4gYnkgZXhwZW5zaXZlIGNhbGN1bGF0aW9ucyBhdCB0aGUgY29zdCBvZiBzb21lIG1lbW9yeSBvdmVyaGVhZFxuICogICAyKSBQcm9kdWNpbmcgc3RhYmxlIHJlZmVyZW5jZXMgZm9yIGEgZ2l2ZW4gc2V0IG9mIGFyZ3VtZW50cy4gVXNlZnVsIHdoZW4gcmVseWluZyBvbiByZWZlcmVuY2UgZXF1YWxpdHkuXG4gKlxuICogTWVtb2l6ZWQgZnVuY3Rpb25zIGtlZXAgaW50ZXJuYWwgc3RhdGUuIElmIHlvdSB3aXNoIHRvIGNsZWFyIHRoYXQgc3RhdGUgZW50aXJlbHksIHlvdSBjYW4gcmVjcmVhdGUgdGhlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1biwgb3B0aW9ucykge1xuICAgIC8vIFRoZSB1bmlxdWUgcHJvcGVydHkgbmFtZSB1c2VkIGJ5IHRoaXMgbWVtb2l6ZSBmdW5jdGlvbiBpbnN0YW5jZS5cbiAgICAvLyBUaGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIGlkL3JlZmVyZW5jZSBvZiBvYmplY3QgYXJndW1lbnRzLCBhcyBXZWFrIG1hcHMvc2V0cyBhcmUgdmVyeSBsaW1pdGVkLlxuICAgIHZhciBtZW1vS2V5ID0gXCJfX21lbW9fX1wiICsgY3VycmVudE1lbW9JZCsrO1xuICAgIHZhciBsYXN0QXJnS2V5cyA9IFtdO1xuICAgIHZhciBjYWNoZVNpemUgPSAob3B0aW9ucyAmJiBvcHRpb25zLmNhY2hlU2l6ZSkgfHwgMzA7XG4gICAgdmFyIGtleUZ1bmN0aW9uID0gb3B0aW9ucyAmJiBvcHRpb25zLmtleTtcbiAgICAvLyBUaGUgdW5pcXVlIGlkcy9yZWZlcmVuY2VzIG9mIG9iamVjdHMgaW5zaWRlIHRoZSBhcml0eU5DYWNoZSBjYWNoZVxuICAgIHZhciBvYmpJZCA9IDA7XG4gICAgdmFyIGFyaXR5MENhY2hlO1xuICAgIHZhciBhcml0eU5DYWNoZTtcbiAgICB2YXIga2V5Q2FjaGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAvLyAwIGFyZ3VtZW50cyBlZGdlLWNhc2VcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoIWFyaXR5MENhY2hlKVxuICAgICAgICAgICAgICAgIGFyaXR5MENhY2hlID0gZnVuKCk7XG4gICAgICAgICAgICByZXR1cm4gYXJpdHkwQ2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3VzdG9tIGtleSBmdW5jdGlvblxuICAgICAgICBlbHNlIGlmIChrZXlGdW5jdGlvbikge1xuICAgICAgICAgICAga2V5Q2FjaGUgPSBrZXlDYWNoZSB8fCB7fTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlGdW5jdGlvbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBrZXlDYWNoZVtrZXldO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBsYXN0QXJnS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgbGltaXRDYWNoZVNpemUoa2V5Q2FjaGUsIGxhc3RBcmdLZXlzLCBjYWNoZVNpemUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGtleUNhY2hlW2tleV0gPSBmdW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIE4gYXJndW1lbnRzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXJpdHlOQ2FjaGUgPSBhcml0eU5DYWNoZSB8fCB7fTtcbiAgICAgICAgICAgIHZhciBrZXkgPSAnJztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBhcmdLZXkgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGlzXzEub2JqZWN0KGFyZykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnS2V5ID0gYXJnW21lbW9LZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZ0tleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9uIGVudW1lcmFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcmcsIG1lbW9LZXksIHsgdmFsdWU6IFwib2JqXCIgKyBvYmpJZCsrIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnS2V5ID0gYXJnW21lbW9LZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcmdLZXkgPSBhcmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtleSArPSAoYXJnS2V5ICsgJ18nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBhcml0eU5DYWNoZVtrZXldO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBsYXN0QXJnS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgbGltaXRDYWNoZVNpemUoYXJpdHlOQ2FjaGUsIGxhc3RBcmdLZXlzLCBjYWNoZVNpemUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFyaXR5TkNhY2hlW2tleV0gPSBmdW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMubWVtb2l6ZSA9IG1lbW9pemU7XG5mdW5jdGlvbiBsaW1pdENhY2hlU2l6ZShjYWNoZSwgbGFzdEFyZ0tleXMsIHNpemUpIHtcbiAgICBpZiAobGFzdEFyZ0tleXMubGVuZ3RoID09PSBzaXplICsgMSkge1xuICAgICAgICB2YXIga2V5ID0gbGFzdEFyZ0tleXMuc2hpZnQoKTtcbiAgICAgICAgZGVsZXRlIGNhY2hlW2tleV07XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGxpZnRfMSA9IHJlcXVpcmUoXCIuL2xpZnRcIik7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGxpZnRfMVtcImRlZmF1bHRcIl07XG52YXIgbGlmdF8yID0gcmVxdWlyZShcIi4vbGlmdFwiKTtcbmV4cG9ydHMuQXJyYXlPcHMgPSBsaWZ0XzIuQXJyYXlPcHM7XG5leHBvcnRzLk9iamVjdE9wcyA9IGxpZnRfMi5PYmplY3RPcHM7XG5leHBvcnRzLk51bWJlck9wcyA9IGxpZnRfMi5OdW1iZXJPcHM7XG5leHBvcnRzLlN0cmluZ09wcyA9IGxpZnRfMi5TdHJpbmdPcHM7XG5leHBvcnRzLkRhdGVPcHMgPSBsaWZ0XzIuRGF0ZU9wcztcbmV4cG9ydHMuZ2V0VmFsdWUgPSBsaWZ0XzIuZ2V0VmFsdWU7XG52YXIgaW1tdXBkYXRlXzEgPSByZXF1aXJlKFwiaW1tdXBkYXRlXCIpO1xuZXhwb3J0cy51cGRhdGUgPSBpbW11cGRhdGVfMS51cGRhdGU7XG5leHBvcnRzLmRlZXBVcGRhdGUgPSBpbW11cGRhdGVfMS5kZWVwVXBkYXRlO1xuZXhwb3J0cy5ERUxFVEUgPSBpbW11cGRhdGVfMS5ERUxFVEU7XG52YXIgb3B0aW9uXzEgPSByZXF1aXJlKFwiLi9vcHRpb25cIik7XG5leHBvcnRzLk9wdGlvbiA9IG9wdGlvbl8xLk9wdGlvbjtcbmV4cG9ydHMuTm9uZSA9IG9wdGlvbl8xLk5vbmU7XG5leHBvcnRzLlNvbWUgPSBvcHRpb25fMS5Tb21lO1xudmFyIHJlc3VsdF8xID0gcmVxdWlyZShcIi4vcmVzdWx0XCIpO1xuZXhwb3J0cy5SZXN1bHQgPSByZXN1bHRfMS5SZXN1bHQ7XG5leHBvcnRzLk9rID0gcmVzdWx0XzEuT2s7XG5leHBvcnRzLkVyciA9IHJlc3VsdF8xLkVycjtcbnZhciByYW5nZV8xID0gcmVxdWlyZShcIi4vYXJyYXkvcmFuZ2VcIik7XG5leHBvcnRzLnJhbmdlID0gcmFuZ2VfMS5yYW5nZTtcbnZhciBmcm9tQXJyYXlMaWtlXzEgPSByZXF1aXJlKFwiLi9hcnJheS9mcm9tQXJyYXlMaWtlXCIpO1xuZXhwb3J0cy5mcm9tQXJyYXlMaWtlID0gZnJvbUFycmF5TGlrZV8xLmZyb21BcnJheUxpa2U7XG52YXIgdHVwbGVfMSA9IHJlcXVpcmUoXCIuL2FycmF5L3R1cGxlXCIpO1xuZXhwb3J0cy50dXBsZSA9IHR1cGxlXzEudHVwbGU7XG52YXIgc2V0XzEgPSByZXF1aXJlKFwiLi9vYmplY3Qvc2V0XCIpO1xuZXhwb3J0cy5TZXQgPSBzZXRfMS5TZXQ7XG52YXIgbWVtb2l6ZV8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb24vbWVtb2l6ZVwiKTtcbmV4cG9ydHMubWVtb2l6ZSA9IG1lbW9pemVfMS5tZW1vaXplO1xudmFyIGlzVHlwZSA9IHJlcXVpcmUoXCIuL29iamVjdC9pc1wiKTtcbmV4cG9ydHMuaXMgPSBpc1R5cGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbGlmdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgIHJldHVybiBuZXcgZXhwb3J0cy5BcnJheU9wcyhvYmopO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuRGF0ZU9wcyhvYmopO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLlN0cmluZ09wcyhvYmopO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLk51bWJlck9wcyhvYmopO1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5PYmplY3RPcHMob2JqKTtcbn07XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGxpZnQ7XG5mdW5jdGlvbiBnZXRWYWx1ZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCAmJiBpbnB1dFsnX2lzTGlmdFdyYXBwZXInXVxuICAgICAgICA/IGlucHV0LnZhbHVlKClcbiAgICAgICAgOiBpbnB1dDtcbn1cbmV4cG9ydHMuZ2V0VmFsdWUgPSBnZXRWYWx1ZTtcbmZ1bmN0aW9uIG1ha2VPcHMoKSB7XG4gICAgdmFyIE9wcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT3BzKF92YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9pc0xpZnRXcmFwcGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBPcHMucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH07XG4gICAgICAgIHJldHVybiBPcHM7XG4gICAgfSgpKTtcbiAgICByZXR1cm4gT3BzO1xufVxuZXhwb3J0cy5BcnJheU9wcyA9IG1ha2VPcHMoKTtcbmV4cG9ydHMuT2JqZWN0T3BzID0gbWFrZU9wcygpO1xuZXhwb3J0cy5OdW1iZXJPcHMgPSBtYWtlT3BzKCk7XG5leHBvcnRzLlN0cmluZ09wcyA9IG1ha2VPcHMoKTtcbmV4cG9ydHMuRGF0ZU9wcyA9IG1ha2VPcHMoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbi8qKiBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGFuIEFycmF5ICovXG5leHBvcnRzLmFycmF5ID0gQXJyYXkuaXNBcnJheTtcbi8qKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvYmplY3QgaXMgYSBmdW5jdGlvbiAqL1xuZnVuY3Rpb24gZnVuYyhvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpO1xufVxuZXhwb3J0cy5mdW5jID0gZnVuYztcbi8qKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvYmplY3QgaXMgYSBzdHJpbmcgKi9cbmZ1bmN0aW9uIHN0cmluZyhvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKTtcbn1cbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuLyoqIFJldHVybnMgd2hldGhlciB0aGlzIG9iamVjdCBpcyBhIG51bWJlciAqL1xuZnVuY3Rpb24gbnVtYmVyKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG4vKiogUmV0dXJucyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIGEgYm9vbGVhbiAqL1xuZnVuY3Rpb24gYm9vbGVhbihvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdib29sZWFuJyk7XG59XG5leHBvcnRzLmJvb2xlYW4gPSBib29sZWFuO1xuLyoqIFJldHVybnMgd2hldGhlciB0aGlzIHZhbHVlIGlzIGFuIG9iamVjdCAoZS5nIG5vdCBhIHByaW1pdGl2ZTogZGF0ZXMsIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJykpICovXG5mdW5jdGlvbiBvYmplY3Qob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuZXhwb3J0cy5vYmplY3QgPSBvYmplY3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbGlmdF8xID0gcmVxdWlyZShcIi4uL2xpZnRcIik7XG4vKipcbiAqIENyZWF0ZXMgYSBTZXQtbGlrZSBvYmplY3QgKHN0cmluZyBrZXlzLCB0cnVlIHZhbHVlcykgZnJvbSBhIGxpc3Qgb2Yga2V5c1xuICovXG5mdW5jdGlvbiBTZXQoKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBrZXlzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gcmVzdWx0W2tleV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gbmV3IGxpZnRfMS5PYmplY3RPcHMocmVzdWx0KTtcbn1cbmV4cG9ydHMuU2V0ID0gU2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGxpZnRfMSA9IHJlcXVpcmUoXCIuLi9saWZ0XCIpO1xuLy8gVGhlIE9wdGlvbiBmYWN0b3J5IC8gc3RhdGljIG9iamVjdFxudmFyIE9wdGlvbk9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBpc0RlZih2YWx1ZSkgPyBTb21lKHZhbHVlKSA6IGV4cG9ydHMuTm9uZTtcbn07XG5PcHRpb25PYmplY3QuYWxsID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJbaV07XG4gICAgICAgIGlmIChleHBvcnRzLk9wdGlvbi5pc09wdGlvbih2YWx1ZSkpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmdldCgpO1xuICAgICAgICBpZiAoIWlzRGVmKHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5vbmU7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIFNvbWUodmFsdWVzKTtcbn07XG5PcHRpb25PYmplY3QuaXNPcHRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAodmFsdWUudHlwZSA9PT0gJ3NvbWUnIHx8IHZhbHVlLnR5cGUgPT09ICdub25lJyk7XG59O1xuZnVuY3Rpb24gbWFrZU5vbmUoKSB7XG4gICAgdmFyIHNlbGYgPSB7fTtcbiAgICBmdW5jdGlvbiByZXR1cm5Ob25lKCkgeyByZXR1cm4gZXhwb3J0cy5Ob25lOyB9XG4gICAgc2VsZi50eXBlID0gJ25vbmUnO1xuICAgIHNlbGYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9O1xuICAgIHNlbGYuaXNEZWZpbmVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgc2VsZi5mb3JFYWNoID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHNlbGYubWFwID0gcmV0dXJuTm9uZTtcbiAgICBzZWxmLmZsYXRNYXAgPSByZXR1cm5Ob25lO1xuICAgIHNlbGYuZmlsdGVyID0gcmV0dXJuTm9uZTtcbiAgICBzZWxmLmZvbGQgPSBmdW5jdGlvbiAoaWZFbXB0eSkgeyByZXR1cm4gaWZFbXB0eSgpOyB9O1xuICAgIHNlbGYub3JFbHNlID0gZnVuY3Rpb24gKGFsdCkgeyByZXR1cm4gYWx0KCk7IH07XG4gICAgc2VsZi5nZXRPckVsc2UgPSBmdW5jdGlvbiAoYWx0KSB7IHJldHVybiBhbHQ7IH07XG4gICAgc2VsZi50b0FycmF5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlmdF8xW1wiZGVmYXVsdFwiXShbXSk7IH07XG4gICAgc2VsZi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOb25lJzsgfTtcbiAgICBzZWxmLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfU29tZSh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn1cbl9Tb21lLnByb3RvdHlwZSA9IHtcbiAgICB0eXBlOiAnc29tZScsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH0sXG4gICAgaXNEZWZpbmVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGZuKHRoaXMudmFsdWUpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuT3B0aW9uKGxpZnRfMS5nZXRWYWx1ZShmbih0aGlzLnZhbHVlKSkpO1xuICAgIH0sXG4gICAgZmxhdE1hcDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbih0aGlzLnZhbHVlKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbih0aGlzLnZhbHVlKSA/IHRoaXMgOiBleHBvcnRzLk5vbmU7XG4gICAgfSxcbiAgICBmb2xkOiBmdW5jdGlvbiAoaWZFbXB0eSwgaWZEZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBpZkRlZmluZWQodGhpcy52YWx1ZSk7XG4gICAgfSxcbiAgICBvckVsc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRPckVsc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfSxcbiAgICB0b0FycmF5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsaWZ0XzFbXCJkZWZhdWx0XCJdKFt0aGlzLnZhbHVlXSk7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJTb21lKFwiICsgdGhpcy52YWx1ZSArIFwiKVwiO1xuICAgIH0sXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbn07XG5mdW5jdGlvbiBpc0RlZih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5PcHRpb24gPSBPcHRpb25PYmplY3Q7XG4vKiogQ3JlYXRlcyBhIG5ldyBTb21lIGluc3RhbmNlIHVzaW5nIGEgbm9uIG51bGxhYmxlIHZhbHVlICovXG4vLyBleHRlbmRzIHt9IHRvIHByZXZlbnQgbnVsbCBhbmQgdW5kZWZpbmVkIGJlaW5nIHBhc3NlZFxuZnVuY3Rpb24gU29tZSh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1NvbWUodmFsdWUpO1xufVxuZXhwb3J0cy5Tb21lID0gU29tZTtcbmV4cG9ydHMuTm9uZSA9IG1ha2VOb25lKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbGlmdF8xID0gcmVxdWlyZShcIi4uL2xpZnRcIik7XG52YXIgUmVzdWx0T2JqZWN0ID0ge307XG5SZXN1bHRPYmplY3QuYWxsID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciBva1ZhbHVlcyA9IFtdO1xuICAgIHZhciBjdXJyZW50UmVzdWx0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50UmVzdWx0XzEgPSBhcnJbaV07XG4gICAgICAgIGlmICghY3VycmVudFJlc3VsdF8xLmlzT2soKSlcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50UmVzdWx0XzE7XG4gICAgICAgIG9rVmFsdWVzLnB1c2goY3VycmVudFJlc3VsdF8xLmdldCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIE9rKG9rVmFsdWVzKTtcbn07XG5SZXN1bHRPYmplY3QuaXNSZXN1bHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAodmFsdWUudHlwZSA9PT0gJ29rJyB8fCB2YWx1ZS50eXBlID09PSAnZXJyJyk7XG59O1xuZnVuY3Rpb24gX09rKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbn1cbl9Pay5wcm90b3R5cGUgPSB7XG4gICAgdHlwZTogJ29rJyxcbiAgICBpc09rOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIE9rKGxpZnRfMS5nZXRWYWx1ZShmbih0aGlzLl92YWx1ZSkpKTtcbiAgICB9LFxuICAgIG1hcEVycm9yOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBmbGF0TWFwOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKHRoaXMuX3ZhbHVlKTtcbiAgICB9LFxuICAgIGZvbGQ6IGZ1bmN0aW9uIChpZkVyciwgaWZPaykge1xuICAgICAgICByZXR1cm4gaWZPayh0aGlzLl92YWx1ZSk7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJPayhcIiArIHRoaXMuX3ZhbHVlICsgXCIpXCI7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbn07XG5mdW5jdGlvbiBfRXJyKGVycm9yKSB7XG4gICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbn1cbl9FcnIucHJvdG90eXBlID0ge1xuICAgIHR5cGU6ICdlcnInLFxuICAgIGlzT2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBtYXBFcnJvcjogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBFcnIoZm4odGhpcy5fZXJyb3IpKTtcbiAgICB9LFxuICAgIGZsYXRNYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZvbGQ6IGZ1bmN0aW9uIChpZkVyciwgaWZPaykge1xuICAgICAgICByZXR1cm4gaWZFcnIodGhpcy5fZXJyb3IpO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiRXJyKFwiICsgdGhpcy5fZXJyb3IgKyBcIilcIjtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgfVxufTtcbmV4cG9ydHMuUmVzdWx0ID0gUmVzdWx0T2JqZWN0O1xuZnVuY3Rpb24gT2sodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9Payh2YWx1ZSk7XG59XG5leHBvcnRzLk9rID0gT2s7XG5mdW5jdGlvbiBFcnIoZXJyb3IpIHtcbiAgICByZXR1cm4gbmV3IF9FcnIoZXJyb3IpO1xufVxuZXhwb3J0cy5FcnIgPSBFcnI7XG4iXX0=
