(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Scope_1 = require("./lib/structural/Scope");
exports.Scope = Scope_1.Scope;
/* BINARY OPS */
var AssignOp_1 = require("./lib/binops/AssignOp");
exports.AssignOp = AssignOp_1.AssignOp;
var BinaryOperation_1 = require("./lib/binops/BinaryOperation");
exports.BinaryOperation = BinaryOperation_1.BinaryOperation;
var DivOp_1 = require("./lib/binops/DivOp");
exports.DivOp = DivOp_1.DivOp;
var MinusOp_1 = require("./lib/binops/MinusOp");
exports.MinusOp = MinusOp_1.MinusOp;
var MulOp_1 = require("./lib/binops/MulOp");
exports.MulOp = MulOp_1.MulOp;
var PlusOp_1 = require("./lib/binops/PlusOp");
exports.PlusOp = PlusOp_1.PlusOp;
var GreaterThan_1 = require("./lib/logic/GreaterThan");
exports.GreaterThan = GreaterThan_1.GreaterThan;
var GreaterThanEq_1 = require("./lib/logic/GreaterThanEq");
exports.GreaterThanEq = GreaterThanEq_1.GreaterThanEq;
var LessThan_1 = require("./lib/logic/LessThan");
exports.LessThan = LessThan_1.LessThan;
var LessThanEq_1 = require("./lib/logic/LessThanEq");
exports.LessThanEq = LessThanEq_1.LessThanEq;
var DeclareOp_1 = require("./lib/binops/DeclareOp");
exports.DeclareOp = DeclareOp_1.DeclareOp;
var And_1 = require("./lib/logic/And");
exports.And = And_1.And;
var Or_1 = require("./lib/logic/Or");
exports.Or = Or_1.Or;
var Equals_1 = require("./lib/logic/Equals");
exports.Equals = Equals_1.Equals;
var NotEqual_1 = require("./lib/logic/NotEqual");
exports.NotEqual = NotEqual_1.NotEqual;
var Increment_1 = require("./lib/binops/Increment");
exports.Increment = Increment_1.Increment;
var Decrement_1 = require("./lib/binops/Decrement");
exports.Decrement = Decrement_1.Decrement;
/* UNARY OPS */
var UnaryOperation_1 = require("./lib/unops/UnaryOperation");
exports.UnaryOperation = UnaryOperation_1.UnaryOperation;
var NegOp_1 = require("./lib/unops/NegOp");
exports.NegOp = NegOp_1.NegOp;
var Not_1 = require("./lib/logic/Not");
exports.Not = Not_1.Not;
/* DATA TYPES */
var ListNode_1 = require("./lib/lists/ListNode");
exports.ListNode = ListNode_1.ListNode;
var NumberNode_1 = require("./lib/prims/NumberNode");
exports.NumberNode = NumberNode_1.NumberNode;
var StringNode_1 = require("./lib/prims/StringNode");
exports.StringNode = StringNode_1.StringNode;
var BooleanNode_1 = require("./lib/prims/BooleanNode");
exports.BooleanNode = BooleanNode_1.BooleanNode;
var NOP_1 = require("./lib/prims/NOP");
exports.NOP = NOP_1.NOP;
/* VARIABLES */
var VariableNode_1 = require("./lib/vars/VariableNode");
exports.VariableNode = VariableNode_1.VariableNode;
/* CONTROL CONSTRUCTS */
var Conditional_1 = require("./lib/conditionals/Conditional");
exports.Conditional = Conditional_1.Conditional;
var FunApp_1 = require("./lib/funhouse/FunApp");
exports.FunApp = FunApp_1.FunApp;
var FunDef_1 = require("./lib/funhouse/FunDef");
exports.FunDef = FunDef_1.FunDef;
var SequenceNode_1 = require("./lib/structural/SequenceNode");
exports.SequenceNode = SequenceNode_1.SequenceNode;
var WhileNode_1 = require("./lib/loops/WhileNode");
exports.WhileNode = WhileNode_1.WhileNode;
var ForNode_1 = require("./lib/loops/ForNode");
exports.ForNode = ForNode_1.ForNode;
/* BUILTIN FUNCTIONS */
var ColorNode_1 = require("./lib/shapes/ColorNode");
exports.ColorNode = ColorNode_1.ColorNode;
var EllipseNode_1 = require("./lib/shapes/EllipseNode");
exports.EllipseNode = EllipseNode_1.EllipseNode;
var RectangleNode_1 = require("./lib/shapes/RectangleNode");
exports.RectangleNode = RectangleNode_1.RectangleNode;
var LineNode_1 = require("./lib/shapes/LineNode");
exports.LineNode = LineNode_1.LineNode;
var CurveNode_1 = require("./lib/shapes/CurveNode");
exports.CurveNode = CurveNode_1.CurveNode;
var EphNode_1 = require("./lib/shapes/EphNode");
exports.EphNode = EphNode_1.EphNode;
var PrintNode_1 = require("./lib/structural/PrintNode");
exports.PrintNode = PrintNode_1.PrintNode;
var Return_1 = require("./lib/structural/Return");
exports.Return = Return_1.Return;
var ReturnError_1 = require("./lib/structural/ReturnError");
exports.ReturnError = ReturnError_1.ReturnError;
var EllipseEffect_1 = require("./lib/effects/EllipseEffect");
exports.EllipseEffect = EllipseEffect_1.EllipseEffect;
var NumberEffect_1 = require("./lib/effects/NumberEffect");
exports.NumberEffect = NumberEffect_1.NumberEffect;
var StringEffect_1 = require("./lib/effects/StringEffect");
exports.StringEffect = StringEffect_1.StringEffect;
var Dimensions_1 = require("./lib/structural/Dimensions");
exports.Dimensions = Dimensions_1.Dimensions;
var RectangleEffect_1 = require("./lib/effects/RectangleEffect");
exports.RectangleEffect = RectangleEffect_1.RectangleEffect;
var LineEffect_1 = require("./lib/effects/LineEffect");
exports.LineEffect = LineEffect_1.LineEffect;
var CurveEffect_1 = require("./lib/effects/CurveEffect");
exports.CurveEffect = CurveEffect_1.CurveEffect;
var EphEffect_1 = require("./lib/effects/EphEffect");
exports.EphEffect = EphEffect_1.EphEffect;
/* EVENTS */
var LogEvent_1 = require("./lib/logging/LogEvent");
exports.LogEvent = LogEvent_1.LogEvent;
var ClearEvent_1 = require("./lib/logging/ClearEvent");
exports.ClearEvent = ClearEvent_1.ClearEvent;
var DragEvent_1 = require("./lib/logging/DragEvent");
exports.DragEvent = DragEvent_1.DragEvent;
var PaintEvent_1 = require("./lib/logging/PaintEvent");
exports.PaintEvent = PaintEvent_1.PaintEvent;
var ResizeEvent_1 = require("./lib/logging/ResizeEvent");
exports.ResizeEvent = ResizeEvent_1.ResizeEvent;
var SelectEvent_1 = require("./lib/logging/SelectEvent");
exports.SelectEvent = SelectEvent_1.SelectEvent;
var IDEvent_1 = require("./lib/logging/IDEvent");
exports.IDEvent = IDEvent_1.IDEvent;
var ModuleGenerator_1 = require("./lib/modules/ModuleGenerator");
exports.ModuleGenerator = ModuleGenerator_1.ModuleGenerator;
var LessonOneCpOne_1 = require("./lib/modules/LessonOneCpOne");
exports.LessonOneCpOne = LessonOneCpOne_1.LessonOneCpOne;
var LessonOneCpTwo_1 = require("./lib/modules/LessonOneCpTwo");
exports.LessonOneCpTwo = LessonOneCpTwo_1.LessonOneCpTwo;
var LessonOneCpThree_1 = require("./lib/modules/LessonOneCpThree");
exports.LessonOneCpThree = LessonOneCpThree_1.LessonOneCpThree;
var LessonOneCpFour_1 = require("./lib/modules/LessonOneCpFour");
exports.LessonOneCpFour = LessonOneCpFour_1.LessonOneCpFour;
var LessonTwoCpOne_1 = require("./lib/modules/LessonTwoCpOne");
exports.LessonTwoCpOne = LessonTwoCpOne_1.LessonTwoCpOne;
var LessonTwoCpTwo_1 = require("./lib/modules/LessonTwoCpTwo");
exports.LessonTwoCpTwo = LessonTwoCpTwo_1.LessonTwoCpTwo;
var LessonTwoCpThree_1 = require("./lib/modules/LessonTwoCpThree");
exports.LessonTwoCpThree = LessonTwoCpThree_1.LessonTwoCpThree;
var LessonTwoCpFour_1 = require("./lib/modules/LessonTwoCpFour");
exports.LessonTwoCpFour = LessonTwoCpFour_1.LessonTwoCpFour;
var LessonTwoCpFive_1 = require("./lib/modules/LessonTwoCpFive");
exports.LessonTwoCpFive = LessonTwoCpFive_1.LessonTwoCpFive;
var LessonTwoCpSix_1 = require("./lib/modules/LessonTwoCpSix");
exports.LessonTwoCpSix = LessonTwoCpSix_1.LessonTwoCpSix;
var LessonTwoCpSeven_1 = require("./lib/modules/LessonTwoCpSeven");
exports.LessonTwoCpSeven = LessonTwoCpSeven_1.LessonTwoCpSeven;
var LessonThreeCpOne_1 = require("./lib/modules/LessonThreeCpOne");
exports.LessonThreeCpOne = LessonThreeCpOne_1.LessonThreeCpOne;
var LessonThreeCpTwo_1 = require("./lib/modules/LessonThreeCpTwo");
exports.LessonThreeCpTwo = LessonThreeCpTwo_1.LessonThreeCpTwo;
var LessonThreeCpThree_1 = require("./lib/modules/LessonThreeCpThree");
exports.LessonThreeCpThree = LessonThreeCpThree_1.LessonThreeCpThree;
var LessonThreeCpFour_1 = require("./lib/modules/LessonThreeCpFour");
exports.LessonThreeCpFour = LessonThreeCpFour_1.LessonThreeCpFour;
var LessonThreeCpFive_1 = require("./lib/modules/LessonThreeCpFive");
exports.LessonThreeCpFive = LessonThreeCpFive_1.LessonThreeCpFive;
var LessonThreeCpSix_1 = require("./lib/modules/LessonThreeCpSix");
exports.LessonThreeCpSix = LessonThreeCpSix_1.LessonThreeCpSix;
var LessonFourCpOne_1 = require("./lib/modules/LessonFourCpOne");
exports.LessonFourCpOne = LessonFourCpOne_1.LessonFourCpOne;
var LessonFourCpTwo_1 = require("./lib/modules/LessonFourCpTwo");
exports.LessonFourCpTwo = LessonFourCpTwo_1.LessonFourCpTwo;
/* PARSER */
var parser_1 = require("./lib/parser/parser");
exports.Parser = parser_1.Parser;

},{"./lib/binops/AssignOp":2,"./lib/binops/BinaryOperation":3,"./lib/binops/DeclareOp":4,"./lib/binops/Decrement":5,"./lib/binops/DivOp":6,"./lib/binops/Increment":7,"./lib/binops/MinusOp":8,"./lib/binops/MulOp":9,"./lib/binops/PlusOp":10,"./lib/conditionals/Conditional":11,"./lib/effects/CurveEffect":12,"./lib/effects/EllipseEffect":13,"./lib/effects/EphEffect":14,"./lib/effects/LineEffect":15,"./lib/effects/NumberEffect":16,"./lib/effects/RectangleEffect":17,"./lib/effects/StringEffect":18,"./lib/funhouse/FunApp":19,"./lib/funhouse/FunDef":20,"./lib/lists/ListNode":21,"./lib/logging/ClearEvent":22,"./lib/logging/DragEvent":24,"./lib/logging/IDEvent":25,"./lib/logging/LogEvent":26,"./lib/logging/PaintEvent":27,"./lib/logging/ResizeEvent":28,"./lib/logging/SelectEvent":29,"./lib/logic/And":30,"./lib/logic/Equals":31,"./lib/logic/GreaterThan":32,"./lib/logic/GreaterThanEq":33,"./lib/logic/LessThan":34,"./lib/logic/LessThanEq":35,"./lib/logic/Not":36,"./lib/logic/NotEqual":37,"./lib/logic/Or":38,"./lib/loops/ForNode":39,"./lib/loops/WhileNode":40,"./lib/modules/LessonFourCpOne":42,"./lib/modules/LessonFourCpTwo":43,"./lib/modules/LessonOneCpFour":44,"./lib/modules/LessonOneCpOne":45,"./lib/modules/LessonOneCpThree":46,"./lib/modules/LessonOneCpTwo":47,"./lib/modules/LessonThreeCpFive":48,"./lib/modules/LessonThreeCpFour":49,"./lib/modules/LessonThreeCpOne":50,"./lib/modules/LessonThreeCpSix":51,"./lib/modules/LessonThreeCpThree":52,"./lib/modules/LessonThreeCpTwo":53,"./lib/modules/LessonTwoCpFive":54,"./lib/modules/LessonTwoCpFour":55,"./lib/modules/LessonTwoCpOne":56,"./lib/modules/LessonTwoCpSeven":57,"./lib/modules/LessonTwoCpSix":58,"./lib/modules/LessonTwoCpThree":59,"./lib/modules/LessonTwoCpTwo":60,"./lib/modules/ModuleGenerator":61,"./lib/parser/parser":62,"./lib/prims/BooleanNode":63,"./lib/prims/NOP":64,"./lib/prims/NumberNode":65,"./lib/prims/StringNode":66,"./lib/shapes/ColorNode":67,"./lib/shapes/CurveNode":68,"./lib/shapes/EllipseNode":69,"./lib/shapes/EphNode":70,"./lib/shapes/LineNode":71,"./lib/shapes/RectangleNode":72,"./lib/structural/Dimensions":73,"./lib/structural/PrintNode":74,"./lib/structural/Return":75,"./lib/structural/ReturnError":76,"./lib/structural/Scope":77,"./lib/structural/SequenceNode":78,"./lib/unops/NegOp":80,"./lib/unops/UnaryOperation":81,"./lib/vars/VariableNode":82}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const VariableNode_1 = require("../vars/VariableNode");
// left side is variable, right side is val
// Reassign new value to var
class AssignOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for an assignment operation
     * @param left The left side of the assignment (the var)
     * @param right The right side of the assignment (the value)
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        if (!(left instanceof VariableNode_1.VariableNode)) {
            throw new Error("The left hand side of the assignment must be a variable.");
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates assign op by assigning value to var
     * @param context The current context
     */
    eval(context) {
        if (this.left instanceof VariableNode_1.VariableNode) {
            let r = this.right.eval(context);
            context.assign(this.left.name, r);
            return r;
        }
        throw new Error("HALP (in AssignOp)");
    }
    /**
     * Returns a string representation of the AssignOp
     */
    toString() {
        return this._ws + this.left.toString() + ' = ' + this.right.toString();
    }
    /**
     * AssignOps can't be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on AssignOp
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.AssignOp = AssignOp;

},{"../vars/VariableNode":82,"./BinaryOperation":3}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BinaryOperation {
    /**
     * Constructor for the BinOp abstract class
     * @param _left The left side of the binary operation
     * @param _right The right side of the binary operation
     */
    constructor(_left, _right) {
        this._left = _left;
        this._right = _right;
        this._newLine = false;
    }
    ;
    /**
     * Draws the binary operation, if applicable
     * @param context The current program context
     * @param dims The dimensions
     * @param ast The AST
     */
    draw(context, dims, ast) { }
    /**
     * Checks if equal to another expression
     * @param right The right side of the equality
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on BinOp");
    }
    /**
     * Returns a string representation of the binary operation
     */
    toString() { return ""; }
    ;
    /**
     * Gets left side of the binary operation
     */
    get left() {
        return this._left;
    }
    /**
     * Sets left side of the binary operation
     */
    set left(left) {
        this._left = left;
    }
    /**
     * Gets right side of the binary operation
     */
    get right() {
        return this._right;
    }
    /**
     * Sets right side of the binary operation
     */
    set right(right) {
        this._right = right;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.BinaryOperation = BinaryOperation;

},{}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const VariableNode_1 = require("../vars/VariableNode");
// left side is variable, right side is val
// Declares new val
class DeclareOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the declare operation, which declares a variable for the first time
     * @param left The left side of the declare op (the variable)
     * @param right The right side of the op (the value)
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        if (!(left instanceof VariableNode_1.VariableNode)) {
            throw new Error("The left hand side of the assignment must be a variable.");
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the declaration by declaring the variable in the context and assigning the value
     * @param context The current program context
     */
    eval(context) {
        if (this.left instanceof VariableNode_1.VariableNode) {
            context.declare(this.left.name);
            let r = this.right.eval(context);
            context.assign(this.left.name, r);
            return r;
        }
        throw new Error("HALP (in DeclareOp)");
    }
    /**
     * Returns a string representation of the declare op
     */
    toString() {
        return this._ws + "var " + this.left.toString() + ' = ' + this.right.toString();
    }
    /**
     * DeclareOps cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called direcly on a DeclareOp
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.DeclareOp = DeclareOp;

},{"../vars/VariableNode":82,"./BinaryOperation":3}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const MinusOp_1 = require("./MinusOp");
const AssignOp_1 = require("./AssignOp");
const VariableNode_1 = require("../vars/VariableNode");
class Decrement {
    /**
     * Constructor for the decrement operation
     * @param variable The expression to be decremented
     * @param ws Preceding whitespace
     */
    constructor(variable, ws) {
        this.expr = variable;
        if (variable instanceof VariableNode_1.VariableNode) {
            this.innerRep = new AssignOp_1.AssignOp(variable, new MinusOp_1.MinusOp(variable, new NumberNode_1.NumberNode(1)));
        }
        else {
            this.innerRep = new MinusOp_1.MinusOp(variable, new NumberNode_1.NumberNode(1));
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the decrement op to a NumberNode
     * @param context The current program context
     */
    eval(context) {
        return this.innerRep.eval(context);
    }
    /**
     * Returns a string representation of the decrement op
     */
    toString() {
        return this._ws + this.expr.toString() + "--";
    }
    /**
     * Decrement ops can't be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on decrement
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.Decrement = Decrement;

},{"../prims/NumberNode":65,"../vars/VariableNode":82,"./AssignOp":2,"./MinusOp":8}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
class DivOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the division operation
     * @param left The dividend
     * @param right The divisor
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the division and evaluates into a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val / this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Division ops can't be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on a division op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the division
     */
    toString() {
        return this._ws + this.left.toString() + ' / ' + this.right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.DivOp = DivOp;

},{"../prims/NumberNode":65,"../structural/Scope":77,"./BinaryOperation":3}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PlusOp_1 = require("./PlusOp");
const AssignOp_1 = require("./AssignOp");
const VariableNode_1 = require("../vars/VariableNode");
class Increment {
    /**
     * Constructor for Increment
     * @param variable The expression to increment
     * @param ws Tracks preceding whitespace
     */
    constructor(variable, ws) {
        this.expr = variable;
        if (variable instanceof VariableNode_1.VariableNode) {
            this.innerRep = new AssignOp_1.AssignOp(variable, new PlusOp_1.PlusOp(variable, new NumberNode_1.NumberNode(1)));
        }
        else {
            this.innerRep = new PlusOp_1.PlusOp(variable, new NumberNode_1.NumberNode(1, ""));
        }
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates increment into a number node
     * @param context The function scope
     */
    eval(context) {
        return this.innerRep.eval(context);
    }
    /**
     * Increments cannot be drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Cannot call equals directly on binops
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the increment expression
     */
    toString() {
        return this._ws + this.expr.toString() + "++";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.Increment = Increment;

},{"../prims/NumberNode":65,"../vars/VariableNode":82,"./AssignOp":2,"./PlusOp":10}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
class MinusOp extends BinaryOperation_1.BinaryOperation {
    /**
     * The constructor for the subtraction operation
     * @param left The minuend
     * @param right The subrahend
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the subtraction and evaluates to a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val - this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Subtraction ops can't be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals can't be called directly on subtraction
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the subtraction op
     */
    toString() {
        return this._ws + this.left.toString() + ' - ' + this.right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.MinusOp = MinusOp;

},{"../prims/NumberNode":65,"../structural/Scope":77,"./BinaryOperation":3}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
class MulOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the multiplication operation
     * @param left The multiplicand
     * @param right The multiplier
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the multiplication and returns a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val * this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Returns a string representation of the multiplication op
     */
    toString() {
        return this._ws + this.left.toString() + ' * ' + this.right.toString();
    }
    /**
     * Multiplication ops cannot be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a multiplicaiton operation
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.MulOp = MulOp;

},{"../prims/NumberNode":65,"../structural/Scope":77,"./BinaryOperation":3}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryOperation_1 = require("./BinaryOperation");
const Scope_1 = require("../structural/Scope");
const NumberNode_1 = require("../prims/NumberNode");
// left and right are both expressions
class PlusOp extends BinaryOperation_1.BinaryOperation {
    /**
     * Constructor for the addition operation
     * @param left The first addend
     * @param right The second addend
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        super(left, right);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the addition and returns a single NumberNode
     * @param context The current program context
     */
    eval(context) {
        return new NumberNode_1.NumberNode(this.left.eval(new Scope_1.Scope(context)).eval(context).val + this.right.eval(new Scope_1.Scope(context)).eval(context).val);
    }
    /**
     * Addition ops cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on an addition op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on binary operations");
    }
    /**
     * Returns a string representation of the addition op
     */
    toString() {
        return this._ws + this.left.toString() + ' + ' + this.right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.PlusOp = PlusOp;

},{"../prims/NumberNode":65,"../structural/Scope":77,"./BinaryOperation":3}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const BooleanNode_1 = require("../prims/BooleanNode");
const space_lift_1 = require("space-lift");
class Conditional {
    /**
     * The constructor for conditionals (if, else if, and else statements)
     * @param test The condition of the statement
     * @param trueBranch The branch to follow if the condition evaluates to true
     * @param falseBranch The branch to follow if the condition evaluates to false
     */
    constructor(test, trueBranch, falseBranch) {
        this._newLine = true;
        this._test = test;
        this._trueBranch = trueBranch;
        this._falseBranch = falseBranch;
    }
    /**
     * Checks the test result and returns the result of the true or false branch, depending on the test
     * @param context The current program context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        let res = this._test.eval(childCtx);
        if (!(res instanceof BooleanNode_1.BooleanNode)) {
            throw new Error("The condition must be a boolean expression.");
        }
        if (res.val) {
            return this._trueBranch.eval(childCtx);
        }
        else if (this._falseBranch != null) { // check if else/else if is null or undefined
            return this._falseBranch.eval(childCtx); // possibly a bad idea
        }
    }
    /**
     * Returns a string representation of the conditional statement
     */
    toString() {
        let res = 'if(' + this._test.toString() + ") {\n " + this._trueBranch.toString() + "}";
        if (this._falseBranch !== undefined) {
            res += '\nelse {\n ' + this._falseBranch.toString() + '}';
        }
        return res;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the true branch of the conditional
     */
    get trueBranch() {
        return this._trueBranch;
    }
    /**
     * Returns the false branch of the conditional
     */
    get falseBranch() {
        return this._falseBranch;
    }
    /**
     * Conditionals cannot be drawn directly
     */
    draw() {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a conditional
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on conditionals");
    }
}
exports.Conditional = Conditional;

},{"../prims/BooleanNode":63,"../structural/Scope":77,"space-lift":91}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class CurveEffect {
    constructor(curve) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._curve = curve;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        let curvature = this.curvature;
        this._ctx.beginPath();
        this._ctx.moveTo(x, y);
        let v = this.perpendicularVector(width, height);
        this._ctx.quadraticCurveTo((x + width / 2) + curvature * v[0], (y + height / 2) + curvature * v[1], x + width, y + height);
        this._ctx.strokeStyle = "#673AB7";
        this._ctx.stroke();
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    //a * w + b * h = 0
    perpendicularVector(w, h) {
        if (w == 0 && h == 0) {
            return [0, 0];
        }
        else if (w == 0) {
            return [1, 0];
        }
        else if (h == 0) {
            return [0, 1];
        }
        return [1, (-w) / h];
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) { // a corner guide is selected
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) { // a middle guide is selected
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else { //if no guides are selected, colors everything white
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._curve.dx = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._curve.dy = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._curve.dy = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._curve.dx = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._curve.dx = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._curve.dy = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._curve.dx = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._curve.dy = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.h > 10) { //as long as the height is > 10
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10) { // as long as width is > 10
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._curve.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) { // sets the offsets depending on which corner is selected
                case 1: // top left
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w; // offset is bottom right
                    this._dragoffy = y + h;
                    break;
                case 2: // top right
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h; // offset is bottom left, etc
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) { // sets the offsets depending on which middle guide is selected
                case 5: // top middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2; // offset is bottom middle
                    this._dragoffy = y + h;
                    break;
                case 6: //right middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2; // offset is left middle etc
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) { // dragging
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) { // not selected
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isChangingDims = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a rectangle paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("rectangle", this.x, this.y);
    }
    /**
     * Logs a rectangle resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("rectangle with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs a rectangle click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("rectangle with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the rect
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the rect
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the rect
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the rect
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the curvature of the curve
     */
    get curvature() {
        return this._dims.curvature.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the rect is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the rect
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the rect has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the rect has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the rect is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " rectangle with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("rectangle with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to rectangle at " + this.x + ", " + this.y);
    }
}
exports.CurveEffect = CurveEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":65}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const NumberNode_1 = require("../prims/NumberNode");
const ClickEvent_1 = require("../logging/ClickEvent");
class EllipseEffect {
    constructor(circle) {
        this._corner = 0;
        this._isSelected = false; // Private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false; // Has this object just been dragged?
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._circle = circle;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        // logging
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        this._ctx.beginPath();
        this._ctx.ellipse(x, y, w / 2, h / 2, 0, 0, Math.PI * 2, false);
        //this._ctx.strokeStyle = "black";
        //this._ctx.stroke();
        this._ctx.fillStyle = "#D5B8FF";
        this._ctx.shadowColor = "#6C6C6C";
        this._ctx.shadowBlur = 15;
        //this._ctx.shadowOffsetX = 2;
        //this._ctx.shadowOffsetY = 2;
        this._ctx.fill();
        if (this._isSelected) {
            this.drawGuides(x - w / 2, y - h / 2, w, h, this._corner);
        }
    }
    /*
        private mouseMove = this.onMouseMove.bind(this);
        private mouseDown = this.onMouseDown.bind(this);
        private mouseUp = this.onMouseUp.bind(this);
        private shiftDown = this.onShiftDown.bind(this);
        private shiftUp = this.onShiftUp.bind(this);
        private mouseOutside = this.isMouseOutside.bind(this);
        private selectStart = function(e:any) { e.preventDefault(); return false; };
    */
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    removeEventListeners() {
        /*
        console.log("removing EventListners");
          this._canvas.removeEventListener('mousemove', this.mouseMove); // bind in order to maintain the meaning of 'this'
          this._canvas.removeEventListener('mousedown', this.mouseDown);
          this._canvas.removeEventListener('mouseup', this.mouseUp);
          window.removeEventListener('keydown', this.shiftDown);
          window.removeEventListener('keyup', this.shiftUp);
          window.removeEventListener('mousedown', this.mouseOutside);
          //makes it so that double clicking doesn't select text on the page
          this._canvas.removeEventListener('selectstart', this.selectStart, false);
          */
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        return Math.pow(mx - x, 2) / Math.pow(w / 2, 2) + Math.pow(my - y, 2) / Math.pow(h / 2, 2) <= 1;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - (x - w / 2);
        let ydif = my - (y - h / 2);
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - (x - w / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - x;
        ydif = my - (y - h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - (x - w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) {
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0 && corner > 4) {
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else {
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 14, this.h < 14);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 14, this.h < 14);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        //console.log("I'm an ellipse!");
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //console.log("ellipse dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 14 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     * @param widthTooSmall true if the width dimension is < 14
     * @param heightTooSmall true if the height dimension is < 14
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 14;
            this._circle.width = new NumberNode_1.NumberNode(14); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 14 / this._ratio;
            this._circle.height = new NumberNode_1.NumberNode(Math.round(14 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._initDistance = newDistance;
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 14;
            this._circle.height = new NumberNode_1.NumberNode(14); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 14 * this._ratio;
            this._circle.width = new NumberNode_1.NumberNode(Math.round(14 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._initDistance = newDistance;
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
            this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
            this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
            this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
            this._initDistance = newDistance;
        }
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (this._corner == 5 || this._corner == 7) { // if modifying height
            if (!heightTooSmall) {
                this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._initDistance = newDistance;
                this._ratio = this.w / this.h; // setting width/height ratio = to the new ratio
            }
            else {
                this._dims.height.eval(this._context).val = 14;
                this._circle.height = new NumberNode_1.NumberNode(14);
                this._ratio = this.w / this.h;
                if (newDistance - this._initDistance > 0) {
                    this._dims.height.eval(this._context).val += (newDistance - this._initDistance) * 2 / this._ratio;
                    this._circle.height = new NumberNode_1.NumberNode(Math.round(this.h));
                    this._initDistance = newDistance;
                    this._ratio = this.w / this.h;
                }
            }
        }
        else { // modifying width
            if (!widthTooSmall) {
                this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._initDistance = newDistance;
                this._ratio = this.w / this.h;
            }
            else {
                this._dims.width.eval(this._context).val = 14;
                this._circle.width = new NumberNode_1.NumberNode(14);
                this._ratio = this.w / this.h;
                if (newDistance - this._initDistance > 0) {
                    this._dims.width.eval(this._context).val += (newDistance - this._initDistance) * 2;
                    this._circle.width = new NumberNode_1.NumberNode(Math.round(this.w));
                    this._initDistance = newDistance;
                    this._ratio = this.w / this.h;
                }
            }
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
            else {
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = guideContains;
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
            this._width1 = this.w;
            this._height1 = this.h;
            //this._size1 = Math.sqrt(Math.pow(this.w,2) + Math.pow(this.h,2)); // saving old size
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
        }
        else if (contains) { //simply selecting the shape or dragging
            this._x1 = this.x; // Saving original x and y
            this._y1 = this.y;
            this._isSelected = true;
            this._isDragging = true;
            this._context.eventLog.push(this.logClick());
            this._dragoffx = this._mouse.x - this.x;
            this._dragoffy = this._mouse.y - this.y;
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) { // probs only need dragging but oh well | isSel || selMul?
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
                //this._context.eventLog.push(this.logMove());
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            //console.log("resizing ellipse");
            this._isResizing = false;
            //let size2 = Math.sqrt(Math.pow(this.w,2) + Math.pow(this.h,2));
            //console.log("Size diff: " + Math.abs(this._size1 - size2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        // if(this._isSelectingMultiple){
        //     if(Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
        //         this._context.eventLog.push(this.logMove());
        //     }
        // }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("ellipse", this.x, this.y);
    }
    /**
     * Logs a resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("ellipse with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
        //Math.round(this._size1*100)/100, Math.round((Math.sqrt(Math.pow(this.w,2) + Math.pow(this.h,2))*100))/100);
    }
    /**
     * Logs a click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("ellipse with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the ellipse
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the ellipse
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the ellipse
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the ellipse
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the ellipse is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the ellipse
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the ellipse has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the ellipse has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the ellipse is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return (" ellipse with ID " + this.getID().toString() + " at " + this.x + ", " + this.y);
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("ellipse with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to ellipse at " + this.x + ", " + this.y);
    }
}
exports.EllipseEffect = EllipseEffect;
/**
 * Get's the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":65}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class EphEffect {
    constructor(eph) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._eph = eph;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ephImg = new Image();
            this._ephImg.src = './pics/demoncow.png';
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        //var imgObj = new Image();
        //let ctx = this._canvas.getContext('2d');
        // this._ephImg = new Image();
        // this._ephImg.src = './pics/demoncow.png';
        //imgObj.onload = function(){
        //this._ephImg.onload = function(){
        this._ctx.drawImage(this._ephImg, this.x, this.y, width, height);
        //this._ephImg.onload = function(){
        // this._ephImg.width = width;
        // this._ephImg.height = height;
        //}
        //}
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) {
            switch (corner) { //colors the coreph guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) {
            switch (corner) { //colors the coreph guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else {
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * @param event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //console.log("ephangle dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._eph.width = new NumberNode_1.NumberNode(10);
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._eph.height = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._eph.height = new NumberNode_1.NumberNode(10);
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._eph.width = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._eph.width = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._eph.height = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._eph.width = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._eph.height = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.w > 10 && this.h > 10) {
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._eph.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._eph.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._eph.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10 && this.h > 10) {
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._eph.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) {
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) {
                case 1:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h;
                    break;
                case 2:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h;
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
            //this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h / 2);
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) {
                case 5:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y + h;
                    break;
                case 6:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2;
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) {
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let eph = this._canvas.getBoundingClientRect();
        if (mouseX < eph.left || mouseX > eph.right || mouseY < eph.top || mouseY > eph.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs an eph paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("eph", this.x, this.y);
    }
    /**
     * Logs an eph resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("eph with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs an eph click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("eph with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Not implemented");
    }
    updateAST() {
        throw new Error("Not implemented");
    }
    /**
     * Returns the x position of the eph
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the eph
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the eph
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the eph
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the eph is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the image
     */
    get image() {
        return this._ephImg;
    }
    /**
     * Returns the ID of the eph
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the eph has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the eph has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the eph is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " eph with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("eph with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to eph at " + this.x + ", " + this.y);
    }
}
exports.EphEffect = EphEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let eph = canvas.getBoundingClientRect();
    return {
        x: event.clientX - eph.left,
        y: event.clientY - eph.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":65}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class LineEffect {
    constructor(line) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._line = line;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        this._ctx.moveTo(x, y);
        this._ctx.lineTo(x + width, y + height);
        this._ctx.strokeStyle = "#673AB7";
        this._ctx.stroke();
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) { // a corner guide is selected
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) { // a middle guide is selected
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else { //if no guides are selected, colors everything white
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._line.dx = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._line.dy = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._line.dy = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._line.dx = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._line.dx = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._line.dy = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._line.dx = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._line.dy = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.h > 10) { //as long as the height is > 10
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._line.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._line.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._line.dy = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10) { // as long as width is > 10
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._line.dx = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) { // sets the offsets depending on which corner is selected
                case 1: // top left
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w; // offset is bottom right
                    this._dragoffy = y + h;
                    break;
                case 2: // top right
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h; // offset is bottom left, etc
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) { // sets the offsets depending on which middle guide is selected
                case 5: // top middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2; // offset is bottom middle
                    this._dragoffy = y + h;
                    break;
                case 6: //right middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2; // offset is left middle etc
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) { // dragging
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) { // not selected
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isChangingDims = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a rectangle paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("rectangle", this.x, this.y);
    }
    /**
     * Logs a rectangle resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("rectangle with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs a rectangle click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("rectangle with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the rect
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the rect
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the rect
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the rect
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the rect is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the rect
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the rect has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the rect has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the rect is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " rectangle with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("rectangle with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to rectangle at " + this.x + ", " + this.y);
    }
}
exports.LineEffect = LineEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":65}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class NumberEffect {
    constructor(num) {
        this._fontSize = 20;
        this._corner = 0;
        this._isEditing = false;
        this._isListening = false;
        this._isDragging = false;
        this._isResizing = false;
        this._isSelectingMultiple = false;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._numberMetrics = {
            width: 0,
            height: 0,
            interval: 0,
            str: "",
            initMousePos: 0,
            cursorPos: 0
        };
        this._num = num;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas != undefined) {
            this._context = context;
            this._canvas = context.canvas.get();
            this._dims = dims;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this.update();
            // logging
            this._context.eventLog.push(this.logPaint()); // this.context or context?
            context.effects.push(this);
            this.addEventListeners();
        }
        else {
            console.log("canvas is NOT defined");
        }
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let fontDeets = this._fontSize + "px Courier New";
        this._ctx.font = fontDeets;
        this._ctx.fillStyle = "#673AB7";
        let str = this._num.toString();
        this._ctx.fillText(str, this.x, this.y);
        let numberDims = this._ctx.measureText(str);
        this._numberMetrics.width = numberDims.width;
        this._numberMetrics.height = this._fontSize;
        this._numberMetrics.str = str;
        this._numberMetrics.interval = this._numberMetrics.width / this._numberMetrics.str.length;
        if (this._isSelected) {
            this.drawTextGuides(this.x, this.y - this._fontSize, this._numberMetrics.width, this._numberMetrics.height, this._corner);
        }
        if (this._isEditing) {
            this.modifyTextCursor();
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        return (this.x <= mx) && (this.x + this._numberMetrics.width >= mx) &&
            (this.y - this._fontSize <= my) && (this.y >= my);
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let xdif = mx - (this.x + this._numberMetrics.width);
        let ydif = my - (this.y - this._fontSize);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) {
            this._isEditing = false;
            return 2;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawTextGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0) {
            switch (corner) { //colors the guide blue if selected
                case 2:
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue');
                    break;
            }
        }
        else {
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white');
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /* Event listener functions */
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isSelected && this._isDragging) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this._fontSize < 15);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        if (!this._isSelectingMultiple && this._isSelected && this.contains(this._mouse.x, this._mouse.y)) { //text editing
            if (!this._isListening) {
                window.addEventListener('keydown', this.modifyText.bind(this));
            }
            this._isListening = true;
            this._isEditing = true;
            this._isDragging = false;
            this._numberMetrics.initMousePos = this._mouse.x;
            this.modifyTextCursor();
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isEditing = false;
        }
        else {
            this._isEditing = false;
        }
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y) > 0, this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //("string dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Creates and moves the text edit cursor based on where the mouse is clicked
     */
    modifyTextCursor() {
        let leftWall = this.x; // the x position of the left most side of the bounding rectangle
        let xDif = this._numberMetrics.initMousePos - leftWall; // difference between mouse x and left wall
        let interval = this._numberMetrics.interval; // the text width divided by the length of the string
        let moveFactor = 0;
        if (xDif >= interval / 2 && xDif <= interval) {
            moveFactor = leftWall + interval;
            this._numberMetrics.cursorPos = interval;
        }
        else if (xDif <= interval / 2) {
            moveFactor = leftWall;
            this._numberMetrics.cursorPos = 0;
        }
        else if (xDif % interval >= interval / 2) {
            moveFactor = leftWall + interval * Math.ceil(xDif / interval);
            this._numberMetrics.cursorPos = interval * Math.ceil(xDif / interval);
        }
        else if (xDif % interval < interval / 2) {
            moveFactor = leftWall + interval * Math.floor(xDif / interval);
            this._numberMetrics.cursorPos = interval * Math.floor(xDif / interval);
        }
        this._ctx.moveTo(moveFactor, this.y - this._fontSize);
        this._ctx.lineTo(moveFactor, this.y);
        this._ctx.strokeStyle = "grey";
        this._ctx.stroke();
    }
    /**
     * This edits the string when editing text
     * @param event keydown event
     */
    modifyText(event) {
        if (this._isEditing) {
            let firstHalf;
            let secondHalf;
            let str = this._num.toString();
            let breakPoint = this._numberMetrics.cursorPos / this._numberMetrics.interval;
            firstHalf = str.substring(0, breakPoint);
            secondHalf = str.substring(breakPoint);
            if (event.keyCode == 37 && this._numberMetrics.initMousePos > this.x + this._numberMetrics.interval / 2) {
                this._numberMetrics.initMousePos -= this._numberMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 39 && this._numberMetrics.initMousePos < this.x + this._numberMetrics.width) {
                this._numberMetrics.initMousePos += this._numberMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 8 && str.length > 0) {
                firstHalf = firstHalf.substring(0, firstHalf.length - 1);
                str = firstHalf + secondHalf;
                this._num.val = Number(str);
                this._numberMetrics.initMousePos -= this._numberMetrics.interval;
                this.modifyTextCursor();
            }
            else {
                let keyName = event.key;
                if (keyName.length == 1) {
                    firstHalf += keyName;
                    str = firstHalf + secondHalf;
                    this._num.val = Number(str);
                    this._numberMetrics.initMousePos += this._numberMetrics.interval;
                    this.modifyTextCursor();
                }
            }
        }
    }
    /**
     * Modifies the font size of the text
     * If the text font is smaller than 15pt, it set's it equal to 15pt
     * @param isTooSmall true if the font size is < 15
     */
    modifyResize(isTooSmall) {
        if (isTooSmall) {
            this._fontSize = 15;
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._fontSize += (newDistance - this._initDistance) * 0.2;
                this._initDistance = newDistance;
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this._fontSize += (newDistance - this._initDistance) * 0.2;
            this._initDistance = newDistance;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x = this.x;
                this._y = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
            else {
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
                this._isDragging = true;
            }
            // if(this._context.mulSelected.mulSel){
            //     console.log("string effect mulSelected: " + this._context.mulSelected.mulSel);
            //     //if(this._context.mulSelected.val){
            //     this._context.eventLog.push(this.logSelected());
            //     //this.logSelected();
            // }
        }
        else if (guideContains) { //if the corner guides contain the mouse we are resizing
            this._isSelected = true;
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._context.eventLog.push(this.logClick());
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
            this._isResizing = true;
            this._size1 = this._fontSize; // saving old font size
        }
        else if (contains) {
            this._x = this.x; // Saving original x and y
            this._y = this.y;
            this._isSelected = true;
            this._context.eventLog.push(this.logClick());
            this._dragoffx = this._mouse.x - this.x;
            this._dragoffy = this._mouse.y - this.y;
            if (!this._isEditing) {
                this._isDragging = true;
            }
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
            this._isEditing = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x - this.x) > 1 || Math.abs(this._y - this.y) > 1) {
                this._justDragged = true;
                //this._context.eventLog.push(this.logMove());
            }
        }
        else if (this._isResizing && this._isSelected) {
            this._isResizing = false;
            if (Math.abs(this._size1 - this._fontSize) > 0) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._corner = 0;
        // console.log("string effect mulSelected: " + this._context.mulSelected.val);
        // if(this._context.mulSelected.val){
        //     this.logSelected();
        // }
        // if(this.isMultipleSelected){
        //     context.eventLog.push(new SelectEvent(selectedElems));
        //     masterLog.push(context.eventLog[context.eventLog.length - 1]);
        //     //console.log("multiple selected");
        // }
        // //this._context.eventLog.push(this.logMove());
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._isEditing = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent(this._num.toString(), this.x, this.y);
    }
    /**
     * Logs a resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent(this._num.toString() + " with ID " + this.getID().toString(), Math.round(this._size1 * 100) / 100, Math.round(this._fontSize * 100) / 100);
    }
    /**
     * Logs a click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent(this._num.toString() + " with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id, };
    }
    /**
     * Returns the canvas
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Sets the canvas
     * @param canvas The canvas to be assigned
     */
    set canvas(canvas) {
        this._canvas = canvas;
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the number
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the number
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
    * Returns whether or not the ellipse has just been dragged
    */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the ellipse has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the ellipse is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Returns whether or not this is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the number
     */
    get num() {
        return this._num.val;
    }
    /**
     * Returns the object ID
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " " + this._num.toString() + " with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return (this._num.toString() + " with ID " + this.getID().toString() + " from " + this._x + ", " + this._y + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to " + this._num.toString() + " at " + this.x + ", " + this.y);
    }
}
exports.NumberEffect = NumberEffect;
/**
 * Get's the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class RectangleEffect {
    constructor(rect) {
        this._corner = 0;
        this._isSelected = false; // private bools
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._isSelectingMultiple = false;
        this._justDragged = false;
        this._ratio = 0;
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._rect = rect;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas.isDefined()) {
            this._dims = dims;
            this._canvas = context.canvas.get();
            this._context = context;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this._ratio = this.w / this.h;
            this.update();
        }
        this._context.eventLog.push(this.logPaint());
        context.effects.push(this);
        this.addEventListeners();
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let x = this.x;
        let y = this.y;
        let width = this.w;
        let height = this.h;
        this._ctx.beginPath();
        this._ctx.rect(x, y, width, height);
        //this._ctx.strokeStyle = "black";
        //this._ctx.stroke();
        this._ctx.fillStyle = "#d5b8ff";
        this._ctx.shadowColor = "#6C6C6C";
        this._ctx.shadowBlur = 15;
        //this._ctx.shadowOffsetX = 2;
        //this._ctx.shadowOffsetY = 2;
        this._ctx.fill();
        if (this._isSelected) {
            this.drawGuides(x, y, width, height, this._corner);
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (mx > x && mx < x + w && my > y && my < y + h) {
            return true;
        }
        else
            return false;
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        let xdif = mx - x;
        let ydif = my - y;
        /* Corner Guides */
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top left
            return 1;
        }
        xdif = mx - (x + w);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top right
            return 2;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom right
            return 3;
        }
        xdif = mx - x;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom left
            return 4;
        }
        /* Middle Guides */
        xdif = mx - (x + w / 2);
        ydif = my - y;
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //top middle
            return 5;
        }
        xdif = mx - (x + w);
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle right
            return 6;
        }
        xdif = mx - (x + w / 2);
        ydif = my - (y + h);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //bottom middle
            return 7;
        }
        xdif = mx - x;
        ydif = my - (y + h / 2);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) { //middle left
            return 8;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0 && corner <= 4) { // a corner guide is selected
            switch (corner) { //colors the correct guide blue
                case 1:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'blue'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 2:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 3:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 4:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
            }
        }
        else if (corner !== 0) { // a middle guide is selected
            switch (corner) { //colors the correct guide blue
                case 5:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'blue'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 6:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 7:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'blue'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
                    break;
                case 8:
                    this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
                    this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
                    this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
                    this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
                    this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
                    this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
                    this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'blue'); // middle left
                    break;
            }
        }
        else { //if no guides are selected, colors everything white
            this.drawSquare(x - 2.5, y - 2.5, 5, 5, 'white'); // top left
            this.drawSquare((x + w / 2) - 2.5, y - 2.5, 5, 5, 'white'); // top middle
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white'); // top right
            this.drawSquare(x + w - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle right
            this.drawSquare(x + w - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom right
            this.drawSquare((x + w / 2) - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom middle
            this.drawSquare(x - 2.5, y + h - 2.5, 5, 5, 'white'); // bottom left
            this.drawSquare(x - 2.5, (y + h / 2) - 2.5, 5, 5, 'white'); // middle left
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isDragging && this._isSelected) {
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this.w < 10, this.h < 10);
        }
        else if (this._isChangingDims && this._isSelected) {
            this.modifyChangeDims(this.w < 10, this.h < 10);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y), this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Changes the size of the object when called (when a corner guide is clicked and dragged).
     *
     * If any of width or height is too small, it sets them equal to 10 and the other equal to
     * 10 divided or multiplied by the ratio of width/height to keep it the same.
     *
     * The work of changing the size is done by calling the helper method modifyResizeHelper.
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyResize(widthTooSmall, heightTooSmall) {
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._rect.width = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.height.eval(this._context).val = 10 / this._ratio;
            this._rect.height = new NumberNode_1.NumberNode(Math.round(10 / this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._rect.height = new NumberNode_1.NumberNode(10); // set for the prodirect manipulation
            this._dims.width.eval(this._context).val = 10 * this._ratio;
            this._rect.width = new NumberNode_1.NumberNode(Math.round(10 * this._ratio));
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this.modifyResizeHelper(newDistance);
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this.modifyResizeHelper(newDistance);
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 1, 2, or 4 are selected
     *
     * @param newDistance the distance between the mouse and the location opposite to it
     * (if top right guide is clicked, the distance between that and the bottom left guide is newDistance)
     */
    modifyResizeHelper(newDistance) {
        if (this.w > 10 && this.h > 10) {
            switch (this._corner) {
                case 1:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
                case 2:
                    this._dims.y.eval(this._context).val -= Math.round((newDistance - this._initDistance) / this._ratio);
                    break;
                case 4:
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                    break;
            }
        }
        this._dims.width.eval(this._context).val += newDistance - this._initDistance;
        this._rect.width = new NumberNode_1.NumberNode(Math.round(this.w));
        this._dims.height.eval(this._context).val += (newDistance - this._initDistance) / this._ratio;
        this._rect.height = new NumberNode_1.NumberNode(Math.round(this.h));
        this._initDistance = newDistance;
    }
    /**
     * Changes the dimensions of the object when called.
     * If any of width or height is too small, it sets them equal to 10.
     * Calls modifyChangeDimsHelper to actually do the work
     * @param widthTooSmall true if the width dimension is < 10
     * @param heightTooSmall true if the height dimension is < 10
     */
    modifyChangeDims(widthTooSmall, heightTooSmall) {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        if (widthTooSmall) {
            this._dims.width.eval(this._context).val = 10;
            this._rect.width = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        if (heightTooSmall) {
            this._dims.height.eval(this._context).val = 10;
            this._rect.height = new NumberNode_1.NumberNode(10);
            if (newDistance - this._initDistance > 0) {
                this.modifyChangeDimsHelper();
            }
        }
        else {
            this.modifyChangeDimsHelper();
        }
    }
    /**
     * Does the work of changing the size of the object.
     *
     * Since the rectangle originates from the top left corner and not the center,
     * it changes the x and y coordinates as well if guides 5 or 8 are selected
     */
    modifyChangeDimsHelper() {
        let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
        switch (this._corner) {
            case 5:
                if (this.h > 10) { //as long as the height is > 10
                    this._dims.y.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._rect.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 6:
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._rect.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 7:
                this._dims.height.eval(this._context).val += newDistance - this._initDistance;
                this._rect.height = new NumberNode_1.NumberNode(Math.round(this.h));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
            case 8:
                if (this.w > 10) { // as long as width is > 10
                    this._dims.x.eval(this._context).val -= Math.round(newDistance - this._initDistance);
                }
                this._dims.width.eval(this._context).val += newDistance - this._initDistance;
                this._rect.width = new NumberNode_1.NumberNode(Math.round(this.w));
                this._ratio = this.w / this.h;
                this._initDistance = newDistance;
                break;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        let x = this.x;
        let y = this.y;
        let w = this.w;
        let h = this.h;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
            }
            else {
                this._dragoffx = this._mouse.x - x;
                this._dragoffy = this._mouse.y - y;
                this._isDragging = true;
            }
        }
        else if (guideContains > 0 && guideContains <= 4) { //resizing
            this._isSelected = true;
            this._isResizing = true;
            this._context.eventLog.push(this.logClick());
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._height1 = this.h;
            this._width1 = this.w;
            //this._size1 = Math.sqrt(Math.pow(w,2) + Math.pow(h,2)); // size is diagonal length
            switch (this._corner) { // sets the offsets depending on which corner is selected
                case 1: // top left
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h);
                    this._dragoffx = x + w; // offset is bottom right
                    this._dragoffy = y + h;
                    break;
                case 2: // top right
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h);
                    this._dragoffx = x;
                    this._dragoffy = y + h; // offset is bottom left, etc
                    break;
                case 3:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y);
                    this._dragoffx = x;
                    this._dragoffy = y;
                    break;
                case 4:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y);
                    this._dragoffx = x + w;
                    this._dragoffy = y;
                    break;
            }
        }
        else if (guideContains > 4) { //changing shape dimensions
            this._isSelected = true;
            this._isChangingDims = true;
            this._corner = guideContains;
            switch (this._corner) { // sets the offsets depending on which middle guide is selected
                case 5: // top middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y + h);
                    this._dragoffx = x + w / 2; // offset is bottom middle
                    this._dragoffy = y + h;
                    break;
                case 6: //right middle
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x, y + h / 2);
                    this._dragoffx = x;
                    this._dragoffy = y + h / 2; // offset is left middle etc
                    break;
                case 7:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w / 2, y);
                    this._dragoffx = x + w / 2;
                    this._dragoffy = y;
                    break;
                case 8:
                    this._initDistance = distance(this._mouse.x, this._mouse.y, x + w, y + h / 2);
                    this._dragoffx = x + w;
                    this._dragoffy = y + h / 2;
                    break;
            }
        }
        else if (contains) { // dragging
            this._x1 = x; // Saving original x and y
            this._y1 = y;
            this._context.eventLog.push(this.logClick());
            this._isSelected = true;
            this._isDragging = true;
            this._dragoffx = this._mouse.x - x;
            this._dragoffy = this._mouse.y - y;
        }
        else if (!this._isSelectingMultiple) { // not selected
            this._isSelected = false;
            this._isDragging = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
            }
        }
        else if ((this._isResizing || this._isChangingDims) && this._isSelected) {
            this._isResizing = false;
            let size2 = Math.sqrt(Math.pow(this.w, 2) + Math.pow(this.h, 2));
            if ((Math.abs(this._width1 - this.w) > 0) || (Math.abs(this._height1 - this.h) > 0)) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._isChangingDims = false;
        this._corner = 0;
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isChangingDims = false;
            this._isSelected = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a rectangle paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent("rectangle", this.x, this.y);
    }
    /**
     * Logs a rectangle resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent("rectangle with ID " + this.getID().toString(), Math.round(this._width1 * 100) / 100, Math.round(this._height1 * 100) / 100, Math.round(this.w * 100) / 100, Math.round(this.h * 100) / 100);
    }
    /**
     * Logs a rectangle click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent("rectangle with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id };
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the rect
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the rect
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the width of the rect
     */
    get w() {
        return this._dims.width.eval(this._context).val;
    }
    /**
     * Returns the height of the rect
     */
    get h() {
        return this._dims.height.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether or not the rect is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the ID of the rect
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Returns whether or not the rect has just been dragged
     */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the rect has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the rect is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " rectangle with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return ("rectangle with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to rectangle at " + this.x + ", " + this.y);
    }
}
exports.RectangleEffect = RectangleEffect;
/**
 * Gets the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28,"../prims/NumberNode":65}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PaintEvent_1 = require("../logging/PaintEvent");
const ResizeEvent_1 = require("../logging/ResizeEvent");
const ClickEvent_1 = require("../logging/ClickEvent");
class StringEffect {
    constructor(str) {
        this._fontSize = 20;
        //private _size2: number;
        this._corner = 0;
        this._isSelected = false; // Private bools
        this._isEditing = false;
        this._isListening = false;
        this._isDragging = false;
        this._isResizing = false;
        this._isSelectingMultiple = false;
        this._justDragged = false; // Has this object just been dragged?
        //private _log: string[];
        this._dragoffx = 0;
        this._dragoffy = 0;
        this._initDistance = 0;
        this._mouse = {
            x: 0,
            y: 0
        };
        this._textMetrics = {
            width: 0,
            height: 0,
            interval: 0,
            str: "",
            initMousePos: 0,
            cursorPos: 0
        };
        this._str = str;
    }
    /**
     * The method that is called when evaluating nodes (StringNode, EllipseNode, etc)
     * This method assigns all params to private variables and draws the initial object to the canvas
     * by calling update()
     * @param context The parent Scope that contains the canvas among other things
     * @param dims The object's dimensions including x and y position
     * @param ast Unnecessary now, used to be the parent AST
     */
    draw(context, dims, ast) {
        if (context.canvas != undefined) {
            this._context = context;
            this._canvas = context.canvas.get();
            this._dims = dims;
            let ctx = context.canvas.get().getContext("2d");
            this._ctx = ctx;
            this.update();
            // logging
            this._context.eventLog.push(this.logPaint()); // this.context or context?
            context.effects.push(this);
            this.addEventListeners();
        }
        else {
            console.log("canvas is NOT defined");
        }
    }
    /**
     * This method is called in order to draw and redraw the object when manipulations are made
     */
    update() {
        let fontDeets = this._fontSize + "px Courier New";
        this._ctx.font = fontDeets;
        this._ctx.fillStyle = "#673AB7";
        this._ctx.fillText(this._str.val, this.x, this.y);
        let textDims = this._ctx.measureText(this._str.val);
        this._textMetrics.width = textDims.width;
        this._textMetrics.height = this._fontSize;
        this._textMetrics.str = this._str.val;
        this._textMetrics.interval = this._textMetrics.width / this._textMetrics.str.length;
        if (this._isSelected) {
            this.drawTextGuides(this.x, this.y - this._fontSize, this._textMetrics.width, this._textMetrics.height, this._corner);
        }
        if (this._isEditing) {
            this.modifyTextCursor();
        }
    }
    /**
     * Adds all the necessary event listeners in one fell swoop
     */
    addEventListeners() {
        this._canvas.addEventListener('mousemove', this.onMouseMove.bind(this)); // bind in order to maintain the meaning of 'this'
        this._canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        this._canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        window.addEventListener('keydown', this.onShiftDown.bind(this));
        window.addEventListener('keyup', this.onShiftUp.bind(this));
        window.addEventListener('mousedown', this.isMouseOutside.bind(this));
        //makes it so that double clicking doesn't select text on the page
        this._canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
    }
    /**
     * Removes all the necessary event listeners in another fell swoop
     */
    removeEventListeners() {
    }
    /**
     * Returns true if the mouse is inside of the object's bounding rectangle, false if otherwise
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    contains(mx, my) {
        return (this.x <= mx) && (this.x + this._textMetrics.width >= mx) &&
            (this.y - this._fontSize <= my) && (this.y >= my);
    }
    /**
     * Returns a number > 0 if the mouse is inside one of the corner/side guides, returns 0 if not
     * The corner guides are numbered 1-4 with 1 being the top left, 2 being the top right, and so on.
     * The middle guides are numbered 5-8, with 5 being the top middle, 6 being the right middle, and so on.
     * @param mx the mouse x coordinate
     * @param my the mouse y coordinate
     */
    guideContains(mx, my) {
        let xdif = mx - (this.x + this._textMetrics.width);
        let ydif = my - (this.y - this._fontSize);
        if (Math.abs(xdif) <= 5 && Math.abs(ydif) <= 5) {
            this._isEditing = false;
            return 2;
        }
        else
            return 0;
    }
    /**
     * Draws the bounding rectangle and guides for the object when the object is selected
     * If one of the guides is selected, it colors that guide blue
     * @param x the x coordinate for where the rectangle will originate from (top left corner)
     * @param y the y coordinate for where the rectangle will originate from (top left corner)
     * @param w the width of the bounding rectangle
     * @param h the height of the bounding rectangle
     * @param corner the number of the corner to be colored blue (if any at all, if 0, all are white)
     */
    drawTextGuides(x, y, w, h, corner) {
        this._ctx.beginPath();
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
        if (corner !== 0) {
            switch (corner) { //colors the guide blue if selected
                case 2:
                    this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'blue');
                    break;
            }
        }
        else {
            this.drawSquare(x + w - 2.5, y - 2.5, 5, 5, 'white');
        }
    }
    /**
     * Simple method that draws a rectangle
     * @param x x coordinate for the top left corner of the rectangle
     * @param y y coordinate for the top left corner of the rectangle
     * @param w width of the rectangle
     * @param h height of the rectangle
     * @param color color of the rectangle's fill
     */
    drawSquare(x, y, w, h, color) {
        this._ctx.beginPath();
        this._ctx.fillStyle = color;
        this._ctx.fillRect(x, y, w, h);
        this._ctx.rect(x, y, w, h);
        this._ctx.strokeStyle = 'gray';
        this._ctx.stroke();
    }
    /* Event listener functions */
    /**
     * Called whenever the mouse moves within the canvas.
     * Gets the mouse position, calls the modify methods if the booleans satisfy them.
     * @param event the mousemove event
     */
    onMouseMove(event) {
        this.getMousePosition();
        if (this._isSelected && this._isDragging) {
            //console.log(this._str.val + " is being dragged.");
            this.modifyDrag();
        }
        else if (this._isResizing && this._isSelected) {
            this.modifyResize(this._fontSize < 15);
        }
    }
    /**
     * Called whenever the mouse clicks inside the canvas.
     * Modifies the state depending on whether the guides contain the mouse or the bounding rect contains the mouse.
     * @param event the mousedown event
     */
    onMouseDown(event) {
        if (!this._isSelectingMultiple && this._isSelected && this.contains(this._mouse.x, this._mouse.y)) { //text editing
            if (!this._isListening) {
                window.addEventListener('keydown', this.modifyText.bind(this));
            }
            this._isListening = true;
            this._isEditing = true;
            this._isDragging = false;
            //console.log(this._str.val + " is setting dragging to false");
            this._textMetrics.initMousePos = this._mouse.x;
            this.modifyTextCursor();
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isEditing = false;
        }
        else {
            this._isEditing = false;
        }
        this.modifyState(this.guideContains(this._mouse.x, this._mouse.y) > 0, this.contains(this._mouse.x, this._mouse.y));
    }
    /**
     * Called whenever the mouse unclicks.
     * Calls modifyReset to reset dragging and resizing booleans among others.
     * @param event the mouseup event
     */
    onMouseUp(event) {
        this.modifyReset();
    }
    /**
     * Called whenever a key is pressed down
     * Toggles the isSelectingMultiple boolean if the key pressed is the shift key
     * @param event the keydown event
     */
    onShiftDown(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = true;
        }
    }
    /**
     * Called whenever a key is released
     * Toggles the isSelectingMultiple boolean if the key released is the shift key
     * @param event the keydown event
     */
    onShiftUp(event) {
        if (event.keyCode == "16") { //shift keycode
            this._isSelectingMultiple = false;
        }
    }
    /* Modification functions */
    /**
     * Changes the x and y coordinates of the object in order to drag the object.
     */
    modifyDrag() {
        //("string dragoffx: " + this._dragoffx);
        this._dims.x.eval(this._context).val = this._mouse.x - this._dragoffx;
        this._dims.y.eval(this._context).val = this._mouse.y - this._dragoffy;
    }
    /**
     * Creates and moves the text edit cursor based on where the mouse is clicked
     */
    modifyTextCursor() {
        let leftWall = this.x; // the x position of the left most side of the bounding rectangle
        let xDif = this._textMetrics.initMousePos - leftWall; // difference between mouse x and left wall
        let interval = this._textMetrics.interval; // the text width divided by the length of the string
        let moveFactor = 0;
        if (xDif >= interval / 2 && xDif <= interval) {
            moveFactor = leftWall + interval;
            this._textMetrics.cursorPos = interval;
        }
        else if (xDif <= interval / 2) {
            moveFactor = leftWall;
            this._textMetrics.cursorPos = 0;
        }
        else if (xDif % interval >= interval / 2) {
            moveFactor = leftWall + interval * Math.ceil(xDif / interval);
            this._textMetrics.cursorPos = interval * Math.ceil(xDif / interval);
        }
        else if (xDif % interval < interval / 2) {
            moveFactor = leftWall + interval * Math.floor(xDif / interval);
            this._textMetrics.cursorPos = interval * Math.floor(xDif / interval);
        }
        this._ctx.moveTo(moveFactor, this.y - this._fontSize);
        this._ctx.lineTo(moveFactor, this.y);
        this._ctx.strokeStyle = "grey";
        this._ctx.stroke();
    }
    /**
     * This edits the string when editing text
     * @param event keydown event
     */
    modifyText(event) {
        if (this._isEditing) {
            let firstHalf;
            let secondHalf;
            let breakPoint = this._textMetrics.cursorPos / this._textMetrics.interval;
            firstHalf = this._str.val.substring(0, breakPoint);
            secondHalf = this._str.val.substring(breakPoint);
            if (event.keyCode == 37 && this._textMetrics.initMousePos > this.x + this._textMetrics.interval / 2) {
                this._textMetrics.initMousePos -= this._textMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 39 && this._textMetrics.initMousePos < this.x + this._textMetrics.width) {
                this._textMetrics.initMousePos += this._textMetrics.interval;
                this.modifyTextCursor();
            }
            else if (event.keyCode == 8 && this._str.val.length > 0) {
                firstHalf = firstHalf.substring(0, firstHalf.length - 1);
                this._str.str = firstHalf + secondHalf;
                this._textMetrics.initMousePos -= this._textMetrics.interval;
                this.modifyTextCursor();
            }
            else {
                let keyName = event.key;
                if (keyName.length == 1) {
                    firstHalf += keyName;
                    this._str.str = firstHalf + secondHalf;
                    this._textMetrics.initMousePos += this._textMetrics.interval;
                    this.modifyTextCursor();
                }
            }
        }
    }
    /**
     * Modifies the font size of the text
     * If the text font is smaller than 15pt, it set's it equal to 15pt
     * @param isTooSmall true if the font size is < 15
     */
    modifyResize(isTooSmall) {
        if (isTooSmall) {
            this._fontSize = 15;
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            if (newDistance - this._initDistance > 0) {
                this._fontSize += (newDistance - this._initDistance) * 0.2;
                this._initDistance = newDistance;
            }
        }
        else {
            let newDistance = distance(this._mouse.x, this._mouse.y, this._dragoffx, this._dragoffy);
            this._fontSize += (newDistance - this._initDistance) * 0.2;
            this._initDistance = newDistance;
        }
    }
    /**
     * Toggles all of the private booleans depending on the mouse position when called (onMouseDown)
     * e.g. if the mouse is within the bounding rectangle when this is called, isSelected = true
     * @param guideContains
     * @param contains
     */
    modifyState(guideContains, contains) {
        this._justDragged = false;
        if (this._isSelectingMultiple) { //prepares the object for dragging whether it is personally selected or not
            if (contains) {
                this._x1 = this.x;
                this._y1 = this.y;
                this._isSelected = true;
                this._isDragging = true;
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
            }
            else {
                this._dragoffx = this._mouse.x - this.x;
                this._dragoffy = this._mouse.y - this.y;
                this._isDragging = true;
            }
            // if(this._context.mulSelected.mulSel){
            //     console.log("string effect mulSelected: " + this._context.mulSelected.mulSel);
            //     //if(this._context.mulSelected.val){
            //     this._context.eventLog.push(this.logSelected());
            //     //this.logSelected();
            // }
        }
        else if (guideContains) { //if the corner guides contain the mouse we are resizing
            this._isSelected = true;
            this._corner = this.guideContains(this._mouse.x, this._mouse.y);
            this._context.eventLog.push(this.logClick());
            //console.log(this._str.val + "is selected?" + this._selected);
            //console.log("state selection is " + this._str.val);
            this._dragoffx = this.x;
            this._dragoffy = this.y;
            this._initDistance = distance(this._mouse.x, this._mouse.y, this.x, this.y);
            this._isResizing = true;
            this._size1 = this._fontSize; // saving old font size
        }
        else if (contains) {
            this._x1 = this.x; // Saving original x and y
            this._y1 = this.y;
            this._isSelected = true;
            this._context.eventLog.push(this.logClick());
            //console.log(this._str.val + "is selected?" + this._selected);
            //console.log("state selection is " + this._str.val);
            this._dragoffx = this._mouse.x - this.x;
            this._dragoffy = this._mouse.y - this.y;
            if (!this._isEditing) {
                this._isDragging = true;
                //console.log(this._str.val + " is dragging? " + this._isDragging);
            }
        }
        else if (!this._isSelectingMultiple) {
            this._isSelected = false;
            this._isDragging = false;
            this._isEditing = false;
        }
    }
    /**
     * Resets all of the private booleans to false (like dragging, resizing, etc) when the mouse is released
     */
    modifyReset() {
        if (this._isDragging && this._isSelected) {
            //console.log(this._str.val + " logging drag");
            this._isDragging = false;
            if (Math.abs(this._x1 - this.x) > 1 || Math.abs(this._y1 - this.y) > 1) {
                this._justDragged = true;
                //this._context.eventLog.push(this.logMove());
            }
        }
        else if (this._isResizing && this._isSelected) {
            //console.log(this._str.val + " logging resize");
            this._isResizing = false;
            if (Math.abs(this._size1 - this._fontSize) > 0) {
                this._context.eventLog.push(this.logResize());
            }
        }
        this._isDragging = false;
        this._isResizing = false;
        this._corner = 0;
        // console.log("string effect mulSelected: " + this._context.mulSelected.val);
        // if(this._context.mulSelected.val){
        //     this.logSelected();
        // }
        // if(this.isMultipleSelected){
        //     context.eventLog.push(new SelectEvent(selectedElems));
        //     masterLog.push(context.eventLog[context.eventLog.length - 1]);
        //     //console.log("multiple selected");
        // }
        // //this._context.eventLog.push(this.logMove());
    }
    /**
     * Gets the current x and y coordinates of the mouse
     */
    getMousePosition() {
        this._mouse.x = getMousePos(this._canvas, event).x;
        this._mouse.y = getMousePos(this._canvas, event).y;
    }
    /**
     * Sets isDragging, isResizing, isChangingDims, and isSelected to false if the mouse clicks outside of the canvas
     * @param event the mousedown event
     */
    isMouseOutside(event) {
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let rect = this._canvas.getBoundingClientRect();
        if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
            this._isDragging = false;
            this._isResizing = false;
            this._isSelected = false;
            this._isEditing = false;
            this._corner = 0;
        }
    }
    /**
     * Logs a paint event
     */
    logPaint() {
        return new PaintEvent_1.PaintEvent(this._str.val, this.x, this.y);
    }
    /**
     * Logs a resize event
     */
    logResize() {
        return new ResizeEvent_1.ResizeEvent(this._str.val + " with ID " + this.getID().toString(), Math.round(this._size1 * 100) / 100, Math.round(this._fontSize * 100) / 100);
    }
    /**
     * Logs a click event
     */
    logClick() {
        return new ClickEvent_1.ClickEvent(this._str.val + " with ID " + this.getID().toString(), this.x, this.y);
    }
    /**
     * Initializes and assigns an ID to an object
     * @param id The ID to be assigned
     */
    initID(id) {
        this.idObj = { _id: id, };
    }
    /**
     * Returns the canvas
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Sets the canvas
     * @param canvas The canvas to be assigned
     */
    set canvas(canvas) {
        this._canvas = canvas;
    }
    ast() {
        throw new Error("Method not implemented.");
    }
    /**
     * Returns the x position of the ellipse
     */
    get x() {
        return this._dims.x.eval(this._context).val;
    }
    /**
     * Returns the y position of the ellipse
     */
    get y() {
        return this._dims.y.eval(this._context).val;
    }
    /**
     * Returns the Dimensions object
     */
    get dims() {
        return this._dims;
    }
    /**
    * Returns whether or not the ellipse has just been dragged
    */
    getJustDragged() {
        return this._justDragged;
    }
    /**
     * Sets whether or not the ellipse has just been dragged
     * @param val The value to be assigned
     */
    setJustDragged(val) {
        this._justDragged = val;
    }
    /**
     * Returns whether or not the ellipse is dragging
     */
    get isDragging() {
        return this._isDragging;
    }
    /**
     * Returns whether or not this is selected
     */
    get selected() {
        return this._isSelected;
    }
    /**
     * Returns the string
     */
    get str() {
        return this._str.val;
    }
    /**
     * Returns the object ID
     */
    getID() {
        return this.idObj._id;
    }
    /**
     * Assembles a string for selection events
     */
    toSelString() {
        return " " + this._str.val + " with ID " + this.getID().toString() + " at " + this.x + ", " + this.y;
    }
    /**
    * Assembles a string for drag events
    */
    toDragString() {
        return (this._str.val + " with ID " + this.getID().toString() + " from " + this._x1 + ", " + this._y1 + " to " + this.x + ", " + this.y);
    }
    /**
     * Assembles a string for ID assignment events
     */
    toIDString() {
        return (this.idObj._id.toString() + " to " + this._str.val + " at " + this.x + ", " + this.y);
    }
}
exports.StringEffect = StringEffect;
/**
 * Get's the mouse x and y coordinates in relation to the canvas
 * @param canvas the canvas object
 * @param event the mousemove event
 */
function getMousePos(canvas, event) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}
/**
 * Computes the distance between two points
 * @param x1 x coordinate of first point
 * @param y1 y coordinate of first point
 * @param x2 x coordinate of second point
 * @param y2 y coordinate of second point
 */
function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

},{"../logging/ClickEvent":23,"../logging/PaintEvent":27,"../logging/ResizeEvent":28}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ReturnError_1 = require("../structural/ReturnError");
const space_lift_1 = require("space-lift");
// Application of a function. Assumes arg values passed in same order as FunDef args
class FunApp {
    /**
     * The constructor for a function application
     * @param name The name of the function
     * @param args Function arguments, if applicable
     * @param ws Preceding whitespace
     * @param defaultValue The default return value of the function, if any
     */
    constructor(name, args, ws, defaultValue) {
        this._defaultValue = undefined;
        this._newLine = false;
        this._name = name;
        this._args = args;
        this._defaultValue = defaultValue;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the function application
     * @param context
     */
    eval(context) {
        let fundef = context.lookup(this._name, context); // looking up function
        //let child = new Scope(fundef.scope); // avoiding overwrite; need to toss after returning
        let child = fundef.scope.copy(); // Copying definition scope
        // Assigns arg values to definition arguments
        if (this._args != null) {
            for (let i = 0; i < this._args.length; i++) { //lookups?
                //child.declare(this._funct.args[i]); // redeclare?
                child.assign(fundef.args[i], this._args[i]);
            }
        }
        let id = context.globalFunID; // Assigns an ID to the function
        context.globalFunID++;
        child.retValID = space_lift_1.Some(id); // new method
        // we only return a value with function application
        // if it is explicitly returned using a return statement;
        // we abuse JS exceptions for this purpose
        try {
            child.hadFunEval = true;
            fundef.body.eval(child);
            return this._defaultValue;
        }
        catch (e) {
            // make sure that we catch only the error intended for us
            if (e instanceof ReturnError_1.ReturnError && parseInt(e.ID) == id) {
                return e.retVal;
            }
            // error was not intended for us; rethrow
            throw e;
        }
        //return fundef.body.eval(child);
    }
    /**
     * Returns a string representation of the function application
     */
    toString() {
        let argsList = '';
        if (this._args.length > 0) {
            for (let i = 0; i < this._args.length - 1; i++) {
                argsList += this._args[i].toString() + ", ";
            }
            argsList += this._args[this._args.length - 1].toString();
        }
        return this._ws + this.name + '(' + argsList + ")";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Function applications cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Equals cannot be called directly on a function application
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals directly on functions");
    }
    /**
     * Returns the name of the function
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the arguments of the function
     */
    get args() {
        return this._args;
    }
}
exports.FunApp = FunApp;

},{"../structural/ReturnError":76,"space-lift":91}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
class FunDef {
    constructor(name, body, args, ws) {
        this._newLine = true;
        this._name = name;
        this._body = body;
        this._args = args;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    ;
    // Binds args in context of definition; no values
    // Binds name to parent context (cur context is new context)
    eval(context) {
        this._funScope = new Scope_1.Scope(context); // ************* copy????
        this._funScope.canvas = context.canvas;
        this._funScope.eventLog = context.eventLog;
        this._funScope.effects = context.effects;
        /*
        if(this._args != null){
            for(let entry of this._args){
                this._funScope.declare(entry);
            }
        }
        */
        context.declare(this._name); // assign with val function
        context.assign(this._name, this); // parent or current?
        return null;
    }
    newLine() {
        return this._newLine;
    }
    toString() {
        let argsList = '';
        if (this._args.length > 0) {
            for (let i = 0; i < this._args.length - 1; i++) {
                argsList += this._args[i] + ", ";
            }
            argsList += this._args[this._args.length - 1];
        }
        return this._ws + "fun " + this._name + "(" + argsList + ')' + ' {\n ' + this._body.toString() + '}';
    }
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    equalsVal(right) {
        throw new Error("Cannot call equals directly on functions");
    }
    // Get methods
    get name() {
        return this._name;
    }
    get body() {
        return this._body;
    }
    get args() {
        return this._args;
    }
    get scope() {
        return this._funScope;
    }
}
exports.FunDef = FunDef;

},{"../structural/Scope":77}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ListNode {
    /**
     * Constructor for an array-like list
     * @param list The list, stored in a TS array
     * @param ws Preceding whitespace
     */
    constructor(list, ws) {
        this._newLine = false;
        this._list = list;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates each element of the list and pushes it onto the internal representation
     * @param context
     */
    eval(context) {
        let evalList = [];
        for (let expr of this._list) {
            evalList.push(expr.eval(context));
        }
        return new ListNode(evalList);
    }
    /**
     * Returns a string representation of the list
     */
    toString() {
        let list = '';
        for (let i = 0; i < this._list.length - 1; i++) {
            list += this._list[i].toString() + ", ";
        }
        list += this._list[this._list.length - 1].toString();
        return this._ws + '[' + list + ']';
    }
    /**
     * Returns whether the list equals another list
     * @param right The right side of the equality (must be a ListNode)
     */
    equalsVal(right) {
        if (right instanceof ListNode) {
            for (let i = 0; i < this.list.length; i++) {
                if (!(this.list[i].equalsVal(right.list[i]))) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Draw cannot be called directly on a list
     */
    draw() {
        throw new Error("Cannot draw a ListNode");
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the internal representation of the list
     */
    get list() {
        return this._list;
    }
}
exports.ListNode = ListNode;

},{}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class ClearEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for the Clear Event, which logs when the canvas is cleared
     * @param toLog What to log (spoiler: nothing)
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "clear";
    }
    /**
     * Assembles and returns message "Console cleared" with date and time attached
     */
    assembleLog() {
        let toPrint = "Console cleared";
        return this.logItem(toPrint);
    }
}
exports.ClearEvent = ClearEvent;

},{"./LogEvent":26}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class ClickEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Click Event, which logs when an object on the canvas is clicked
     * @param toLog The string representation of the object to log
     * @param x1 The x coordinate of the object to log
     * @param y1 The y coordinate of the object to log
     */
    constructor(toLog, x1, y1) {
        super(toLog, x1, y1);
        this.tag = "click";
    }
    /**
     * Assembles and returns message of form "Clicked on obj at x, y" with date and time attached
     */
    assembleLog() {
        let toPrint = "Clicked on " + this.toLog + " at " + this.x1.toString() + ", " + this.y1.toString();
        return this.logItem(toPrint);
    }
}
exports.ClickEvent = ClickEvent;

},{"./LogEvent":26}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class DragEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Drag Event, which logs when an object on the canvas is dragged
     * @param toLog The effect to log
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "drag";
        this._toPrint = this.assembleString();
    }
    /**
     * Assembles a log string using the Effect's toDragString() method
     */
    assembleString() {
        this._toPrint = this.toLog.toDragString();
        return this._toPrint;
    }
    /**
     * Assembles and returns final log message of form "Dragged obj from x1, y1 to x2, y2"
     * with date and time attached
     */
    assembleLog() {
        let print = "Dragged " + this._toPrint;
        return this.logItem(print);
    }
}
exports.DragEvent = DragEvent;

},{"./LogEvent":26}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class IDEvent extends LogEvent_1.LogEvent {
    /**
     * A constructor for an ID event, used when an object gets assigned an ID
     * @param toLog The effect to log
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "ID";
        this._toPrint = this.assembleString();
    }
    /**
     * Assembles string using the effect's toIDString() method
     */
    assembleString() {
        this._toPrint = this.toLog.toIDString();
        return this._toPrint;
    }
    /**
     * Assembles message of form "Assigned ID # to obj at x, y" with date and time attached
     */
    assembleLog() {
        let print = "Assigned ID " + this._toPrint;
        return this.logItem(print);
    }
}
exports.IDEvent = IDEvent;

},{"./LogEvent":26}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class LogEvent {
    /**
     * Abstract class constructor for a Log Event. Registers event time.
     * @param toLog The string, object, or array of objects to be logged
     * @param x1 Initial x position, if applicable
     * @param y1 Initial y position, if applicable
     * @param x2 Final x position, if applicable
     * @param y2 Final y position, if applicable
     */
    constructor(toLog, x1, y1, x2, y2) {
        let today = new Date();
        this._date = today.getFullYear() + '-' + (today.getMonth() + 1) + '-' + today.getDate();
        this._time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds();
        this._dateTime = this._date + ' ' + this._time;
        this._toLog = toLog;
        //this._toLogArray = toLogArray;
        this._x1 = x1;
        this._y1 = y1;
        this._x2 = x2;
        this._y2 = y2;
    }
    /**
     * Attaches date and time to log message
     * @param toLog The log message
     */
    logItem(toLog) {
        return " " + this._dateTime + ": " + toLog;
    }
    /**
     * Returns date-time string
     */
    get dateTime() {
        return this._dateTime;
    }
    /**
     * Returns string or effect(s) to be logged
     */
    get toLog() {
        return this._toLog;
    }
    /**
     * Returns event tag
     */
    get tag() {
        return this._tag;
    }
    /**
     * Sets tag string
     */
    set tag(tag) {
        this._tag = tag;
    }
    /**
     * Returns x1
     */
    get x1() {
        return this._x1;
    }
    /**
     * Returns y1
     */
    get y1() {
        return this._y1;
    }
    /**
     * Returns x2
     */
    get x2() {
        return this._x2;
    }
    /**
     * Returns y2
     */
    get y2() {
        return this._y2;
    }
}
exports.LogEvent = LogEvent;

},{}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class PaintEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Paint Event, used when an object is painted on the canvas
     * @param toLog The string representation of the object to be logged
     * @param x1 The x position of the object
     * @param y1 The y position of the object
     */
    constructor(toLog, x1, y1) {
        super(toLog, x1, y1);
        this.tag = "paint";
    }
    /**
     * Assembles and returns message of form "Painted obj at x, y" with date and time attached
     */
    assembleLog() {
        let toPrint = "Painted " + this.toLog + " at " + this.x1.toString() + ", " + this.y1.toString();
        return this.logItem(toPrint);
    }
}
exports.PaintEvent = PaintEvent;

},{"./LogEvent":26}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class ResizeEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for Resize Event, used when an object on the canvas is resized
     * @param toLog String representation of the object to be logged
     * @param x1 Initial x dimension of the object, or initial font size
     * @param y1 Initial y dimension of the object, or final font size
     * @param x2 Final x dimension of the object
     * @param y2 Final y dimension of the object
     */
    constructor(toLog, x1, y1, x2, y2) {
        super(toLog, x1, y1, x2, y2);
        this.tag = "resize";
    }
    /**
     * Assembles log message of form "Resized obj from size x1, y1 to size x1, y2" for rects and ellipses
     * or of form "Resized obj from size x1 to size y1" for strings
     * Has date and time attached
     */
    assembleLog() {
        if (this.x2 != undefined && this.y2 != undefined) {
            this.toPrint = "Resized " + this.toLog + " from size " + this.x1.toString() + " by " + this.y1.toString()
                + " to size " + this.x2.toString() + " by " + this.y2.toString();
        }
        else {
            this.toPrint = "Resized " + this.toLog + " from size " + this.x1.toString() + " to size " + this.y1.toString();
        }
        return this.logItem(this.toPrint);
    }
}
exports.ResizeEvent = ResizeEvent;

},{"./LogEvent":26}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogEvent_1 = require("./LogEvent");
class SelectEvent extends LogEvent_1.LogEvent {
    /**
     * Constructor for a Selection Event, used when multiple objects on the canvas are selected
     * @param toLog The array of objects selected
     */
    constructor(toLog) {
        super(toLog);
        this.tag = "select";
        this._toPrint = this.assembleStrings();
    }
    /**
     * Assembles and returns a string representation of all the objects selected
     */
    assembleStrings() {
        let logStrings = [];
        for (let elem of this.toLog) {
            logStrings.push(elem.toSelString());
        }
        return "Selected" + logStrings;
    }
    /**
     * Returns the message with date and time attached
     */
    assembleLog() {
        return this.logItem(this._toPrint);
    }
}
exports.SelectEvent = SelectEvent;

},{"./LogEvent":26}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class And {
    /**
     * Constructor for logical 'and' (&&) operation
     * @param left The left side of the operation
     * @param right The right side of the operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the operation and returns a boolean of the result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof BooleanNode_1.BooleanNode && rhs instanceof BooleanNode_1.BooleanNode) {
            return new BooleanNode_1.BooleanNode(lhs.val && rhs.val);
        }
        else {
            throw new Error("The arguments to the 'and' operator must be booleans.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + ' and ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on the 'and' op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * The 'and' operation cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns the left side of the op
     */
    get left() {
        return this._left;
    }
    /**
     * Returns the right side of the op
     */
    get right() {
        return this._right;
    }
}
exports.And = And;

},{"../prims/BooleanNode":63}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class Equals {
    /**
     * Constructor for equality (==) operation
     * @param left The left side of the equality
     * @param right The right side of the equality
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the comparison and evaluates to a BooleanNode
     * @param context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        return new BooleanNode_1.BooleanNode(lhs.equalsVal(rhs));
    }
    /**
     * Returns a string representation of the equality op
     */
    toString() {
        return this._ws + this._left.toString() + ' equals ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals can't be called directly on an equality op
     * @param right
     */
    equalsVal(right) {
        throw new Error("well this is meta");
    }
    /**
     * Equality ops can't be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.Equals = Equals;

},{"../prims/BooleanNode":63}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class GreaterThan {
    /**
     * Constructor for GreaterThan (>) op
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs GreaterThan comparison and returns BooleanNode representation of result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val > rhs.val));
        }
        else {
            throw new Error("The arguments to the > operator must be numeric.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + " > " + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on GreaterThan op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * GreaterThan op cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.GreaterThan = GreaterThan;

},{"../prims/BooleanNode":63,"../prims/NumberNode":65}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class GreaterThanEq {
    /**
     * Constructor for GreaterThanEq (greater than or equal to, >=) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs GreaterThanEq operation and returns BooleanNode with result
     * @param context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val >= rhs.val));
        }
        else {
            throw new Error("The arguments to the >= operator must be numeric.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + ' >= ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on GreaterThanEq op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * GreaterThanEq op cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.GreaterThanEq = GreaterThanEq;

},{"../prims/BooleanNode":63,"../prims/NumberNode":65}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class LessThan {
    /**
     * Constructor for LessThan (<) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the LessThan comparison and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        //console.log(this._left.eval(context) + " is less than " + this._right.eval(context));
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            //console.log("They're both number nodes");
            //console.log(lhs.val + "<" + rhs.val);
            //let bool: boolean = lhs.val < rhs.val;
            //console.log("bool: " + bool);
            return (new BooleanNode_1.BooleanNode(lhs.val < rhs.val));
        }
        else {
            throw new Error("Arguments to less than must produce numeric values.");
        }
    }
    /**
     * Returns string representation of operation
     */
    toString() {
        return this._left.toString() + ' < ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on LessThan op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * LessThan op cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.LessThan = LessThan;

},{"../prims/BooleanNode":63,"../prims/NumberNode":65}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class LessThanEq {
    /**
     * Constructor for LessThanEq (less than or equal to, <=) operation
     * @param left The left side of the operation
     * @param right The right side of the operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the LessThanEq comparison and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val <= rhs.val));
        }
        else {
            throw new Error("The arguments to the <= operator must be numeric.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + this._left.toString() + " <= " + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on LessThanEq op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * LessThanEq ops cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.LessThanEq = LessThanEq;

},{"../prims/BooleanNode":63,"../prims/NumberNode":65}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class Not {
    /**
     * Constructor for the logical Not (!) operation
     * @param expr The expression to be operated on (must be a BooleanNode)
     * @param ws Preceding whitespace
     */
    constructor(expr, ws) {
        this._newLine = false;
        this._expr = expr;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs the Not operation and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        let e = this._expr.eval(context);
        if (e instanceof BooleanNode_1.BooleanNode) {
            return new BooleanNode_1.BooleanNode(!e.val);
        }
        else {
            throw new Error("The argument to the ! operator must be boolean.");
        }
    }
    /**
     * Returns a string representation of the operation
     */
    toString() {
        return this._ws + "not " + this._expr.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on a Not op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * Not operations cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns expression to be operated on
     */
    get expr() {
        return this._expr;
    }
}
exports.Not = Not;

},{"../prims/BooleanNode":63}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
const NumberNode_1 = require("../prims/NumberNode");
class NotEqual {
    /**
     * Constructor for NotEqual (!=) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs NotEqual operation and returns BooleanNode with result
     * @param context The current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof NumberNode_1.NumberNode && rhs instanceof NumberNode_1.NumberNode) {
            return (new BooleanNode_1.BooleanNode(lhs.val !== rhs.val));
        }
        else {
            throw new Error("The arguments to the != operator must be numeric.");
        }
    }
    /**
     * Returns string representation of operation
     */
    toString() {
        return this._ws + this._left.toString() + " not equals " + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on a NotEqual op
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * NotEqual ops cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.NotEqual = NotEqual;

},{"../prims/BooleanNode":63,"../prims/NumberNode":65}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BooleanNode_1 = require("../prims/BooleanNode");
class Or {
    /**
     * Constructor for logical 'or' (||) operation
     * @param left Left side of operation
     * @param right Right side of operation
     * @param ws Preceding whitespace
     */
    constructor(left, right, ws) {
        this._newLine = false;
        this._left = left;
        this._right = right;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Performs Or operation and returns BooleanNode with result
     * @param context Current program context
     */
    eval(context) {
        let lhs = this._left.eval(context);
        let rhs = this._right.eval(context);
        if (lhs instanceof BooleanNode_1.BooleanNode && rhs instanceof BooleanNode_1.BooleanNode) {
            return new BooleanNode_1.BooleanNode(lhs.val || rhs.val);
        }
        else {
            throw new Error("The arguments to the 'or' operator must be booleans.");
        }
    }
    /**
     * Returns string representation of operation
     */
    toString() {
        return this._ws + this._left.toString() + ' or ' + this._right.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Equals cannot be called directly on Or operation
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on logical ops");
    }
    /**
     * Or operations cannot be drawn directly
     */
    draw() {
        throw new Error("Cannot call draw on logical ops");
    }
    /**
     * Returns left side of operation
     */
    get left() {
        return this._left;
    }
    /**
     * Returns right side of operation
     */
    get right() {
        return this._right;
    }
}
exports.Or = Or;

},{"../prims/BooleanNode":63}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const BooleanNode_1 = require("../prims/BooleanNode");
const space_lift_1 = require("space-lift");
class ForNode {
    /**
     * Constructor for a For loop
     * @param init Initializes the variable used in the condition
     * @param cond The condition (must evaluate to BooleanNode)
     * @param post The postevaluation condition
     * @param body The body of the loop
     * @param ws Preceding whitespace
     */
    constructor(init, cond, post, body, ws) {
        this._newLine = true;
        this._init = init;
        this._cond = cond;
        this._post = post;
        this._body = body;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the For loop
     * @param context The current program context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        this._init.eval(childCtx); // initialize var
        let res = this._cond.eval(childCtx);
        if (!(res instanceof BooleanNode_1.BooleanNode)) {
            throw new Error("The condition must be a boolean expression.");
        }
        let ret;
        while (res.val) {
            ret = this._body.eval(childCtx);
            this._post.eval(childCtx);
            res = this._cond.eval(childCtx);
        }
        return ret;
    }
    /**
     * Equals cannot be called directly on ForNode
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on For loop");
    }
    /**
     * ForNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        return "Cannot call draw on For loop";
    }
    /**
     * Returns a string representation of the for loop
     */
    toString() {
        return this._ws + 'for(' + this._init.toString() + ", " + this._cond.toString() + ", " + this._post.toString() + ") {\n "
            + this._body.toString() + "}";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.ForNode = ForNode;

},{"../prims/BooleanNode":63,"../structural/Scope":77,"space-lift":91}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("../structural/Scope");
const BooleanNode_1 = require("../prims/BooleanNode");
const space_lift_1 = require("space-lift");
class WhileNode {
    /**
     * Constructor for a While loop
     * @param cond The While loop condition
     * @param body The body of the loop
     * @param ws Preceding whitespace
     */
    constructor(cond, body, ws) {
        this._newLine = true;
        this._cond = cond;
        this._body = body;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the body of the loop while the condition is true
     * @param context
     */
    eval(context) {
        let childCtx = new Scope_1.Scope(context, context.effects, context.eventLog);
        childCtx.canvas = space_lift_1.Some(context.canvas.get());
        let res = this._cond.eval(childCtx);
        if (!(res instanceof BooleanNode_1.BooleanNode)) {
            throw new Error("The condition must be a boolean expression.");
        }
        let ret;
        while (res.val) {
            ret = this._body.eval(childCtx);
            res = this._cond.eval(childCtx);
        }
        return ret;
    }
    /**
     * Equals cannot be called directly on WhileNodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on While loop");
    }
    /**
     * WhileNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        return "Cannot call draw on While loop";
    }
    /**
     * Returns a string representation of the While loop
     */
    toString() {
        return this._ws + "while(" + this._cond.toString() + ") {\n " + this._body.toString() + "}";
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.WhileNode = WhileNode;

},{"../prims/BooleanNode":63,"../structural/Scope":77,"space-lift":91}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Instruction {
    constructor(location, content, top, left) {
        this._location = location;
        this._content = content;
        this._top = top;
        this._left = left;
    }
}
exports.Instruction = Instruction;

},{}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonFourCpOne {
    constructor() {
        this._name = "l4c1";
        this._nextModule = 'l4c2';
        this._constraint = 'none';
        this._instructions = `<p> You've made it to the FINAL CHALLENGES! Complete these challenges to earn ETERNAL GLORY! </p>
    <p> Throughout this Hour of Code, you have learned: </p>
    <p> - How to print a word, circle, rectangle, and curve. </p>
    <p> - How to store any of the value above in a variable. </p>
    <p> - How to use if/else statement to check a condition about a variable. </p>
    <p> Each of the following challenges will test these concepts. Let's dive right in! </p>
    <p> Print a circle and put its height and width in one of the boxes to the side. Then print a rectangle and put its height and width in the box. </p>
    <p> CHALLENGE: Print a circle and rectangle. Put their respective width and height in the boxes provided. </p>`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonFourCpOne = LessonFourCpOne;

},{"../effects/EllipseEffect":13}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonFourCpTwo {
    constructor() {
        this._name = "l4c2";
        this._nextModule = 'l4c2';
        this._constraint = 'none';
        this._instructions = `<p> Yes! You got this! </p>
    <p> Now let's put those skills in if/else statements to work! </p>
    <p> Create a pair of if/else statements to print out to the CANVAS a claim of whether the circle is positioned ABOVE or BELOW the rectangle. </p>
    <p> CHALLENGE: Print a claim that states whether circle is ABOVE or BELOW the rectangle. </p>
    <p> HINT: Remember that the numbers in the print() statements determine the position of the shapes being printed. </p>`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonFourCpTwo = LessonFourCpTwo;

},{"../effects/EllipseEffect":13}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpFour {
    constructor() {
        this._name = "l1c4";
        this._prevModule = 'l1c2';
        this._nextModule = 'l2c1';
        this._constraint = 'canvas';
        this._instructions = `<p> Note that changing the first number in the print statement moves the words left or right, while changing the second number move them up or down. </p>
    <p> Now time for a challenge! Print the word "moo" on the CANVAS, and put it right in the center of the entire CANVAS. </p>
    <p> CHALLENGE: Print the word "moo" in the center of the CANVAS. </p>
    <p> HINT: Write print("moo", 50, 50) in the CODE area first, then change the numbers inside that print statement. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "moo") {
                if ((effect.x > 200 && effect.x < 300) && (effect.y > 200 && effect.y < 300)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpFour = LessonOneCpFour;

},{"../effects/StringEffect":18}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Instruction_1 = require("./Instruction");
class LessonOneCpOne {
    constructor() {
        this._name = "l1c1";
        this._nextModule = 'l1c2';
        this._constraint = 'none';
        this._instructions = `<p> Computers can do wonderful things, but they unfortunately don't understand English. </p>
    <p> However, they understand computer code, so let's learn how to write code that instruct the computer to do things! </p>
    <p> On the CODE area above, write print("Hello") </p>
    <p> GOAL: Write 'Hello' on the CANVAS. </p>`;
        this._instrBoxes = [];
        this._instrIndex = 0;
        this._latestInstrIndex = 0;
        let content = "First, let's tell the computer to print something on the CANVAS. Click on the CODE box.";
        this._instrBoxes.push(new Instruction_1.Instruction('code', content, "30%", "10%"));
        content = 'Now type `print("Hello")` in this CODE box.';
        this._instrBoxes.push(new Instruction_1.Instruction('code', content, "30%", "10%"));
        content = 'Notice that what you typed causes the computer to print the word "Hello" on the CANVAS here. Congratulations! You just wrote your first line of code!';
        this._instrBoxes.push(new Instruction_1.Instruction('canvas', content, "65%", "10%"));
    }
    /**
     * A lesson to print a string
     * goals: write any string on CANVAS
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        let input = document.getElementById('input');
        let regex = /print\s*\(\s*\"Hello\"\s*\)/;
        let match = input.value.match(regex);
        if (match != null && match.length > 0) {
            return true;
        }
        return false;
        /*
        console.log("instrIndex in checkGoal: " + this._instrIndex);
        switch(this._instrIndex) {

          case 0:
            if (document.activeElement === input && this._latestInstrIndex == 0) {
              this._latestInstrIndex++;
              this.nextInstruction(document);
            }
            return false;
            break;

          case 1:
            let regex: RegExp = /print\s*\(\s*\"Hello\"\s*\)/;
            let match = input.value.match(regex);
            if (match != null && match.length > 0 && this._latestInstrIndex == 1) {
              this._latestInstrIndex++;
              this.nextInstruction(document);
            }
            return false;
            break;

          default:
            return true;
            break;
        }

        return false;
        */
    }
    nextInstruction(document) {
        this._instrIndex = (this._instrIndex + 1 < this._instrBoxes.length) ? this._instrIndex + 1 : this._instrIndex;
        this.renderInstruction(document);
    }
    prevInstruction(document) {
        this._instrIndex = (this._instrIndex - 1 >= 0) ? this._instrIndex - 1 : this._instrIndex;
        this.renderInstruction(document);
    }
    /**
     * render the current instruction of this checkpoint
     * @param document The HTML document
     */
    renderInstruction(document) {
        let curInstruction = document.getElementById("instruction");
        if (curInstruction != null) {
            curInstruction.remove();
        }
        let instruction = this._instrBoxes[this._instrIndex];
        let instrDiv = document.createElement("div");
        instrDiv.className = "instruction";
        instrDiv.id = 'instruction';
        instrDiv.innerText = instruction._content;
        instrDiv.style.top = instruction._top;
        instrDiv.style.left = instruction._left;
        instrDiv.style.display = "block";
        let prevInstr = document.createElement("button");
        prevInstr.id = 'previous-instruction';
        prevInstr.innerText = "<";
        let thisModule = this;
        prevInstr.onclick = function () {
            console.log("instrIndex " + thisModule._instrIndex);
            thisModule.prevInstruction(document);
        };
        if (this._instrIndex == 0) {
            prevInstr.style.background = "#D8D8D8";
            prevInstr.disabled = true;
        }
        instrDiv.appendChild(prevInstr);
        let nextInstr = document.createElement("button");
        nextInstr.id = 'next-instruction';
        nextInstr.innerText = ">";
        nextInstr.onclick = function () {
            console.log("instrIndex " + thisModule._instrIndex);
            thisModule.nextInstruction(document);
        };
        if (this._instrIndex == this._instrBoxes.length || this._instrIndex == this._latestInstrIndex) {
            nextInstr.style.background = "#D8D8D8";
            nextInstr.disabled = true;
        }
        instrDiv.appendChild(nextInstr);
        document.getElementById(instruction._location).appendChild(instrDiv);
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpOne = LessonOneCpOne;

},{"./Instruction":41}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpThree {
    constructor() {
        this._name = "l1c3";
        this._prevModule = 'l1c2';
        this._nextModule = 'l1c4';
        this._constraint = 'canvas';
        this._instructions = `<p> Yep! Moving the words actually change the numbers in your CODE. </p>
    <p> Now the CANVAS has been frozen! Try changing your CODE to see if you can move the words to the bottom right corner. </p>
    <p> GOAL: Move the words to the bottom right of the CANVAS. </p>
    <p> HINT: Change one of the 2 numbers at a time, then click RUN to see how that changes the CANVAS.`;
        this.x = 10;
        this.y = 430;
    }
    drawGuides(ctx) {
        ctx.beginPath();
        ctx.rect(this.x, this.y, 100, 100);
        ctx.strokeStyle = '#6C6C6C';
        ctx.stroke();
        ctx.font = 20 + "px Courier New";
        ctx.fillStyle = '#6C6C6C';
        ctx.fillText("Put text", this.x, 390);
        ctx.fillText("in here", this.x, 410);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str !== "") {
                if (effect.x > this.x && effect.x < this.x + 100 && effect.y > this.y && effect.y < this.y + 100) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpThree = LessonOneCpThree;

},{"../effects/StringEffect":18}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonOneCpTwo {
    constructor() {
        this._name = "l1c2";
        this._nextModule = 'l1c3';
        this._constraint = 'code';
        this._instructions = `<p> You just told the computer to write words on the CANVAS! </p>
    <p> Now let's do something more interesting: click on the words on the CANVAS, then drag it inside the box at the top-right corner. Observe what happens to your code. </p>
    <p> GOAL: Move the words you just created inside the top-right box. </p>`;
        this.x = 390;
        this.y = 10;
    }
    drawGuides(ctx) {
        ctx.beginPath();
        ctx.rect(this.x, this.y, 100, 100);
        ctx.strokeStyle = '#6C6C6C';
        ctx.stroke();
        ctx.font = 20 + "px Courier New";
        ctx.fillStyle = '#6C6C6C';
        ctx.fillText("Put text", 390, 130);
        ctx.fillText("in here", 390, 150);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str !== "") {
                if (effect.x > this.x && effect.x < this.x + 100 && effect.y > this.y && effect.y < this.y + 100) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonOneCpTwo = LessonOneCpTwo;

},{"../effects/StringEffect":18}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpFive {
    constructor() {
        this._name = "l3c5";
        this._nextModule = 'l3c6';
        this._constraint = 'none';
        this._instructions = `<p> So we print a message to the CANVAS anytime c is exactly equal to 8. </p>
    <p> What if we want to print another message, "c is not equal to 8" any time c is not equal to 8? </p>
    <p> We do so by using an else statement. Observe the CODE above. </p>
    <p> When the condition inside the if() statement is satisfied, the code block inside the {} right after it would run. </p>
    <p> When that condition is not satisfied, the code block inside the {} after the else statement would run. </p>
    <p> GOAL: Change the value of c so that the line "c is NOT equal to 8." is printed on the CANVAS. </p>`;
        this._starterCode = `c = 8;
if(c == 8) {
  print("c is equal to 8.", 103, 143);
} else {
  print("c is NOT equal to 8.", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /c\s*=\s*[^8]\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "c is NOT equal to 8.") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpFive = LessonThreeCpFive;

},{"../effects/StringEffect":18}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpFour {
    constructor() {
        this._name = "l3c4";
        this._nextModule = 'l3c5';
        this._constraint = 'none';
        this._instructions = `<p> You can put an inequality condition in the if() clause, such as "a < 5" or "b > 20". </p>
    <p> You can also use an equality condition. Observe the CODE above with "c == 8". The 2 equal signs mean that you are checking whether c is exactly equal to 8 or not. </p>
    <p> Change the value of c so that the line "c is equal to 8." is printed on the CANVAS. </p>
    <p> GOAL: Change the value of c so that the line "c is equal to 8." is printed on the CANVAS. </p>`;
        this._starterCode = `c = 100;
if(c == 8) {
  print("c is equal to 8.", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /c\s*=\s*8\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "c is equal to 8.") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpFour = LessonThreeCpFour;

},{"../effects/StringEffect":18}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpOne {
    constructor() {
        this._name = "l3c1";
        this._nextModule = 'l3c2';
        this._constraint = 'none';
        this._instructions = `<p> We learned to tell the computer to print a lot of things. Unfortunately, the computer is kinda bad at math. </p>
    <p> Look at the CODE above. We let a = 5, then we print the value of a to the CANVAS. Then we print the line "a is less than 10". </p>
    <p> Since a = 5, and 5 < 10, we know that a is less than 10. But what would happen if we change the value of a to, say, 12? </p>
    <p> GOAL: change the value of a to 12. </p>
    <p> HINT: You can do this by changing the line a = 5 in the CODE area, or you can click on the number 5 on the CANVAS. </p>`;
        this._starterCode = `a = 5;
print(a, 118, 63);
print("a is less than 10", 103, 143);`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /a\s*=\s*12\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "a is less than 10") {
                //canvasIsCorrect = true;
                //break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpOne = LessonThreeCpOne;

},{"../effects/StringEffect":18}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpSix {
    constructor() {
        this._name = "l3c6";
        this._nextModule = 'l4c1';
        this._constraint = 'none';
        this._instructions = `<p> Now that you know how to use if/else statements, let's put them all together! </p>
    <p> Above we have the CODE to draw 2 circles: circle A has height and width a, and circle B has height and width b. </p>
    <p> However, currently the claim that "Circle A is smaller than circle B." regardless of the circles' actual sizes. </p>
    <p> Create an if/else statement to print "Circle A is smaller than circle B." when it is actually so, and print "Circle A is bigger than circle B" otherwise. </p>
    <p> CHALLENGE: Create an if/else statement to print the correct claim about the sizes of the 2 circles. </p>`;
        this._starterCode = `a = 200;
print(a, 111, 103);
print(ellipse(a, a), 131, 263);
b = 100;
print(b, 337, 104);
print(ellipse(b, b), 371, 248);
print("Circle A is smaller than circle B.", 45, 453);
`;
        this.xA = 20;
        this.yA = 150;
        this.xB = this.xA + 225 + 10;
        this.yB = 150;
    }
    drawGuides(ctx) {
        ctx.beginPath();
        ctx.rect(this.xA, this.yA, 225, 225);
        ctx.strokeStyle = '#6C6C6C';
        ctx.stroke();
        ctx.font = 20 + "px Courier New";
        ctx.fillStyle = '#6C6C6C';
        ctx.fillText("Circle A", this.xA, this.yA - 20);
        ctx.beginPath();
        ctx.rect(this.xB, this.yB, 225, 225);
        ctx.stroke();
        ctx.fillText("Circle B", this.xB, this.yB - 20);
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            /*
            if(a < b) {
              print("Circle A is smaller than circle B.", 45, 453);
            } else {
              print("Circle A is bigger than circle B.", 45, 453);
            }*/
            let regex1 = /if\s*\(\s*a\s*[<>]\s*b\s*\)/;
            let regex2 = /if\s*\(\s*b\s*[<>]\s*a\s*\)/;
            let match1 = code.match(regex1);
            let match2 = code.match(regex2);
            codeIsCorrect = (match1 != null && match1.length > 0) || (match2 != null && match2.length > 0);
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        let circleA = null;
        let circleB = null;
        //look for circles A and B
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                if (effect.x > this.xA && effect.x < this.xA + 225 && effect.y > this.yA && effect.y < this.yA + 225) {
                    circleA = effect;
                }
                else if (effect.x > this.xB && effect.x < this.xB + 225 && effect.y > this.yB && effect.y < this.yB + 225) {
                    circleB = effect;
                }
            }
        }
        if (circleA != null && circleB != null) {
            for (let effect of effects) {
                if (effect instanceof StringEffect_1.StringEffect) {
                    let str = effect.str;
                    if ((str === "Circle A is smaller than circle B." && circleA.w < circleB.w && circleA.h < circleB.h)
                        || (str === "Circle A is bigger than circle B." && circleA.w > circleB.w && circleA.h > circleB.h)) {
                        canvasIsCorrect = true;
                        break;
                    }
                }
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpSix = LessonThreeCpSix;

},{"../effects/EllipseEffect":13,"../effects/StringEffect":18}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpThree {
    constructor() {
        this._name = "l3c3";
        this._nextModule = 'l3c4';
        this._constraint = 'none';
        this._instructions = `<p> if statements allow you to run a block of code inside the curly braces {} ONLY when the condition inside the if() clause is true. </p>
    <p> Let's have a quick challenge: observe the CODE above. Make it so that the line "b is greater than 20" is only printed on the CANVAS when b is actually greater than 20. </p>
    <p> GOAL: Make the line "b is greater than 20" only be printed on the CANVAS when b is actually greater than 20. Change b to test the if() statement. </p>`;
        this._starterCode = `b = 8;
if(b < 10) {
  print("b is greater than 20.", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /if\s*\(\s*b\s*>\s*20\s*\)/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "b is greater than 20.") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpThree = LessonThreeCpThree;

},{"../effects/StringEffect":18}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class LessonThreeCpTwo {
    constructor() {
        this._name = "l3c2";
        this._nextModule = 'l3c3';
        this._constraint = 'none';
        this._instructions = `<p> Did you notice the claim that "a is less than 10" did not change? a is now 12 and clearly greater than 10! </p>
    <p> What we want is for the computer to only print "a is less than 10" ONLY when the value of a is truly less than 10. </p>
    <p> To do so, we use an if statement. Observe the CODE above. All we changed was to put in an if statement that checks whether a < 10. If a is, the code inside the curly braces {} are executed. </p>
    <p> Change the value of a to 12, 10, 8 and observe what happens. </p>
    <p> GOAL: RUN the CODE with a = 12 or 10 or 8. </p>`;
        this._starterCode = `a = 12;
print(a, 118, 63);
if(a < 10) {
  print("a is less than 10", 103, 143);
}`;
    }
    /**
     * A lesson leading into conditionals
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /a\s*=\s*8\s*/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof StringEffect_1.StringEffect && effect.str === "a is less than 10") {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonThreeCpTwo = LessonThreeCpTwo;

},{"../effects/StringEffect":18}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpFive {
    constructor() {
        this._name = "l2c5";
        this._nextModule = 'l2c6';
        this._constraint = 'none';
        this._instructions = `<p> Did you see the CANVAS changed? </p>
    <p> In our code, we make variable a refer to the words "moo moo", and variable b refer to an ellipse(100, 100). </p>
    <p> As a result, when we tell the computer to print a, it will print "moo moo", and when we tell the computer to print b, it will print a circle. </p>
    <p> Let's take this one step further: Create a new variable c, and make it refer to an ellipse(100, 100). Then write 2 statements to print c. What do you think would happen? </p>
    <p> GOAL: Create a variable c referring to an ellipse(100, 100), then write 2 print statements to print c. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let assignment = /c\s*=\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*/g;
            let matchAssign = code.match(assignment);
            let print = /print\s*\(\s*c\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)/g;
            let matchPrint = code.match(print);
            codeIsCorrect = matchAssign != null && matchAssign.length > 0 && matchPrint != null && matchPrint.length >= 2;
        }
        //check for correct CANVAS effects
        let circleCount = 0;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                circleCount += 1;
            }
        }
        return codeIsCorrect && circleCount >= 2;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpFive = LessonTwoCpFive;

},{"../effects/EllipseEffect":13}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpFour {
    constructor() {
        this._name = "l2c4";
        this._nextModule = 'l2c5';
        this._constraint = 'none';
        this._instructions = `<p> There's no limit to how many print statements the computer can understand, so you can write 1000 print statements, and the computer will draw 1000 things on the CANVAS for you! </p>
    <p> Time to take your coding to the next level. Let's learn about variables. </p>
    <p> Variables are simply names you give to the things that you draw. </p>
    <p> For example, take a look at the code above. Change the a in the print statement to b, and observe what happened on the CANVAS. </p>
    <p> GOAL: Change a to b in the print statement. </p>`;
        this._starterCode = `a = "moo moo";\nb = ellipse(100, 100);\nprint(a, 50, 70);`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*b\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\);/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = true;
        for (let effect of effects) {
            if (!canvasIsCorrect && effect instanceof EllipseEffect_1.EllipseEffect) {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpFour = LessonTwoCpFour;

},{"../effects/EllipseEffect":13}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpOne {
    constructor() {
        this._name = "l2c1";
        this._nextModule = 'l2c2';
        this._constraint = 'none';
        this._instructions = `<p> Printing only words is kinda boring, so let's learn to print some shapes on the CANVAS! </p>
    <p> In the print statement, replace "moo" with ellipse(100,100). Hit the RUN button to see what happens. </p>
    <p> GOAL: replace "moo" with ellipse(100,100) in the print statement above. </p>
    <p> HINT: Highlight "moo" - including the double quotes ", and replace that with ellipse(100, 100). KEEP EVERYTHING ELSE THE SAME. </p>`;
        this._starterCode = `
    print("moo", 50, 70)`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        //check for correct CODE
        let codeIsCorrect = false;
        let code = document.getElementById("input").value;
        if (code != null) {
            let regex = /print\s*\(\s*ellipse\s*\(\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)\s*,\s*[1-9][0-9]*\s*,\s*[1-9][0-9]*\s*\)/;
            let match = code.match(regex);
            codeIsCorrect = match != null && match.length > 0;
        }
        //check for correct CANVAS effects
        let canvasIsCorrect = false;
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                canvasIsCorrect = true;
                break;
            }
        }
        return codeIsCorrect && canvasIsCorrect;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpOne = LessonTwoCpOne;

},{"../effects/EllipseEffect":13}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberEffect_1 = require("../effects/NumberEffect");
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpSeven {
    constructor() {
        this._name = "l2c7";
        this._nextModule = 'l3c1';
        this._constraint = 'none';
        this._instructions = `<p> Changing one circle changes c, which will then in turn change the other circle! </p>
    <p> Now let's put all we have learned to practice. </p>
    <p> Create a circle, and print out the size of that circle in the given box. </p>
    <p> IF we ever change the circle, we want the number in the box to change, too! </p>
    <p> CHALLENGE: Create a circle and print its size in the given box. </p>`;
        this.x = 10;
        this.y = 430;
    }
    drawGuides(ctx) {
        ctx.beginPath();
        ctx.rect(this.x, this.y, 100, 100);
        ctx.strokeStyle = '#6C6C6C';
        ctx.stroke();
        ctx.font = 20 + "px Courier New";
        ctx.fillStyle = '#6C6C6C';
        ctx.fillText("Put circle's size", this.x, 390);
        ctx.fillText("in here", this.x, 410);
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof NumberEffect_1.NumberEffect && effect.num != null) {
                if (effect.x > this.x && effect.x < this.x + 100 && effect.y > this.y && effect.y < this.y + 100) {
                    let val = effect.num;
                    for (let effect2 of effects) {
                        if (effect2 instanceof EllipseEffect_1.EllipseEffect && (val == effect2.w || val == effect2.h)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpSeven = LessonTwoCpSeven;

},{"../effects/EllipseEffect":13,"../effects/NumberEffect":16}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpSix {
    constructor() {
        this._name = "l2c6";
        this._nextModule = 'l2c7';
        this._constraint = 'code';
        this._instructions = `<p> Now that you have drawn 2 circles both are called c, let's see what happens when you try to modify one of them. </p>
    <p> Click on one of the circles on the CANVAS, and try make it bigger. Observe what happens to your declaration of c. </p>
    <p> GOAL: Enlarge one of the circles referred to by c on the CANVAS. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                if (effect.w > 250 && effect.h > 250) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpSix = LessonTwoCpSix;

},{"../effects/EllipseEffect":13}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
const StringEffect_1 = require("../effects/StringEffect");
class LessonTwoCpThree {
    constructor() {
        this._name = "l2c3";
        this._nextModule = 'l2c4';
        this._constraint = 'none';
        this._instructions = `<p> So we can draw a circle and change it. But what if we want to draw both circles and words? </p>
    <p> Well, simple! Just write more print statements in the CODE area! </p>
    <p> GOAL: Draw 2 circles and a word on the CANVAS. </p>
    <p> HINT: Remember that the numbers right inside the ellipse(_,_) statement change the circle's sizes.`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document: The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        let stringExists = false;
        let circleCount = 0;
        for (let effect of effects) {
            if (!stringExists) {
                stringExists = effect instanceof StringEffect_1.StringEffect && effect.str !== "";
            }
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                circleCount += 1;
            }
        }
        return stringExists && circleCount >= 2;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpThree = LessonTwoCpThree;

},{"../effects/EllipseEffect":13,"../effects/StringEffect":18}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class LessonTwoCpTwo {
    /*
    `<p> So we can draw a circle and change it. But what if we want to draw both a circle and a word? </p>
    <p> Well, simple! Just write another print statement in the CODE area! </p>
    <p> GOAL: Draw 2 circles and a word on the CANVAS. </p>
    <p> HINT: Remember that the numbers right inside the ellipse(_,_) statement change the circle's sizes.`;
*/
    constructor() {
        this._name = "l2c2";
        this._nextModule = 'l2c3';
        this._constraint = 'code';
        this._instructions = `<p> We can write ellipse(100, 100) in the print statement to draw a circle on the CANVAS. </p>
    <p> What are the numbers (100, 100) for? I'm glad you asked... </p>
    <p> Because the CODE area is frozen again! Drag one of the 9 white tips around the circle on the CANVAS to see how the number changes! </p>
    <p> GOAL: Make the circle wider but shorter. </p>`;
    }
    /**
     * A lesson to print a string
     * goals: moving the text and observe the code
     * @param document The HTML document
     * @param effects: the list of effects currently on the CANVAS
     */
    checkGoal(document, effects) {
        for (let effect of effects) {
            if (effect instanceof EllipseEffect_1.EllipseEffect) {
                if (effect.w > 200 && effect.h < 80) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Returns the module name
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the module instructions
     */
    get instructions() {
        return this._instructions;
    }
}
exports.LessonTwoCpTwo = LessonTwoCpTwo;

},{"../effects/EllipseEffect":13}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../../index");
const index_2 = require("../../index");
const index_3 = require("../../index");
const index_4 = require("../../index");
class ModuleGenerator {
    constructor(isDM) {
        this.dmConstructors = new Map([
            ['l1c1', () => new index_1.LessonOneCpOne()],
            ['l1c2', () => new index_1.LessonOneCpTwo()],
            ['l1c3', () => new index_1.LessonOneCpThree()],
            ['l1c4', () => new index_1.LessonOneCpFour()],
            ['l2c1', () => new index_2.LessonTwoCpOne()],
            ['l2c2', () => new index_2.LessonTwoCpTwo()],
            ['l2c3', () => new index_2.LessonTwoCpThree()],
            ['l2c4', () => new index_2.LessonTwoCpFour()],
            ['l2c5', () => new index_2.LessonTwoCpFive()],
            ['l2c6', () => new index_2.LessonTwoCpSix()],
            ['l2c7', () => new index_2.LessonTwoCpSeven()],
            ['l3c1', () => new index_3.LessonThreeCpOne()],
            ['l3c2', () => new index_3.LessonThreeCpTwo()],
            ['l3c3', () => new index_3.LessonThreeCpThree()],
            ['l3c4', () => new index_3.LessonThreeCpFour()],
            ['l3c5', () => new index_3.LessonThreeCpFive()],
            ['l3c6', () => new index_3.LessonThreeCpSix()],
            ['l4c1', () => new index_4.LessonFourCpOne()],
            ['l4c2', () => new index_4.LessonFourCpTwo()]
        ]);
        this.nonDmConstructors = new Map([
            ['l1c1', () => new index_1.LessonOneCpOne()],
            ['l1c2', () => new index_1.LessonOneCpThree()],
            ['l1c3', () => new index_1.LessonOneCpFour()],
            ['l2c1', () => new index_2.LessonTwoCpOne()],
            ['l2c2', () => new index_2.LessonTwoCpThree()],
            ['l2c3', () => new index_2.LessonTwoCpFour()],
            ['l2c4', () => new index_2.LessonTwoCpFive()],
            ['l2c5', () => new index_2.LessonTwoCpSeven()],
            ['l3c1', () => new index_3.LessonThreeCpOne()],
            ['l3c2', () => new index_3.LessonThreeCpTwo()],
            ['l3c3', () => new index_3.LessonThreeCpThree()],
            ['l3c4', () => new index_3.LessonThreeCpFour()],
            ['l3c5', () => new index_3.LessonThreeCpFive()],
            ['l3c6', () => new index_3.LessonThreeCpSix()],
            ['l4c1', () => new index_4.LessonFourCpOne()],
            ['l4c2', () => new index_4.LessonFourCpTwo()]
        ]);
        this.checkpoints = new Map([
            ['l1c1', null],
            ['l1c2', null],
            ['l1c3', null],
            ['l1c4', null],
            ['l2c1', null],
            ['l2c2', null],
            ['l2c3', null],
            ['l2c4', null],
            ['l2c5', null],
            ['l2c6', null],
            ['l2c7', null],
            ['l3c1', null],
            ['l3c2', null],
            ['l3c3', null],
            ['l3c4', null],
            ['l3c5', null],
            ['l3c6', null],
            ['l4c1', null],
            ['l4c2', null]
        ]);
        if (isDM) {
            this.curConstructors = this.dmConstructors;
        }
        else {
            this.curConstructors = this.nonDmConstructors;
        }
    }
    generateCheckpoint(cp) {
        let checkpoint = this.checkpoints.get(cp);
        if (checkpoint != null) {
            return checkpoint;
        }
        checkpoint = this.curConstructors.get(cp)();
        this.checkpoints.set(cp, checkpoint);
        return checkpoint;
    }
}
exports.ModuleGenerator = ModuleGenerator;

},{"../../index":1}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pants_1 = require("pants");
const index_1 = require("../../index");
const space_lift_1 = require("space-lift");
var Parser;
(function (Parser) {
    /**
     * to be moved to Pants
     * number parses numbers by repeatedly applying the digit parser
     */
    function number() {
        return (istream) => {
            const o = pants_1.Primitives.many1(pants_1.Primitives.digit())(istream);
            switch (o.tag) {
                case "success":
                    let s = "";
                    for (let digit of o.result) {
                        s += digit.toString();
                    }
                    return new pants_1.Primitives.Success(o.inputstream, parseFloat(s));
                case "failure":
                    return o;
            }
        };
    }
    Parser.number = number;
    /**
     * to be moved to Pants
     * string is an arbitrary string parser that repeatedly applies the letter primitive
     * returns a CharStream representing the entire parsed string
     */
    function string() {
        let p = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.many1(pants_1.Primitives.letter()));
        let f = (xs) => pants_1.CharUtil.CharStream.concat(xs);
        return pants_1.Primitives.appfun(p)(f);
    }
    Parser.string = string;
    /**
     * to be moved to Pants
     * punctuation parses all possible punctuation characters
     */
    function punctuation() {
        return pants_1.Primitives.sat(x => x == "!"
            || x == "."
            || x == ','
            || x == ";"
            || x == '?'
            || x == "-"
            || x == "&"
            || x == '$'
            || x == ':'
            || x == '/'
            || x == '|'
            || x == '%'
            || x == '#'
            || x == "@"
            || x == "~"
            || x == '`'
            || x == '*'
            || x == '^'
            || x == '{'
            || x == '}'
            || x == "["
            || x == ']'
            || x == '('
            || x == ")"
            || x == "'"
            || x == "_");
    }
    Parser.punctuation = punctuation;
    let id = (x) => x;
    //let effects: Effect<any>[] = [];
    /**
     * parse is a function that wraps the input text in a CharStream
     * and passes it to the upper-level parse function
     * @param program a string representing program text
     */
    function parse(program) {
        program += "\n";
        //printOffset = -1;
        //this.effects = effects;
        let o = Parser.ExpressionParser(new pants_1.CharUtil.CharStream(program));
        switch (o.tag) {
            case "success":
                return space_lift_1.Some(o.result);
            case "failure":
                return space_lift_1.None;
        }
    }
    Parser.parse = parse;
    /**
     * Expression parser first searches for the first expression of a sequence and either
     * another expression or the end of the program (NOP) and returns a sequence node
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParser = i => {
        let f = (tup) => {
            return new index_1.SequenceNode(tup[0], tup[1]);
        };
        let p = pants_1.Primitives.seq(Parser.ExpressionParserNoSeq)(pants_1.Primitives.right(pants_1.Primitives.choice(pants_1.Primitives.char(';'))(pants_1.Primitives.nl()))(pants_1.Primitives.choice(pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser))(pants_1.Primitives.appfun(pants_1.Primitives.ws())(_ => new index_1.NOP()))))(f);
        return p(i);
    };
    /**
     * Searches through all possible expressions except for sequences
     * used to avoid infinite looping in upper level parse
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParserNoSeq = i => {
        let p1 = pants_1.Primitives.choice(lNumber())(lstring2());
        let p2 = pants_1.Primitives.choice(varNameParse())(p1);
        let p3 = pants_1.Primitives.choice(BoolParse())(p2);
        let p4 = pants_1.Primitives.choice(varDecParse())(p3);
        let p5 = pants_1.Primitives.choice(Parser.unOpsExpr)(p4);
        let p6 = pants_1.Primitives.choice(Declare())(p5);
        let p7 = pants_1.Primitives.choice(Parser.binOpExpr)(p6);
        let p8 = pants_1.Primitives.choice(LogicExpr())(p7);
        let p9 = pants_1.Primitives.choice(Parser.ListHead)(p8);
        let p10 = pants_1.Primitives.choice(Parser.funApp)(p9);
        let p11 = pants_1.Primitives.choice(Parser.returnParser)(p10);
        let p12 = pants_1.Primitives.choice(Parser.condParse)(p11);
        let p13 = pants_1.Primitives.choice(Parser.WhileLoop)(p12);
        let p14 = pants_1.Primitives.choice(Parser.ForLoop)(p13);
        let p15 = pants_1.Primitives.choice(Parser.funDef)(p14);
        return p15(i);
    };
    /**
     * Searches through all possible expressions except for binOp expressions
     * used to avoid infinite looping in the binary expression parser
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParserNoBinOp = i => {
        let p1 = pants_1.Primitives.choice(lNumber())(lstring2());
        let p2 = pants_1.Primitives.choice(varNameParse())(p1);
        let p3 = pants_1.Primitives.choice(BoolParse())(p2);
        let p4 = pants_1.Primitives.choice(varDecParse())(p3);
        let p5 = pants_1.Primitives.choice(Parser.unOpsExpr)(p4);
        let p6 = pants_1.Primitives.choice(Declare())(p5);
        let p7 = pants_1.Primitives.choice(Parser.ListHead)(p6);
        let p8 = pants_1.Primitives.choice(Parser.funApp)(p7);
        let p9 = pants_1.Primitives.choice(Parser.returnParser)(p8);
        let p10 = pants_1.Primitives.choice(Parser.condParse)(p9);
        let p11 = pants_1.Primitives.choice(Parser.WhileLoop)(p10);
        let p12 = pants_1.Primitives.choice(Parser.ForLoop)(p11);
        let p13 = pants_1.Primitives.choice(Parser.funDef)(p12);
        return p13(i);
    };
    /**
     * Searches through all possible expressions except for logical expressions
     * used to avoid infinite looping in the logical expression parser
     * @param i a nonsense parameter used to avoid bug of eager parsing
     */
    Parser.ExpressionParserNoLogic = i => {
        let p1 = pants_1.Primitives.choice(lNumber())(lstring2());
        let p2 = pants_1.Primitives.choice(varNameParse())(p1);
        let p3 = pants_1.Primitives.choice(BoolParse())(p2);
        let p4 = pants_1.Primitives.choice(varDecParse())(p3);
        let p5 = pants_1.Primitives.choice(Parser.unOpsExpr)(p4);
        let p6 = pants_1.Primitives.choice(Declare())(p5);
        let p7 = pants_1.Primitives.choice(Parser.binOpExpr)(p6);
        let p8 = pants_1.Primitives.choice(Parser.ListHead)(p7);
        let p9 = pants_1.Primitives.choice(Parser.funApp)(p8);
        let p10 = pants_1.Primitives.choice(Parser.returnParser)(p9);
        let p11 = pants_1.Primitives.choice(Parser.condParse)(p10);
        let p12 = pants_1.Primitives.choice(Parser.WhileLoop)(p11);
        let p13 = pants_1.Primitives.choice(Parser.ForLoop)(p12);
        let p14 = pants_1.Primitives.choice(Parser.funDef)(p13);
        return p14(i);
    };
    /**
     * lNumber is used to wrap parsed numbers in NumberNodes for the AST
     */
    function lNumber() {
        return (istream) => {
            let o = number()(istream);
            switch (o.tag) {
                case "success":
                    return new pants_1.Primitives.Success(o.inputstream, new index_1.NumberNode(o.result));
                case "failure":
                    return o;
            }
        };
    }
    Parser.lNumber = lNumber;
    /**
     * binOpsChar parses all possible binary operators, such as + or -
     */
    function binOpsChar() {
        return (istream) => {
            return pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.sat(x => x == "+"
                || x == "-"
                || x == "/"
                || x == "="
                || x == "*"))(istream);
        };
    }
    Parser.binOpsChar = binOpsChar;
    /**
     * binOpsShort returns a tuple where the first element is the binary operator (CharStream)
     * and the second element is the expression to the right of the operator (Expression<{}>)
     */
    function binOpShort() {
        return pants_1.Primitives.seq(binOpsChar())(Parser.ExpressionParserNoSeq)((x) => x);
    }
    Parser.binOpShort = binOpShort;
    /**
     * binOpExpr parses all possible binary operation expressions and returns the
     * corresponding AST node construct (also parses postfix increments/decrements like i++)
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.binOpExpr = i => {
        var f = (tup) => {
            let lhs = tup[0];
            let op = tup[1][0];
            let rhs = tup[1][1];
            switch (op.toString()) {
                case "+":
                    return new index_1.PlusOp(lhs, rhs, ws);
                case "-":
                    return new index_1.MinusOp(lhs, rhs, ws);
                case "/":
                    return new index_1.DivOp(lhs, rhs, ws);
                case "*":
                    return new index_1.MulOp(lhs, rhs, ws);
                case "=":
                    return new index_1.AssignOp(lhs, rhs, ws);
                default:
                    throw new Error("Binary Operation not supported");
            }
        };
        let p1 = pants_1.Primitives.choice(Parser.ExpressionParserNoBinOp)(varDecParse());
        let p2 = binOpShort();
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let postPlus = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.ExpressionParserNoBinOp))(pants_1.Primitives.str('++'))(tup => { return new index_1.Increment(tup[0], ws); });
        let postMinus = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.ExpressionParserNoBinOp))(pants_1.Primitives.str('--'))(tup => { return new index_1.Decrement(tup[0], ws); });
        let binOp = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(p1))(p2)(f);
        return pants_1.Primitives.choice(binOp)(pants_1.Primitives.choice(postPlus)(postMinus))(i);
    };
    /**
     * unOpsChar parses all possible unary operators
     * Only negations are supported, but more can be added as needed
     * @param i nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.unOpsChar = i => {
        return pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char("-"))(i);
    };
    /**
     * unOpsExpr wraps a unary operation expression in the corresponding
     * AST node and returns it
     * @param i nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.unOpsExpr = i => {
        var f = (tup) => {
            return new index_1.NegOp(tup[1], ws);
        };
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        return pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.unOpsChar))(Parser.ExpressionParserNoSeq)(f)(i);
    };
    /**
     * lstring parses valid strings in the SWELL language
     * a valid string is surrounded by quotations and consists of letters, numbers, punctuation, and/or whitespace
     */
    function lstring() {
        let p1 = pants_1.Primitives.choice(pants_1.Primitives.choice(pants_1.Primitives.letter())(pants_1.Primitives.ws1()))(pants_1.Primitives.digit());
        //let p1 = Primitives.choice(Primitives.letter())(Primitives.ws1());
        let p = pants_1.Primitives.between(pants_1.Primitives.str("\""))(pants_1.Primitives.str("\""))(pants_1.Primitives.many(pants_1.Primitives.choice(p1)(punctuation())));
        let f = (xs) => pants_1.CharUtil.CharStream.concat(xs);
        return pants_1.Primitives.appfun(p)(f);
    }
    Parser.lstring = lstring;
    /**
     * lstring2 wraps strings parsed by lstring in StrinNode objects and returns them
     */
    function lstring2() {
        return (istream) => {
            let ws = "";
            let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
            let o = pants_1.Primitives.right(precedingWS)(lstring())(istream);
            switch (o.tag) {
                case "success":
                    return new pants_1.Primitives.Success(o.inputstream, new index_1.StringNode(o.result.toString(), ws));
                case "failure":
                    return o;
            }
        };
    }
    Parser.lstring2 = lstring2;
    /**
     * varNameParse parses valid variable names
     * variable names in SWELL begin with a lowercase char and are followed
     * by letters or digits
     */
    function varNameParse() {
        var f = (tup) => {
            return new index_1.VariableNode(tup[0].toString() + pants_1.CharUtil.CharStream.concat(tup[1]).toString(), ws);
        };
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let firstChar = pants_1.Primitives.right(precedingWS)(pants_1.Primitives.lower());
        let nextChars = pants_1.Primitives.many(pants_1.Primitives.choice(pants_1.Primitives.digit())(pants_1.Primitives.letter()));
        return pants_1.Primitives.seq(firstChar)(nextChars)(f);
    }
    Parser.varNameParse = varNameParse;
    /**
     * varDecParse parses valid variable declarations in the form "var x"
     * the parser then wraps the parsed value in a variable node for the AST
     */
    function varDecParse() {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str("var"));
        let varName = pants_1.Primitives.between(pants_1.Primitives.ws1())(pants_1.Primitives.ws())(varNameParse());
        let p = pants_1.Primitives.seq(p1)(varName)(tup => tup[1]);
        return p;
    }
    Parser.varDecParse = varDecParse;
    /**
     * Declare parses variable declarations in the form "var x = 2"
     * and returns a DeclareOp node
     */
    function Declare() {
        let eq = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('='));
        let p1 = pants_1.Primitives.left(varDecParse())(eq);
        return pants_1.Primitives.seq(p1)(Parser.ExpressionParserNoSeq)(tup => { return new index_1.DeclareOp(tup[0], tup[1]); });
    }
    Parser.Declare = Declare;
    /**
     * ListHead parses all lists in the SWELL language, including empty lists
     * Lists are surrounded by square brackets and each element is separated by a comma
     * returns a listNode object
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.ListHead = i => {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p0 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let p1 = pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.char('[')))(p0);
        var f = (tup) => {
            let hd = tup[0];
            let res = [hd];
            let tail = tup[1];
            for (let elem of tail) {
                res.push(elem);
            }
            return new index_1.ListNode(res, ws);
        };
        let p2 = pants_1.Primitives.seq(p1)(ListTail())(f);
        let p3 = pants_1.Primitives.appfun(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('[]')))(_ => new index_1.ListNode([], ws));
        return pants_1.Primitives.choice(p3)(p2)(i);
    };
    /**
     * List Tail parses second through last elements of a list, each separated by a comma
     * returns an array of Expressions that will be accessed by ListHead
     */
    function ListTail() {
        let p0 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char(','))(p0);
        let p2 = pants_1.Primitives.left(pants_1.Primitives.many(p1))(pants_1.Primitives.char(']'));
        return p2;
    }
    Parser.ListTail = ListTail;
    /**
     * funDefArgList parses argument lists for function definitions,
     * surrounded by parens and separated by commas
     * returns an array of the parameters
     */
    function funDefArgList() {
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char('('))(string());
        var f = (tup) => {
            let hd = tup[0].toString();
            let res = [hd];
            let tail = tup[1];
            for (let elem of tail) {
                res.push(elem.toString());
            }
            return res;
        };
        let p2 = pants_1.Primitives.seq(p1)(funDefArgListTail())(f);
        let p3 = pants_1.Primitives.appfun(pants_1.Primitives.str('()'))(_ => []);
        return pants_1.Primitives.choice(p3)(p2);
    }
    Parser.funDefArgList = funDefArgList;
    /**
     * funDefArgListTail parses the second through last elements of a function definition parameter list
     * parameters are separated by commas and end with a closing parens
     * returns an array of parameters, which is accessed by funDefArgList
     */
    function funDefArgListTail() {
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char(','))(string());
        let p2 = pants_1.Primitives.left(pants_1.Primitives.many(p1))(pants_1.Primitives.char(')'));
        return p2;
    }
    /**
     * funAppArgList parses argument lists for function applications, including empty args lists
     * the parser returns an array of Expression objects that represent the arguments
     */
    function funAppArgList() {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let p1 = pants_1.Primitives.right(pants_1.Primitives.char('('))(expr);
        var f = (tup) => {
            let hd = tup[0];
            let res = [hd];
            let tail = tup[1];
            for (let elem of tail) {
                res.push(elem);
            }
            return res;
        };
        let p2 = pants_1.Primitives.seq(p1)(funAppArgListTail())(f);
        let p3 = pants_1.Primitives.appfun(pants_1.Primitives.str('()'))(_ => []);
        return pants_1.Primitives.choice(p3)(p2);
    }
    Parser.funAppArgList = funAppArgList;
    /**
     * funAppArgListTail parses the second through last elements of an argument list
     * each element is separated by a comma
     * returns an array of Expression objects, later accessed by funAppArgsList
     */
    function funAppArgListTail() {
        let comma = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char(','));
        let p1 = pants_1.Primitives.right(comma)(Parser.ExpressionParserNoSeq);
        let p2 = pants_1.Primitives.left(pants_1.Primitives.many(p1))(pants_1.Primitives.right(pants_1.Primitives.ws())(pants_1.Primitives.char(')')));
        return p2;
    }
    /**
     * returnParser parses valid return statements in the form "return x"
     * wraps the parsed value in a Return node for the AST
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.returnParser = i => {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p = pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('return')))(expr);
        var f = (e) => { return new index_1.Return(e, ws); };
        return pants_1.Primitives.appfun(p)(f)(i);
    };
    /**
     * funDef parses valid function definitions in the form "fun functionName(argList){ body;}"
     * the parser returns a funDef node for the AST
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.funDef = i => {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        return pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('fun')))(pants_1.Primitives.seq(
        /* function name */
        pants_1.Primitives.appfun(string())(cs => cs.toString()))(pants_1.Primitives.seq(
        /* function arguments */
        funDefArgList())(pants_1.Primitives.right(
        /* function body */
        pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{')))(pants_1.Primitives.left(pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser))(pants_1.Primitives.char('}'))))(id))(
        // create the AST node
        (tup) => {
            let fname = tup[0];
            let args = tup[1][0];
            let body = tup[1][1];
            return new index_1.FunDef(fname, body, args, ws);
        }))(i);
    };
    let printOffset = -1;
    let boundingRects = [];
    //TODO
    function getNonOverlappingCoords() {
        return [0, 0];
    }
    Parser.getNonOverlappingCoords = getNonOverlappingCoords;
    /**
     * funApp parses valid function applications in the form "functionName(argsList)" and returns a funApp node
     * parser checks for built-in functions, like print, ellipse, and rect; and returns the valid AST node
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.funApp = i => {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        return pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(string()))(funAppArgList())(tup => {
            let fname = tup[0].toString();
            switch (fname) {
                case "print":
                    if (tup[1].length == 3) {
                        //boundingRects.push([tup[1][0].width, tup[1][0].height, tup[1][1], tup[1][2]]);
                        return new index_1.PrintNode(tup[1][0], new index_1.Dimensions(tup[1][1], tup[1][2], new index_1.NumberNode(1)), ws);
                    }
                    printOffset = (printOffset + 1) % 12;
                    console.log("printOffset: " + printOffset);
                    return new index_1.PrintNode(tup[1][0], new index_1.Dimensions(new index_1.NumberNode(100 + 100 * (printOffset % 3)), new index_1.NumberNode(100 + 100 * (printOffset / 4)), new index_1.NumberNode(1)), ws);
                case "ellipse":
                    if (tup[1].length == 2) {
                        return new index_1.EllipseNode(tup[1][0], tup[1][1], ws);
                    }
                case "rect":
                    if (tup[1].length == 2) {
                        return new index_1.RectangleNode(tup[1][0], tup[1][1], ws);
                    }
                case "line":
                    if (tup[1].length == 2) {
                        return new index_1.LineNode(tup[1][0], tup[1][1], ws);
                    }
                case "curve":
                    if (tup[1].length == 3) {
                        return new index_1.CurveNode(tup[1][0], tup[1][1], tup[1][2], ws);
                    }
                case "eph":
                    if (tup[1].length == 2) {
                        return new index_1.EphNode(tup[1][0], tup[1][1], ws);
                    }
            }
            let args = tup[1];
            return new index_1.FunApp(fname, args, ws);
        })(i);
    };
    /**
     * BoolParse parses valid booleans, true and false, and returns a BooleanNode
     */
    function BoolParse() {
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.appfun(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('true')))(_ => new index_1.BooleanNode(true, ws));
        let p2 = pants_1.Primitives.appfun(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('false')))(_ => new index_1.BooleanNode(false, ws));
        return pants_1.Primitives.choice(p1)(p2);
    }
    Parser.BoolParse = BoolParse;
    /**
     * logicChar parses all logical operators in the SWELL language and returns the consumed operator
     */
    function logicChar() {
        var logicChar = ["equals", '==', 'and', '>', '<', 'not equals', 'or'];
        var logicChar2 = ['>=', '<='];
        let p1 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.strSat(logicChar));
        let p2 = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.strSat(logicChar2));
        return pants_1.Primitives.choice(p2)(p1);
    }
    Parser.logicChar = logicChar;
    /**
     * logicShort returns a tuple, where the first element represents the logical operator and
     * the second element is the expression to the right of the operator
     */
    function logicShort() {
        return pants_1.Primitives.seq(logicChar())(Parser.ExpressionParserNoSeq)((x) => x);
    }
    Parser.logicShort = logicShort;
    /**
     * logicExpr parses logical expressions and returns the corresponding AST node
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    function LogicExpr() {
        // TODO: Dan (2018-11-19), shouldn't parameterized type be BooleanNode?
        var f = (tup) => {
            let lhs = tup[0];
            let op = tup[1][0];
            let rhs = tup[1][1];
            switch (op.toString()) {
                case "equals":
                    return new index_1.Equals(lhs, rhs, ws);
                case "==":
                    return new index_1.Equals(lhs, rhs, ws);
                case "and":
                    return new index_1.And(lhs, rhs, ws);
                case ">":
                    return new index_1.GreaterThan(lhs, rhs, ws);
                case "<":
                    return new index_1.LessThan(lhs, rhs, ws);
                case ">=":
                    return new index_1.GreaterThanEq(lhs, rhs, ws);
                case "<=":
                    return new index_1.LessThanEq(lhs, rhs, ws);
                case "or":
                    return new index_1.Or(lhs, rhs, ws);
                case "not equals":
                    return new index_1.NotEqual(lhs, rhs, ws);
                default:
                    throw new Error("Logical expression not supported");
            }
        };
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let not = pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('not'));
        let p1 = pants_1.Primitives.right(not)(Parser.ExpressionParserNoSeq);
        let notExpr = pants_1.Primitives.appfun(p1)(x => new index_1.Not(x, ws));
        let logicExpr = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(Parser.ExpressionParserNoLogic))(logicShort())(f);
        return pants_1.Primitives.choice(notExpr)(logicExpr);
    }
    Parser.LogicExpr = LogicExpr;
    /**
     * IfParse parses valid if statements in the form "if(condition){ body; }"
     * returns an array where the first elem is the condition and the second is the body
     */
    function IfParse() {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let bodyParse = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let p1 = pants_1.Primitives.seq(pants_1.Primitives.str('if'))(pants_1.Primitives.char('('))(x => x);
        let cond = pants_1.Primitives.between(p1)(pants_1.Primitives.char(')'))(expr);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(bodyParse);
        return pants_1.Primitives.seq(cond)(body)(x => x);
    }
    Parser.IfParse = IfParse;
    /**
      * IfElseParse parses valid if else statements in the form "if(condition){ body; } else{ body2;}"
      * returns an array where the first elem is the condition and the second is the first body and the third is body2
      */
    function IfElseParse() {
        let e = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.str('else'));
        let body = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let body2 = pants_1.Primitives.between(pants_1.Primitives.str('{'))(pants_1.Primitives.str('}'))(body);
        let elseParse = pants_1.Primitives.right(e)(body2);
        var f = (tup) => {
            tup[0].push(tup[1]);
            return tup[0];
        };
        return pants_1.Primitives.seq(IfParse())(elseParse)(f);
    }
    Parser.IfElseParse = IfElseParse;
    /**
     * condParse parses possible conditional statements, including if and if/else statements
     * returns a Conditional node
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.condParse = i => {
        var f = (tup) => {
            if (tup.length == 3) {
                return new index_1.Conditional(tup[0], tup[1], tup[2]);
            }
            else {
                return new index_1.Conditional(tup[0], tup[1]);
            }
        };
        return pants_1.Primitives.appfun(pants_1.Primitives.choice(IfElseParse())(IfParse()))(f)(i);
    };
    /**
     * WhileLoop parses valid while loops in the form "while(condition) { body;}"
     * returns a WhileNode for the AST
     */
    Parser.WhileLoop = i => {
        let expr = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParserNoSeq);
        let bodyParse = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.seq(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str("while")))(pants_1.Primitives.char('('))(x => x);
        let cond = pants_1.Primitives.between(p1)(pants_1.Primitives.char(')'))(expr);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(bodyParse);
        var f = (tup) => { return new index_1.WhileNode(tup[0], tup[1], ws); };
        return pants_1.Primitives.seq(cond)(body)(f)(i);
    };
    /**
     * ForLoop parses valid for loops in the form "for(initial, condition, post) { body;}" and returns a ForNode
     * @param i a nonsense parameter used to avoid the bug with eager evaluation
     */
    Parser.ForLoop = i => {
        let args = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(funAppArgList());
        let ws = "";
        let precedingWS = pants_1.Primitives.appfun(pants_1.Primitives.ws())(x => ws = x.toString());
        let p1 = pants_1.Primitives.right(pants_1.Primitives.right(precedingWS)(pants_1.Primitives.str('for')))(args);
        let curly = pants_1.Primitives.between(pants_1.Primitives.ws())(pants_1.Primitives.ws())(pants_1.Primitives.char('{'));
        let expr = pants_1.Primitives.between(pants_1.Primitives.choice(pants_1.Primitives.ws())(pants_1.Primitives.nl()))(pants_1.Primitives.ws())(Parser.ExpressionParser);
        let body = pants_1.Primitives.between(curly)(pants_1.Primitives.char('}'))(expr);
        var f = (tup) => {
            let init = tup[0][0];
            let cond = tup[0][1];
            let post = tup[0][2];
            let body = tup[1];
            return new index_1.ForNode(init, cond, post, body, ws);
        };
        return pants_1.Primitives.seq(p1)(body)(f)(i);
    };
    function singleComment() {
        let p1 = pants_1.Primitives.many1(pants_1.Primitives.item());
        let p2 = pants_1.Primitives.appfun(p1)(xs => pants_1.CharUtil.CharStream.concat(xs));
        return pants_1.Primitives.between(pants_1.Primitives.str('//'))(pants_1.Primitives.nl())(p2);
        //return Primitives.seq<CharUtil.CharStream, CharUtil.CharStream, CharUtil.CharStream[]>(Primitives.str('//'))(Primitives.nl())(x=>x);
    }
    Parser.singleComment = singleComment;
    function multiLineComment() {
        let p1 = pants_1.Primitives.many1(pants_1.Primitives.item());
        let p2 = pants_1.Primitives.appfun(p1)(xs => pants_1.CharUtil.CharStream.concat(xs));
        return pants_1.Primitives.between(pants_1.Primitives.str('\/**'))(pants_1.Primitives.str('*\/'))(p2);
    }
    Parser.multiLineComment = multiLineComment;
})(Parser = exports.Parser || (exports.Parser = {}));

},{"../../index":1,"pants":85,"space-lift":91}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BooleanNode {
    /**
     * Constructor for BooleanNode, a node representing a boolean
     * @param val The boolean value of the BooleanNode
     * @param ws Preceding white space
     */
    constructor(val, ws) {
        this._newLine = false;
        this._val = val;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    ;
    /**
     * Returns the BooleanNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * BooleanNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Returns whether this BooleanNode equals another
     * @param right The right side of the equality
     */
    equalsVal(right) {
        if (right instanceof BooleanNode) {
            return this.val === right.val;
        }
        return false;
    }
    /**
     * Returns a string representation of the BooleanNode
     */
    toString() {
        return this._ws + this._val;
    }
    /**
     * Returns the boolean value
     */
    get val() {
        return this._val;
    }
    /**
     * Sets the boolean value
     */
    set val(value) {
        this._val = value;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.BooleanNode = BooleanNode;

},{}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class NOP {
    constructor() {
        /* A NOP is a placeholder operation that evaluates to nothing */
        this._newLine = true;
    }
    /**
     * Returns the NOP
     * @param context
     */
    eval(context) {
        return this;
    }
    /**
     * NOPs cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("NOPs cannot be drawn.");
    }
    /**
     * Returns a string representation of the NOP
     */
    toString() {
        return "";
    }
    /**
     * Returns whether this NOP equals another (spoiler: it doesn't)
     * @param right
     */
    equalsVal(right) {
        return false;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.NOP = NOP;

},{}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberEffect_1 = require("../effects/NumberEffect");
// Nodes representing numbers
// Should abstract Node class implement Expression?
class NumberNode {
    /**
     * Constructor for a NumberNode, a node representing a number
     * @param val The number value
     * @param ws Preceding whitespace
     */
    constructor(val, ws) {
        this._newLine = false;
        this._val = val;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    ;
    /**
     * Returns this NumberNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * NumberNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        let e = new NumberEffect_1.NumberEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this NumberNode equals another NumberNode
     * @param right The right side of the equality (must be a NumberNode)
     */
    equalsVal(right) {
        if (right instanceof NumberNode) {
            return this.val === right.val;
        }
        return false;
    }
    /**
     * Returns a string representation of the NumberNode
     */
    toString() {
        return this._ws + this._val;
    }
    /**
     * Returns the number stored in the node
     */
    get val() {
        return this._val;
    }
    /**
     * Sets the value of the number stored in the node
     */
    set val(value) {
        this._val = value;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.NumberNode = NumberNode;

},{"../effects/NumberEffect":16}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StringEffect_1 = require("../effects/StringEffect");
class StringNode {
    /**
     * Constructor for a StringNode, a node representing a string
     * @param str The string stored in the node
     * @param ws Preceding whitespace
     */
    constructor(str, ws) {
        this._newLine = false;
        this._str = str;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this StringNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the String using StringEffect
     * @param context The current program context
     * @param dims The dimensions of the string to be drawn
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        let e = new StringEffect_1.StringEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this StringNode equals another StringNode
     * @param right The right side of the equality, must be a StringNode
     */
    equalsVal(right) {
        if (right instanceof StringNode) {
            return this.val === right.val;
        }
        return false;
    }
    /**
     * Returns a string representation of the StringNode
     */
    toString() {
        return this._ws + '\"' + this._str + '\"';
    }
    /**
     * Sets the string stored in the node
     */
    set str(value) {
        this._str = value;
    }
    /**
     * Returns the string stored in the node
     */
    get val() {
        return this._str;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.StringNode = StringNode;

},{"../effects/StringEffect":18}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ColorNode {
    /**
     * Constructor for a ColorNode, a node representing an RGB color
     */
    constructor(red, green, blue) {
        this._newLine = false;
        this._red = red;
        this._green = green;
        this._blue = blue;
    }
    ;
    /**
     * Evaluates into a string RGB value
     * @param context The current program context
     */
    eval(context) {
        return this._red + " " + this._green + " " + this._blue;
    }
    /**
     * ColorNodes cannot currently be drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Not implemented");
    }
    /**
     * Returns whether this ColorNode equals another ColorNode
     * @param right The right side of the equality (must be a BooleanNode)
     */
    equalsVal(right) {
        if (right instanceof ColorNode) {
            return (this.red === right.red && this.green === right.green && this.blue === right.blue);
        }
        return false;
    }
    /**
     * Returns a string representation of the ColorNode
     */
    toString() {
        return "";
    }
    /**
     * Returns the red value
     */
    get red() {
        return this._red;
    }
    /**
     * Sets the red value
     */
    set red(red) {
        this._red = red;
    }
    /**
     * Returns the green value
     */
    get green() {
        return this._green;
    }
    /**
     * Sets the green value
     */
    set green(green) {
        this._green = green;
    }
    /**
     * Returns the blue value
     */
    get blue() {
        return this._blue;
    }
    /**
     * Sets the blue value
     */
    set blue(blue) {
        this._blue = blue;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.ColorNode = ColorNode;

},{}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const CurveEffect_1 = require("../effects/CurveEffect");
class CurveNode {
    /**
     * Constructor for a CurveNode, a node representing a curve
     * @param dx the run of the curve
     * @param dy the rise of the curve
     * @param curvature how much the curve, umm, curves
     * @param ws Preceding whitespace
     */
    constructor(dx, dy, curvature, ws) {
        this._newLine = false;
        this._dx = dx;
        this._dy = dy;
        this._curvature = curvature;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this CurveNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the curve using CurveEffect
     * @param context The current program context
     * @param dims The line dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._dx.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._dy.eval(context).val, "");
        dims.curvature = new NumberNode_1.NumberNode(this._curvature.eval(context).val, "");
        let e = new CurveEffect_1.CurveEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this CurveNode equals another (if their dx, dy, and curvature are equal)
     * @param right The right side of the equality (must be a CurveNode)
     */
    equalsVal(right) {
        if (right instanceof CurveNode) {
            return (this.dx.equalsVal(right.dx) && this.dy.equalsVal(right.dy) && this.curvature.equalsVal(right.curvature));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the curve
     */
    toString() {
        return this._ws + "curve(" + this._dx.toString() + ", " + this._dy.toString() + ", " + this._curvature.toString() + ")";
    }
    /**
     * Returns the run of the curve
     */
    get dx() {
        return this._dx;
    }
    /**
     * Sets the run of the curve
     */
    set dx(dx) {
        this._dx = dx;
    }
    /**
     * Returns the rise of the curve
     */
    get dy() {
        return this._dy;
    }
    /**
     * Sets the rise of the curve
     */
    set dy(dy) {
        this._dy = dy;
    }
    /**
     * Returns the curvature of the curve
     */
    get curvature() {
        return this._curvature;
    }
    /**
     * Sets the curvature of the curve
     */
    set curvature(curvature) {
        this._curvature = curvature;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.CurveNode = CurveNode;

},{"../effects/CurveEffect":12,"../prims/NumberNode":65}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EllipseEffect_1 = require("../effects/EllipseEffect");
class EllipseNode {
    /**
     * Constructor for an EllipseNode, a node representing an ellipse
     * @param width The width of the ellipse
     * @param height The height of the ellipse
     * @param ws Preceding whitespace
     */
    constructor(width, height, ws) {
        this._newLine = false;
        this._width = width;
        this._height = height;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this EllipseNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the ellipse on the canvas using EllipseEffect
     * @param context The current program context
     * @param dims The dimensions of the ellipse
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = this._width;
        dims.height = this._height;
        let e = new EllipseEffect_1.EllipseEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this EllipseNode equals another EllipseNode (if their widths and heights are equal)
     * @param right The right side of the equality (must be an EllipseNode)
     */
    equalsVal(right) {
        if (right instanceof EllipseNode) {
            return (this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    /**
     * Returns a string representation of the ellipse
     */
    toString() {
        return this._ws + "ellipse(" + this._width.toString() + ", " + this._height.toString() + ")";
    }
    move() { }
    /**
     * Returns the ellipse width
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the ellipse width
     */
    set width(width) {
        this._width = width;
    }
    /**
    * Returns the ellipse height
    */
    get height() {
        return this._height;
    }
    /**
     * Sets the ellipse height
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.EllipseNode = EllipseNode;

},{"../effects/EllipseEffect":13}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const EphEffect_1 = require("../effects/EphEffect");
class EphNode {
    /**
     * Constructor for an EphNode, a node representing something very special
     * @param width The width of the EphNode
     * @param height The height of the EphNode
     * @param ws Preceding whitespace
     */
    constructor(width, height, ws) {
        this._newLine = false;
        //this._image = image;
        this._width = width;
        this._height = height;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this EphNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the rectangle using EphEffect
     * @param context The current program context
     * @param dims The rectangle dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._width.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._height.eval(context).val, "");
        let e = new EphEffect_1.EphEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this EphNode equals another (if their widths and heights are equal)
     * @param right The right side of the equality (must be an EphNode)
     */
    equalsVal(right) {
        if (right instanceof EphNode) {
            return (this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the EphNode
     */
    toString() {
        return this._ws + "eph(" + this._width.toString() + ", " + this._height.toString() + ")";
    }
    /**
     * Returns the width of the EphNode
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the EphNode
     */
    set width(width) {
        this._width = width;
    }
    /**
     * Returns the height of the EphNode
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the EphNode
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.EphNode = EphNode;

},{"../effects/EphEffect":14,"../prims/NumberNode":65}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const LineEffect_1 = require("../effects/LineEffect");
class LineNode {
    /**
     * Constructor for a LineNode, a node representing a line
     * @param dx the run of the line
     * @param dy the rise of the line
     * @param ws Preceding whitespace
     */
    constructor(dx, dy, ws) {
        this._newLine = false;
        this._dx = dx;
        this._dy = dy;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this LineNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the line using LineEffect
     * @param context The current program context
     * @param dims The line dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._dx.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._dy.eval(context).val, "");
        let e = new LineEffect_1.LineEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this LineNode equals another (if their dx and dy are equal)
     * @param right The right side of the equality (must be a LineNode)
     */
    equalsVal(right) {
        if (right instanceof LineNode) {
            return (this.dx.equalsVal(right.dx) && this.dy.equalsVal(right.dy));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the line
     */
    toString() {
        return this._ws + "line(" + this._dx.toString() + ", " + this._dy.toString() + ")";
    }
    /**
     * Returns the run of the line
     */
    get dx() {
        return this._dx;
    }
    /**
     * Sets the run of the line
     */
    set dx(dx) {
        this._dx = dx;
    }
    /**
     * Returns the rise of the line
     */
    get dy() {
        return this._dy;
    }
    /**
     * Sets the rise of the line
     */
    set dy(dy) {
        this._dy = dy;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.LineNode = LineNode;

},{"../effects/LineEffect":15,"../prims/NumberNode":65}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
const RectangleEffect_1 = require("../effects/RectangleEffect");
class RectangleNode {
    /**
     * Constructor for a RectangleNode, a node representing a rectangle
     * @param width The width of the rectangle
     * @param height The height of the rectangle
     * @param ws Preceding whitespace
     */
    constructor(width, height, ws) {
        this._newLine = false;
        this._width = width;
        this._height = height;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Returns this RectangleNode
     * @param context The current program context
     */
    eval(context) {
        return this;
    }
    /**
     * Draws the rectangle using RectangleEffect
     * @param context The current program context
     * @param dims The rectangle dimensions
     * @param ast The program AST
     */
    draw(context, dims, ast) {
        dims.width = new NumberNode_1.NumberNode(this._width.eval(context).val, "");
        dims.height = new NumberNode_1.NumberNode(this._height.eval(context).val, "");
        let e = new RectangleEffect_1.RectangleEffect(this);
        e.draw(context, dims, ast);
    }
    /**
     * Returns whether this RectangleNode equals another (if their widths and heights are equal)
     * @param right The right side of the equality (must be a RectangleNode)
     */
    equalsVal(right) {
        if (right instanceof RectangleNode) {
            return (this.width.equalsVal(right.width) && this.height.equalsVal(right.height));
        }
        return false;
    }
    move() { }
    /**
     * Returns a string representation of the rectangle
     */
    toString() {
        return this._ws + "rect(" + this._width.toString() + ", " + this._height.toString() + ")";
    }
    /**
     * Returns the width of the rectangle
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the rectangle
     */
    set width(width) {
        this._width = width;
    }
    /**
     * Returns the height of the rectangle
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the rectangle
     */
    set height(height) {
        this._height = height;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.RectangleNode = RectangleNode;

},{"../effects/RectangleEffect":17,"../prims/NumberNode":65}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NumberNode_1 = require("../prims/NumberNode");
class Dimensions {
    /**
     * Constructor for Dimensions, which stores object dimensions
     * @param x The x coordinate of the object
     * @param y The y coordinate of the object
     * @param scale The scale of the object
     * @param radius The radius of the object
     */
    constructor(x, y, scale, radius) {
        this._x = x;
        this._y = y;
        this._scale = scale;
        this._radius = radius || new NumberNode_1.NumberNode(30, "");
    }
    /**
     * Returns a string representation of the dimensions
     */
    toString() {
        return this.x.toString() + ", " + this.y.toString();
    }
    /**
     * Returns the x coordinate of the object
     */
    get x() {
        return this._x;
    }
    /**
     * Sets the x coordinate of the object
     */
    set x(val) {
        this._x = val;
    }
    /**
     * Returns the y coordinate of the object
     */
    get y() {
        return this._y;
    }
    /**
     * Sets the y coordinate of the object
     */
    set y(val) {
        this._y = val;
    }
    /**
     * Returns the radius of the object
     */
    get radius() {
        return this._radius;
    }
    /**
     * Sets the radius of the object
     */
    set radius(val) {
        this._radius = val;
    }
    /**
     * Returns the scale of the object
     */
    get scale() {
        return this._scale;
    }
    /**
     * Sets the scale of the object
     */
    set scale(val) {
        this._scale = val;
    }
    /**
     * Returns the width of the object
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the object
     */
    set width(val) {
        this._width = val;
    }
    /**
     * Returns the height of the object
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the object
     */
    set height(val) {
        this._height = val;
    }
    /**
     * Returns the curvature of the object
     */
    get curvature() {
        return this._curvature;
    }
    /**
     * Sets the curvature of the object
     */
    set curvature(val) {
        this._curvature = val;
    }
}
exports.Dimensions = Dimensions;

},{"../prims/NumberNode":65}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class PrintNode {
    /**
     * Constructor for a PrintNode, representing an object to be printed
     * @param toPrint The object to be printed
     * @param dimensions The dimensions of the object to be printed
     * @param ws Preceding whitespace
     */
    constructor(toPrint, dimensions, ws) {
        this._scale = 1;
        this._newLine = false;
        this._toPrint = toPrint;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
        this._dims = dimensions || null;
    }
    /**
     * Returns a string representation of the object to be printed
     */
    toString() {
        return this._ws + "print(" + this.toPrint.toString() + ", " + this.dims.toString() + ")";
    }
    /**
     * Equals cannot be called directly on a PrintNode
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on PrintNode");
    }
    /**
     * PrintNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw() on printOp");
    }
    /**
     * Evaluates the object to be printed and draws it
     * @param context
     */
    eval(context) {
        let res = this._toPrint.eval(context);
        res.draw(context, this._dims, this);
        return res;
    }
    /**
     * Returns the object to be printed
     */
    get toPrint() {
        return this._toPrint;
    }
    /**
     * Returns the dimensions of the object to be printed
     */
    get dims() {
        return this._dims;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.PrintNode = PrintNode;

},{}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ReturnError_1 = require("./ReturnError");
class Return {
    /**
     * Constructor for a Return object, representing something to be returned in a function
     * @param expr The expression to be returned
     * @param ws Preceding whitespace
     */
    constructor(expr, ws) {
        this._newLine = false;
        this._expr = expr;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the expression to be returned and returns via a ReturnErro
     * @param context The current program context
     */
    eval(context) {
        // If return val is a var, returns that var's value
        let result = this._expr.eval(context);
        throw new ReturnError_1.ReturnError(result, context.retIDLookup());
    }
    /**
     * Equals cannot be called directly on Return nodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on Return");
    }
    /**
     * Returns a string representation of the Return node
     */
    toString() {
        return this._ws + "return " + this._expr.toString();
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Return nodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw on Return");
    }
}
exports.Return = Return;

},{"./ReturnError":76}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ReturnError extends Error {
    /**
     * Constructor for ReturnError, a custom error class that we abuse to return values
     * @param retVal The value to be returned
     * @param ID The ID of the value to be returned
     */
    constructor(retVal, ID) {
        super(ID);
        this.retVal = retVal;
        this.ID = ID;
        Object.setPrototypeOf(this, ReturnError.prototype);
    }
}
exports.ReturnError = ReturnError;

},{}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const space_lift_1 = require("space-lift");
class Scope {
    /**
     * Constructor for Scope, an object keeping track of objects within a particular context
     * @param parent The parent Scope
     * @param effects Effects within this Scope
     * @param myState The scope state
     * @param eventLog The log of events that occurred
     */
    constructor(parent, effects, eventLog) {
        this._retValID = space_lift_1.None;
        this._canvas = space_lift_1.None;
        this._eventLog = []; // The event log
        this._hadFunEval = false; // Was this created in a function?
        //public globalFunID = Math.random();
        this.globalFunID = 10000000; // The global ID for functions in this context
        this._varBindings = new Map();
        this._parent = parent;
        this._effects = effects || null;
        this._eventLog = eventLog;
        if (this._parent != null && this._parent._hadFunEval)
            this._hadFunEval = true; // copy function eval flag from parent
    }
    /**
     * Copies information from this Scope into another Scope and returns the new Scope
     */
    copy() {
        let s = new Scope(this._parent, this._effects, this._eventLog);
        s.varBindings = new Map(this._varBindings);
        s.canvas = this.canvas;
        s.eventLog = this.eventLog;
        return s;
    }
    /**
     * Declares a new variable
     * @param name The name of the variable to be declared
     */
    declare(name) {
        if (this._varBindings.has(name)) {
            throw new Error("Scope already has var with name " + name);
        }
        this._varBindings.set(name, space_lift_1.None);
    }
    /**
     * Assigns a value to a variable in this Context
     * @param name The name of the variable
     * @param val The value of the variable
     */
    assign(name, val) {
        this._varBindings.set(name, space_lift_1.Some(val)); //Some(val)?
    }
    /**
     * Looks up a value within the Scope and all its ancestor Scopes
     * @param name The name of the value
     * @param context The context to search within
     */
    lookup(name, context) {
        if (context.varBindings.has(name)) {
            if (context.varBindings.get(name).isDefined()) {
                return (context.varBindings.get(name).get()); //extra get to manage Some()
            }
        }
        if (!(context.parent == null)) {
            return this.lookup(name, context.parent);
        }
        throw new Error("Variable could not be found.");
    }
    /**
     * Looks up and returns the return ID value
     */
    retIDLookup() {
        if (this._retValID.isDefined()) {
            return this._retValID.get();
        }
        else {
            if (this._parent) {
                return this._parent.retIDLookup();
            }
            else {
                throw new Error("Unknown caller.");
            }
        }
    }
    /**
     * Returns the Map of variable bindings
     */
    get varBindings() {
        return this._varBindings;
    }
    /**
     * Sets the Map of variable bindings
     */
    set varBindings(m) {
        this._varBindings = m;
    }
    /**
     * Returns the parent Scope
     */
    get parent() {
        return this._parent;
    }
    /**
     * Returns the return value ID
     */
    get retValID() {
        return this._retValID;
    }
    /**
     * Sets the return value ID
     */
    set retValID(val) {
        this._retValID = val;
    }
    /**
     * Returns the HTML canvas
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Sets the HTML canvas
     */
    set canvas(val) {
        this._canvas = val;
    }
    /**
     * Returns the effects array
     */
    get effects() {
        return this._effects;
    }
    /**
     * Sets the effects array
     */
    set effects(arr) {
        this._effects = arr;
    }
    /**
     * Returns the event log
     */
    get eventLog() {
        return this._eventLog;
    }
    /**
     * Sets the event log
     */
    set eventLog(update) {
        this._eventLog = update;
    }
    /**
     * Returns the array of effects
     */
    get mulSelArray() {
        return this._mulSelArray;
    }
    /**
     * Sets the array of effects
     */
    set mulSelArray(update) {
        this._mulSelArray = update;
    }
    /**
     * Returns whether this Scope was created in a function
     */
    get hadFunEval() {
        return this._hadFunEval;
    }
    /**
     * Sets whether this Scope was created in a function
     */
    set hadFunEval(val) {
        this._hadFunEval = val;
    }
}
exports.Scope = Scope;

},{"space-lift":91}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Scope_1 = require("./Scope");
const space_lift_1 = require("space-lift");
class SequenceNode {
    /**
     * Constructor for a SequenceNode, the building block of the AST
     * @param left The left side of the Sequence
     * @param right The right side of the Sequence
     */
    constructor(left, right) {
        this._newLine = true;
        this._left = left;
        this._right = right;
    }
    /**
     * Evaluates the children in postorder (left, right, parent)
     * @param context The current program context
     */
    eval(context) {
        let leftScope = new Scope_1.Scope(context, context.effects, context.eventLog);
        leftScope.canvas = space_lift_1.Some(context.canvas.get());
        //throwing away after evaling
        this._leftVal = this._left.eval(leftScope);
        this._rightVal = this._right.eval(leftScope); // leftScope may be modified now
    }
    /**
     * SequenceNodes cannot be directly drawn
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw() on SequenceNodes");
    }
    /**
     * Equals cannot be directly called on SequenceNodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on SequenceNode");
    }
    /**
     * Returns a string representation of the AST
     */
    toString() {
        let result = this._left.toString();
        if (this._left.newLine() == true) {
            result += '\n';
        }
        else {
            result += ";\n";
        }
        if (this._right.newLine() == false) {
            result += this._right.toString() + ";";
        }
        else {
            result += this._right.toString();
        }
        return result;
    }
    /**
     * Returns the left child
     */
    set left(left) {
        this._left = left;
    }
    /**
     * Sets the left child
     */
    get left() {
        return this._left;
    }
    /**
     * Returns the right child
     */
    set right(right) {
        this._right = right;
    }
    /**
     * Sets the right child
     */
    get right() {
        return this._right;
    }
    /**
     * Returns the value of the left chile
     */
    get leftVal() {
        return this._leftVal;
    }
    /**
     * Returns the value of the right chile
     */
    get rightVal() {
        return this._rightVal;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.SequenceNode = SequenceNode;

},{"./Scope":77,"space-lift":91}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../../index");
const index_2 = require("../../index");
const space_lift_1 = require("space-lift");
let canvas = document.querySelector('canvas');
let ctx = canvas.getContext("2d");
let inputBox = document.getElementById('input');
let lastWorkingInputText = "";
let starCount = 0;
//the effects array that holds all the text, ellipses, and rectangles
let effects = [];
let ast;
let context;
let showDebug = true; // flag to show or hide debug button
let masterLog = [];
let selectedElems = [];
let checkpoint = null;
let modGen = new index_2.ModuleGenerator(false);
let checkpointIsActive = false;
let textBoxSelected; //sees if the text box is selected
let canvasIsDisabled = false;
let selected = 0; //the number of selected effects if multiply selecting
let alreadyLogged = false;
let numLogged = 0;
let globalID = 1;
let eph;
/*
let bugButton = document.getElementById('debug');
if(!showDebug){
    bugButton.style.visibility='hidden';
}

bugButton.onclick = function(){
    printLog();
}
*/
/**
 * <div class="col-item">
 *  <button id='paint' style="background-color:#DFB534"> Run </button>
 * </div>
 *
 * Put this in html file for Run button's styling
 */
//let paintButton = document.getElementById('paint');
/**
 * makes the paint button paint text from the textarea to the canvas!
 */
/*
paintButton.onclick = function () {
    effects.length = 0; // slightly sketch clearing method to maintain reference to original array
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    isPainting = true;
    let inputText = inputBox.value;

    let astOpt = Parser.parse(inputText);
    if(astOpt.isDefined()){
        ast = astOpt.get();
        context = new Scope(null, effects, masterLog);
        context.canvas = Some(canvas);
        ast.eval(context); //this is where we draw the objects to the screen
    } else {
        let error = "error text";
        alert("Quan: so something with this syntax error: " + error);
    }

    //let paintEvt = new PaintEvent(inputText); // will need to get from ast when that's implemented

    // Adding context log to master log
    //logEvent.push(paintEvt.assembleLog());
    printLog();
    //event1.logItem();
    // }
};
*/
//clears the canvas!
let resetButton = document.getElementById('reset');
resetButton.onclick = function () {
    if (checkpoint._starterCode != null) {
        textBoxSelected = true;
        inputBox.value = checkpoint._starterCode;
    }
    context.eventLog.push(new index_2.ClearEvent());
    masterLog.push(context.eventLog[context.eventLog.length - 1]); // Does this actually work?
    printLog();
    //let clearEvt = new ClearEvent();
    //logEvent.push(clearEvt.assembleLog());
    //console.log("Log: " + logEvent);
};
let timer = null;
inputBox.onkeydown = function () {
    if (timer != null) {
        clearTimeout(timer);
    }
    timer = setTimeout(parse, 200);
};
function parse() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let inputText = inputBox.value;
    let astOpt = index_1.Parser.parse(inputText);
    effects.length = 0; // slightly sketch clearing method to maintain reference to original array
    if (astOpt.isDefined()) {
        ast = astOpt.get();
        context = new index_2.Scope(null, effects, masterLog);
        context.canvas = space_lift_1.Some(canvas);
        ast.eval(context); //this is where we draw the objects to the screen
        lastWorkingInputText = inputText;
    }
    //let paintEvt = new PaintEvent(inputText); // will need to get from ast when that's implemented
    // Adding context log to master log
    //logEvent.push(paintEvt.assembleLog());
    printLog();
    //event1.logItem();
    // }
}
/**
 * The animation function that basically recursively calls itself, clearing and
 * redrawing to the canvas at 60fps.
 */
function animate() {
    requestAnimationFrame(animate);
    ctx.clearRect(0, 0, canvas.width, canvas.height); //clears canvas
    selected = 0;
    for (let i = 0; i < effects.length; i++) {
        effects[i].update();
        if (effects[i].selected) {
            selectedElems.push(effects[i]);
            selected++;
        }
        if (effects[i].getJustDragged()) { // Logs drag event
            context.eventLog.push(new index_2.DragEvent(effects[i]));
            masterLog.push(context.eventLog[context.eventLog.length - 1]);
            effects[i].setJustDragged(false);
        }
        if (effects[i].idObj == undefined) { // Gives object an ID if it doesn't have one
            effects[i].initID(globalID);
            context.eventLog.push(new index_2.IDEvent(effects[i])); // Logs ID
            globalID++;
            //console.log(effects[i].getID());
        }
        // if(((effects[i] as EllipseEffect).justDragged)){
        //     //context.eventLog.push(new DragEvent(effects[i]));
        // }
    }
    // at this point, have iterated through all effects and have complete list to log
    if (selected != numLogged) { // if selections have changed, should log again
        alreadyLogged = false;
    }
    if (!alreadyLogged && selected >= 2) { // logs if hasn't already
        numLogged = selected;
        context.eventLog.push(new index_2.SelectEvent(selectedElems));
        masterLog.push(context.eventLog[context.eventLog.length - 1]);
        alreadyLogged = true;
    }
    //This does the prodirect manipulation, passing the new strings to the text box
    if (ast != undefined && !textBoxSelected) {
        let newInput = ast.toString();
        inputBox.value = newInput;
    }
    if (checkpointIsActive) {
        checkpointChecksGoal();
    }
    if (checkpoint != null && checkpoint.drawGuides != null) {
        checkpoint.drawGuides(ctx);
        /*
              if (checkpoint._name == "l1c3") {
                ctx.beginPath();
                ctx.rect(10, 430, 100, 100);
                ctx.strokeStyle = '#6C6C6C';
                ctx.stroke();
        
                ctx.font = 20 + "px Courier New";
                ctx.fillStyle = '#6C6C6C';
                ctx.fillText("Put text", 10, 390);
                ctx.fillText("in here", 10, 410);
              }
        */
    }
    selectedElems = [];
}
//checks to see whether the text box is selected
window.addEventListener('mousedown', isInputBoxSelected);
/**
 * This function manages the state of the UI when the text box is selected and when it isn't.
 * If it is inside the text box, isPainting is false and textBoxSelected is true.
 * If it's not, if it's inside the paint button, then isPainting = true.
 * @param event the mouse down event
 */
function isInputBoxSelected(event) {
    let mouseX = event.clientX;
    let mouseY = event.clientY;
    let rect = inputBox.getBoundingClientRect();
    if (mouseX > rect.left && mouseX < rect.right && mouseY > rect.top && mouseY < rect.bottom) {
        textBoxSelected = true;
    }
    else {
        textBoxSelected = false;
    }
}
//checks to see whether the text box is selected
window.addEventListener('mousedown', disabledCanvasIsSelected);
/**
 * This function handles the case when a disabled canvas is selected.
 * @param event the mouse down event
 */
function disabledCanvasIsSelected(event) {
    let mouseX = event.clientX;
    let mouseY = event.clientY;
    let rect = canvas.getBoundingClientRect();
    let popUp = document.getElementById('popup');
    if (canvasIsDisabled && mouseX > rect.left && mouseX < rect.right && mouseY > rect.top && mouseY < rect.bottom) {
        popUp.style.display = 'block';
    }
    else {
        popUp.style.display = 'none';
    }
}
function printLog() {
    console.log("Log: ");
    for (let elem of masterLog) {
        console.log(elem.assembleLog());
    }
}
let paletteButtons = [
    "ellipse", "rect", "string", "number",
    "line", "curve"
];
for (let buttonName of paletteButtons) {
    let paletteButton = document.getElementById(buttonName);
    paletteButton.onclick = function () {
        textBoxSelected = true;
        printNewNode(buttonName);
    };
}
function printNewNode(buttonName) {
    let printLine = "";
    switch (buttonName) {
        case "ellipse":
            printLine = "print(ellipse(100,100));";
            break;
        case "rect":
            printLine = "print(rect(100,100));";
            break;
        case "string":
            printLine = 'print("newWord");';
            break;
        case "number":
            printLine = "print(10);";
            break;
        case "line":
            printLine = "print(line(100,100));";
            break;
        case "curve":
            printLine = "print(curve(100,100,100));";
            break;
        default:
            console.log("Problem with " + buttonName);
    }
    inputBox.value += printLine;
    parse();
}
let instructions = document.getElementById('goal');
let rewardBox = document.getElementById('reward-container');
let instrLabel = document.getElementById('instr-label');
//Map maintaining code last used at a checkpoint
let cpCode = new Map([
    ['l1c1', ""],
    ['l1c2', ""],
    ['l1c3', ""],
    ['l1c4', ""],
    ['l2c1', ""],
    ['l2c2', ""],
    ['l2c3', ""],
    ['l2c4', ""],
    ['l2c5', ""],
    ['l2c6', ""],
    ['l2c7', ""],
    ['l3c1', ""],
    ['l3c2', ""],
    ['l3c3', ""],
    ['l3c4', ""],
    ['l3c5', ""],
    ['l3c6', ""],
    ['l4c1', ""],
    ['l4c2', ""]
]);
//Map maintaining whether a checkpoint has been completed
let cpCompletion = new Map([
    ['l1c1', false],
    ['l1c2', false],
    ['l1c3', false],
    ['l1c4', false],
    ['l2c1', false],
    ['l2c2', false],
    ['l2c3', false],
    ['l2c4', false],
    ['l2c5', false],
    ['l2c6', false],
    ['l2c7', false],
    ['l3c1', false],
    ['l3c2', false],
    ['l3c3', false],
    ['l3c4', false],
    ['l3c5', false],
    ['l3c6', false],
    ['l4c1', false],
    ['l4c2', false]
]);
let cpNames = [
    'l1c1', 'l1c2', 'l1c3',
    'l2c1', 'l2c2', 'l2c3', 'l2c4', 'l2c5',
    'l3c1', 'l3c2', 'l3c3', 'l3c4', 'l3c5', 'l3c6' /*,
    'l4c1', 'l4c2'*/
];
for (let cp of cpNames) {
    let cpButton = document.getElementById(cp);
    cpButton.onclick = function () {
        initCheckpoint(cp);
    };
}
/**
 * Creates a module corresponding to a checkpoint passed in.
 * Sets up the instruction, CODE area, and goal box accordingly.
 * @param cp: the name of the checkpoint
 */
function initCheckpoint(cp) {
    //store CODE of old checkpoint
    if (checkpoint != null) {
        cpCode.set(checkpoint._name, inputBox.value);
    }
    console.log("Initiating checkpoint " + cp);
    checkpoint = modGen.generateCheckpoint(cp);
    instrLabel.innerHTML = cp + " - GOAL";
    instructions.innerHTML = checkpoint._instructions;
    //set up the CODE and CANVAS areas
    if (checkpoint._constraint == 'code') {
        inputBox.setAttribute('disabled', 'disabled');
        inputBox.style.opacity = '0.5';
        canvas.style.pointerEvents = "auto";
        canvas.style.background = '#EBEBEB';
        canvasIsDisabled = false;
    }
    else if (checkpoint._constraint == 'canvas') {
        inputBox.removeAttribute('disabled');
        inputBox.style.opacity = '1.0';
        canvas.style.pointerEvents = "none";
        canvas.style.background = '#C0C0C0';
        canvasIsDisabled = true;
    }
    else {
        inputBox.removeAttribute('disabled');
        inputBox.style.opacity = '1.0';
        canvas.style.pointerEvents = "auto";
        canvas.style.background = '#EBEBEB';
        canvasIsDisabled = false;
    }
    let popUp = document.getElementById('popup');
    popUp.style.display = 'none';
    if (cpCode.get(checkpoint._name) !== "") {
        textBoxSelected = true;
        inputBox.value = cpCode.get(checkpoint._name);
    }
    //set up the instruction and goal boxes
    if (cpCompletion.get(cp)) {
        updateRewardBox();
    }
    else {
        if (checkpoint._starterCode != null) {
            textBoxSelected = true;
            inputBox.value = checkpoint._starterCode;
            parse();
        }
        let curInstruction = document.getElementById("instruction");
        if (curInstruction != null) {
            curInstruction.remove();
        }
        if (checkpoint._name === "l1c1") {
            checkpoint.renderInstruction(document);
        }
        rewardBox.style.background = '#C0C0C0';
        let reward = document.getElementById('reward-text');
        reward.style.color = 'black';
        reward.innerHTML = 'Complete goal to earn a star!';
        let rewardImg = document.getElementById('reward-image');
        rewardImg.src = 'pics/greystar.svg';
        rewardImg.alt = 'a star to be earned';
        let nextBtn = document.getElementById('next');
        nextBtn.style.display = 'none';
        instructions.scrollTop = 0;
        checkpointIsActive = true;
    }
}
function checkpointChecksGoal() {
    if (checkpoint.checkGoal(document, effects)) {
        updateRewardBox();
        cpCompletion.set(checkpoint._name, true);
    }
}
function updateRewardBox() {
    rewardBox.style.background = '#673AB7';
    console.log(document);
    let rewardText = document.getElementById('reward-text');
    rewardText.style.color = '#D8D8D8';
    rewardText.innerHTML = "Goal met! Click 'Next' to go to next checkpoint!";
    let rewardImg = document.getElementById('reward-image');
    rewardImg.src = 'pics/star.svg';
    rewardImg.alt = 'star earned';
    let nextBtn = document.getElementById('next');
    nextBtn.style.display = 'block';
    instructions.scrollTop = instructions.scrollHeight;
    checkpointIsActive = false;
}
let nextButton = document.getElementById('next');
nextButton.onclick = function () {
    let nextModule = checkpoint._nextModule;
    if (nextModule != '') {
        initCheckpoint(nextModule);
    }
};
let prevButton = document.getElementById('prev');
prevButton.onclick = function () {
    let prevModule = checkpoint._prevModule;
    if (prevModule != '') {
        initCheckpoint(prevModule);
    }
};
//call to animate
animate();

},{"../../index":1,"space-lift":91}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const UnaryOperation_1 = require("./UnaryOperation");
const NumberNode_1 = require("../prims/NumberNode");
class NegOp extends UnaryOperation_1.UnaryOperation {
    /**
     * Constructor for a NegationOperation
     * @param val The value to be negated (must be a NumberNode)
     * @param ws Preceding whitespace
     */
    constructor(val, ws) {
        super(val);
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Evaluates the value into the negative version
     * @param context The current program context
     */
    eval(context) {
        let v = this.val.eval(context);
        return new NumberNode_1.NumberNode(-v.val, "");
    }
    /**
     * NegOps cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Negation ops cannot be drawn directly");
    }
    /**
     * Equals cannot be called directly on a NegOp
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on NegOp");
    }
    /**
     * Returns a string representation of the NegOp
     */
    toString() {
        return this._ws + "-" + this.val;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return false;
    }
}
exports.NegOp = NegOp;

},{"../prims/NumberNode":65,"./UnaryOperation":81}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class UnaryOperation {
    /**
     * Abstract class constructor for Unary Operations
     * @param _val The object to be operated on
     */
    constructor(_val) {
        this._val = _val;
        this._newLine = false;
    }
    ;
    /**
     * Abstract draw method for undrawable UnaryOps
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Unary Operations cannot be drawn directly");
    }
    /**
     * Equals cannot be called directly on UnaryOps
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot call equals on UnaryOp");
    }
    ;
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
    /**
     * Returns the UnaryOp value
     */
    get val() {
        return this._val;
    }
    /**
     * Sets the UnaryOp value
     */
    set val(value) {
        this._val = value;
    }
}
exports.UnaryOperation = UnaryOperation;

},{}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class VariableNode {
    /**
     * Constructor for a VariableNode, a node representing a variable
     * @param name The variable name
     * @param ws Preceding whitespace
     */
    constructor(name, ws) {
        this._newLine = false;
        this._name = name;
        this._ws = ws;
        if (ws == undefined) {
            this._ws = "";
        }
    }
    /**
     * Looks up the value of the variable in the context
     * @param context The current program context
     */
    eval(context) {
        return context.lookup(this._name, context);
    }
    /**
     * VariableNodes cannot be drawn directly
     * @param context
     * @param dims
     * @param ast
     */
    draw(context, dims, ast) {
        throw new Error("Cannot call draw on variable nodes");
    }
    /**
     * Equals cannot be called directly on VariableNodes
     * @param right
     */
    equalsVal(right) {
        throw new Error("Cannot directly compare vars, eval first");
    }
    /**
     * Returns a string representation of the VariableNode
     */
    toString() {
        return this._ws + this._name;
    }
    /**
     * Returns the name of the variable
     */
    get name() {
        return this._name;
    }
    /**
     * Returns whether the element is terminated by a newline (true) or semicolon (false)
     */
    newLine() {
        return this._newLine;
    }
}
exports.VariableNode = VariableNode;

},{}],83:[function(require,module,exports){
"use strict";
//--------------------------------------
//  Shallow update
//--------------------------------------
exports.__esModule = true;
/** Performs a shallow update of an object using a partial object of the same shape. A new object is returned. */
function update(host, spec) {
    var result = clone(host);
    for (var key in spec) {
        var specValue = spec[key];
        if (specValue === exports.DELETE) {
            delete result[key];
        }
        else {
            result[key] = specValue;
        }
    }
    return result;
}
exports.update = update;
// We lie about the public type so that only a property that is optional or that can be assigned to undefined can be DELETE'd
/** Marker used to delete a key */
exports.DELETE = {};
var _Updater = /** @class */ (function () {
    function _Updater(data) {
        this.data = data;
    }
    _Updater.prototype.at = function (keyOrIndex) {
        return new _Updater({ type: 'at', parent: this, field: keyOrIndex });
    };
    _Updater.prototype.set = function (value) {
        var _this = this;
        var doSet = function (target) {
            var result = _this.cloneForUpdate(target);
            if (result.name === 'aborted')
                return target;
            var clonedTarget = result.clonedTarget, leafHost = result.leafHost, field = result.field;
            value === exports.DELETE ? delete leafHost[field] : leafHost[field] = value;
            return clonedTarget;
        };
        var boundTarget = this.findBoundTarget();
        return boundTarget
            ? doSet(boundTarget)
            : doSet;
    };
    _Updater.prototype.modify = function (modifier) {
        var _this = this;
        var doModify = function (target) {
            var result = _this.cloneForUpdate(target);
            if (result.name === 'aborted')
                return target;
            var clonedTarget = result.clonedTarget, leafHost = result.leafHost, field = result.field;
            var value = modifier(leafHost[field]);
            value === exports.DELETE ? delete leafHost[field] : leafHost[field] = value;
            return clonedTarget;
        };
        var boundTarget = this.findBoundTarget();
        return boundTarget
            ? doModify(boundTarget)
            : doModify;
    };
    _Updater.prototype.withDefault = function (value) {
        return new _Updater({ type: 'withDefault', parent: this, defaultValue: value });
    };
    _Updater.prototype.abortIfUndef = function () {
        return new _Updater({ type: 'abortIfUndef', parent: this });
    };
    _Updater.prototype.findBoundTarget = function () {
        var current = this;
        while (true) {
            if (current.data.type === 'root')
                return current.data.boundTarget;
            current = current.data.parent;
        }
    };
    _Updater.prototype.parentUpdaters = function () {
        var updaters = [this];
        var parentUpdater = this.data.parent;
        // Ignore the root updater
        while (parentUpdater && parentUpdater.data.parent) {
            updaters.unshift(parentUpdater);
            parentUpdater = parentUpdater.data.parent;
        }
        return updaters;
    };
    _Updater.prototype.getNextValue = function (previousHost, host, field, isLast) {
        if (this.data.type === 'at') {
            var newField = this.data.field;
            var value_1 = host[newField];
            var nextValue = isObjectOrArray(value_1) ? clone(value_1) : value_1;
            var newHost_1 = isLast ? host : nextValue;
            host[this.data.field] = nextValue;
            return { host: newHost_1, field: newField };
        }
        var value = previousHost[field];
        if (this.data.type === 'abortIfUndef' && value === undefined) {
            return { host: host, field: field, aborted: true };
        }
        if (this.data.type === 'withDefault' && value === undefined) {
            var nextValue = this.data.defaultValue;
            var newHost_2 = isLast ? previousHost : nextValue;
            previousHost[field] = nextValue;
            return { host: newHost_2, field: field };
        }
        var newHost = isLast ? previousHost : host;
        return { host: newHost, field: field };
    };
    _Updater.prototype.cloneForUpdate = function (target) {
        var updaters = this.parentUpdaters();
        var obj = clone(target);
        var previousHost = obj;
        var host = obj;
        var field = '';
        for (var i = 0; i < updaters.length; i++) {
            var result = updaters[i].getNextValue(previousHost, host, field, i === updaters.length - 1);
            if (result.aborted)
                return { name: 'aborted' };
            previousHost = host;
            host = result.host;
            field = result.field;
        }
        return {
            name: 'result',
            clonedTarget: obj,
            leafHost: host,
            field: field
        };
    };
    return _Updater;
}());
function isObjectOrArray(obj) {
    return obj !== null && typeof obj === 'object';
}
function clone(obj) {
    if (Array.isArray(obj))
        return obj.slice();
    var cloned = {};
    Object.keys(obj).forEach(function (key) { cloned[key] = obj[key]; });
    return cloned;
}
function deepUpdate(target) {
    return new _Updater({ type: 'root', boundTarget: target });
}
exports.deepUpdate = deepUpdate;

},{}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CharUtil;
(function (CharUtil) {
    class CharStream {
        constructor(s, startpos, endpos, hasEOF) {
            this.hasEOF = true;
            this.input = s;
            if (hasEOF != undefined) {
                this.hasEOF = hasEOF;
            }
            if (startpos == undefined) {
                this.startpos = 0; // not specified; set default
            }
            else if (startpos > s.length) {
                this.startpos = s.length; // seek too far; set EOF
            }
            else {
                this.startpos = startpos; // specified and in bounds
            }
            if (endpos == undefined) {
                this.endpos = s.length; // not specified; set default
            }
            else if (endpos > s.length) {
                this.endpos = s.length; // seek too far; set EOF
            }
            else {
                this.endpos = endpos; // specified and in bounds
            }
            if (this.startpos > this.endpos) {
                this.startpos = this.endpos; // if the user flipped positions
            }
        }
        /**
         * Returns true of the end of the input has been reached.
         */
        isEOF() {
            return this.hasEOF && this.startpos == this.input.length;
        }
        /**
         * Returns a Javscript primitive string of the slice of input
         * represented by this CharStream.
         */
        toString() {
            return this.input.substring(this.startpos, this.endpos);
        }
        /**
         * Returns a new CharStream representing the input from the
         * current start position to an end position num chars from
         * the current start position.  If startpos + num > endpos,
         * the current CharStream is returned.
         * @param num
         */
        peek(num) {
            if (this.startpos + num > this.endpos) {
                return this;
            }
            else {
                let newHasEOF = this.startpos + num == this.endpos && this.hasEOF;
                return new CharStream(this.input, this.startpos, this.startpos + num, newHasEOF);
            }
        }
        /**
         * Returns a new CharStream representing the string after
         * seeking num characters from the current position.
         * @param num
         */
        seek(num) {
            if (this.startpos + num > this.endpos) {
                return new CharStream(this.input, this.endpos, this.endpos, this.hasEOF);
            }
            else {
                return new CharStream(this.input, this.startpos + num, this.endpos, this.hasEOF);
            }
        }
        /**
         * Returns a new CharStream representing the head of the input at
         * the current position.  Throws an exception if the CharStream is
         * empty.
         */
        head() {
            if (!this.isEmpty()) {
                const newHasEOF = this.startpos + 1 == this.endpos && this.hasEOF;
                return new CharStream(this.input, this.startpos, this.startpos + 1, newHasEOF);
            }
            else {
                throw new Error("Cannot get the head of an empty string.");
            }
        }
        /**
         * Returns a new CharStream representing the tail of the input at
         * the current position.  Throws an exception if the CharStream is
         * empty.
         */
        tail() {
            if (!this.isEmpty()) {
                return new CharStream(this.input, this.startpos + 1, this.endpos, this.hasEOF);
            }
            else {
                throw new Error("Cannot get the tail of an empty string.");
            }
        }
        /**
         * Returns true if the input at the current position is empty. Note
         * that a CharStream at the end of the input contains an empty
         * string but that an empty string may not be the end-of-file (i.e.,
         * isEOF is false).
         */
        isEmpty() {
            return this.startpos == this.endpos;
        }
        /**
         * Returns the number of characters remaining at
         * the current position.
         */
        length() {
            return this.endpos - this.startpos;
        }
        /**
         * Returns the substring between start and end at the
         * current position.
         * @param start the start index of the substring, inclusive
         * @param end the end index of the substring, exclusive
         */
        substring(start, end) {
            const start2 = this.startpos + start;
            const end2 = this.startpos + end;
            const newHasEOF = this.endpos == end2 && this.hasEOF;
            return new CharStream(this.input, start2, end2, newHasEOF);
        }
        /**
         * Returns the concatenation of the current CharStream with
         * the given CharStream. Note: returned object does not
         * reuse original input string, and startpos and endpos
         * are reset. If the given CharStream contains EOF, the
         * concatenated CharStream will also contain EOF.
         * @param cs the CharStream to concat to this CharStream
         */
        concat(cs) {
            const s = this.toString() + cs.toString();
            return new CharStream(s, 0, s.length, cs.hasEOF);
        }
        /**
         * Concatenate an array of CharStream objects into a single
         * CharStream object.
         * @param css a CharStream[]
         */
        static concat(css) {
            if (css.length == 0) {
                return new CharStream("", 0, 0, false);
            }
            else {
                let cs = css[0];
                for (let i = 1; i < css.length; i++) {
                    cs = cs.concat(css[i]);
                }
                return cs;
            }
        }
    }
    CharUtil.CharStream = CharStream;
})(CharUtil = exports.CharUtil || (exports.CharUtil = {}));

},{}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var primitives_1 = require("./primitives");
exports.Primitives = primitives_1.Primitives;
var charstream_1 = require("./charstream");
exports.CharUtil = charstream_1.CharUtil;

},{"./charstream":84,"./primitives":86}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const charstream_1 = require("./charstream");
var Primitives;
(function (Primitives) {
    class EOFMark {
        constructor() { }
        static get Instance() {
            return this._instance || (this._instance = new this());
        }
    }
    Primitives.EOFMark = EOFMark;
    Primitives.EOF = EOFMark.Instance;
    /**
     * Represents a successful parse.
     */
    class Success {
        /**
         * Returns an object representing a successful parse.
         * @param istream The remaining string.
         * @param res The result of the parse
         */
        constructor(istream, res) {
            this.tag = "success";
            this.inputstream = istream;
            this.result = res;
        }
    }
    Primitives.Success = Success;
    /**
     * Represents a failed parse.
     */
    class Failure {
        /**
         * Returns an object representing a failed parse.
         * @param istream The string, unmodified, that was given to the parser.
         */
        constructor(istream) {
            this.tag = "failure";
            this.inputstream = istream;
        }
    }
    Primitives.Failure = Failure;
    /**
     * result succeeds without consuming any input, and returns v.
     * @param v The result of the parse.
     */
    function result(v) {
        return (istream) => new Success(istream, v);
    }
    Primitives.result = result;
    /**
     * zero fails without consuming any input.
     */
    function zero() {
        return (istream) => new Failure(istream);
    }
    Primitives.zero = zero;
    /**
     * item successfully consumes the first character if the input
     * string is non-empty, otherwise it fails.
     */
    function item() {
        return (istream) => {
            if (istream.isEmpty()) {
                return new Failure(istream);
            }
            else {
                return new Success(istream.tail(), istream.head());
            }
        };
    }
    Primitives.item = item;
    /**
     * bind is a curried function that takes a parser p and returns
     * a function that takes a parser f which returns the composition
     * of p and f.  If _any_ of the parsers fail, the original inputstream
     * is returned in the Failure object (i.e., bind backtracks).
     * @param p A parser
     */
    function bind(p) {
        return (f) => {
            return (istream) => {
                let r = p(istream);
                switch (r.tag) {
                    case "success":
                        let o = f(r.result)(r.inputstream);
                        switch (o.tag) {
                            case "success": return o;
                            case "failure":
                                // note: backtracks, returning original istream
                                return new Failure(istream);
                        }
                    case "failure": return new Failure(istream);
                }
            };
        };
    }
    Primitives.bind = bind;
    function delay(p) {
        return () => p;
    }
    Primitives.delay = delay;
    /**
     * seq is a curried function that takes a parser p, a parser q,
     * and a function f. It applies p to the input, passing the
     * remaining input stream to q; q is then applied.  The function
     * f takes the result of p and q, as a tuple, and returns
     * a single result.
     * @param p A parser
     */
    // export let seq = function<T,U,V>(p: IParser<T>) {
    //     return (q: IParser<U>) => {
    //         return (f: (e: [T,U]) => V) => {
    //             return bind<T,V>(p)((x) => {
    //                 return bind<U,V>(q)((y) => {
    //                     let tup : [T,U] = [x,y];
    //                     return result<V>(f(tup));
    //                 });
    //             });
    //         }
    //     };
    // }
    function seq(p) {
        return (q) => {
            return (f) => {
                return bind(p)((x) => {
                    return bind(q)((y) => {
                        let tup = [x, y];
                        return result(f(tup));
                    });
                });
            };
        };
    }
    Primitives.seq = seq;
    /**
     * sat takes a predicate and yields a parser that consumes a
     * single character if the character satisfies the predicate,
     * otherwise it fails.
     * @param pred a character predicate
     */
    function sat(pred) {
        let pred2 = (cs) => pred(cs.toString());
        let a = item();
        let b = (x) => {
            if (pred2(x)) {
                return result(x);
            }
            else {
                return zero();
            }
        };
        return bind(a)(b);
    }
    Primitives.sat = sat;
    /**
     * char takes a character and yields a parser that consume
     * that character. The returned parser succeeds if the next
     * character in the input stream is c, otherwise it fails.
     * @param c
     */
    function char(c) {
        if (c.length != 1) {
            throw new Error("char parser takes a string of length 1 (i.e., a char)");
        }
        return sat(x => x == c);
    }
    Primitives.char = char;
    /**
     * letter returns a parser that consumes a single alphabetic
     * character, from a-z, regardless of case.
     */
    function letter() {
        let contains_letter = (x) => {
            let a_letter = /[A-Za-z]/;
            return x.match(a_letter) != undefined;
        };
        return sat(contains_letter);
    }
    Primitives.letter = letter;
    /**
     * digit returns a parser that consumes a single numeric
     * character, from 0-9.  Note that the type of the result
     * is a string, not a number.
     */
    function digit() {
        return sat(x => x == "0"
            || x == "1"
            || x == "2"
            || x == "3"
            || x == "4"
            || x == "5"
            || x == "6"
            || x == "7"
            || x == "8"
            || x == "9");
    }
    Primitives.digit = digit;
    /**
     * upper returns a parser that consumes a single character
     * if that character is uppercase.
     */
    function upper() {
        return (istream) => {
            let o1 = letter()(istream);
            switch (o1.tag) {
                case "success":
                    let o2 = sat(x => x == x.toUpperCase())(o1.result);
                    switch (o2.tag) {
                        case "success":
                            return o1;
                        case "failure":
                            return new Failure(istream);
                    }
                    break;
                case "failure":
                    return o1;
            }
            throw new Error("never happens");
        };
    }
    Primitives.upper = upper;
    /**
     * lower returns a parser that consumes a single character
     * if that character is lowercase.
     */
    function lower() {
        return (istream) => {
            let o1 = letter()(istream);
            switch (o1.tag) {
                case "success":
                    let o2 = sat(x => x == x.toLowerCase())(o1.result);
                    switch (o2.tag) {
                        case "success":
                            return o1;
                        case "failure":
                            return new Failure(istream);
                    }
                    break;
                case "failure":
                    return o1;
            }
            throw new Error("never happens");
        };
    }
    Primitives.lower = lower;
    /**
     * choice specifies an ordered choice between two parsers,
     * p1 and p2. The returned parser will first apply
     * parser p1.  If p1 succeeds, p1's Outcome is returned.
     * If p1 fails, p2 is applied and the Outcome of p2 is returned.
     * Note that the input stream given to p1 and p2 is exactly
     * the same input stream.
     * @param p1 A parser.
     */
    function choice(p1) {
        return (p2) => {
            return (istream) => {
                let o = p1(istream);
                switch (o.tag) {
                    case "success":
                        return o;
                    case "failure":
                        return p2(istream);
                }
            };
        };
    }
    Primitives.choice = choice;
    /**
     * appfun allows the user to apply a function f to
     * the result of a parser p, assuming that p is successful.
     * @param p A parser.  This is the same as the |>>
     * function from FParsec.
     */
    function appfun(p) {
        return (f) => {
            return (istream) => {
                let o = p(istream);
                switch (o.tag) {
                    case "success":
                        return new Success(o.inputstream, f(o.result));
                    case "failure":
                        return o;
                }
            };
        };
    }
    Primitives.appfun = appfun;
    /**
     * many repeatedly applies the parser p until p fails. many always
     * succeeds, even if it matches nothing.  many tries to guard
     * against an infinite loop by raising an exception if p succeeds
     * without changing the parser state.
     * @param p
     */
    function many(p) {
        return (istream) => {
            let istream2 = istream;
            let outputs = [];
            let succeeds = true;
            while (!istream2.isEmpty() && succeeds) {
                let o = p(istream2);
                switch (o.tag) {
                    case "success":
                        if (istream2 == o.inputstream) {
                            throw new Error("Parser loops infinitely.");
                        }
                        istream2 = o.inputstream;
                        outputs.push(o.result);
                        break;
                    case "failure":
                        succeeds = false;
                        break;
                }
            }
            return new Success(istream2, outputs);
        };
    }
    Primitives.many = many;
    /**
     * many1 repeatedly applies the parser p until p fails. many1 must
     * succeed at least once.  many1 tries to guard against an infinite
     * loop by raising an exception if p succeeds without changing the
     * parser state.
     * @param p
     */
    function many1(p) {
        return (istream) => {
            return seq(p)(many(p))(tup => {
                let hd = tup["0"];
                let tl = tup["1"];
                tl.unshift(hd);
                return tl;
            })(istream);
        };
    }
    Primitives.many1 = many1;
    /**
     * str yields a parser for the given string.
     * @param s A string
     */
    // TODO: this should actually be a sequence of parsers constructed
    // from the string s
    function str(s) {
        return (istream) => {
            // escape regex metacharacters
            // (this likely needs work)
            let s2 = s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
            let re = new RegExp("^" + s2);
            if (istream.toString().match(re)) {
                const rem = istream.substring(s.length, istream.length());
                const res = istream.substring(0, s.length);
                return new Success(rem, res);
            }
            else {
                return new Failure(istream);
            }
        };
    }
    Primitives.str = str;
    /**
     * Returns a parser that succeeds only if the end of the
     * input has been reached.
     */
    function eof() {
        return (istream) => {
            if (istream.isEOF()) {
                return new Success(istream, Primitives.EOF);
            }
            else {
                return new Failure(istream);
            }
        };
    }
    Primitives.eof = eof;
    /**
     * fresult returns a parser that applies the parser p,
     * and if p succeeds, returns the value x.
     * @param p a parser
     */
    function fresult(p) {
        return (x) => {
            return (istream) => {
                return bind(p)((t) => result(x))(istream);
            };
        };
    }
    Primitives.fresult = fresult;
    /**
     * left returns a parser that applies the parser p,
     * then the parser q, and if both are successful,
     * returns the result of p.
     * @param p a parser
     */
    function left(p) {
        return (q) => {
            return (istream) => {
                return bind(p)((t) => fresult(q)(t))(istream);
            };
        };
    }
    Primitives.left = left;
    /**
     * right returns a parser that applies the parser p,
     * then the parser q, and if both are successful,
     * returns the result of q.
     * @param p a parser
     */
    function right(p) {
        return (q) => {
            return (istream) => {
                return bind(p)(_ => q)(istream);
            };
        };
    }
    Primitives.right = right;
    /**
     * between returns a parser that applies the parser
     * popen, p, and pclose in sequence, and if all are
     * successful, returns the result of p.
     * @param popen the first parser
     */
    function between(popen) {
        return (pclose) => {
            return (p) => {
                let l = left(p)(pclose);
                let r = right(popen)(l);
                return r;
            };
        };
    }
    Primitives.between = between;
    /**
     * The debug parser takes a parser p and a debug string,
     * printing the debug string as a side-effect before
     * applying p to the input.
     * @param p a parser
     */
    function debug(p) {
        return (label) => {
            return (istream) => {
                console.log("apply: " + label);
                let o = p(istream);
                switch (o.tag) {
                    case "success":
                        console.log("success: " + label + ", startpos: " + istream.startpos + ", endpos: " + istream.endpos);
                        break;
                    case "failure":
                        console.log("failure: " + label + ", startpos: " + istream.startpos + ", endpos: " + istream.endpos);
                        break;
                }
                return o;
            };
        };
    }
    Primitives.debug = debug;
    let wschars = choice(sat(c => c == ' ' || c == '\t'))(nl());
    /**
     * ws matches zero or more of the following whitespace characters:
     * ' ', '\t', '\n', or '\r\n'
     * ws returns matched whitespace in a single CharStream result.
     */
    function ws() {
        return (istream) => {
            let o = many(wschars)(istream);
            switch (o.tag) {
                case "success":
                    return new Success(o.inputstream, charstream_1.CharUtil.CharStream.concat(o.result));
                // ws never fails
            }
        };
    }
    Primitives.ws = ws;
    /**
     * ws1 matches one or more of the following whitespace characters:
     * ' ', '\t', '\n', or '\r\n'
     * ws1 returns matched whitespace in a single CharStream result.
     */
    function ws1() {
        return (istream) => {
            let o = many1(wschars)(istream);
            switch (o.tag) {
                case "success":
                    return new Success(o.inputstream, charstream_1.CharUtil.CharStream.concat(o.result));
                case "failure":
                    return o;
            }
        };
    }
    Primitives.ws1 = ws1;
    /**
     * nl matches and returns a newline.
     */
    function nl() {
        return Primitives.choice(Primitives.str("\n"))(Primitives.str("\r\n"));
    }
    Primitives.nl = nl;
    function groupBy(list, keyGetter) {
        let m = new Map();
        list.forEach((item) => {
            const key = keyGetter(item);
            if (!m.has(key)) {
                m.set(key, []);
            }
            let collection = m.get(key);
            collection.push(item);
        });
        return m;
    }
    function strSat(strs) {
        // sort strings first by length, and then lexicograpically;
        // slice() called here so as not to modify original array
        let smap = groupBy(strs, s => s.length);
        let sizes = [];
        // find size classes;
        // also sort each set of equivalent-length values
        smap.forEach((vals, key, m) => {
            sizes.push(key);
            vals.sort();
        });
        sizes.sort();
        return (istream) => {
            // start with the smallest size class       
            for (let peekIndex = 0; peekIndex < sizes.length; peekIndex++) {
                // for each size class, try matching all of
                // the strings; if one is found, return the
                // appropriate CharStream; if not, fail.
                let peek = istream.peek(sizes[peekIndex]);
                let tail = istream.seek(sizes[peekIndex]);
                let candidates = smap.get(sizes[peekIndex]);
                for (let cIndex = 0; cIndex < candidates.length; cIndex++) {
                    if (candidates[cIndex] === peek.toString()) {
                        return new Success(tail, peek);
                    }
                }
            }
            return new Failure(istream);
        };
    }
    Primitives.strSat = strSat;
})(Primitives = exports.Primitives || (exports.Primitives = {}));

},{"./charstream":84}],87:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
/**
 * Converts an Array-like object (such as an arguments or NodeList instance) to a regular Array
 */
function fromArrayLike(arrayLike) {
    return new lift_1.ArrayOps([].slice.call(arrayLike));
}
exports.fromArrayLike = fromArrayLike;

},{"../lift":92}],88:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
/*
* Returns a number[] wrapper with all numbers from start to stop (inclusive),
* incremented or decremented by step.
*/
function range(start, stop, step) {
    if (arguments.length === 1) {
        stop = arguments[0] - 1;
        start = 0;
    }
    step = step || 1;
    var result = [];
    var increasing = step > 0;
    var next = start;
    while ((increasing && next <= stop) || (!increasing && next >= stop)) {
        result.push(next);
        next = next + step;
    }
    return new lift_1.ArrayOps(result);
}
exports.range = range;

},{"../lift":92}],89:[function(require,module,exports){
"use strict";
exports.__esModule = true;
function tuple(arr) {
    return arr;
}
exports.tuple = tuple;

},{}],90:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var is_1 = require("../object/is");
var currentMemoId = 0;
/**
 * Memoizes a function of arbitrary arity.
 * This has two main uses:
 *   1) Reducing the CPU time taken by expensive calculations at the cost of some memory overhead
 *   2) Producing stable references for a given set of arguments. Useful when relying on reference equality.
 *
 * Memoized functions keep internal state. If you wish to clear that state entirely, you can recreate the function.
 */
function memoize(fun, options) {
    // The unique property name used by this memoize function instance.
    // This is used to store the id/reference of object arguments, as Weak maps/sets are very limited.
    var memoKey = "__memo__" + currentMemoId++;
    var lastArgKeys = [];
    var cacheSize = (options && options.cacheSize) || 30;
    var keyFunction = options && options.key;
    // The unique ids/references of objects inside the arityNCache cache
    var objId = 0;
    var arity0Cache;
    var arityNCache;
    var keyCache;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // 0 arguments edge-case
        if (args.length === 0) {
            if (!arity0Cache)
                arity0Cache = fun();
            return arity0Cache;
        }
        // custom key function
        else if (keyFunction) {
            keyCache = keyCache || {};
            var key = keyFunction.apply(null, args);
            var result = keyCache[key];
            if (!result) {
                lastArgKeys.push(key);
                limitCacheSize(keyCache, lastArgKeys, cacheSize);
                result = keyCache[key] = fun.apply(null, args);
            }
            return result;
        }
        // N arguments
        else {
            arityNCache = arityNCache || {};
            var key = '';
            for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                var argKey = void 0;
                if (is_1.object(arg)) {
                    argKey = arg[memoKey];
                    if (!argKey) {
                        // Non enumerable
                        Object.defineProperty(arg, memoKey, { value: "obj" + objId++ });
                        argKey = arg[memoKey];
                    }
                }
                else {
                    argKey = arg;
                }
                key += (argKey + '_');
            }
            var result = arityNCache[key];
            if (!result) {
                lastArgKeys.push(key);
                limitCacheSize(arityNCache, lastArgKeys, cacheSize);
                result = arityNCache[key] = fun.apply(null, args);
            }
            return result;
        }
    };
}
exports.memoize = memoize;
function limitCacheSize(cache, lastArgKeys, size) {
    if (lastArgKeys.length === size + 1) {
        var key = lastArgKeys.shift();
        delete cache[key];
    }
}

},{"../object/is":93}],91:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("./lift");
exports["default"] = lift_1["default"];
var lift_2 = require("./lift");
exports.ArrayOps = lift_2.ArrayOps;
exports.ObjectOps = lift_2.ObjectOps;
exports.NumberOps = lift_2.NumberOps;
exports.StringOps = lift_2.StringOps;
exports.DateOps = lift_2.DateOps;
exports.getValue = lift_2.getValue;
var immupdate_1 = require("immupdate");
exports.update = immupdate_1.update;
exports.deepUpdate = immupdate_1.deepUpdate;
exports.DELETE = immupdate_1.DELETE;
var option_1 = require("./option");
exports.Option = option_1.Option;
exports.None = option_1.None;
exports.Some = option_1.Some;
var result_1 = require("./result");
exports.Result = result_1.Result;
exports.Ok = result_1.Ok;
exports.Err = result_1.Err;
var range_1 = require("./array/range");
exports.range = range_1.range;
var fromArrayLike_1 = require("./array/fromArrayLike");
exports.fromArrayLike = fromArrayLike_1.fromArrayLike;
var tuple_1 = require("./array/tuple");
exports.tuple = tuple_1.tuple;
var set_1 = require("./object/set");
exports.Set = set_1.Set;
var memoize_1 = require("./function/memoize");
exports.memoize = memoize_1.memoize;
var isType = require("./object/is");
exports.is = isType;

},{"./array/fromArrayLike":87,"./array/range":88,"./array/tuple":89,"./function/memoize":90,"./lift":92,"./object/is":93,"./object/set":94,"./option":95,"./result":96,"immupdate":83}],92:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift = function (obj) {
    if (obj instanceof Array)
        return new exports.ArrayOps(obj);
    if (obj instanceof Date)
        return new exports.DateOps(obj);
    if (typeof obj === 'string')
        return new exports.StringOps(obj);
    if (typeof obj === 'number')
        return new exports.NumberOps(obj);
    return new exports.ObjectOps(obj);
};
exports["default"] = lift;
function getValue(input) {
    return input && input['_isLiftWrapper']
        ? input.value()
        : input;
}
exports.getValue = getValue;
function makeOps() {
    var Ops = /** @class */ (function () {
        function Ops(_value) {
            this._value = _value;
            this._isLiftWrapper = true;
        }
        Ops.prototype.value = function () { return this._value; };
        return Ops;
    }());
    return Ops;
}
exports.ArrayOps = makeOps();
exports.ObjectOps = makeOps();
exports.NumberOps = makeOps();
exports.StringOps = makeOps();
exports.DateOps = makeOps();

},{}],93:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/** Returns whether an object is an Array */
exports.array = Array.isArray;
/** Returns whether this object is a function */
function func(obj) {
    return (typeof obj === 'function');
}
exports.func = func;
/** Returns whether this object is a string */
function string(obj) {
    return (typeof obj === 'string');
}
exports.string = string;
/** Returns whether this object is a number */
function number(obj) {
    return (typeof obj === 'number');
}
exports.number = number;
/** Returns whether this object is a boolean */
function boolean(obj) {
    return (typeof obj === 'boolean');
}
exports.boolean = boolean;
/** Returns whether this value is an object (e.g not a primitive: dates, arrays, functions, objects, regexes, `new Number(0)`, and `new String('')) */
function object(obj) {
    var type = typeof obj;
    return (type == 'object' || type == 'function');
}
exports.object = object;

},{}],94:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
/**
 * Creates a Set-like object (string keys, true values) from a list of keys
 */
function Set() {
    var keys = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        keys[_i] = arguments[_i];
    }
    var result = {};
    keys.forEach(function (key) { return result[key] = true; });
    return new lift_1.ObjectOps(result);
}
exports.Set = Set;

},{"../lift":92}],95:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
// The Option factory / static object
var OptionObject = function (value) {
    return isDef(value) ? Some(value) : exports.None;
};
OptionObject.all = function (arr) {
    var values = [];
    for (var i = 0; i < arr.length; i++) {
        var value = arr[i];
        if (exports.Option.isOption(value))
            value = value.get();
        if (!isDef(value))
            return exports.None;
        values.push(value);
    }
    return Some(values);
};
OptionObject.isOption = function (value) {
    return !!value && (value.type === 'some' || value.type === 'none');
};
function makeNone() {
    var self = {};
    function returnNone() { return exports.None; }
    self.type = 'none';
    self.get = function () { return undefined; };
    self.isDefined = function () { return false; };
    self.forEach = function () { };
    self.map = returnNone;
    self.flatMap = returnNone;
    self.filter = returnNone;
    self.fold = function (ifEmpty) { return ifEmpty(); };
    self.orElse = function (alt) { return alt(); };
    self.getOrElse = function (alt) { return alt; };
    self.toArray = function () { return lift_1["default"]([]); };
    self.toString = function () { return 'None'; };
    self.toJSON = function () { return null; };
    return self;
}
function _Some(value) {
    this.value = value;
}
_Some.prototype = {
    type: 'some',
    get: function () {
        return this.value;
    },
    isDefined: function () {
        return true;
    },
    forEach: function (fn) {
        fn(this.value);
    },
    map: function (fn) {
        return exports.Option(lift_1.getValue(fn(this.value)));
    },
    flatMap: function (fn) {
        return fn(this.value);
    },
    filter: function (fn) {
        return fn(this.value) ? this : exports.None;
    },
    fold: function (ifEmpty, ifDefined) {
        return ifDefined(this.value);
    },
    orElse: function () {
        return this;
    },
    getOrElse: function () {
        return this.value;
    },
    toArray: function () {
        return lift_1["default"]([this.value]);
    },
    toString: function () {
        return "Some(" + this.value + ")";
    },
    toJSON: function () {
        return this.value;
    }
};
function isDef(value) {
    return value !== null && value !== undefined;
}
exports.Option = OptionObject;
/** Creates a new Some instance using a non nullable value */
// extends {} to prevent null and undefined being passed
function Some(value) {
    return new _Some(value);
}
exports.Some = Some;
exports.None = makeNone();

},{"../lift":92}],96:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var lift_1 = require("../lift");
var ResultObject = {};
ResultObject.all = function (arr) {
    var okValues = [];
    var currentResult;
    for (var i = 0; i < arr.length; i++) {
        var currentResult_1 = arr[i];
        if (!currentResult_1.isOk())
            return currentResult_1;
        okValues.push(currentResult_1.get());
    }
    return Ok(okValues);
};
ResultObject.isResult = function (value) {
    return !!value && (value.type === 'ok' || value.type === 'err');
};
function _Ok(value) {
    this._value = value;
}
_Ok.prototype = {
    type: 'ok',
    isOk: function () {
        return true;
    },
    map: function (fn) {
        return Ok(lift_1.getValue(fn(this._value)));
    },
    mapError: function (fn) {
        return this;
    },
    flatMap: function (fn) {
        return fn(this._value);
    },
    fold: function (ifErr, ifOk) {
        return ifOk(this._value);
    },
    toString: function () {
        return "Ok(" + this._value + ")";
    },
    get: function () {
        return this._value;
    }
};
function _Err(error) {
    this._error = error;
}
_Err.prototype = {
    type: 'err',
    isOk: function () {
        return false;
    },
    map: function (fn) {
        return this;
    },
    mapError: function (fn) {
        return Err(fn(this._error));
    },
    flatMap: function (fn) {
        return this;
    },
    fold: function (ifErr, ifOk) {
        return ifErr(this._error);
    },
    toString: function () {
        return "Err(" + this._error + ")";
    },
    get: function () {
        return this._error;
    }
};
exports.Result = ResultObject;
function Ok(value) {
    return new _Ok(value);
}
exports.Ok = Ok;
function Err(error) {
    return new _Err(error);
}
exports.Err = Err;

},{"../lift":92}]},{},[79])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImRpc3QvaW5kZXguanMiLCJkaXN0L2xpYi9iaW5vcHMvQXNzaWduT3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvQmluYXJ5T3BlcmF0aW9uLmpzIiwiZGlzdC9saWIvYmlub3BzL0RlY2xhcmVPcC5qcyIsImRpc3QvbGliL2Jpbm9wcy9EZWNyZW1lbnQuanMiLCJkaXN0L2xpYi9iaW5vcHMvRGl2T3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvSW5jcmVtZW50LmpzIiwiZGlzdC9saWIvYmlub3BzL01pbnVzT3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvTXVsT3AuanMiLCJkaXN0L2xpYi9iaW5vcHMvUGx1c09wLmpzIiwiZGlzdC9saWIvY29uZGl0aW9uYWxzL0NvbmRpdGlvbmFsLmpzIiwiZGlzdC9saWIvZWZmZWN0cy9DdXJ2ZUVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvRWxsaXBzZUVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvRXBoRWZmZWN0LmpzIiwiZGlzdC9saWIvZWZmZWN0cy9MaW5lRWZmZWN0LmpzIiwiZGlzdC9saWIvZWZmZWN0cy9OdW1iZXJFZmZlY3QuanMiLCJkaXN0L2xpYi9lZmZlY3RzL1JlY3RhbmdsZUVmZmVjdC5qcyIsImRpc3QvbGliL2VmZmVjdHMvU3RyaW5nRWZmZWN0LmpzIiwiZGlzdC9saWIvZnVuaG91c2UvRnVuQXBwLmpzIiwiZGlzdC9saWIvZnVuaG91c2UvRnVuRGVmLmpzIiwiZGlzdC9saWIvbGlzdHMvTGlzdE5vZGUuanMiLCJkaXN0L2xpYi9sb2dnaW5nL0NsZWFyRXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL0NsaWNrRXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL0RyYWdFdmVudC5qcyIsImRpc3QvbGliL2xvZ2dpbmcvSURFdmVudC5qcyIsImRpc3QvbGliL2xvZ2dpbmcvTG9nRXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL1BhaW50RXZlbnQuanMiLCJkaXN0L2xpYi9sb2dnaW5nL1Jlc2l6ZUV2ZW50LmpzIiwiZGlzdC9saWIvbG9nZ2luZy9TZWxlY3RFdmVudC5qcyIsImRpc3QvbGliL2xvZ2ljL0FuZC5qcyIsImRpc3QvbGliL2xvZ2ljL0VxdWFscy5qcyIsImRpc3QvbGliL2xvZ2ljL0dyZWF0ZXJUaGFuLmpzIiwiZGlzdC9saWIvbG9naWMvR3JlYXRlclRoYW5FcS5qcyIsImRpc3QvbGliL2xvZ2ljL0xlc3NUaGFuLmpzIiwiZGlzdC9saWIvbG9naWMvTGVzc1RoYW5FcS5qcyIsImRpc3QvbGliL2xvZ2ljL05vdC5qcyIsImRpc3QvbGliL2xvZ2ljL05vdEVxdWFsLmpzIiwiZGlzdC9saWIvbG9naWMvT3IuanMiLCJkaXN0L2xpYi9sb29wcy9Gb3JOb2RlLmpzIiwiZGlzdC9saWIvbG9vcHMvV2hpbGVOb2RlLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9JbnN0cnVjdGlvbi5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uRm91ckNwT25lLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Gb3VyQ3BUd28uanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3Nvbk9uZUNwRm91ci5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uT25lQ3BPbmUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3Nvbk9uZUNwVGhyZWUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3Nvbk9uZUNwVHdvLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25UaHJlZUNwRml2ZS5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcEZvdXIuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BPbmUuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BTaXguanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BUaHJlZS5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcFR3by5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVHdvQ3BGaXZlLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Ud29DcEZvdXIuanMiLCJkaXN0L2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwT25lLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFNldmVuLmpzIiwiZGlzdC9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFNpeC5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVHdvQ3BUaHJlZS5qcyIsImRpc3QvbGliL21vZHVsZXMvTGVzc29uVHdvQ3BUd28uanMiLCJkaXN0L2xpYi9tb2R1bGVzL01vZHVsZUdlbmVyYXRvci5qcyIsImRpc3QvbGliL3BhcnNlci9wYXJzZXIuanMiLCJkaXN0L2xpYi9wcmltcy9Cb29sZWFuTm9kZS5qcyIsImRpc3QvbGliL3ByaW1zL05PUC5qcyIsImRpc3QvbGliL3ByaW1zL051bWJlck5vZGUuanMiLCJkaXN0L2xpYi9wcmltcy9TdHJpbmdOb2RlLmpzIiwiZGlzdC9saWIvc2hhcGVzL0NvbG9yTm9kZS5qcyIsImRpc3QvbGliL3NoYXBlcy9DdXJ2ZU5vZGUuanMiLCJkaXN0L2xpYi9zaGFwZXMvRWxsaXBzZU5vZGUuanMiLCJkaXN0L2xpYi9zaGFwZXMvRXBoTm9kZS5qcyIsImRpc3QvbGliL3NoYXBlcy9MaW5lTm9kZS5qcyIsImRpc3QvbGliL3NoYXBlcy9SZWN0YW5nbGVOb2RlLmpzIiwiZGlzdC9saWIvc3RydWN0dXJhbC9EaW1lbnNpb25zLmpzIiwiZGlzdC9saWIvc3RydWN0dXJhbC9QcmludE5vZGUuanMiLCJkaXN0L2xpYi9zdHJ1Y3R1cmFsL1JldHVybi5qcyIsImRpc3QvbGliL3N0cnVjdHVyYWwvUmV0dXJuRXJyb3IuanMiLCJkaXN0L2xpYi9zdHJ1Y3R1cmFsL1Njb3BlLmpzIiwiZGlzdC9saWIvc3RydWN0dXJhbC9TZXF1ZW5jZU5vZGUuanMiLCJkaXN0L2xpYi91aS91aS1ub25kbS5qcyIsImRpc3QvbGliL3Vub3BzL05lZ09wLmpzIiwiZGlzdC9saWIvdW5vcHMvVW5hcnlPcGVyYXRpb24uanMiLCJkaXN0L2xpYi92YXJzL1ZhcmlhYmxlTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9pbW11cGRhdGUvY29tbW9uanMvaW1tdXBkYXRlLmpzIiwibm9kZV9tb2R1bGVzL3BhbnRzL2xpYi9jaGFyc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3BhbnRzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYW50cy9saWIvcHJpbWl0aXZlcy5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL2FycmF5L2Zyb21BcnJheUxpa2UuanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9hcnJheS9yYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL2FycmF5L3R1cGxlLmpzIiwibm9kZV9tb2R1bGVzL3NwYWNlLWxpZnQvY29tbW9uanMvZnVuY3Rpb24vbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NwYWNlLWxpZnQvY29tbW9uanMvbGlmdC5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL29iamVjdC9pcy5qcyIsIm5vZGVfbW9kdWxlcy9zcGFjZS1saWZ0L2NvbW1vbmpzL29iamVjdC9zZXQuanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9vcHRpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3BhY2UtbGlmdC9jb21tb25qcy9yZXN1bHQvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3J3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2h2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9qQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNydkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNjb3BlXzEgPSByZXF1aXJlKFwiLi9saWIvc3RydWN0dXJhbC9TY29wZVwiKTtcbmV4cG9ydHMuU2NvcGUgPSBTY29wZV8xLlNjb3BlO1xuLyogQklOQVJZIE9QUyAqL1xudmFyIEFzc2lnbk9wXzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL0Fzc2lnbk9wXCIpO1xuZXhwb3J0cy5Bc3NpZ25PcCA9IEFzc2lnbk9wXzEuQXNzaWduT3A7XG52YXIgQmluYXJ5T3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL0JpbmFyeU9wZXJhdGlvblwiKTtcbmV4cG9ydHMuQmluYXJ5T3BlcmF0aW9uID0gQmluYXJ5T3BlcmF0aW9uXzEuQmluYXJ5T3BlcmF0aW9uO1xudmFyIERpdk9wXzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL0Rpdk9wXCIpO1xuZXhwb3J0cy5EaXZPcCA9IERpdk9wXzEuRGl2T3A7XG52YXIgTWludXNPcF8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9NaW51c09wXCIpO1xuZXhwb3J0cy5NaW51c09wID0gTWludXNPcF8xLk1pbnVzT3A7XG52YXIgTXVsT3BfMSA9IHJlcXVpcmUoXCIuL2xpYi9iaW5vcHMvTXVsT3BcIik7XG5leHBvcnRzLk11bE9wID0gTXVsT3BfMS5NdWxPcDtcbnZhciBQbHVzT3BfMSA9IHJlcXVpcmUoXCIuL2xpYi9iaW5vcHMvUGx1c09wXCIpO1xuZXhwb3J0cy5QbHVzT3AgPSBQbHVzT3BfMS5QbHVzT3A7XG52YXIgR3JlYXRlclRoYW5fMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9HcmVhdGVyVGhhblwiKTtcbmV4cG9ydHMuR3JlYXRlclRoYW4gPSBHcmVhdGVyVGhhbl8xLkdyZWF0ZXJUaGFuO1xudmFyIEdyZWF0ZXJUaGFuRXFfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9HcmVhdGVyVGhhbkVxXCIpO1xuZXhwb3J0cy5HcmVhdGVyVGhhbkVxID0gR3JlYXRlclRoYW5FcV8xLkdyZWF0ZXJUaGFuRXE7XG52YXIgTGVzc1RoYW5fMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9MZXNzVGhhblwiKTtcbmV4cG9ydHMuTGVzc1RoYW4gPSBMZXNzVGhhbl8xLkxlc3NUaGFuO1xudmFyIExlc3NUaGFuRXFfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9MZXNzVGhhbkVxXCIpO1xuZXhwb3J0cy5MZXNzVGhhbkVxID0gTGVzc1RoYW5FcV8xLkxlc3NUaGFuRXE7XG52YXIgRGVjbGFyZU9wXzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL0RlY2xhcmVPcFwiKTtcbmV4cG9ydHMuRGVjbGFyZU9wID0gRGVjbGFyZU9wXzEuRGVjbGFyZU9wO1xudmFyIEFuZF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2ljL0FuZFwiKTtcbmV4cG9ydHMuQW5kID0gQW5kXzEuQW5kO1xudmFyIE9yXzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvT3JcIik7XG5leHBvcnRzLk9yID0gT3JfMS5PcjtcbnZhciBFcXVhbHNfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dpYy9FcXVhbHNcIik7XG5leHBvcnRzLkVxdWFscyA9IEVxdWFsc18xLkVxdWFscztcbnZhciBOb3RFcXVhbF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2ljL05vdEVxdWFsXCIpO1xuZXhwb3J0cy5Ob3RFcXVhbCA9IE5vdEVxdWFsXzEuTm90RXF1YWw7XG52YXIgSW5jcmVtZW50XzEgPSByZXF1aXJlKFwiLi9saWIvYmlub3BzL0luY3JlbWVudFwiKTtcbmV4cG9ydHMuSW5jcmVtZW50ID0gSW5jcmVtZW50XzEuSW5jcmVtZW50O1xudmFyIERlY3JlbWVudF8xID0gcmVxdWlyZShcIi4vbGliL2Jpbm9wcy9EZWNyZW1lbnRcIik7XG5leHBvcnRzLkRlY3JlbWVudCA9IERlY3JlbWVudF8xLkRlY3JlbWVudDtcbi8qIFVOQVJZIE9QUyAqL1xudmFyIFVuYXJ5T3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9saWIvdW5vcHMvVW5hcnlPcGVyYXRpb25cIik7XG5leHBvcnRzLlVuYXJ5T3BlcmF0aW9uID0gVW5hcnlPcGVyYXRpb25fMS5VbmFyeU9wZXJhdGlvbjtcbnZhciBOZWdPcF8xID0gcmVxdWlyZShcIi4vbGliL3Vub3BzL05lZ09wXCIpO1xuZXhwb3J0cy5OZWdPcCA9IE5lZ09wXzEuTmVnT3A7XG52YXIgTm90XzEgPSByZXF1aXJlKFwiLi9saWIvbG9naWMvTm90XCIpO1xuZXhwb3J0cy5Ob3QgPSBOb3RfMS5Ob3Q7XG4vKiBEQVRBIFRZUEVTICovXG52YXIgTGlzdE5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9saXN0cy9MaXN0Tm9kZVwiKTtcbmV4cG9ydHMuTGlzdE5vZGUgPSBMaXN0Tm9kZV8xLkxpc3ROb2RlO1xudmFyIE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuZXhwb3J0cy5OdW1iZXJOb2RlID0gTnVtYmVyTm9kZV8xLk51bWJlck5vZGU7XG52YXIgU3RyaW5nTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3ByaW1zL1N0cmluZ05vZGVcIik7XG5leHBvcnRzLlN0cmluZ05vZGUgPSBTdHJpbmdOb2RlXzEuU3RyaW5nTm9kZTtcbnZhciBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuZXhwb3J0cy5Cb29sZWFuTm9kZSA9IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGU7XG52YXIgTk9QXzEgPSByZXF1aXJlKFwiLi9saWIvcHJpbXMvTk9QXCIpO1xuZXhwb3J0cy5OT1AgPSBOT1BfMS5OT1A7XG4vKiBWQVJJQUJMRVMgKi9cbnZhciBWYXJpYWJsZU5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi92YXJzL1ZhcmlhYmxlTm9kZVwiKTtcbmV4cG9ydHMuVmFyaWFibGVOb2RlID0gVmFyaWFibGVOb2RlXzEuVmFyaWFibGVOb2RlO1xuLyogQ09OVFJPTCBDT05TVFJVQ1RTICovXG52YXIgQ29uZGl0aW9uYWxfMSA9IHJlcXVpcmUoXCIuL2xpYi9jb25kaXRpb25hbHMvQ29uZGl0aW9uYWxcIik7XG5leHBvcnRzLkNvbmRpdGlvbmFsID0gQ29uZGl0aW9uYWxfMS5Db25kaXRpb25hbDtcbnZhciBGdW5BcHBfMSA9IHJlcXVpcmUoXCIuL2xpYi9mdW5ob3VzZS9GdW5BcHBcIik7XG5leHBvcnRzLkZ1bkFwcCA9IEZ1bkFwcF8xLkZ1bkFwcDtcbnZhciBGdW5EZWZfMSA9IHJlcXVpcmUoXCIuL2xpYi9mdW5ob3VzZS9GdW5EZWZcIik7XG5leHBvcnRzLkZ1bkRlZiA9IEZ1bkRlZl8xLkZ1bkRlZjtcbnZhciBTZXF1ZW5jZU5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zdHJ1Y3R1cmFsL1NlcXVlbmNlTm9kZVwiKTtcbmV4cG9ydHMuU2VxdWVuY2VOb2RlID0gU2VxdWVuY2VOb2RlXzEuU2VxdWVuY2VOb2RlO1xudmFyIFdoaWxlTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL2xvb3BzL1doaWxlTm9kZVwiKTtcbmV4cG9ydHMuV2hpbGVOb2RlID0gV2hpbGVOb2RlXzEuV2hpbGVOb2RlO1xudmFyIEZvck5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb29wcy9Gb3JOb2RlXCIpO1xuZXhwb3J0cy5Gb3JOb2RlID0gRm9yTm9kZV8xLkZvck5vZGU7XG4vKiBCVUlMVElOIEZVTkNUSU9OUyAqL1xudmFyIENvbG9yTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3NoYXBlcy9Db2xvck5vZGVcIik7XG5leHBvcnRzLkNvbG9yTm9kZSA9IENvbG9yTm9kZV8xLkNvbG9yTm9kZTtcbnZhciBFbGxpcHNlTm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3NoYXBlcy9FbGxpcHNlTm9kZVwiKTtcbmV4cG9ydHMuRWxsaXBzZU5vZGUgPSBFbGxpcHNlTm9kZV8xLkVsbGlwc2VOb2RlO1xudmFyIFJlY3RhbmdsZU5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zaGFwZXMvUmVjdGFuZ2xlTm9kZVwiKTtcbmV4cG9ydHMuUmVjdGFuZ2xlTm9kZSA9IFJlY3RhbmdsZU5vZGVfMS5SZWN0YW5nbGVOb2RlO1xudmFyIExpbmVOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvc2hhcGVzL0xpbmVOb2RlXCIpO1xuZXhwb3J0cy5MaW5lTm9kZSA9IExpbmVOb2RlXzEuTGluZU5vZGU7XG52YXIgQ3VydmVOb2RlXzEgPSByZXF1aXJlKFwiLi9saWIvc2hhcGVzL0N1cnZlTm9kZVwiKTtcbmV4cG9ydHMuQ3VydmVOb2RlID0gQ3VydmVOb2RlXzEuQ3VydmVOb2RlO1xudmFyIEVwaE5vZGVfMSA9IHJlcXVpcmUoXCIuL2xpYi9zaGFwZXMvRXBoTm9kZVwiKTtcbmV4cG9ydHMuRXBoTm9kZSA9IEVwaE5vZGVfMS5FcGhOb2RlO1xudmFyIFByaW50Tm9kZV8xID0gcmVxdWlyZShcIi4vbGliL3N0cnVjdHVyYWwvUHJpbnROb2RlXCIpO1xuZXhwb3J0cy5QcmludE5vZGUgPSBQcmludE5vZGVfMS5QcmludE5vZGU7XG52YXIgUmV0dXJuXzEgPSByZXF1aXJlKFwiLi9saWIvc3RydWN0dXJhbC9SZXR1cm5cIik7XG5leHBvcnRzLlJldHVybiA9IFJldHVybl8xLlJldHVybjtcbnZhciBSZXR1cm5FcnJvcl8xID0gcmVxdWlyZShcIi4vbGliL3N0cnVjdHVyYWwvUmV0dXJuRXJyb3JcIik7XG5leHBvcnRzLlJldHVybkVycm9yID0gUmV0dXJuRXJyb3JfMS5SZXR1cm5FcnJvcjtcbnZhciBFbGxpcHNlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi9saWIvZWZmZWN0cy9FbGxpcHNlRWZmZWN0XCIpO1xuZXhwb3J0cy5FbGxpcHNlRWZmZWN0ID0gRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3Q7XG52YXIgTnVtYmVyRWZmZWN0XzEgPSByZXF1aXJlKFwiLi9saWIvZWZmZWN0cy9OdW1iZXJFZmZlY3RcIik7XG5leHBvcnRzLk51bWJlckVmZmVjdCA9IE51bWJlckVmZmVjdF8xLk51bWJlckVmZmVjdDtcbnZhciBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuL2xpYi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmV4cG9ydHMuU3RyaW5nRWZmZWN0ID0gU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0O1xudmFyIERpbWVuc2lvbnNfMSA9IHJlcXVpcmUoXCIuL2xpYi9zdHJ1Y3R1cmFsL0RpbWVuc2lvbnNcIik7XG5leHBvcnRzLkRpbWVuc2lvbnMgPSBEaW1lbnNpb25zXzEuRGltZW5zaW9ucztcbnZhciBSZWN0YW5nbGVFZmZlY3RfMSA9IHJlcXVpcmUoXCIuL2xpYi9lZmZlY3RzL1JlY3RhbmdsZUVmZmVjdFwiKTtcbmV4cG9ydHMuUmVjdGFuZ2xlRWZmZWN0ID0gUmVjdGFuZ2xlRWZmZWN0XzEuUmVjdGFuZ2xlRWZmZWN0O1xudmFyIExpbmVFZmZlY3RfMSA9IHJlcXVpcmUoXCIuL2xpYi9lZmZlY3RzL0xpbmVFZmZlY3RcIik7XG5leHBvcnRzLkxpbmVFZmZlY3QgPSBMaW5lRWZmZWN0XzEuTGluZUVmZmVjdDtcbnZhciBDdXJ2ZUVmZmVjdF8xID0gcmVxdWlyZShcIi4vbGliL2VmZmVjdHMvQ3VydmVFZmZlY3RcIik7XG5leHBvcnRzLkN1cnZlRWZmZWN0ID0gQ3VydmVFZmZlY3RfMS5DdXJ2ZUVmZmVjdDtcbnZhciBFcGhFZmZlY3RfMSA9IHJlcXVpcmUoXCIuL2xpYi9lZmZlY3RzL0VwaEVmZmVjdFwiKTtcbmV4cG9ydHMuRXBoRWZmZWN0ID0gRXBoRWZmZWN0XzEuRXBoRWZmZWN0O1xuLyogRVZFTlRTICovXG52YXIgTG9nRXZlbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dnaW5nL0xvZ0V2ZW50XCIpO1xuZXhwb3J0cy5Mb2dFdmVudCA9IExvZ0V2ZW50XzEuTG9nRXZlbnQ7XG52YXIgQ2xlYXJFdmVudF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2dpbmcvQ2xlYXJFdmVudFwiKTtcbmV4cG9ydHMuQ2xlYXJFdmVudCA9IENsZWFyRXZlbnRfMS5DbGVhckV2ZW50O1xudmFyIERyYWdFdmVudF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2dpbmcvRHJhZ0V2ZW50XCIpO1xuZXhwb3J0cy5EcmFnRXZlbnQgPSBEcmFnRXZlbnRfMS5EcmFnRXZlbnQ7XG52YXIgUGFpbnRFdmVudF8xID0gcmVxdWlyZShcIi4vbGliL2xvZ2dpbmcvUGFpbnRFdmVudFwiKTtcbmV4cG9ydHMuUGFpbnRFdmVudCA9IFBhaW50RXZlbnRfMS5QYWludEV2ZW50O1xudmFyIFJlc2l6ZUV2ZW50XzEgPSByZXF1aXJlKFwiLi9saWIvbG9nZ2luZy9SZXNpemVFdmVudFwiKTtcbmV4cG9ydHMuUmVzaXplRXZlbnQgPSBSZXNpemVFdmVudF8xLlJlc2l6ZUV2ZW50O1xudmFyIFNlbGVjdEV2ZW50XzEgPSByZXF1aXJlKFwiLi9saWIvbG9nZ2luZy9TZWxlY3RFdmVudFwiKTtcbmV4cG9ydHMuU2VsZWN0RXZlbnQgPSBTZWxlY3RFdmVudF8xLlNlbGVjdEV2ZW50O1xudmFyIElERXZlbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2dnaW5nL0lERXZlbnRcIik7XG5leHBvcnRzLklERXZlbnQgPSBJREV2ZW50XzEuSURFdmVudDtcbnZhciBNb2R1bGVHZW5lcmF0b3JfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL01vZHVsZUdlbmVyYXRvclwiKTtcbmV4cG9ydHMuTW9kdWxlR2VuZXJhdG9yID0gTW9kdWxlR2VuZXJhdG9yXzEuTW9kdWxlR2VuZXJhdG9yO1xudmFyIExlc3Nvbk9uZUNwT25lXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25PbmVDcE9uZVwiKTtcbmV4cG9ydHMuTGVzc29uT25lQ3BPbmUgPSBMZXNzb25PbmVDcE9uZV8xLkxlc3Nvbk9uZUNwT25lO1xudmFyIExlc3Nvbk9uZUNwVHdvXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25PbmVDcFR3b1wiKTtcbmV4cG9ydHMuTGVzc29uT25lQ3BUd28gPSBMZXNzb25PbmVDcFR3b18xLkxlc3Nvbk9uZUNwVHdvO1xudmFyIExlc3Nvbk9uZUNwVGhyZWVfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3Nvbk9uZUNwVGhyZWVcIik7XG5leHBvcnRzLkxlc3Nvbk9uZUNwVGhyZWUgPSBMZXNzb25PbmVDcFRocmVlXzEuTGVzc29uT25lQ3BUaHJlZTtcbnZhciBMZXNzb25PbmVDcEZvdXJfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3Nvbk9uZUNwRm91clwiKTtcbmV4cG9ydHMuTGVzc29uT25lQ3BGb3VyID0gTGVzc29uT25lQ3BGb3VyXzEuTGVzc29uT25lQ3BGb3VyO1xudmFyIExlc3NvblR3b0NwT25lXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Ud29DcE9uZVwiKTtcbmV4cG9ydHMuTGVzc29uVHdvQ3BPbmUgPSBMZXNzb25Ud29DcE9uZV8xLkxlc3NvblR3b0NwT25lO1xudmFyIExlc3NvblR3b0NwVHdvXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Ud29DcFR3b1wiKTtcbmV4cG9ydHMuTGVzc29uVHdvQ3BUd28gPSBMZXNzb25Ud29DcFR3b18xLkxlc3NvblR3b0NwVHdvO1xudmFyIExlc3NvblR3b0NwVGhyZWVfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwVGhyZWVcIik7XG5leHBvcnRzLkxlc3NvblR3b0NwVGhyZWUgPSBMZXNzb25Ud29DcFRocmVlXzEuTGVzc29uVHdvQ3BUaHJlZTtcbnZhciBMZXNzb25Ud29DcEZvdXJfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwRm91clwiKTtcbmV4cG9ydHMuTGVzc29uVHdvQ3BGb3VyID0gTGVzc29uVHdvQ3BGb3VyXzEuTGVzc29uVHdvQ3BGb3VyO1xudmFyIExlc3NvblR3b0NwRml2ZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVHdvQ3BGaXZlXCIpO1xuZXhwb3J0cy5MZXNzb25Ud29DcEZpdmUgPSBMZXNzb25Ud29DcEZpdmVfMS5MZXNzb25Ud29DcEZpdmU7XG52YXIgTGVzc29uVHdvQ3BTaXhfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblR3b0NwU2l4XCIpO1xuZXhwb3J0cy5MZXNzb25Ud29DcFNpeCA9IExlc3NvblR3b0NwU2l4XzEuTGVzc29uVHdvQ3BTaXg7XG52YXIgTGVzc29uVHdvQ3BTZXZlbl8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVHdvQ3BTZXZlblwiKTtcbmV4cG9ydHMuTGVzc29uVHdvQ3BTZXZlbiA9IExlc3NvblR3b0NwU2V2ZW5fMS5MZXNzb25Ud29DcFNldmVuO1xudmFyIExlc3NvblRocmVlQ3BPbmVfMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvblRocmVlQ3BPbmVcIik7XG5leHBvcnRzLkxlc3NvblRocmVlQ3BPbmUgPSBMZXNzb25UaHJlZUNwT25lXzEuTGVzc29uVGhyZWVDcE9uZTtcbnZhciBMZXNzb25UaHJlZUNwVHdvXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25UaHJlZUNwVHdvXCIpO1xuZXhwb3J0cy5MZXNzb25UaHJlZUNwVHdvID0gTGVzc29uVGhyZWVDcFR3b18xLkxlc3NvblRocmVlQ3BUd287XG52YXIgTGVzc29uVGhyZWVDcFRocmVlXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25UaHJlZUNwVGhyZWVcIik7XG5leHBvcnRzLkxlc3NvblRocmVlQ3BUaHJlZSA9IExlc3NvblRocmVlQ3BUaHJlZV8xLkxlc3NvblRocmVlQ3BUaHJlZTtcbnZhciBMZXNzb25UaHJlZUNwRm91cl8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcEZvdXJcIik7XG5leHBvcnRzLkxlc3NvblRocmVlQ3BGb3VyID0gTGVzc29uVGhyZWVDcEZvdXJfMS5MZXNzb25UaHJlZUNwRm91cjtcbnZhciBMZXNzb25UaHJlZUNwRml2ZV8xID0gcmVxdWlyZShcIi4vbGliL21vZHVsZXMvTGVzc29uVGhyZWVDcEZpdmVcIik7XG5leHBvcnRzLkxlc3NvblRocmVlQ3BGaXZlID0gTGVzc29uVGhyZWVDcEZpdmVfMS5MZXNzb25UaHJlZUNwRml2ZTtcbnZhciBMZXNzb25UaHJlZUNwU2l4XzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25UaHJlZUNwU2l4XCIpO1xuZXhwb3J0cy5MZXNzb25UaHJlZUNwU2l4ID0gTGVzc29uVGhyZWVDcFNpeF8xLkxlc3NvblRocmVlQ3BTaXg7XG52YXIgTGVzc29uRm91ckNwT25lXzEgPSByZXF1aXJlKFwiLi9saWIvbW9kdWxlcy9MZXNzb25Gb3VyQ3BPbmVcIik7XG5leHBvcnRzLkxlc3NvbkZvdXJDcE9uZSA9IExlc3NvbkZvdXJDcE9uZV8xLkxlc3NvbkZvdXJDcE9uZTtcbnZhciBMZXNzb25Gb3VyQ3BUd29fMSA9IHJlcXVpcmUoXCIuL2xpYi9tb2R1bGVzL0xlc3NvbkZvdXJDcFR3b1wiKTtcbmV4cG9ydHMuTGVzc29uRm91ckNwVHdvID0gTGVzc29uRm91ckNwVHdvXzEuTGVzc29uRm91ckNwVHdvO1xuLyogUEFSU0VSICovXG52YXIgcGFyc2VyXzEgPSByZXF1aXJlKFwiLi9saWIvcGFyc2VyL3BhcnNlclwiKTtcbmV4cG9ydHMuUGFyc2VyID0gcGFyc2VyXzEuUGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCaW5hcnlPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL0JpbmFyeU9wZXJhdGlvblwiKTtcbmNvbnN0IFZhcmlhYmxlTm9kZV8xID0gcmVxdWlyZShcIi4uL3ZhcnMvVmFyaWFibGVOb2RlXCIpO1xuLy8gbGVmdCBzaWRlIGlzIHZhcmlhYmxlLCByaWdodCBzaWRlIGlzIHZhbFxuLy8gUmVhc3NpZ24gbmV3IHZhbHVlIHRvIHZhclxuY2xhc3MgQXNzaWduT3AgZXh0ZW5kcyBCaW5hcnlPcGVyYXRpb25fMS5CaW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhbiBhc3NpZ25tZW50IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IHNpZGUgb2YgdGhlIGFzc2lnbm1lbnQgKHRoZSB2YXIpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBhc3NpZ25tZW50ICh0aGUgdmFsdWUpXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHN1cGVyKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKCEobGVmdCBpbnN0YW5jZW9mIFZhcmlhYmxlTm9kZV8xLlZhcmlhYmxlTm9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBsZWZ0IGhhbmQgc2lkZSBvZiB0aGUgYXNzaWdubWVudCBtdXN0IGJlIGEgdmFyaWFibGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgYXNzaWduIG9wIGJ5IGFzc2lnbmluZyB2YWx1ZSB0byB2YXJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmxlZnQgaW5zdGFuY2VvZiBWYXJpYWJsZU5vZGVfMS5WYXJpYWJsZU5vZGUpIHtcbiAgICAgICAgICAgIGxldCByID0gdGhpcy5yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICAgICAgY29udGV4dC5hc3NpZ24odGhpcy5sZWZ0Lm5hbWUsIHIpO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSEFMUCAoaW4gQXNzaWduT3ApXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBBc3NpZ25PcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLmxlZnQudG9TdHJpbmcoKSArICcgPSAnICsgdGhpcy5yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NpZ25PcHMgY2FuJ3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbid0IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBBc3NpZ25PcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmluYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3NpZ25PcCA9IEFzc2lnbk9wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNzaWduT3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBCaW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgQmluT3AgYWJzdHJhY3QgY2xhc3NcbiAgICAgKiBAcGFyYW0gX2xlZnQgVGhlIGxlZnQgc2lkZSBvZiB0aGUgYmluYXJ5IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBfcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGJpbmFyeSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbGVmdCwgX3JpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBfbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSBfcmlnaHQ7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBiaW5hcnkgb3BlcmF0aW9uLCBpZiBhcHBsaWNhYmxlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXMgVGhlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkgeyB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGVxdWFsIHRvIGFub3RoZXIgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIEJpbk9wXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiaW5hcnkgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBcIlwiOyB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdldHMgbGVmdCBzaWRlIG9mIHRoZSBiaW5hcnkgb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGxlZnQgc2lkZSBvZiB0aGUgYmluYXJ5IG9wZXJhdGlvblxuICAgICAqL1xuICAgIHNldCBsZWZ0KGxlZnQpIHtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgcmlnaHQgc2lkZSBvZiB0aGUgYmluYXJ5IG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHJpZ2h0IHNpZGUgb2YgdGhlIGJpbmFyeSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBzZXQgcmlnaHQocmlnaHQpIHtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuQmluYXJ5T3BlcmF0aW9uID0gQmluYXJ5T3BlcmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmluYXJ5T3BlcmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmluYXJ5T3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9CaW5hcnlPcGVyYXRpb25cIik7XG5jb25zdCBWYXJpYWJsZU5vZGVfMSA9IHJlcXVpcmUoXCIuLi92YXJzL1ZhcmlhYmxlTm9kZVwiKTtcbi8vIGxlZnQgc2lkZSBpcyB2YXJpYWJsZSwgcmlnaHQgc2lkZSBpcyB2YWxcbi8vIERlY2xhcmVzIG5ldyB2YWxcbmNsYXNzIERlY2xhcmVPcCBleHRlbmRzIEJpbmFyeU9wZXJhdGlvbl8xLkJpbmFyeU9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBkZWNsYXJlIG9wZXJhdGlvbiwgd2hpY2ggZGVjbGFyZXMgYSB2YXJpYWJsZSBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbGVmdCBzaWRlIG9mIHRoZSBkZWNsYXJlIG9wICh0aGUgdmFyaWFibGUpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBvcCAodGhlIHZhbHVlKVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICBzdXBlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmICghKGxlZnQgaW5zdGFuY2VvZiBWYXJpYWJsZU5vZGVfMS5WYXJpYWJsZU5vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGFzc2lnbm1lbnQgbXVzdCBiZSBhIHZhcmlhYmxlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBkZWNsYXJhdGlvbiBieSBkZWNsYXJpbmcgdGhlIHZhcmlhYmxlIGluIHRoZSBjb250ZXh0IGFuZCBhc3NpZ25pbmcgdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmxlZnQgaW5zdGFuY2VvZiBWYXJpYWJsZU5vZGVfMS5WYXJpYWJsZU5vZGUpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVjbGFyZSh0aGlzLmxlZnQubmFtZSk7XG4gICAgICAgICAgICBsZXQgciA9IHRoaXMucmlnaHQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnRleHQuYXNzaWduKHRoaXMubGVmdC5uYW1lLCByKTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhBTFAgKGluIERlY2xhcmVPcClcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRlY2xhcmUgb3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJ2YXIgXCIgKyB0aGlzLmxlZnQudG9TdHJpbmcoKSArICcgPSAnICsgdGhpcy5yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNsYXJlT3BzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2FuJ3QgYmUgY2FsbGVkIGRpcmVjbHkgb24gYSBEZWNsYXJlT3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGJpbmFyeSBvcGVyYXRpb25zXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuRGVjbGFyZU9wID0gRGVjbGFyZU9wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVjbGFyZU9wLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBNaW51c09wXzEgPSByZXF1aXJlKFwiLi9NaW51c09wXCIpO1xuY29uc3QgQXNzaWduT3BfMSA9IHJlcXVpcmUoXCIuL0Fzc2lnbk9wXCIpO1xuY29uc3QgVmFyaWFibGVOb2RlXzEgPSByZXF1aXJlKFwiLi4vdmFycy9WYXJpYWJsZU5vZGVcIik7XG5jbGFzcyBEZWNyZW1lbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgZGVjcmVtZW50IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB2YXJpYWJsZSBUaGUgZXhwcmVzc2lvbiB0byBiZSBkZWNyZW1lbnRlZFxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhcmlhYmxlLCB3cykge1xuICAgICAgICB0aGlzLmV4cHIgPSB2YXJpYWJsZTtcbiAgICAgICAgaWYgKHZhcmlhYmxlIGluc3RhbmNlb2YgVmFyaWFibGVOb2RlXzEuVmFyaWFibGVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyUmVwID0gbmV3IEFzc2lnbk9wXzEuQXNzaWduT3AodmFyaWFibGUsIG5ldyBNaW51c09wXzEuTWludXNPcCh2YXJpYWJsZSwgbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyUmVwID0gbmV3IE1pbnVzT3BfMS5NaW51c09wKHZhcmlhYmxlLCBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgdGhlIGRlY3JlbWVudCBvcCB0byBhIE51bWJlck5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXJSZXAuZXZhbChjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGVjcmVtZW50IG9wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuZXhwci50b1N0cmluZygpICsgXCItLVwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNyZW1lbnQgb3BzIGNhbid0IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW4ndCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gZGVjcmVtZW50XG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBiaW5hcnkgb3BlcmF0aW9uc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLkRlY3JlbWVudCA9IERlY3JlbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlY3JlbWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJpbmFyeU9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vQmluYXJ5T3BlcmF0aW9uXCIpO1xuY29uc3QgU2NvcGVfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3R1cmFsL1Njb3BlXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jbGFzcyBEaXZPcCBleHRlbmRzIEJpbmFyeU9wZXJhdGlvbl8xLkJpbmFyeU9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBkaXZpc2lvbiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBUaGUgZGl2aWRlbmRcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIGRpdmlzb3JcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgc3VwZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIGRpdmlzaW9uIGFuZCBldmFsdWF0ZXMgaW50byBhIHNpbmdsZSBOdW1iZXJOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5sZWZ0LmV2YWwobmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCkpLmV2YWwoY29udGV4dCkudmFsIC8gdGhpcy5yaWdodC5ldmFsKG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpKS5ldmFsKGNvbnRleHQpLnZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpdmlzaW9uIG9wcyBjYW4ndCBiZSBkaXJlY3RseSBkcmF3blxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2FuJ3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGEgZGl2aXNpb24gb3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGJpbmFyeSBvcGVyYXRpb25zXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkaXZpc2lvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLmxlZnQudG9TdHJpbmcoKSArICcgLyAnICsgdGhpcy5yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuRGl2T3AgPSBEaXZPcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpdk9wLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBQbHVzT3BfMSA9IHJlcXVpcmUoXCIuL1BsdXNPcFwiKTtcbmNvbnN0IEFzc2lnbk9wXzEgPSByZXF1aXJlKFwiLi9Bc3NpZ25PcFwiKTtcbmNvbnN0IFZhcmlhYmxlTm9kZV8xID0gcmVxdWlyZShcIi4uL3ZhcnMvVmFyaWFibGVOb2RlXCIpO1xuY2xhc3MgSW5jcmVtZW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgSW5jcmVtZW50XG4gICAgICogQHBhcmFtIHZhcmlhYmxlIFRoZSBleHByZXNzaW9uIHRvIGluY3JlbWVudFxuICAgICAqIEBwYXJhbSB3cyBUcmFja3MgcHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2YXJpYWJsZSwgd3MpIHtcbiAgICAgICAgdGhpcy5leHByID0gdmFyaWFibGU7XG4gICAgICAgIGlmICh2YXJpYWJsZSBpbnN0YW5jZW9mIFZhcmlhYmxlTm9kZV8xLlZhcmlhYmxlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5pbm5lclJlcCA9IG5ldyBBc3NpZ25PcF8xLkFzc2lnbk9wKHZhcmlhYmxlLCBuZXcgUGx1c09wXzEuUGx1c09wKHZhcmlhYmxlLCBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJSZXAgPSBuZXcgUGx1c09wXzEuUGx1c09wKHZhcmlhYmxlLCBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMSwgXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgaW5jcmVtZW50IGludG8gYSBudW1iZXIgbm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBmdW5jdGlvbiBzY29wZVxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbm5lclJlcC5ldmFsKGNvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmNyZW1lbnRzIGNhbm5vdCBiZSBkcmF3blxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gYmlub3BzXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBiaW5hcnkgb3BlcmF0aW9uc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5jcmVtZW50IGV4cHJlc3Npb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5leHByLnRvU3RyaW5nKCkgKyBcIisrXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5JbmNyZW1lbnQgPSBJbmNyZW1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbmNyZW1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCaW5hcnlPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL0JpbmFyeU9wZXJhdGlvblwiKTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgTWludXNPcCBleHRlbmRzIEJpbmFyeU9wZXJhdGlvbl8xLkJpbmFyeU9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgc3VidHJhY3Rpb24gb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIG1pbnVlbmRcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHN1YnJhaGVuZFxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICBzdXBlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgc3VidHJhY3Rpb24gYW5kIGV2YWx1YXRlcyB0byBhIHNpbmdsZSBOdW1iZXJOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5sZWZ0LmV2YWwobmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCkpLmV2YWwoY29udGV4dCkudmFsIC0gdGhpcy5yaWdodC5ldmFsKG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpKS5ldmFsKGNvbnRleHQpLnZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0aW9uIG9wcyBjYW4ndCBiZSBkaXJlY3RseSBkcmF3blxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2FuJ3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIHN1YnRyYWN0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBiaW5hcnkgb3BlcmF0aW9uc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3VidHJhY3Rpb24gb3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5sZWZ0LnRvU3RyaW5nKCkgKyAnIC0gJyArIHRoaXMucmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLk1pbnVzT3AgPSBNaW51c09wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWludXNPcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJpbmFyeU9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vQmluYXJ5T3BlcmF0aW9uXCIpO1xuY29uc3QgU2NvcGVfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3R1cmFsL1Njb3BlXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jbGFzcyBNdWxPcCBleHRlbmRzIEJpbmFyeU9wZXJhdGlvbl8xLkJpbmFyeU9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBtdWx0aXBsaWNhdGlvbiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbXVsdGlwbGljYW5kXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSBtdWx0aXBsaWVyXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHN1cGVyKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBtdWx0aXBsaWNhdGlvbiBhbmQgcmV0dXJucyBhIHNpbmdsZSBOdW1iZXJOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5sZWZ0LmV2YWwobmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCkpLmV2YWwoY29udGV4dCkudmFsICogdGhpcy5yaWdodC5ldmFsKG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpKS5ldmFsKGNvbnRleHQpLnZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG11bHRpcGxpY2F0aW9uIG9wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMubGVmdC50b1N0cmluZygpICsgJyAqICcgKyB0aGlzLnJpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpY2F0aW9uIG9wcyBjYW5ub3QgYmUgZGlyZWN0bHkgZHJhd25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBtdWx0aXBsaWNhaXRvbiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIGRpcmVjdGx5IG9uIGJpbmFyeSBvcGVyYXRpb25zXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuTXVsT3AgPSBNdWxPcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU11bE9wLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmluYXJ5T3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9CaW5hcnlPcGVyYXRpb25cIik7XG5jb25zdCBTY29wZV8xID0gcmVxdWlyZShcIi4uL3N0cnVjdHVyYWwvU2NvcGVcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbi8vIGxlZnQgYW5kIHJpZ2h0IGFyZSBib3RoIGV4cHJlc3Npb25zXG5jbGFzcyBQbHVzT3AgZXh0ZW5kcyBCaW5hcnlPcGVyYXRpb25fMS5CaW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgYWRkaXRpb24gb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGZpcnN0IGFkZGVuZFxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgc2Vjb25kIGFkZGVuZFxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICBzdXBlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgYWRkaXRpb24gYW5kIHJldHVybnMgYSBzaW5nbGUgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMubGVmdC5ldmFsKG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQpKS5ldmFsKGNvbnRleHQpLnZhbCArIHRoaXMucmlnaHQuZXZhbChuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0KSkuZXZhbChjb250ZXh0KS52YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRpdGlvbiBvcHMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIGFuIGFkZGl0aW9uIG9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBiaW5hcnkgb3BlcmF0aW9uc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYWRkaXRpb24gb3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5sZWZ0LnRvU3RyaW5nKCkgKyAnICsgJyArIHRoaXMucmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLlBsdXNPcCA9IFBsdXNPcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBsdXNPcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0dXJhbC9TY29wZVwiKTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jb25zdCBzcGFjZV9saWZ0XzEgPSByZXF1aXJlKFwic3BhY2UtbGlmdFwiKTtcbmNsYXNzIENvbmRpdGlvbmFsIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIGNvbmRpdGlvbmFscyAoaWYsIGVsc2UgaWYsIGFuZCBlbHNlIHN0YXRlbWVudHMpXG4gICAgICogQHBhcmFtIHRlc3QgVGhlIGNvbmRpdGlvbiBvZiB0aGUgc3RhdGVtZW50XG4gICAgICogQHBhcmFtIHRydWVCcmFuY2ggVGhlIGJyYW5jaCB0byBmb2xsb3cgaWYgdGhlIGNvbmRpdGlvbiBldmFsdWF0ZXMgdG8gdHJ1ZVxuICAgICAqIEBwYXJhbSBmYWxzZUJyYW5jaCBUaGUgYnJhbmNoIHRvIGZvbGxvdyBpZiB0aGUgY29uZGl0aW9uIGV2YWx1YXRlcyB0byBmYWxzZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRlc3QsIHRydWVCcmFuY2gsIGZhbHNlQnJhbmNoKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl90ZXN0ID0gdGVzdDtcbiAgICAgICAgdGhpcy5fdHJ1ZUJyYW5jaCA9IHRydWVCcmFuY2g7XG4gICAgICAgIHRoaXMuX2ZhbHNlQnJhbmNoID0gZmFsc2VCcmFuY2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgdGVzdCByZXN1bHQgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgdHJ1ZSBvciBmYWxzZSBicmFuY2gsIGRlcGVuZGluZyBvbiB0aGUgdGVzdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgY2hpbGRDdHggPSBuZXcgU2NvcGVfMS5TY29wZShjb250ZXh0LCBjb250ZXh0LmVmZmVjdHMsIGNvbnRleHQuZXZlbnRMb2cpO1xuICAgICAgICBjaGlsZEN0eC5jYW52YXMgPSBzcGFjZV9saWZ0XzEuU29tZShjb250ZXh0LmNhbnZhcy5nZXQoKSk7XG4gICAgICAgIGxldCByZXMgPSB0aGlzLl90ZXN0LmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICBpZiAoIShyZXMgaW5zdGFuY2VvZiBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbmRpdGlvbiBtdXN0IGJlIGEgYm9vbGVhbiBleHByZXNzaW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzLnZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RydWVCcmFuY2guZXZhbChjaGlsZEN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fZmFsc2VCcmFuY2ggIT0gbnVsbCkgeyAvLyBjaGVjayBpZiBlbHNlL2Vsc2UgaWYgaXMgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYWxzZUJyYW5jaC5ldmFsKGNoaWxkQ3R4KTsgLy8gcG9zc2libHkgYSBiYWQgaWRlYVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbmRpdGlvbmFsIHN0YXRlbWVudFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzID0gJ2lmKCcgKyB0aGlzLl90ZXN0LnRvU3RyaW5nKCkgKyBcIikge1xcbiBcIiArIHRoaXMuX3RydWVCcmFuY2gudG9TdHJpbmcoKSArIFwifVwiO1xuICAgICAgICBpZiAodGhpcy5fZmFsc2VCcmFuY2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzICs9ICdcXG5lbHNlIHtcXG4gJyArIHRoaXMuX2ZhbHNlQnJhbmNoLnRvU3RyaW5nKCkgKyAnfSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cnVlIGJyYW5jaCBvZiB0aGUgY29uZGl0aW9uYWxcbiAgICAgKi9cbiAgICBnZXQgdHJ1ZUJyYW5jaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RydWVCcmFuY2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZhbHNlIGJyYW5jaCBvZiB0aGUgY29uZGl0aW9uYWxcbiAgICAgKi9cbiAgICBnZXQgZmFsc2VCcmFuY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWxzZUJyYW5jaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZGl0aW9uYWxzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBjb25kaXRpb25hbFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gY29uZGl0aW9uYWxzXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uZGl0aW9uYWwgPSBDb25kaXRpb25hbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbmRpdGlvbmFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBQYWludEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9QYWludEV2ZW50XCIpO1xuY29uc3QgUmVzaXplRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1Jlc2l6ZUV2ZW50XCIpO1xuY29uc3QgQ2xpY2tFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvQ2xpY2tFdmVudFwiKTtcbmNsYXNzIEN1cnZlRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihjdXJ2ZSkge1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7IC8vIHByaXZhdGUgYm9vbHNcbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmF0aW8gPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gMDtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5fbW91c2UgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gZXZhbHVhdGluZyBub2RlcyAoU3RyaW5nTm9kZSwgRWxsaXBzZU5vZGUsIGV0YylcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3NpZ25zIGFsbCBwYXJhbXMgdG8gcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIGRyYXdzIHRoZSBpbml0aWFsIG9iamVjdCB0byB0aGUgY2FudmFzXG4gICAgICogYnkgY2FsbGluZyB1cGRhdGUoKVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBwYXJlbnQgU2NvcGUgdGhhdCBjb250YWlucyB0aGUgY2FudmFzIGFtb25nIG90aGVyIHRoaW5nc1xuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBvYmplY3QncyBkaW1lbnNpb25zIGluY2x1ZGluZyB4IGFuZCB5IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGFzdCBVbm5lY2Vzc2FyeSBub3csIHVzZWQgdG8gYmUgdGhlIHBhcmVudCBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBpZiAoY29udGV4dC5jYW52YXMuaXNEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMgPSBkaW1zO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gY29udGV4dC5jYW52YXMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0LmNhbnZhcy5nZXQoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUGFpbnQoKSk7XG4gICAgICAgIGNvbnRleHQuZWZmZWN0cy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBpbiBvcmRlciB0byBkcmF3IGFuZCByZWRyYXcgdGhlIG9iamVjdCB3aGVuIG1hbmlwdWxhdGlvbnMgYXJlIG1hZGVcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy53O1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5oO1xuICAgICAgICBsZXQgY3VydmF0dXJlID0gdGhpcy5jdXJ2YXR1cmU7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgbGV0IHYgPSB0aGlzLnBlcnBlbmRpY3VsYXJWZWN0b3Iod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuX2N0eC5xdWFkcmF0aWNDdXJ2ZVRvKCh4ICsgd2lkdGggLyAyKSArIGN1cnZhdHVyZSAqIHZbMF0sICh5ICsgaGVpZ2h0IC8gMikgKyBjdXJ2YXR1cmUgKiB2WzFdLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSBcIiM2NzNBQjdcIjtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3R3VpZGVzKHgsIHksIHdpZHRoLCBoZWlnaHQsIHRoaXMuX2Nvcm5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9hICogdyArIGIgKiBoID0gMFxuICAgIHBlcnBlbmRpY3VsYXJWZWN0b3IodywgaCkge1xuICAgICAgICBpZiAodyA9PSAwICYmIGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3ID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbMSwgMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gWzAsIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMSwgKC13KSAvIGhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBvbmUgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTsgLy8gYmluZCBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgbWVhbmluZyBvZiAndGhpcydcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vblNoaWZ0RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vblNoaWZ0VXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmlzTW91c2VPdXRzaWRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL21ha2VzIGl0IHNvIHRoYXQgZG91YmxlIGNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRleHQgb24gdGhlIHBhZ2VcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgZnVuY3Rpb24gKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZmFsc2U7IH0sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gYW5vdGhlciBmZWxsIHN3b29wXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9mIHRoZSBvYmplY3QncyBib3VuZGluZyByZWN0YW5nbGUsIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBjb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGlmIChteCA+IHggJiYgbXggPCB4ICsgdyAmJiBteSA+IHkgJiYgbXkgPCB5ICsgaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbnVtYmVyID4gMCBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9uZSBvZiB0aGUgY29ybmVyL3NpZGUgZ3VpZGVzLCByZXR1cm5zIDAgaWYgbm90XG4gICAgICogVGhlIGNvcm5lciBndWlkZXMgYXJlIG51bWJlcmVkIDEtNCB3aXRoIDEgYmVpbmcgdGhlIHRvcCBsZWZ0LCAyIGJlaW5nIHRoZSB0b3AgcmlnaHQsIGFuZCBzbyBvbi5cbiAgICAgKiBUaGUgbWlkZGxlIGd1aWRlcyBhcmUgbnVtYmVyZWQgNS04LCB3aXRoIDUgYmVpbmcgdGhlIHRvcCBtaWRkbGUsIDYgYmVpbmcgdGhlIHJpZ2h0IG1pZGRsZSwgYW5kIHNvIG9uLlxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBndWlkZUNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgbGV0IHhkaWYgPSBteCAtIHg7XG4gICAgICAgIGxldCB5ZGlmID0gbXkgLSB5O1xuICAgICAgICAvKiBDb3JuZXIgR3VpZGVzICovXG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgfVxuICAgICAgICAvKiBNaWRkbGUgR3VpZGVzICovXG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICB5ZGlmID0gbXkgLSB5O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIG1pZGRsZVxuICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9taWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiA2O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGgpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgcmV0dXJuIDc7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9taWRkbGUgbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBib3VuZGluZyByZWN0YW5nbGUgYW5kIGd1aWRlcyBmb3IgdGhlIG9iamVjdCB3aGVuIHRoZSBvYmplY3QgaXMgc2VsZWN0ZWRcbiAgICAgKiBJZiBvbmUgb2YgdGhlIGd1aWRlcyBpcyBzZWxlY3RlZCwgaXQgY29sb3JzIHRoYXQgZ3VpZGUgYmx1ZVxuICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB5IHRoZSB5IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB3IHRoZSB3aWR0aCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggdGhlIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvcm5lciB0aGUgbnVtYmVyIG9mIHRoZSBjb3JuZXIgdG8gYmUgY29sb3JlZCBibHVlIChpZiBhbnkgYXQgYWxsLCBpZiAwLCBhbGwgYXJlIHdoaXRlKVxuICAgICAqL1xuICAgIGRyYXdHdWlkZXMoeCwgeSwgdywgaCwgY29ybmVyKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAoY29ybmVyICE9PSAwICYmIGNvcm5lciA8PSA0KSB7IC8vIGEgY29ybmVyIGd1aWRlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgY29ycmVjdCBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvcm5lciAhPT0gMCkgeyAvLyBhIG1pZGRsZSBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcnJlY3QgZ3VpZGUgYmx1ZVxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy9pZiBubyBndWlkZXMgYXJlIHNlbGVjdGVkLCBjb2xvcnMgZXZlcnl0aGluZyB3aGl0ZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltcGxlIG1ldGhvZCB0aGF0IGRyYXdzIGEgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHggeCBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geSB5IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB3IHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb2xvciBjb2xvciBvZiB0aGUgcmVjdGFuZ2xlJ3MgZmlsbFxuICAgICAqL1xuICAgIGRyYXdTcXVhcmUoeCwgeSwgdywgaCwgY29sb3IpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIHdpdGhpbiB0aGUgY2FudmFzLlxuICAgICAqIEdldHMgdGhlIG1vdXNlIHBvc2l0aW9uLCBjYWxscyB0aGUgbW9kaWZ5IG1ldGhvZHMgaWYgdGhlIGJvb2xlYW5zIHNhdGlzZnkgdGhlbS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZ2V0TW91c2VQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeURyYWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jlc2l6aW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplKHRoaXMudyA8IDEwLCB0aGlzLmggPCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNDaGFuZ2luZ0RpbXMgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zKHRoaXMudyA8IDEwLCB0aGlzLmggPCAxMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBjbGlja3MgaW5zaWRlIHRoZSBjYW52YXMuXG4gICAgICogTW9kaWZpZXMgdGhlIHN0YXRlIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBndWlkZXMgY29udGFpbiB0aGUgbW91c2Ugb3IgdGhlIGJvdW5kaW5nIHJlY3QgY29udGFpbnMgdGhlIG1vdXNlLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlTdGF0ZSh0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSksIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIHVuY2xpY2tzLlxuICAgICAqIENhbGxzIG1vZGlmeVJlc2V0IHRvIHJlc2V0IGRyYWdnaW5nIGFuZCByZXNpemluZyBib29sZWFucyBhbW9uZyBvdGhlcnMuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZXVwIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5UmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHByZXNzZWQgZG93blxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHByZXNzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnREb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyByZWxlYXNlZFxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHJlbGVhc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0VXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIE1vZGlmaWNhdGlvbiBmdW5jdGlvbnMgKi9cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgaW4gb3JkZXIgdG8gZHJhZyB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIG1vZGlmeURyYWcoKSB7XG4gICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLl9kcmFnb2ZmeDtcbiAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueSAtIHRoaXMuX2RyYWdvZmZ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBzaXplIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQgKHdoZW4gYSBjb3JuZXIgZ3VpZGUgaXMgY2xpY2tlZCBhbmQgZHJhZ2dlZCkuXG4gICAgICpcbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDEwIGFuZCB0aGUgb3RoZXIgZXF1YWwgdG9cbiAgICAgKiAxMCBkaXZpZGVkIG9yIG11bHRpcGxpZWQgYnkgdGhlIHJhdGlvIG9mIHdpZHRoL2hlaWdodCB0byBrZWVwIGl0IHRoZSBzYW1lLlxuICAgICAqXG4gICAgICogVGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgaXMgZG9uZSBieSBjYWxsaW5nIHRoZSBoZWxwZXIgbWV0aG9kIG1vZGlmeVJlc2l6ZUhlbHBlci5cbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNpemUod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgaWYgKHdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTsgLy8gc2V0IGZvciB0aGUgcHJvZGlyZWN0IG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMCAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fY3VydmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAvIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7IC8vIHNldCBmb3IgdGhlIHByb2RpcmVjdCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMCAqIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fY3VydmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyAxLCAyLCBvciA0IGFyZSBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0Rpc3RhbmNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBtb3VzZSBhbmQgdGhlIGxvY2F0aW9uIG9wcG9zaXRlIHRvIGl0XG4gICAgICogKGlmIHRvcCByaWdodCBndWlkZSBpcyBjbGlja2VkLCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGFuZCB0aGUgYm90dG9tIGxlZnQgZ3VpZGUgaXMgbmV3RGlzdGFuY2UpXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZCgobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpIC8gdGhpcy5fcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgdGhpcy5fY3VydmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAvIHRoaXMuX3JhdGlvO1xuICAgICAgICB0aGlzLl9jdXJ2ZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkLlxuICAgICAqIElmIGFueSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgdG9vIHNtYWxsLCBpdCBzZXRzIHRoZW0gZXF1YWwgdG8gMTAuXG4gICAgICogQ2FsbHMgbW9kaWZ5Q2hhbmdlRGltc0hlbHBlciB0byBhY3R1YWxseSBkbyB0aGUgd29ya1xuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqL1xuICAgIG1vZGlmeUNoYW5nZURpbXMod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgaWYgKHdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGUgcmVjdGFuZ2xlIG9yaWdpbmF0ZXMgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIGFuZCBub3QgdGhlIGNlbnRlcixcbiAgICAgKiBpdCBjaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFzIHdlbGwgaWYgZ3VpZGVzIDUgb3IgOCBhcmUgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmggPiAxMCkgeyAvL2FzIGxvbmcgYXMgdGhlIGhlaWdodCBpcyA+IDEwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VydmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnZlLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VydmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53ID4gMTApIHsgLy8gYXMgbG9uZyBhcyB3aWR0aCBpcyA+IDEwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJ2ZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIGRlcGVuZGluZyBvbiB0aGUgbW91c2UgcG9zaXRpb24gd2hlbiBjYWxsZWQgKG9uTW91c2VEb3duKVxuICAgICAqIGUuZy4gaWYgdGhlIG1vdXNlIGlzIHdpdGhpbiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIHdoZW4gdGhpcyBpcyBjYWxsZWQsIGlzU2VsZWN0ZWQgPSB0cnVlXG4gICAgICogQHBhcmFtIGd1aWRlQ29udGFpbnNcbiAgICAgKiBAcGFyYW0gY29udGFpbnNcbiAgICAgKi9cbiAgICBtb2RpZnlTdGF0ZShndWlkZUNvbnRhaW5zLCBjb250YWlucykge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy9wcmVwYXJlcyB0aGUgb2JqZWN0IGZvciBkcmFnZ2luZyB3aGV0aGVyIGl0IGlzIHBlcnNvbmFsbHkgc2VsZWN0ZWQgb3Igbm90XG4gICAgICAgICAgICBpZiAoY29udGFpbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94MSA9IHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl95MSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucyA+IDAgJiYgZ3VpZGVDb250YWlucyA8PSA0KSB7IC8vcmVzaXppbmdcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KTtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodDEgPSB0aGlzLmg7XG4gICAgICAgICAgICB0aGlzLl93aWR0aDEgPSB0aGlzLnc7XG4gICAgICAgICAgICAvL3RoaXMuX3NpemUxID0gTWF0aC5zcXJ0KE1hdGgucG93KHcsMikgKyBNYXRoLnBvdyhoLDIpKTsgLy8gc2l6ZSBpcyBkaWFnb25hbCBsZW5ndGhcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7IC8vIHNldHMgdGhlIG9mZnNldHMgZGVwZW5kaW5nIG9uIHdoaWNoIGNvcm5lciBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdzsgLy8gb2Zmc2V0IGlzIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDsgLy8gb2Zmc2V0IGlzIGJvdHRvbSBsZWZ0LCBldGNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiA0KSB7IC8vY2hhbmdpbmcgc2hhcGUgZGltZW5zaW9uc1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSBndWlkZUNvbnRhaW5zO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHsgLy8gc2V0cyB0aGUgb2Zmc2V0cyBkZXBlbmRpbmcgb24gd2hpY2ggbWlkZGxlIGd1aWRlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgY2FzZSA1OiAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3IC8gMjsgLy8gb2Zmc2V0IGlzIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OiAvL3JpZ2h0IG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5ICsgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyOyAvLyBvZmZzZXQgaXMgbGVmdCBtaWRkbGUgZXRjXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdyAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSArIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKSB7IC8vIGRyYWdnaW5nXG4gICAgICAgICAgICB0aGlzLl94MSA9IHg7IC8vIFNhdmluZyBvcmlnaW5hbCB4IGFuZCB5XG4gICAgICAgICAgICB0aGlzLl95MSA9IHk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkgeyAvLyBub3Qgc2VsZWN0ZWRcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIHRvIGZhbHNlIChsaWtlIGRyYWdnaW5nLCByZXNpemluZywgZXRjKSB3aGVuIHRoZSBtb3VzZSBpcyByZWxlYXNlZFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB0aGlzLngpID4gMSB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHRoaXMueSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh0aGlzLl9pc1Jlc2l6aW5nIHx8IHRoaXMuX2lzQ2hhbmdpbmdEaW1zKSAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc2l6ZTIgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53LCAyKSArIE1hdGgucG93KHRoaXMuaCwgMikpO1xuICAgICAgICAgICAgaWYgKChNYXRoLmFicyh0aGlzLl93aWR0aDEgLSB0aGlzLncpID4gMCkgfHwgKE1hdGguYWJzKHRoaXMuX2hlaWdodDEgLSB0aGlzLmgpID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dSZXNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKi9cbiAgICBnZXRNb3VzZVBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLl9tb3VzZS54ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueDtcbiAgICAgICAgdGhpcy5fbW91c2UueSA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNDaGFuZ2luZ0RpbXMsIGFuZCBpc1NlbGVjdGVkIHRvIGZhbHNlIGlmIHRoZSBtb3VzZSBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBpc01vdXNlT3V0c2lkZShldmVudCkge1xuICAgICAgICBsZXQgbW91c2VYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgbGV0IG1vdXNlWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5fY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobW91c2VYIDwgcmVjdC5sZWZ0IHx8IG1vdXNlWCA+IHJlY3QucmlnaHQgfHwgbW91c2VZIDwgcmVjdC50b3AgfHwgbW91c2VZID4gcmVjdC5ib3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZWN0YW5nbGUgcGFpbnQgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dQYWludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWludEV2ZW50XzEuUGFpbnRFdmVudChcInJlY3RhbmdsZVwiLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZWN0YW5nbGUgcmVzaXplIGV2ZW50XG4gICAgICovXG4gICAgbG9nUmVzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZUV2ZW50XzEuUmVzaXplRXZlbnQoXCJyZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCBNYXRoLnJvdW5kKHRoaXMuX3dpZHRoMSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5faGVpZ2h0MSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy53ICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLmggKiAxMDApIC8gMTAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlY3RhbmdsZSBjbGljayBldmVudFxuICAgICAqL1xuICAgIGxvZ0NsaWNrKCkge1xuICAgICAgICByZXR1cm4gbmV3IENsaWNrRXZlbnRfMS5DbGlja0V2ZW50KFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgYXNzaWducyBhbiBJRCB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgaW5pdElEKGlkKSB7XG4gICAgICAgIHRoaXMuaWRPYmogPSB7IF9pZDogaWQgfTtcbiAgICB9XG4gICAgYXN0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJ2YXR1cmUgb2YgdGhlIGN1cnZlXG4gICAgICovXG4gICAgZ2V0IGN1cnZhdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMuY3VydmF0dXJlLmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBEaW1lbnNpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBkaW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkT2JqLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKi9cbiAgICBnZXRKdXN0RHJhZ2dlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1c3REcmFnZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgc2V0SnVzdERyYWdnZWQodmFsKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGlzIGRyYWdnaW5nXG4gICAgICovXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIHNlbGVjdGlvbiBldmVudHNcbiAgICAgKi9cbiAgICB0b1NlbFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiIHJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIGRyYWcgZXZlbnRzXG4gICAgKi9cbiAgICB0b0RyYWdTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoXCJyZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgZnJvbSBcIiArIHRoaXMuX3gxICsgXCIsIFwiICsgdGhpcy5feTEgKyBcIiB0byBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgSUQgYXNzaWdubWVudCBldmVudHNcbiAgICAgKi9cbiAgICB0b0lEU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaWRPYmouX2lkLnRvU3RyaW5nKCkgKyBcIiB0byByZWN0YW5nbGUgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ3VydmVFZmZlY3QgPSBDdXJ2ZUVmZmVjdDtcbi8qKlxuICogR2V0cyB0aGUgbW91c2UgeCBhbmQgeSBjb29yZGluYXRlcyBpbiByZWxhdGlvbiB0byB0aGUgY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHRoZSBjYW52YXMgb2JqZWN0XG4gKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICovXG5mdW5jdGlvbiBnZXRNb3VzZVBvcyhjYW52YXMsIGV2ZW50KSB7XG4gICAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHgxIHggY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHkxIHkgY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHgyIHggY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSB5MiB5IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgyLCAyKSArIE1hdGgucG93KHkxIC0geTIsIDIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUN1cnZlRWZmZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUGFpbnRFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUGFpbnRFdmVudFwiKTtcbmNvbnN0IFJlc2l6ZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9SZXNpemVFdmVudFwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgQ2xpY2tFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvQ2xpY2tFdmVudFwiKTtcbmNsYXNzIEVsbGlwc2VFZmZlY3Qge1xuICAgIGNvbnN0cnVjdG9yKGNpcmNsZSkge1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7IC8vIFByaXZhdGUgYm9vbHNcbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTsgLy8gSGFzIHRoaXMgb2JqZWN0IGp1c3QgYmVlbiBkcmFnZ2VkP1xuICAgICAgICB0aGlzLl9yYXRpbyA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSAwO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9tb3VzZSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NpcmNsZSA9IGNpcmNsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIGV2YWx1YXRpbmcgbm9kZXMgKFN0cmluZ05vZGUsIEVsbGlwc2VOb2RlLCBldGMpXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyBhbGwgcGFyYW1zIHRvIHByaXZhdGUgdmFyaWFibGVzIGFuZCBkcmF3cyB0aGUgaW5pdGlhbCBvYmplY3QgdG8gdGhlIGNhbnZhc1xuICAgICAqIGJ5IGNhbGxpbmcgdXBkYXRlKClcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgcGFyZW50IFNjb3BlIHRoYXQgY29udGFpbnMgdGhlIGNhbnZhcyBhbW9uZyBvdGhlciB0aGluZ3NcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgb2JqZWN0J3MgZGltZW5zaW9ucyBpbmNsdWRpbmcgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBhc3QgVW5uZWNlc3Nhcnkgbm93LCB1c2VkIHRvIGJlIHRoZSBwYXJlbnQgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY2FudmFzLmlzRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zID0gZGltcztcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IGNvbnRleHQuY2FudmFzLmdldCgpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgY3R4ID0gY29udGV4dC5jYW52YXMuZ2V0KCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvZ2dpbmdcbiAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUGFpbnQoKSk7XG4gICAgICAgIGNvbnRleHQuZWZmZWN0cy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBpbiBvcmRlciB0byBkcmF3IGFuZCByZWRyYXcgdGhlIG9iamVjdCB3aGVuIG1hbmlwdWxhdGlvbnMgYXJlIG1hZGVcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5lbGxpcHNlKHgsIHksIHcgLyAyLCBoIC8gMiwgMCwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICAgICAgLy90aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIC8vdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gXCIjRDVCOEZGXCI7XG4gICAgICAgIHRoaXMuX2N0eC5zaGFkb3dDb2xvciA9IFwiIzZDNkM2Q1wiO1xuICAgICAgICB0aGlzLl9jdHguc2hhZG93Qmx1ciA9IDE1O1xuICAgICAgICAvL3RoaXMuX2N0eC5zaGFkb3dPZmZzZXRYID0gMjtcbiAgICAgICAgLy90aGlzLl9jdHguc2hhZG93T2Zmc2V0WSA9IDI7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdHdWlkZXMoeCAtIHcgLyAyLCB5IC0gaCAvIDIsIHcsIGgsIHRoaXMuX2Nvcm5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAgICAgcHJpdmF0ZSBtb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHByaXZhdGUgbW91c2VEb3duID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICBwcml2YXRlIG1vdXNlVXAgPSB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICBwcml2YXRlIHNoaWZ0RG93biA9IHRoaXMub25TaGlmdERvd24uYmluZCh0aGlzKTtcbiAgICAgICAgcHJpdmF0ZSBzaGlmdFVwID0gdGhpcy5vblNoaWZ0VXAuYmluZCh0aGlzKTtcbiAgICAgICAgcHJpdmF0ZSBtb3VzZU91dHNpZGUgPSB0aGlzLmlzTW91c2VPdXRzaWRlLmJpbmQodGhpcyk7XG4gICAgICAgIHByaXZhdGUgc2VsZWN0U3RhcnQgPSBmdW5jdGlvbihlOmFueSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IHJldHVybiBmYWxzZTsgfTtcbiAgICAqL1xuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIG9uZSBmZWxsIHN3b29wXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpOyAvLyBiaW5kIGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBtZWFuaW5nIG9mICd0aGlzJ1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uU2hpZnREb3duLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uU2hpZnRVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaXNNb3VzZU91dHNpZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vbWFrZXMgaXQgc28gdGhhdCBkb3VibGUgY2xpY2tpbmcgZG9lc24ndCBzZWxlY3QgdGV4dCBvbiB0aGUgcGFnZVxuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBmdW5jdGlvbiAoZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IHJldHVybiBmYWxzZTsgfSwgZmFsc2UpO1xuICAgIH1cbiAgICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgLypcbiAgICAgICAgY29uc29sZS5sb2coXCJyZW1vdmluZyBFdmVudExpc3RuZXJzXCIpO1xuICAgICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlTW92ZSk7IC8vIGJpbmQgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIG1lYW5pbmcgb2YgJ3RoaXMnXG4gICAgICAgICAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2VEb3duKTtcbiAgICAgICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubW91c2VVcCk7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLnNoaWZ0RG93bik7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5zaGlmdFVwKTtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZU91dHNpZGUpO1xuICAgICAgICAgIC8vbWFrZXMgaXQgc28gdGhhdCBkb3VibGUgY2xpY2tpbmcgZG9lc24ndCBzZWxlY3QgdGV4dCBvbiB0aGUgcGFnZVxuICAgICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHRoaXMuc2VsZWN0U3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAqL1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvZiB0aGUgb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgY29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICByZXR1cm4gTWF0aC5wb3cobXggLSB4LCAyKSAvIE1hdGgucG93KHcgLyAyLCAyKSArIE1hdGgucG93KG15IC0geSwgMikgLyBNYXRoLnBvdyhoIC8gMiwgMikgPD0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciA+IDAgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvbmUgb2YgdGhlIGNvcm5lci9zaWRlIGd1aWRlcywgcmV0dXJucyAwIGlmIG5vdFxuICAgICAqIFRoZSBjb3JuZXIgZ3VpZGVzIGFyZSBudW1iZXJlZCAxLTQgd2l0aCAxIGJlaW5nIHRoZSB0b3AgbGVmdCwgMiBiZWluZyB0aGUgdG9wIHJpZ2h0LCBhbmQgc28gb24uXG4gICAgICogVGhlIG1pZGRsZSBndWlkZXMgYXJlIG51bWJlcmVkIDUtOCwgd2l0aCA1IGJlaW5nIHRoZSB0b3AgbWlkZGxlLCA2IGJlaW5nIHRoZSByaWdodCBtaWRkbGUsIGFuZCBzbyBvbi5cbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ3VpZGVDb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGxldCB4ZGlmID0gbXggLSAoeCAtIHcgLyAyKTtcbiAgICAgICAgbGV0IHlkaWYgPSBteSAtICh5IC0gaCAvIDIpO1xuICAgICAgICAvKiBDb3JuZXIgR3VpZGVzICovXG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3IC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGggLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggLSB3IC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogTWlkZGxlIEd1aWRlcyAqL1xuICAgICAgICB4ZGlmID0gbXggLSB4O1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSAtIGggLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICB5ZGlmID0gbXkgLSB5O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSB4O1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGggLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4IC0gdyAvIDIpO1xuICAgICAgICB5ZGlmID0gbXkgLSB5O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGFuZCBndWlkZXMgZm9yIHRoZSBvYmplY3Qgd2hlbiB0aGUgb2JqZWN0IGlzIHNlbGVjdGVkXG4gICAgICogSWYgb25lIG9mIHRoZSBndWlkZXMgaXMgc2VsZWN0ZWQsIGl0IGNvbG9ycyB0aGF0IGd1aWRlIGJsdWVcbiAgICAgKiBAcGFyYW0geCB0aGUgeCBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0geSB0aGUgeSBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb3JuZXIgdGhlIG51bWJlciBvZiB0aGUgY29ybmVyIHRvIGJlIGNvbG9yZWQgYmx1ZSAoaWYgYW55IGF0IGFsbCwgaWYgMCwgYWxsIGFyZSB3aGl0ZSlcbiAgICAgKi9cbiAgICBkcmF3R3VpZGVzKHgsIHksIHcsIGgsIGNvcm5lcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKGNvcm5lciAhPT0gMCAmJiBjb3JuZXIgPD0gNCkge1xuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcnJlY3QgZ3VpZGUgYmx1ZVxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3JuZXIgIT09IDAgJiYgY29ybmVyID4gNCkge1xuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcnJlY3QgZ3VpZGUgYmx1ZVxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBtZXRob2QgdGhhdCBkcmF3cyBhIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB4IHggY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHkgeSBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gdyB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29sb3IgY29sb3Igb2YgdGhlIHJlY3RhbmdsZSdzIGZpbGxcbiAgICAgKi9cbiAgICBkcmF3U3F1YXJlKHgsIHksIHcsIGgsIGNvbG9yKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBtb3ZlcyB3aXRoaW4gdGhlIGNhbnZhcy5cbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiwgY2FsbHMgdGhlIG1vZGlmeSBtZXRob2RzIGlmIHRoZSBib29sZWFucyBzYXRpc2Z5IHRoZW0uXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICB0aGlzLmdldE1vdXNlUG9zaXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlEcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZXNpemluZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZSh0aGlzLncgPCAxNCwgdGhpcy5oIDwgMTQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQ2hhbmdpbmdEaW1zICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltcyh0aGlzLncgPCAxNCwgdGhpcy5oIDwgMTQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5U3RhdGUodGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpLCB0aGlzLmNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSB1bmNsaWNrcy5cbiAgICAgKiBDYWxscyBtb2RpZnlSZXNldCB0byByZXNldCBkcmFnZ2luZyBhbmQgcmVzaXppbmcgYm9vbGVhbnMgYW1vbmcgb3RoZXJzLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2V1cCBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VVcChldmVudCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiSSdtIGFuIGVsbGlwc2UhXCIpO1xuICAgICAgICB0aGlzLm1vZGlmeVJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyBwcmVzc2VkIGRvd25cbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSBwcmVzc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcmVsZWFzZWRcbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSByZWxlYXNlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdFVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBNb2RpZmljYXRpb24gZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGRyYWcgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBtb2RpZnlEcmFnKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiZWxsaXBzZSBkcmFnb2ZmeDogXCIgKyB0aGlzLl9kcmFnb2ZmeCk7XG4gICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLl9kcmFnb2ZmeDtcbiAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueSAtIHRoaXMuX2RyYWdvZmZ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBzaXplIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQgKHdoZW4gYSBjb3JuZXIgZ3VpZGUgaXMgY2xpY2tlZCBhbmQgZHJhZ2dlZCkuXG4gICAgICpcbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDE0IGFuZCB0aGUgb3RoZXIgZXF1YWwgdG9cbiAgICAgKiAxMCBkaXZpZGVkIG9yIG11bHRpcGxpZWQgYnkgdGhlIHJhdGlvIG9mIHdpZHRoL2hlaWdodCB0byBrZWVwIGl0IHRoZSBzYW1lLlxuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDE0XG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxNFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2l6ZSh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBpZiAod2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDE0O1xuICAgICAgICAgICAgdGhpcy5fY2lyY2xlLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDE0KTsgLy8gc2V0IGZvciB0aGUgcHJvZGlyZWN0IG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxNCAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fY2lyY2xlLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDE0IC8gdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMiAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTQ7XG4gICAgICAgICAgICB0aGlzLl9jaXJjbGUuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDE0KTsgLy8gc2V0IGZvciB0aGUgcHJvZGlyZWN0IG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDE0ICogdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9jaXJjbGUud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxNCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDI7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDIgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMjtcbiAgICAgICAgICAgIHRoaXMuX2NpcmNsZS53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDIgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2NpcmNsZS5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZC5cbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDEwLlxuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqL1xuICAgIG1vZGlmeUNoYW5nZURpbXMod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgaWYgKHRoaXMuX2Nvcm5lciA9PSA1IHx8IHRoaXMuX2Nvcm5lciA9PSA3KSB7IC8vIGlmIG1vZGlmeWluZyBoZWlnaHRcbiAgICAgICAgICAgIGlmICghaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpICogMiAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDsgLy8gc2V0dGluZyB3aWR0aC9oZWlnaHQgcmF0aW8gPSB0byB0aGUgbmV3IHJhdGlvXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDE0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDIgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBtb2RpZnlpbmcgd2lkdGhcbiAgICAgICAgICAgIGlmICghd2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDI7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDE0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIGRlcGVuZGluZyBvbiB0aGUgbW91c2UgcG9zaXRpb24gd2hlbiBjYWxsZWQgKG9uTW91c2VEb3duKVxuICAgICAqIGUuZy4gaWYgdGhlIG1vdXNlIGlzIHdpdGhpbiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIHdoZW4gdGhpcyBpcyBjYWxsZWQsIGlzU2VsZWN0ZWQgPSB0cnVlXG4gICAgICogQHBhcmFtIGd1aWRlQ29udGFpbnNcbiAgICAgKiBAcGFyYW0gY29udGFpbnNcbiAgICAgKi9cbiAgICBtb2RpZnlTdGF0ZShndWlkZUNvbnRhaW5zLCBjb250YWlucykge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkgeyAvL3ByZXBhcmVzIHRoZSBvYmplY3QgZm9yIGRyYWdnaW5nIHdoZXRoZXIgaXQgaXMgcGVyc29uYWxseSBzZWxlY3RlZCBvciBub3RcbiAgICAgICAgICAgIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kxID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiAwICYmIGd1aWRlQ29udGFpbnMgPD0gNCkgeyAvL3Jlc2l6aW5nXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSBndWlkZUNvbnRhaW5zO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLng7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMueTtcbiAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoMSA9IHRoaXMudztcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodDEgPSB0aGlzLmg7XG4gICAgICAgICAgICAvL3RoaXMuX3NpemUxID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMudywyKSArIE1hdGgucG93KHRoaXMuaCwyKSk7IC8vIHNhdmluZyBvbGQgc2l6ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiA0KSB7IC8vY2hhbmdpbmcgc2hhcGUgZGltZW5zaW9uc1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSBndWlkZUNvbnRhaW5zO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLng7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMueTtcbiAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWlucykgeyAvL3NpbXBseSBzZWxlY3RpbmcgdGhlIHNoYXBlIG9yIGRyYWdnaW5nXG4gICAgICAgICAgICB0aGlzLl94MSA9IHRoaXMueDsgLy8gU2F2aW5nIG9yaWdpbmFsIHggYW5kIHlcbiAgICAgICAgICAgIHRoaXMuX3kxID0gdGhpcy55O1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ0NsaWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyB0byBmYWxzZSAobGlrZSBkcmFnZ2luZywgcmVzaXppbmcsIGV0Yykgd2hlbiB0aGUgbW91c2UgaXMgcmVsZWFzZWRcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkgeyAvLyBwcm9icyBvbmx5IG5lZWQgZHJhZ2dpbmcgYnV0IG9oIHdlbGwgfCBpc1NlbCB8fCBzZWxNdWw/XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB0aGlzLngpID4gMSB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHRoaXMueSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nTW92ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodGhpcy5faXNSZXNpemluZyB8fCB0aGlzLl9pc0NoYW5naW5nRGltcykgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInJlc2l6aW5nIGVsbGlwc2VcIik7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvL2xldCBzaXplMiA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLncsMikgKyBNYXRoLnBvdyh0aGlzLmgsMikpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNpemUgZGlmZjogXCIgKyBNYXRoLmFicyh0aGlzLl9zaXplMSAtIHNpemUyKSk7XG4gICAgICAgICAgICBpZiAoKE1hdGguYWJzKHRoaXMuX3dpZHRoMSAtIHRoaXMudykgPiAwKSB8fCAoTWF0aC5hYnModGhpcy5faGVpZ2h0MSAtIHRoaXMuaCkgPiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1Jlc2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZih0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKXtcbiAgICAgICAgLy8gICAgIGlmKE1hdGguYWJzKHRoaXMuX3gxIC0gdGhpcy54KSA+IDEgfHwgTWF0aC5hYnModGhpcy5feTEgLSB0aGlzLnkpID4gMSkge1xuICAgICAgICAvLyAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ01vdmUoKSk7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKi9cbiAgICBnZXRNb3VzZVBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLl9tb3VzZS54ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueDtcbiAgICAgICAgdGhpcy5fbW91c2UueSA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNDaGFuZ2luZ0RpbXMsIGFuZCBpc1NlbGVjdGVkIHRvIGZhbHNlIGlmIHRoZSBtb3VzZSBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBpc01vdXNlT3V0c2lkZShldmVudCkge1xuICAgICAgICBsZXQgbW91c2VYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgbGV0IG1vdXNlWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5fY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobW91c2VYIDwgcmVjdC5sZWZ0IHx8IG1vdXNlWCA+IHJlY3QucmlnaHQgfHwgbW91c2VZIDwgcmVjdC50b3AgfHwgbW91c2VZID4gcmVjdC5ib3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHBhaW50IGV2ZW50XG4gICAgICovXG4gICAgbG9nUGFpbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpbnRFdmVudF8xLlBhaW50RXZlbnQoXCJlbGxpcHNlXCIsIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlc2l6ZSBldmVudFxuICAgICAqL1xuICAgIGxvZ1Jlc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVFdmVudF8xLlJlc2l6ZUV2ZW50KFwiZWxsaXBzZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIE1hdGgucm91bmQodGhpcy5fd2lkdGgxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLl9oZWlnaHQxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLncgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuaCAqIDEwMCkgLyAxMDApO1xuICAgICAgICAvL01hdGgucm91bmQodGhpcy5fc2l6ZTEqMTAwKS8xMDAsIE1hdGgucm91bmQoKE1hdGguc3FydChNYXRoLnBvdyh0aGlzLncsMikgKyBNYXRoLnBvdyh0aGlzLmgsMikpKjEwMCkpLzEwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSBjbGljayBldmVudFxuICAgICAqL1xuICAgIGxvZ0NsaWNrKCkge1xuICAgICAgICByZXR1cm4gbmV3IENsaWNrRXZlbnRfMS5DbGlja0V2ZW50KFwiZWxsaXBzZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIGFzc2lnbnMgYW4gSUQgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIGlkIFRoZSBJRCB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIGluaXRJRChpZCkge1xuICAgICAgICB0aGlzLmlkT2JqID0geyBfaWQ6IGlkIH07XG4gICAgfVxuICAgIGFzdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHggcG9zaXRpb24gb2YgdGhlIGVsbGlwc2VcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgZWxsaXBzZVxuICAgICAqL1xuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgZWxsaXBzZVxuICAgICAqL1xuICAgIGdldCB3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBlbGxpcHNlXG4gICAgICovXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRGltZW5zaW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgZGltcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVsbGlwc2UgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgZWxsaXBzZVxuICAgICAqL1xuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZE9iai5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVsbGlwc2UgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICovXG4gICAgZ2V0SnVzdERyYWdnZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdXN0RHJhZ2dlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgZWxsaXBzZSBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldEp1c3REcmFnZ2VkKHZhbCkge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZWxsaXBzZSBpcyBkcmFnZ2luZ1xuICAgICAqL1xuICAgIGdldCBpc0RyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEcmFnZ2luZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBzZWxlY3Rpb24gZXZlbnRzXG4gICAgICovXG4gICAgdG9TZWxTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoXCIgZWxsaXBzZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBkcmFnIGV2ZW50c1xuICAgICovXG4gICAgdG9EcmFnU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKFwiZWxsaXBzZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBmcm9tIFwiICsgdGhpcy5feDEgKyBcIiwgXCIgKyB0aGlzLl95MSArIFwiIHRvIFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBJRCBhc3NpZ25tZW50IGV2ZW50c1xuICAgICAqL1xuICAgIHRvSURTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pZE9iai5faWQudG9TdHJpbmcoKSArIFwiIHRvIGVsbGlwc2UgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRWxsaXBzZUVmZmVjdCA9IEVsbGlwc2VFZmZlY3Q7XG4vKipcbiAqIEdldCdzIHRoZSBtb3VzZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGluIHJlbGF0aW9uIHRvIHRoZSBjYW52YXNcbiAqIEBwYXJhbSBjYW52YXMgdGhlIGNhbnZhcyBvYmplY3RcbiAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGdldE1vdXNlUG9zKGNhbnZhcywgZXZlbnQpIHtcbiAgICBsZXQgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0LFxuICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gcmVjdC50b3BcbiAgICB9O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0geDEgeCBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geTEgeSBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geDIgeCBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICogQHBhcmFtIHkyIHkgY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDIsIDIpICsgTWF0aC5wb3coeTEgLSB5MiwgMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RWxsaXBzZUVmZmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgUGFpbnRFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUGFpbnRFdmVudFwiKTtcbmNvbnN0IFJlc2l6ZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9SZXNpemVFdmVudFwiKTtcbmNvbnN0IENsaWNrRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL0NsaWNrRXZlbnRcIik7XG5jbGFzcyBFcGhFZmZlY3Qge1xuICAgIGNvbnN0cnVjdG9yKGVwaCkge1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7IC8vIHByaXZhdGUgYm9vbHNcbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmF0aW8gPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gMDtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5fbW91c2UgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9lcGggPSBlcGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiBldmFsdWF0aW5nIG5vZGVzIChTdHJpbmdOb2RlLCBFbGxpcHNlTm9kZSwgZXRjKVxuICAgICAqIFRoaXMgbWV0aG9kIGFzc2lnbnMgYWxsIHBhcmFtcyB0byBwcml2YXRlIHZhcmlhYmxlcyBhbmQgZHJhd3MgdGhlIGluaXRpYWwgb2JqZWN0IHRvIHRoZSBjYW52YXNcbiAgICAgKiBieSBjYWxsaW5nIHVwZGF0ZSgpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIHBhcmVudCBTY29wZSB0aGF0IGNvbnRhaW5zIHRoZSBjYW52YXMgYW1vbmcgb3RoZXIgdGhpbmdzXG4gICAgICogQHBhcmFtIGRpbXMgVGhlIG9iamVjdCdzIGRpbWVuc2lvbnMgaW5jbHVkaW5nIHggYW5kIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gYXN0IFVubmVjZXNzYXJ5IG5vdywgdXNlZCB0byBiZSB0aGUgcGFyZW50IEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNhbnZhcy5pc0RlZmluZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZGltcyA9IGRpbXM7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBjb250ZXh0LmNhbnZhcy5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgbGV0IGN0eCA9IGNvbnRleHQuY2FudmFzLmdldCgpLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICAgICAgICAgIHRoaXMuX2VwaEltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgdGhpcy5fZXBoSW1nLnNyYyA9ICcuL3BpY3MvZGVtb25jb3cucG5nJztcbiAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dQYWludCgpKTtcbiAgICAgICAgY29udGV4dC5lZmZlY3RzLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGluIG9yZGVyIHRvIGRyYXcgYW5kIHJlZHJhdyB0aGUgb2JqZWN0IHdoZW4gbWFuaXB1bGF0aW9ucyBhcmUgbWFkZVxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnc7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmg7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgLy92YXIgaW1nT2JqID0gbmV3IEltYWdlKCk7XG4gICAgICAgIC8vbGV0IGN0eCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAvLyB0aGlzLl9lcGhJbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgLy8gdGhpcy5fZXBoSW1nLnNyYyA9ICcuL3BpY3MvZGVtb25jb3cucG5nJztcbiAgICAgICAgLy9pbWdPYmoub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy90aGlzLl9lcGhJbWcub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5fY3R4LmRyYXdJbWFnZSh0aGlzLl9lcGhJbWcsIHRoaXMueCwgdGhpcy55LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgLy90aGlzLl9lcGhJbWcub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gdGhpcy5fZXBoSW1nLndpZHRoID0gd2lkdGg7XG4gICAgICAgIC8vIHRoaXMuX2VwaEltZy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIC8vfVxuICAgICAgICAvL31cbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0d1aWRlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0aGlzLl9jb3JuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIG9uZSBmZWxsIHN3b29wXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uU2hpZnREb3duLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uU2hpZnRVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaXNNb3VzZU91dHNpZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vbWFrZXMgaXQgc28gdGhhdCBkb3VibGUgY2xpY2tpbmcgZG9lc24ndCBzZWxlY3QgdGV4dCBvbiB0aGUgcGFnZVxuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBmdW5jdGlvbiAoZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IHJldHVybiBmYWxzZTsgfSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBhbm90aGVyIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb2YgdGhlIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSwgZmFsc2UgaWYgb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgaWYgKG14ID4geCAmJiBteCA8IHggKyB3ICYmIG15ID4geSAmJiBteSA8IHkgKyBoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgPiAwIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb25lIG9mIHRoZSBjb3JuZXIvc2lkZSBndWlkZXMsIHJldHVybnMgMCBpZiBub3RcbiAgICAgKiBUaGUgY29ybmVyIGd1aWRlcyBhcmUgbnVtYmVyZWQgMS00IHdpdGggMSBiZWluZyB0aGUgdG9wIGxlZnQsIDIgYmVpbmcgdGhlIHRvcCByaWdodCwgYW5kIHNvIG9uLlxuICAgICAqIFRoZSBtaWRkbGUgZ3VpZGVzIGFyZSBudW1iZXJlZCA1LTgsIHdpdGggNSBiZWluZyB0aGUgdG9wIG1pZGRsZSwgNiBiZWluZyB0aGUgcmlnaHQgbWlkZGxlLCBhbmQgc28gb24uXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGd1aWRlQ29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBsZXQgeGRpZiA9IG14IC0geDtcbiAgICAgICAgbGV0IHlkaWYgPSBteSAtIHk7XG4gICAgICAgIC8qIENvcm5lciBHdWlkZXMgKi9cbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGgpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSB4O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICB9XG4gICAgICAgIC8qIE1pZGRsZSBHdWlkZXMgKi9cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3IC8gMik7XG4gICAgICAgIHlkaWYgPSBteSAtIHk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGggLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3IC8gMik7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbWlkZGxlXG4gICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSB4O1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGggLyAyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL21pZGRsZSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBhbmQgZ3VpZGVzIGZvciB0aGUgb2JqZWN0IHdoZW4gdGhlIG9iamVjdCBpcyBzZWxlY3RlZFxuICAgICAqIElmIG9uZSBvZiB0aGUgZ3VpZGVzIGlzIHNlbGVjdGVkLCBpdCBjb2xvcnMgdGhhdCBndWlkZSBibHVlXG4gICAgICogQHBhcmFtIHggdGhlIHggY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHkgdGhlIHkgY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHcgdGhlIHdpZHRoIG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29ybmVyIHRoZSBudW1iZXIgb2YgdGhlIGNvcm5lciB0byBiZSBjb2xvcmVkIGJsdWUgKGlmIGFueSBhdCBhbGwsIGlmIDAsIGFsbCBhcmUgd2hpdGUpXG4gICAgICovXG4gICAgZHJhd0d1aWRlcyh4LCB5LCB3LCBoLCBjb3JuZXIpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmIChjb3JuZXIgIT09IDAgJiYgY29ybmVyIDw9IDQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JlcGggZ3VpZGUgYmx1ZVxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3JuZXIgIT09IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JlcGggZ3VpZGUgYmx1ZVxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBtZXRob2QgdGhhdCBkcmF3cyBhIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB4IHggY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHkgeSBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gdyB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29sb3IgY29sb3Igb2YgdGhlIHJlY3RhbmdsZSdzIGZpbGxcbiAgICAgKi9cbiAgICBkcmF3U3F1YXJlKHgsIHksIHcsIGgsIGNvbG9yKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBtb3ZlcyB3aXRoaW4gdGhlIGNhbnZhcy5cbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiwgY2FsbHMgdGhlIG1vZGlmeSBtZXRob2RzIGlmIHRoZSBib29sZWFucyBzYXRpc2Z5IHRoZW0uXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICB0aGlzLmdldE1vdXNlUG9zaXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlEcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZXNpemluZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZSh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQ2hhbmdpbmdEaW1zICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltcyh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5U3RhdGUodGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpLCB0aGlzLmNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSB1bmNsaWNrcy5cbiAgICAgKiBDYWxscyBtb2RpZnlSZXNldCB0byByZXNldCBkcmFnZ2luZyBhbmQgcmVzaXppbmcgYm9vbGVhbnMgYW1vbmcgb3RoZXJzLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2V1cCBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VVcChldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyBwcmVzc2VkIGRvd25cbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSBwcmVzc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0VXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIE1vZGlmaWNhdGlvbiBmdW5jdGlvbnMgKi9cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgaW4gb3JkZXIgdG8gZHJhZyB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIG1vZGlmeURyYWcoKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJlcGhhbmdsZSBkcmFnb2ZmeDogXCIgKyB0aGlzLl9kcmFnb2ZmeCk7XG4gICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLl9kcmFnb2ZmeDtcbiAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueSAtIHRoaXMuX2RyYWdvZmZ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBzaXplIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQgKHdoZW4gYSBjb3JuZXIgZ3VpZGUgaXMgY2xpY2tlZCBhbmQgZHJhZ2dlZCkuXG4gICAgICpcbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDEwIGFuZCB0aGUgb3RoZXIgZXF1YWwgdG9cbiAgICAgKiAxMCBkaXZpZGVkIG9yIG11bHRpcGxpZWQgYnkgdGhlIHJhdGlvIG9mIHdpZHRoL2hlaWdodCB0byBrZWVwIGl0IHRoZSBzYW1lLlxuICAgICAqXG4gICAgICogVGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgaXMgZG9uZSBieSBjYWxsaW5nIHRoZSBoZWxwZXIgbWV0aG9kIG1vZGlmeVJlc2l6ZUhlbHBlci5cbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNpemUod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgaWYgKHdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2VwaC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwIC8gdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9lcGguaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTAgLyB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fZXBoLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTAgKiB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2VwaC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDEwICogdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGUgcmVjdGFuZ2xlIG9yaWdpbmF0ZXMgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIGFuZCBub3QgdGhlIGNlbnRlcixcbiAgICAgKiBpdCBjaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFzIHdlbGwgaWYgZ3VpZGVzIDEsIDIsIG9yIDQgYXJlIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3RGlzdGFuY2UgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG1vdXNlIGFuZCB0aGUgbG9jYXRpb24gb3Bwb3NpdGUgdG8gaXRcbiAgICAgKiAoaWYgdG9wIHJpZ2h0IGd1aWRlIGlzIGNsaWNrZWQsIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoYXQgYW5kIHRoZSBib3R0b20gbGVmdCBndWlkZSBpcyBuZXdEaXN0YW5jZSlcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMudyA+IDEwICYmIHRoaXMuaCA+IDEwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQoKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAvIHRoaXMuX3JhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICB0aGlzLl9lcGgud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAvIHRoaXMuX3JhdGlvO1xuICAgICAgICB0aGlzLl9lcGguaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQuXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMC5cbiAgICAgKiBDYWxscyBtb2RpZnlDaGFuZ2VEaW1zSGVscGVyIHRvIGFjdHVhbGx5IGRvIHRoZSB3b3JrXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5Q2hhbmdlRGltcyh3aWR0aFRvb1NtYWxsLCBoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBpZiAod2lkdGhUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fZXBoLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9lcGguaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIHRoZSByZWN0YW5nbGUgb3JpZ2luYXRlcyBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgYW5kIG5vdCB0aGUgY2VudGVyLFxuICAgICAqIGl0IGNoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXMgd2VsbCBpZiBndWlkZXMgNSBvciA4IGFyZSBzZWxlY3RlZFxuICAgICAqL1xuICAgIG1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKSB7XG4gICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudyA+IDEwICYmIHRoaXMuaCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXBoLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXBoLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXBoLmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLncgPiAxMCAmJiB0aGlzLmggPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXBoLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgZGVwZW5kaW5nIG9uIHRoZSBtb3VzZSBwb3NpdGlvbiB3aGVuIGNhbGxlZCAob25Nb3VzZURvd24pXG4gICAgICogZS5nLiBpZiB0aGUgbW91c2UgaXMgd2l0aGluIHRoZSBib3VuZGluZyByZWN0YW5nbGUgd2hlbiB0aGlzIGlzIGNhbGxlZCwgaXNTZWxlY3RlZCA9IHRydWVcbiAgICAgKiBAcGFyYW0gZ3VpZGVDb250YWluc1xuICAgICAqIEBwYXJhbSBjb250YWluc1xuICAgICAqL1xuICAgIG1vZGlmeVN0YXRlKGd1aWRlQ29udGFpbnMsIGNvbnRhaW5zKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5feTEgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiAwICYmIGd1aWRlQ29udGFpbnMgPD0gNCkgeyAvL3Jlc2l6aW5nXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSB0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSk7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQxID0gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy5fd2lkdGgxID0gdGhpcy53O1xuICAgICAgICAgICAgLy90aGlzLl9zaXplMSA9IE1hdGguc3FydChNYXRoLnBvdyh3LDIpICsgTWF0aC5wb3coaCwyKSk7IC8vIHNpemUgaXMgZGlhZ29uYWwgbGVuZ3RoXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy90aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdyAvIDIsIHkgKyBoIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucyA+IDQpIHsgLy9jaGFuZ2luZyBzaGFwZSBkaW1lbnNpb25zXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IGd1aWRlQ29udGFpbnM7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHgsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdyAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSArIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICB0aGlzLl94MSA9IHg7IC8vIFNhdmluZyBvcmlnaW5hbCB4IGFuZCB5XG4gICAgICAgICAgICB0aGlzLl95MSA9IHk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgb2YgdGhlIHByaXZhdGUgYm9vbGVhbnMgdG8gZmFsc2UgKGxpa2UgZHJhZ2dpbmcsIHJlc2l6aW5nLCBldGMpIHdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkXG4gICAgICovXG4gICAgbW9kaWZ5UmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0RyYWdnaW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl94MSAtIHRoaXMueCkgPiAxIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0gdGhpcy55KSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHRoaXMuX2lzUmVzaXppbmcgfHwgdGhpcy5faXNDaGFuZ2luZ0RpbXMpICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBzaXplMiA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLncsIDIpICsgTWF0aC5wb3codGhpcy5oLCAyKSk7XG4gICAgICAgICAgICBpZiAoKE1hdGguYWJzKHRoaXMuX3dpZHRoMSAtIHRoaXMudykgPiAwKSB8fCAoTWF0aC5hYnModGhpcy5faGVpZ2h0MSAtIHRoaXMuaCkgPiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1Jlc2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqL1xuICAgIGdldE1vdXNlUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuX21vdXNlLnggPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS54O1xuICAgICAgICB0aGlzLl9tb3VzZS55ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0NoYW5naW5nRGltcywgYW5kIGlzU2VsZWN0ZWQgdG8gZmFsc2UgaWYgdGhlIG1vdXNlIGNsaWNrcyBvdXRzaWRlIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIGlzTW91c2VPdXRzaWRlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgICAgICBsZXQgbW91c2VZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgbGV0IGVwaCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1vdXNlWCA8IGVwaC5sZWZ0IHx8IG1vdXNlWCA+IGVwaC5yaWdodCB8fCBtb3VzZVkgPCBlcGgudG9wIHx8IG1vdXNlWSA+IGVwaC5ib3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhbiBlcGggcGFpbnQgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dQYWludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWludEV2ZW50XzEuUGFpbnRFdmVudChcImVwaFwiLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYW4gZXBoIHJlc2l6ZSBldmVudFxuICAgICAqL1xuICAgIGxvZ1Jlc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVFdmVudF8xLlJlc2l6ZUV2ZW50KFwiZXBoIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgTWF0aC5yb3VuZCh0aGlzLl93aWR0aDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuX2hlaWdodDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMudyAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5oICogMTAwKSAvIDEwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYW4gZXBoIGNsaWNrIGV2ZW50XG4gICAgICovXG4gICAgbG9nQ2xpY2soKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xpY2tFdmVudF8xLkNsaWNrRXZlbnQoXCJlcGggd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCBhc3NpZ25zIGFuIElEIHRvIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSBpZCBUaGUgSUQgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBpbml0SUQoaWQpIHtcbiAgICAgICAgdGhpcy5pZE9iaiA9IHsgX2lkOiBpZCB9O1xuICAgIH1cbiAgICBhc3QoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgdXBkYXRlQVNUKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHggcG9zaXRpb24gb2YgdGhlIGVwaFxuICAgICAqL1xuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBlcGhcbiAgICAgKi9cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGVwaFxuICAgICAqL1xuICAgIGdldCB3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBlcGhcbiAgICAgKi9cbiAgICBnZXQgaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBEaW1lbnNpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBkaW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZXBoIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW1hZ2VcbiAgICAgKi9cbiAgICBnZXQgaW1hZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lcGhJbWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEIG9mIHRoZSBlcGhcbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRPYmouX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlcGggaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICovXG4gICAgZ2V0SnVzdERyYWdnZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdXN0RHJhZ2dlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgZXBoIGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgc2V0SnVzdERyYWdnZWQodmFsKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlcGggaXMgZHJhZ2dpbmdcbiAgICAgKi9cbiAgICBnZXQgaXNEcmFnZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRHJhZ2dpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3Igc2VsZWN0aW9uIGV2ZW50c1xuICAgICAqL1xuICAgIHRvU2VsU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCIgZXBoIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgZHJhZyBldmVudHNcbiAgICAqL1xuICAgIHRvRHJhZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChcImVwaCB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBmcm9tIFwiICsgdGhpcy5feDEgKyBcIiwgXCIgKyB0aGlzLl95MSArIFwiIHRvIFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBJRCBhc3NpZ25tZW50IGV2ZW50c1xuICAgICAqL1xuICAgIHRvSURTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pZE9iai5faWQudG9TdHJpbmcoKSArIFwiIHRvIGVwaCBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxufVxuZXhwb3J0cy5FcGhFZmZlY3QgPSBFcGhFZmZlY3Q7XG4vKipcbiAqIEdldHMgdGhlIG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZXMgaW4gcmVsYXRpb24gdG8gdGhlIGNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB0aGUgY2FudmFzIG9iamVjdFxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0TW91c2VQb3MoY2FudmFzLCBldmVudCkge1xuICAgIGxldCBlcGggPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCAtIGVwaC5sZWZ0LFxuICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gZXBoLnRvcFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB4MSB4IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB5MSB5IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB4MiB4IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKiBAcGFyYW0geTIgeSBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MiwgMikgKyBNYXRoLnBvdyh5MSAtIHkyLCAyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcGhFZmZlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IFBhaW50RXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1BhaW50RXZlbnRcIik7XG5jb25zdCBSZXNpemVFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUmVzaXplRXZlbnRcIik7XG5jb25zdCBDbGlja0V2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9DbGlja0V2ZW50XCIpO1xuY2xhc3MgTGluZUVmZmVjdCB7XG4gICAgY29uc3RydWN0b3IobGluZSkge1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7IC8vIHByaXZhdGUgYm9vbHNcbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmF0aW8gPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gMDtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5fbW91c2UgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9saW5lID0gbGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIGV2YWx1YXRpbmcgbm9kZXMgKFN0cmluZ05vZGUsIEVsbGlwc2VOb2RlLCBldGMpXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyBhbGwgcGFyYW1zIHRvIHByaXZhdGUgdmFyaWFibGVzIGFuZCBkcmF3cyB0aGUgaW5pdGlhbCBvYmplY3QgdG8gdGhlIGNhbnZhc1xuICAgICAqIGJ5IGNhbGxpbmcgdXBkYXRlKClcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgcGFyZW50IFNjb3BlIHRoYXQgY29udGFpbnMgdGhlIGNhbnZhcyBhbW9uZyBvdGhlciB0aGluZ3NcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgb2JqZWN0J3MgZGltZW5zaW9ucyBpbmNsdWRpbmcgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBhc3QgVW5uZWNlc3Nhcnkgbm93LCB1c2VkIHRvIGJlIHRoZSBwYXJlbnQgQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY2FudmFzLmlzRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zID0gZGltcztcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IGNvbnRleHQuY2FudmFzLmdldCgpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgY3R4ID0gY29udGV4dC5jYW52YXMuZ2V0KCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1BhaW50KCkpO1xuICAgICAgICBjb250ZXh0LmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gZHJhdyBhbmQgcmVkcmF3IHRoZSBvYmplY3Qgd2hlbiBtYW5pcHVsYXRpb25zIGFyZSBtYWRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudztcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuaDtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLl9jdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9IFwiIzY3M0FCN1wiO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdHdWlkZXMoeCwgeSwgd2lkdGgsIGhlaWdodCwgdGhpcy5fY29ybmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBvbmUgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTsgLy8gYmluZCBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgbWVhbmluZyBvZiAndGhpcydcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vblNoaWZ0RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vblNoaWZ0VXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmlzTW91c2VPdXRzaWRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL21ha2VzIGl0IHNvIHRoYXQgZG91YmxlIGNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRleHQgb24gdGhlIHBhZ2VcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgZnVuY3Rpb24gKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZmFsc2U7IH0sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gYW5vdGhlciBmZWxsIHN3b29wXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9mIHRoZSBvYmplY3QncyBib3VuZGluZyByZWN0YW5nbGUsIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBjb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGlmIChteCA+IHggJiYgbXggPCB4ICsgdyAmJiBteSA+IHkgJiYgbXkgPCB5ICsgaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbnVtYmVyID4gMCBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9uZSBvZiB0aGUgY29ybmVyL3NpZGUgZ3VpZGVzLCByZXR1cm5zIDAgaWYgbm90XG4gICAgICogVGhlIGNvcm5lciBndWlkZXMgYXJlIG51bWJlcmVkIDEtNCB3aXRoIDEgYmVpbmcgdGhlIHRvcCBsZWZ0LCAyIGJlaW5nIHRoZSB0b3AgcmlnaHQsIGFuZCBzbyBvbi5cbiAgICAgKiBUaGUgbWlkZGxlIGd1aWRlcyBhcmUgbnVtYmVyZWQgNS04LCB3aXRoIDUgYmVpbmcgdGhlIHRvcCBtaWRkbGUsIDYgYmVpbmcgdGhlIHJpZ2h0IG1pZGRsZSwgYW5kIHNvIG9uLlxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBndWlkZUNvbnRhaW5zKG14LCBteSkge1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgbGV0IHhkaWYgPSBteCAtIHg7XG4gICAgICAgIGxldCB5ZGlmID0gbXkgLSB5O1xuICAgICAgICAvKiBDb3JuZXIgR3VpZGVzICovXG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSByaWdodFxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBsZWZ0XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgfVxuICAgICAgICAvKiBNaWRkbGUgR3VpZGVzICovXG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICB5ZGlmID0gbXkgLSB5O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIG1pZGRsZVxuICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0gKHggKyB3KTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9taWRkbGUgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiA2O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyAvIDIpO1xuICAgICAgICB5ZGlmID0gbXkgLSAoeSArIGgpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgcmV0dXJuIDc7XG4gICAgICAgIH1cbiAgICAgICAgeGRpZiA9IG14IC0geDtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoIC8gMik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9taWRkbGUgbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBib3VuZGluZyByZWN0YW5nbGUgYW5kIGd1aWRlcyBmb3IgdGhlIG9iamVjdCB3aGVuIHRoZSBvYmplY3QgaXMgc2VsZWN0ZWRcbiAgICAgKiBJZiBvbmUgb2YgdGhlIGd1aWRlcyBpcyBzZWxlY3RlZCwgaXQgY29sb3JzIHRoYXQgZ3VpZGUgYmx1ZVxuICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB5IHRoZSB5IGNvb3JkaW5hdGUgZm9yIHdoZXJlIHRoZSByZWN0YW5nbGUgd2lsbCBvcmlnaW5hdGUgZnJvbSAodG9wIGxlZnQgY29ybmVyKVxuICAgICAqIEBwYXJhbSB3IHRoZSB3aWR0aCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggdGhlIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvcm5lciB0aGUgbnVtYmVyIG9mIHRoZSBjb3JuZXIgdG8gYmUgY29sb3JlZCBibHVlIChpZiBhbnkgYXQgYWxsLCBpZiAwLCBhbGwgYXJlIHdoaXRlKVxuICAgICAqL1xuICAgIGRyYXdHdWlkZXMoeCwgeSwgdywgaCwgY29ybmVyKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAoY29ybmVyICE9PSAwICYmIGNvcm5lciA8PSA0KSB7IC8vIGEgY29ybmVyIGd1aWRlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgY29ycmVjdCBndWlkZSBibHVlXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvcm5lciAhPT0gMCkgeyAvLyBhIG1pZGRsZSBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcnJlY3QgZ3VpZGUgYmx1ZVxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy9pZiBubyBndWlkZXMgYXJlIHNlbGVjdGVkLCBjb2xvcnMgZXZlcnl0aGluZyB3aGl0ZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltcGxlIG1ldGhvZCB0aGF0IGRyYXdzIGEgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHggeCBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geSB5IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB3IHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb2xvciBjb2xvciBvZiB0aGUgcmVjdGFuZ2xlJ3MgZmlsbFxuICAgICAqL1xuICAgIGRyYXdTcXVhcmUoeCwgeSwgdywgaCwgY29sb3IpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIHdpdGhpbiB0aGUgY2FudmFzLlxuICAgICAqIEdldHMgdGhlIG1vdXNlIHBvc2l0aW9uLCBjYWxscyB0aGUgbW9kaWZ5IG1ldGhvZHMgaWYgdGhlIGJvb2xlYW5zIHNhdGlzZnkgdGhlbS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZ2V0TW91c2VQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeURyYWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jlc2l6aW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplKHRoaXMudyA8IDEwLCB0aGlzLmggPCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNDaGFuZ2luZ0RpbXMgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zKHRoaXMudyA8IDEwLCB0aGlzLmggPCAxMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBjbGlja3MgaW5zaWRlIHRoZSBjYW52YXMuXG4gICAgICogTW9kaWZpZXMgdGhlIHN0YXRlIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBndWlkZXMgY29udGFpbiB0aGUgbW91c2Ugb3IgdGhlIGJvdW5kaW5nIHJlY3QgY29udGFpbnMgdGhlIG1vdXNlLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlTdGF0ZSh0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSksIHRoaXMuY29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIHVuY2xpY2tzLlxuICAgICAqIENhbGxzIG1vZGlmeVJlc2V0IHRvIHJlc2V0IGRyYWdnaW5nIGFuZCByZXNpemluZyBib29sZWFucyBhbW9uZyBvdGhlcnMuXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZXVwIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5UmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHByZXNzZWQgZG93blxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHByZXNzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnREb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyByZWxlYXNlZFxuICAgICAqIFRvZ2dsZXMgdGhlIGlzU2VsZWN0aW5nTXVsdGlwbGUgYm9vbGVhbiBpZiB0aGUga2V5IHJlbGVhc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0VXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIE1vZGlmaWNhdGlvbiBmdW5jdGlvbnMgKi9cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgaW4gb3JkZXIgdG8gZHJhZyB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIG1vZGlmeURyYWcoKSB7XG4gICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLl9kcmFnb2ZmeDtcbiAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueSAtIHRoaXMuX2RyYWdvZmZ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBzaXplIG9mIHRoZSBvYmplY3Qgd2hlbiBjYWxsZWQgKHdoZW4gYSBjb3JuZXIgZ3VpZGUgaXMgY2xpY2tlZCBhbmQgZHJhZ2dlZCkuXG4gICAgICpcbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDEwIGFuZCB0aGUgb3RoZXIgZXF1YWwgdG9cbiAgICAgKiAxMCBkaXZpZGVkIG9yIG11bHRpcGxpZWQgYnkgdGhlIHJhdGlvIG9mIHdpZHRoL2hlaWdodCB0byBrZWVwIGl0IHRoZSBzYW1lLlxuICAgICAqXG4gICAgICogVGhlIHdvcmsgb2YgY2hhbmdpbmcgdGhlIHNpemUgaXMgZG9uZSBieSBjYWxsaW5nIHRoZSBoZWxwZXIgbWV0aG9kIG1vZGlmeVJlc2l6ZUhlbHBlci5cbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNpemUod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgaWYgKHdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApOyAvLyBzZXQgZm9yIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwIC8gdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9saW5lLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQoMTAgLyB0aGlzLl9yYXRpbykpO1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZUhlbHBlcihuZXdEaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5fbGluZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7IC8vIHNldCBmb3IgdGhlIHByb2RpcmVjdCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMCAqIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fbGluZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDEwICogdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGUgcmVjdGFuZ2xlIG9yaWdpbmF0ZXMgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIGFuZCBub3QgdGhlIGNlbnRlcixcbiAgICAgKiBpdCBjaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFzIHdlbGwgaWYgZ3VpZGVzIDEsIDIsIG9yIDQgYXJlIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3RGlzdGFuY2UgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG1vdXNlIGFuZCB0aGUgbG9jYXRpb24gb3Bwb3NpdGUgdG8gaXRcbiAgICAgKiAoaWYgdG9wIHJpZ2h0IGd1aWRlIGlzIGNsaWNrZWQsIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoYXQgYW5kIHRoZSBib3R0b20gbGVmdCBndWlkZSBpcyBuZXdEaXN0YW5jZSlcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMudyA+IDEwICYmIHRoaXMuaCA+IDEwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQoKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAvIHRoaXMuX3JhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICB0aGlzLl9saW5lLmR4ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgdGhpcy5fbGluZS5keSA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkLlxuICAgICAqIElmIGFueSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgdG9vIHNtYWxsLCBpdCBzZXRzIHRoZW0gZXF1YWwgdG8gMTAuXG4gICAgICogQ2FsbHMgbW9kaWZ5Q2hhbmdlRGltc0hlbHBlciB0byBhY3R1YWxseSBkbyB0aGUgd29ya1xuICAgICAqIEBwYXJhbSB3aWR0aFRvb1NtYWxsIHRydWUgaWYgdGhlIHdpZHRoIGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICogQHBhcmFtIGhlaWdodFRvb1NtYWxsIHRydWUgaWYgdGhlIGhlaWdodCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqL1xuICAgIG1vZGlmeUNoYW5nZURpbXMod2lkdGhUb29TbWFsbCwgaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgaWYgKHdpZHRoVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRUb29TbWFsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMTApO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBjaGFuZ2luZyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJlY3RhbmdsZSBvcmlnaW5hdGVzIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBhbmQgbm90IHRoZSBjZW50ZXIsXG4gICAgICogaXQgY2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcyB3ZWxsIGlmIGd1aWRlcyA1IG9yIDggYXJlIHNlbGVjdGVkXG4gICAgICovXG4gICAgbW9kaWZ5Q2hhbmdlRGltc0hlbHBlcigpIHtcbiAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oID4gMTApIHsgLy9hcyBsb25nIGFzIHRoZSBoZWlnaHQgaXMgPiAxMFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmUuZHkgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmUuZHggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lLmR5ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy5oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLncgLyB0aGlzLmg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudyA+IDEwKSB7IC8vIGFzIGxvbmcgYXMgd2lkdGggaXMgPiAxMFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgLT0gTWF0aC5yb3VuZChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZS5keCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMudykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIGRlcGVuZGluZyBvbiB0aGUgbW91c2UgcG9zaXRpb24gd2hlbiBjYWxsZWQgKG9uTW91c2VEb3duKVxuICAgICAqIGUuZy4gaWYgdGhlIG1vdXNlIGlzIHdpdGhpbiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIHdoZW4gdGhpcyBpcyBjYWxsZWQsIGlzU2VsZWN0ZWQgPSB0cnVlXG4gICAgICogQHBhcmFtIGd1aWRlQ29udGFpbnNcbiAgICAgKiBAcGFyYW0gY29udGFpbnNcbiAgICAgKi9cbiAgICBtb2RpZnlTdGF0ZShndWlkZUNvbnRhaW5zLCBjb250YWlucykge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgeCA9IHRoaXMueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnk7XG4gICAgICAgIGxldCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgaCA9IHRoaXMuaDtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy9wcmVwYXJlcyB0aGUgb2JqZWN0IGZvciBkcmFnZ2luZyB3aGV0aGVyIGl0IGlzIHBlcnNvbmFsbHkgc2VsZWN0ZWQgb3Igbm90XG4gICAgICAgICAgICBpZiAoY29udGFpbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94MSA9IHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl95MSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucyA+IDAgJiYgZ3VpZGVDb250YWlucyA8PSA0KSB7IC8vcmVzaXppbmdcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2Nvcm5lciA9IHRoaXMuZ3VpZGVDb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KTtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodDEgPSB0aGlzLmg7XG4gICAgICAgICAgICB0aGlzLl93aWR0aDEgPSB0aGlzLnc7XG4gICAgICAgICAgICAvL3RoaXMuX3NpemUxID0gTWF0aC5zcXJ0KE1hdGgucG93KHcsMikgKyBNYXRoLnBvdyhoLDIpKTsgLy8gc2l6ZSBpcyBkaWFnb25hbCBsZW5ndGhcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7IC8vIHNldHMgdGhlIG9mZnNldHMgZGVwZW5kaW5nIG9uIHdoaWNoIGNvcm5lciBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdzsgLy8gb2Zmc2V0IGlzIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDsgLy8gb2Zmc2V0IGlzIGJvdHRvbSBsZWZ0LCBldGNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiA0KSB7IC8vY2hhbmdpbmcgc2hhcGUgZGltZW5zaW9uc1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSBndWlkZUNvbnRhaW5zO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9jb3JuZXIpIHsgLy8gc2V0cyB0aGUgb2Zmc2V0cyBkZXBlbmRpbmcgb24gd2hpY2ggbWlkZGxlIGd1aWRlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgY2FzZSA1OiAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHggKyB3IC8gMjsgLy8gb2Zmc2V0IGlzIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OiAvL3JpZ2h0IG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4LCB5ICsgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyOyAvLyBvZmZzZXQgaXMgbGVmdCBtaWRkbGUgZXRjXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcgLyAyLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdyAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdywgeSArIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKSB7IC8vIGRyYWdnaW5nXG4gICAgICAgICAgICB0aGlzLl94MSA9IHg7IC8vIFNhdmluZyBvcmlnaW5hbCB4IGFuZCB5XG4gICAgICAgICAgICB0aGlzLl95MSA9IHk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB4O1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0geTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkgeyAvLyBub3Qgc2VsZWN0ZWRcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIHRvIGZhbHNlIChsaWtlIGRyYWdnaW5nLCByZXNpemluZywgZXRjKSB3aGVuIHRoZSBtb3VzZSBpcyByZWxlYXNlZFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB0aGlzLngpID4gMSB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHRoaXMueSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh0aGlzLl9pc1Jlc2l6aW5nIHx8IHRoaXMuX2lzQ2hhbmdpbmdEaW1zKSAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc2l6ZTIgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53LCAyKSArIE1hdGgucG93KHRoaXMuaCwgMikpO1xuICAgICAgICAgICAgaWYgKChNYXRoLmFicyh0aGlzLl93aWR0aDEgLSB0aGlzLncpID4gMCkgfHwgKE1hdGguYWJzKHRoaXMuX2hlaWdodDEgLSB0aGlzLmgpID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dSZXNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Nvcm5lciA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKi9cbiAgICBnZXRNb3VzZVBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLl9tb3VzZS54ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueDtcbiAgICAgICAgdGhpcy5fbW91c2UueSA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNDaGFuZ2luZ0RpbXMsIGFuZCBpc1NlbGVjdGVkIHRvIGZhbHNlIGlmIHRoZSBtb3VzZSBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBpc01vdXNlT3V0c2lkZShldmVudCkge1xuICAgICAgICBsZXQgbW91c2VYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgbGV0IG1vdXNlWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5fY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobW91c2VYIDwgcmVjdC5sZWZ0IHx8IG1vdXNlWCA+IHJlY3QucmlnaHQgfHwgbW91c2VZIDwgcmVjdC50b3AgfHwgbW91c2VZID4gcmVjdC5ib3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2hhbmdpbmdEaW1zID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZWN0YW5nbGUgcGFpbnQgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dQYWludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWludEV2ZW50XzEuUGFpbnRFdmVudChcInJlY3RhbmdsZVwiLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZWN0YW5nbGUgcmVzaXplIGV2ZW50XG4gICAgICovXG4gICAgbG9nUmVzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZUV2ZW50XzEuUmVzaXplRXZlbnQoXCJyZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCBNYXRoLnJvdW5kKHRoaXMuX3dpZHRoMSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5faGVpZ2h0MSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy53ICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLmggKiAxMDApIC8gMTAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIHJlY3RhbmdsZSBjbGljayBldmVudFxuICAgICAqL1xuICAgIGxvZ0NsaWNrKCkge1xuICAgICAgICByZXR1cm4gbmV3IENsaWNrRXZlbnRfMS5DbGlja0V2ZW50KFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgYXNzaWducyBhbiBJRCB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgaW5pdElEKGlkKSB7XG4gICAgICAgIHRoaXMuaWRPYmogPSB7IF9pZDogaWQgfTtcbiAgICB9XG4gICAgYXN0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnkuZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBEaW1lbnNpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBkaW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEIG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkT2JqLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKi9cbiAgICBnZXRKdXN0RHJhZ2dlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1c3REcmFnZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGhhcyBqdXN0IGJlZW4gZHJhZ2dlZFxuICAgICAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgc2V0SnVzdERyYWdnZWQodmFsKSB7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByZWN0IGlzIGRyYWdnaW5nXG4gICAgICovXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RyYWdnaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIHNlbGVjdGlvbiBldmVudHNcbiAgICAgKi9cbiAgICB0b1NlbFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiIHJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIGRyYWcgZXZlbnRzXG4gICAgKi9cbiAgICB0b0RyYWdTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoXCJyZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgZnJvbSBcIiArIHRoaXMuX3gxICsgXCIsIFwiICsgdGhpcy5feTEgKyBcIiB0byBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgSUQgYXNzaWdubWVudCBldmVudHNcbiAgICAgKi9cbiAgICB0b0lEU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaWRPYmouX2lkLnRvU3RyaW5nKCkgKyBcIiB0byByZWN0YW5nbGUgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbn1cbmV4cG9ydHMuTGluZUVmZmVjdCA9IExpbmVFZmZlY3Q7XG4vKipcbiAqIEdldHMgdGhlIG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZXMgaW4gcmVsYXRpb24gdG8gdGhlIGNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB0aGUgY2FudmFzIG9iamVjdFxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0TW91c2VQb3MoY2FudmFzLCBldmVudCkge1xuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB4MSB4IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB5MSB5IGNvb3JkaW5hdGUgb2YgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB4MiB4IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKiBAcGFyYW0geTIgeSBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MiwgMikgKyBNYXRoLnBvdyh5MSAtIHkyLCAyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lRWZmZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUGFpbnRFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUGFpbnRFdmVudFwiKTtcbmNvbnN0IFJlc2l6ZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9SZXNpemVFdmVudFwiKTtcbmNvbnN0IENsaWNrRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL0NsaWNrRXZlbnRcIik7XG5jbGFzcyBOdW1iZXJFZmZlY3Qge1xuICAgIGNvbnN0cnVjdG9yKG51bSkge1xuICAgICAgICB0aGlzLl9mb250U2l6ZSA9IDIwO1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnggPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IDA7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX21vdXNlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgaW50ZXJ2YWw6IDAsXG4gICAgICAgICAgICBzdHI6IFwiXCIsXG4gICAgICAgICAgICBpbml0TW91c2VQb3M6IDAsXG4gICAgICAgICAgICBjdXJzb3JQb3M6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbnVtID0gbnVtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gZXZhbHVhdGluZyBub2RlcyAoU3RyaW5nTm9kZSwgRWxsaXBzZU5vZGUsIGV0YylcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3NpZ25zIGFsbCBwYXJhbXMgdG8gcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIGRyYXdzIHRoZSBpbml0aWFsIG9iamVjdCB0byB0aGUgY2FudmFzXG4gICAgICogYnkgY2FsbGluZyB1cGRhdGUoKVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBwYXJlbnQgU2NvcGUgdGhhdCBjb250YWlucyB0aGUgY2FudmFzIGFtb25nIG90aGVyIHRoaW5nc1xuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBvYmplY3QncyBkaW1lbnNpb25zIGluY2x1ZGluZyB4IGFuZCB5IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGFzdCBVbm5lY2Vzc2FyeSBub3csIHVzZWQgdG8gYmUgdGhlIHBhcmVudCBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBpZiAoY29udGV4dC5jYW52YXMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IGNvbnRleHQuY2FudmFzLmdldCgpO1xuICAgICAgICAgICAgdGhpcy5fZGltcyA9IGRpbXM7XG4gICAgICAgICAgICBsZXQgY3R4ID0gY29udGV4dC5jYW52YXMuZ2V0KCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIC8vIGxvZ2dpbmdcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1BhaW50KCkpOyAvLyB0aGlzLmNvbnRleHQgb3IgY29udGV4dD9cbiAgICAgICAgICAgIGNvbnRleHQuZWZmZWN0cy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYW52YXMgaXMgTk9UIGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGluIG9yZGVyIHRvIGRyYXcgYW5kIHJlZHJhdyB0aGUgb2JqZWN0IHdoZW4gbWFuaXB1bGF0aW9ucyBhcmUgbWFkZVxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgbGV0IGZvbnREZWV0cyA9IHRoaXMuX2ZvbnRTaXplICsgXCJweCBDb3VyaWVyIE5ld1wiO1xuICAgICAgICB0aGlzLl9jdHguZm9udCA9IGZvbnREZWV0cztcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IFwiIzY3M0FCN1wiO1xuICAgICAgICBsZXQgc3RyID0gdGhpcy5fbnVtLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsVGV4dChzdHIsIHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgbGV0IG51bWJlckRpbXMgPSB0aGlzLl9jdHgubWVhc3VyZVRleHQoc3RyKTtcbiAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy53aWR0aCA9IG51bWJlckRpbXMud2lkdGg7XG4gICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuaGVpZ2h0ID0gdGhpcy5fZm9udFNpemU7XG4gICAgICAgIHRoaXMuX251bWJlck1ldHJpY3Muc3RyID0gc3RyO1xuICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmludGVydmFsID0gdGhpcy5fbnVtYmVyTWV0cmljcy53aWR0aCAvIHRoaXMuX251bWJlck1ldHJpY3Muc3RyLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1RleHRHdWlkZXModGhpcy54LCB0aGlzLnkgLSB0aGlzLl9mb250U2l6ZSwgdGhpcy5fbnVtYmVyTWV0cmljcy53aWR0aCwgdGhpcy5fbnVtYmVyTWV0cmljcy5oZWlnaHQsIHRoaXMuX2Nvcm5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lzRWRpdGluZykge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gb25lIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7IC8vIGJpbmQgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIG1lYW5pbmcgb2YgJ3RoaXMnXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25TaGlmdERvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25TaGlmdFVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy9tYWtlcyBpdCBzbyB0aGF0IGRvdWJsZSBjbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0ZXh0IG9uIHRoZSBwYWdlXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uIChlKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGZhbHNlOyB9LCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIGFub3RoZXIgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvZiB0aGUgb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgY29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIHJldHVybiAodGhpcy54IDw9IG14KSAmJiAodGhpcy54ICsgdGhpcy5fbnVtYmVyTWV0cmljcy53aWR0aCA+PSBteCkgJiZcbiAgICAgICAgICAgICh0aGlzLnkgLSB0aGlzLl9mb250U2l6ZSA8PSBteSkgJiYgKHRoaXMueSA+PSBteSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgPiAwIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb25lIG9mIHRoZSBjb3JuZXIvc2lkZSBndWlkZXMsIHJldHVybnMgMCBpZiBub3RcbiAgICAgKiBUaGUgY29ybmVyIGd1aWRlcyBhcmUgbnVtYmVyZWQgMS00IHdpdGggMSBiZWluZyB0aGUgdG9wIGxlZnQsIDIgYmVpbmcgdGhlIHRvcCByaWdodCwgYW5kIHNvIG9uLlxuICAgICAqIFRoZSBtaWRkbGUgZ3VpZGVzIGFyZSBudW1iZXJlZCA1LTgsIHdpdGggNSBiZWluZyB0aGUgdG9wIG1pZGRsZSwgNiBiZWluZyB0aGUgcmlnaHQgbWlkZGxlLCBhbmQgc28gb24uXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGd1aWRlQ29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ZGlmID0gbXggLSAodGhpcy54ICsgdGhpcy5fbnVtYmVyTWV0cmljcy53aWR0aCk7XG4gICAgICAgIGxldCB5ZGlmID0gbXkgLSAodGhpcy55IC0gdGhpcy5fZm9udFNpemUpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGFuZCBndWlkZXMgZm9yIHRoZSBvYmplY3Qgd2hlbiB0aGUgb2JqZWN0IGlzIHNlbGVjdGVkXG4gICAgICogSWYgb25lIG9mIHRoZSBndWlkZXMgaXMgc2VsZWN0ZWQsIGl0IGNvbG9ycyB0aGF0IGd1aWRlIGJsdWVcbiAgICAgKiBAcGFyYW0geCB0aGUgeCBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0geSB0aGUgeSBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb3JuZXIgdGhlIG51bWJlciBvZiB0aGUgY29ybmVyIHRvIGJlIGNvbG9yZWQgYmx1ZSAoaWYgYW55IGF0IGFsbCwgaWYgMCwgYWxsIGFyZSB3aGl0ZSlcbiAgICAgKi9cbiAgICBkcmF3VGV4dEd1aWRlcyh4LCB5LCB3LCBoLCBjb3JuZXIpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmIChjb3JuZXIgIT09IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBndWlkZSBibHVlIGlmIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgbWV0aG9kIHRoYXQgZHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geCB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5IHkgY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHcgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIGNvbG9yIG9mIHRoZSByZWN0YW5nbGUncyBmaWxsXG4gICAgICovXG4gICAgZHJhd1NxdWFyZSh4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJ2dyYXknO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qIEV2ZW50IGxpc3RlbmVyIGZ1bmN0aW9ucyAqL1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgd2l0aGluIHRoZSBjYW52YXMuXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24sIGNhbGxzIHRoZSBtb2RpZnkgbWV0aG9kcyBpZiB0aGUgYm9vbGVhbnMgc2F0aXNmeSB0aGVtLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRNb3VzZVBvc2l0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGVkICYmIHRoaXMuX2lzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5RHJhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemUodGhpcy5fZm9udFNpemUgPCAxNSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBjbGlja3MgaW5zaWRlIHRoZSBjYW52YXMuXG4gICAgICogTW9kaWZpZXMgdGhlIHN0YXRlIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBndWlkZXMgY29udGFpbiB0aGUgbW91c2Ugb3IgdGhlIGJvdW5kaW5nIHJlY3QgY29udGFpbnMgdGhlIG1vdXNlLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlICYmIHRoaXMuX2lzU2VsZWN0ZWQgJiYgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSkgeyAvL3RleHQgZWRpdGluZ1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0xpc3RlbmluZykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5tb2RpZnlUZXh0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faXNMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuaW5pdE1vdXNlUG9zID0gdGhpcy5fbW91c2UueDtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kaWZ5U3RhdGUodGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpID4gMCwgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgdW5jbGlja3MuXG4gICAgICogQ2FsbHMgbW9kaWZ5UmVzZXQgdG8gcmVzZXQgZHJhZ2dpbmcgYW5kIHJlc2l6aW5nIGJvb2xlYW5zIGFtb25nIG90aGVycy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNldXAgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlSZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcHJlc3NlZCBkb3duXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcHJlc3NlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdERvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gXCIxNlwiKSB7IC8vc2hpZnQga2V5Y29kZVxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEga2V5IGlzIHJlbGVhc2VkXG4gICAgICogVG9nZ2xlcyB0aGUgaXNTZWxlY3RpbmdNdWx0aXBsZSBib29sZWFuIGlmIHRoZSBrZXkgcmVsZWFzZWQgaXMgdGhlIHNoaWZ0IGtleVxuICAgICAqIEBwYXJhbSBldmVudCB0aGUga2V5ZG93biBldmVudFxuICAgICAqL1xuICAgIG9uU2hpZnRVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogTW9kaWZpY2F0aW9uIGZ1bmN0aW9ucyAqL1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBpbiBvcmRlciB0byBkcmFnIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgbW9kaWZ5RHJhZygpIHtcbiAgICAgICAgLy8oXCJzdHJpbmcgZHJhZ29mZng6IFwiICsgdGhpcy5fZHJhZ29mZngpO1xuICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS54IC0gdGhpcy5fZHJhZ29mZng7XG4gICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLl9kcmFnb2ZmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgbW92ZXMgdGhlIHRleHQgZWRpdCBjdXJzb3IgYmFzZWQgb24gd2hlcmUgdGhlIG1vdXNlIGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBtb2RpZnlUZXh0Q3Vyc29yKCkge1xuICAgICAgICBsZXQgbGVmdFdhbGwgPSB0aGlzLng7IC8vIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBsZWZ0IG1vc3Qgc2lkZSBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICAgIGxldCB4RGlmID0gdGhpcy5fbnVtYmVyTWV0cmljcy5pbml0TW91c2VQb3MgLSBsZWZ0V2FsbDsgLy8gZGlmZmVyZW5jZSBiZXR3ZWVuIG1vdXNlIHggYW5kIGxlZnQgd2FsbFxuICAgICAgICBsZXQgaW50ZXJ2YWwgPSB0aGlzLl9udW1iZXJNZXRyaWNzLmludGVydmFsOyAvLyB0aGUgdGV4dCB3aWR0aCBkaXZpZGVkIGJ5IHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZ1xuICAgICAgICBsZXQgbW92ZUZhY3RvciA9IDA7XG4gICAgICAgIGlmICh4RGlmID49IGludGVydmFsIC8gMiAmJiB4RGlmIDw9IGludGVydmFsKSB7XG4gICAgICAgICAgICBtb3ZlRmFjdG9yID0gbGVmdFdhbGwgKyBpbnRlcnZhbDtcbiAgICAgICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuY3Vyc29yUG9zID0gaW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeERpZiA8PSBpbnRlcnZhbCAvIDIpIHtcbiAgICAgICAgICAgIG1vdmVGYWN0b3IgPSBsZWZ0V2FsbDtcbiAgICAgICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuY3Vyc29yUG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4RGlmICUgaW50ZXJ2YWwgPj0gaW50ZXJ2YWwgLyAyKSB7XG4gICAgICAgICAgICBtb3ZlRmFjdG9yID0gbGVmdFdhbGwgKyBpbnRlcnZhbCAqIE1hdGguY2VpbCh4RGlmIC8gaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5jdXJzb3JQb3MgPSBpbnRlcnZhbCAqIE1hdGguY2VpbCh4RGlmIC8gaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHhEaWYgJSBpbnRlcnZhbCA8IGludGVydmFsIC8gMikge1xuICAgICAgICAgICAgbW92ZUZhY3RvciA9IGxlZnRXYWxsICsgaW50ZXJ2YWwgKiBNYXRoLmZsb29yKHhEaWYgLyBpbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmN1cnNvclBvcyA9IGludGVydmFsICogTWF0aC5mbG9vcih4RGlmIC8gaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N0eC5tb3ZlVG8obW92ZUZhY3RvciwgdGhpcy55IC0gdGhpcy5fZm9udFNpemUpO1xuICAgICAgICB0aGlzLl9jdHgubGluZVRvKG1vdmVGYWN0b3IsIHRoaXMueSk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9IFwiZ3JleVwiO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZWRpdHMgdGhlIHN0cmluZyB3aGVuIGVkaXRpbmcgdGV4dFxuICAgICAqIEBwYXJhbSBldmVudCBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgbW9kaWZ5VGV4dChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5faXNFZGl0aW5nKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3RIYWxmO1xuICAgICAgICAgICAgbGV0IHNlY29uZEhhbGY7XG4gICAgICAgICAgICBsZXQgc3RyID0gdGhpcy5fbnVtLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgYnJlYWtQb2ludCA9IHRoaXMuX251bWJlck1ldHJpY3MuY3Vyc29yUG9zIC8gdGhpcy5fbnVtYmVyTWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgICAgIGZpcnN0SGFsZiA9IHN0ci5zdWJzdHJpbmcoMCwgYnJlYWtQb2ludCk7XG4gICAgICAgICAgICBzZWNvbmRIYWxmID0gc3RyLnN1YnN0cmluZyhicmVha1BvaW50KTtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDM3ICYmIHRoaXMuX251bWJlck1ldHJpY3MuaW5pdE1vdXNlUG9zID4gdGhpcy54ICsgdGhpcy5fbnVtYmVyTWV0cmljcy5pbnRlcnZhbCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmluaXRNb3VzZVBvcyAtPSB0aGlzLl9udW1iZXJNZXRyaWNzLmludGVydmFsO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzOSAmJiB0aGlzLl9udW1iZXJNZXRyaWNzLmluaXRNb3VzZVBvcyA8IHRoaXMueCArIHRoaXMuX251bWJlck1ldHJpY3Mud2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9udW1iZXJNZXRyaWNzLmluaXRNb3VzZVBvcyArPSB0aGlzLl9udW1iZXJNZXRyaWNzLmludGVydmFsO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSA4ICYmIHN0ci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RIYWxmID0gZmlyc3RIYWxmLnN1YnN0cmluZygwLCBmaXJzdEhhbGYubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgc3RyID0gZmlyc3RIYWxmICsgc2Vjb25kSGFsZjtcbiAgICAgICAgICAgICAgICB0aGlzLl9udW0udmFsID0gTnVtYmVyKHN0cik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbnVtYmVyTWV0cmljcy5pbml0TW91c2VQb3MgLT0gdGhpcy5fbnVtYmVyTWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBrZXlOYW1lID0gZXZlbnQua2V5O1xuICAgICAgICAgICAgICAgIGlmIChrZXlOYW1lLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0SGFsZiArPSBrZXlOYW1lO1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBmaXJzdEhhbGYgKyBzZWNvbmRIYWxmO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9udW0udmFsID0gTnVtYmVyKHN0cik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX251bWJlck1ldHJpY3MuaW5pdE1vdXNlUG9zICs9IHRoaXMuX251bWJlck1ldHJpY3MuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb2RpZmllcyB0aGUgZm9udCBzaXplIG9mIHRoZSB0ZXh0XG4gICAgICogSWYgdGhlIHRleHQgZm9udCBpcyBzbWFsbGVyIHRoYW4gMTVwdCwgaXQgc2V0J3MgaXQgZXF1YWwgdG8gMTVwdFxuICAgICAqIEBwYXJhbSBpc1Rvb1NtYWxsIHRydWUgaWYgdGhlIGZvbnQgc2l6ZSBpcyA8IDE1XG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplKGlzVG9vU21hbGwpIHtcbiAgICAgICAgaWYgKGlzVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplID0gMTU7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAwLjI7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgdGhpcy5fZm9udFNpemUgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDAuMjtcbiAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIGRlcGVuZGluZyBvbiB0aGUgbW91c2UgcG9zaXRpb24gd2hlbiBjYWxsZWQgKG9uTW91c2VEb3duKVxuICAgICAqIGUuZy4gaWYgdGhlIG1vdXNlIGlzIHdpdGhpbiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIHdoZW4gdGhpcyBpcyBjYWxsZWQsIGlzU2VsZWN0ZWQgPSB0cnVlXG4gICAgICogQHBhcmFtIGd1aWRlQ29udGFpbnNcbiAgICAgKiBAcGFyYW0gY29udGFpbnNcbiAgICAgKi9cbiAgICBtb2RpZnlTdGF0ZShndWlkZUNvbnRhaW5zLCBjb250YWlucykge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkgeyAvL3ByZXBhcmVzIHRoZSBvYmplY3QgZm9yIGRyYWdnaW5nIHdoZXRoZXIgaXQgaXMgcGVyc29uYWxseSBzZWxlY3RlZCBvciBub3RcbiAgICAgICAgICAgIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmKHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQubXVsU2VsKXtcbiAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcInN0cmluZyBlZmZlY3QgbXVsU2VsZWN0ZWQ6IFwiICsgdGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC5tdWxTZWwpO1xuICAgICAgICAgICAgLy8gICAgIC8vaWYodGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC52YWwpe1xuICAgICAgICAgICAgLy8gICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1NlbGVjdGVkKCkpO1xuICAgICAgICAgICAgLy8gICAgIC8vdGhpcy5sb2dTZWxlY3RlZCgpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMpIHsgLy9pZiB0aGUgY29ybmVyIGd1aWRlcyBjb250YWluIHRoZSBtb3VzZSB3ZSBhcmUgcmVzaXppbmdcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gdGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMueDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy55O1xuICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zaXplMSA9IHRoaXMuX2ZvbnRTaXplOyAvLyBzYXZpbmcgb2xkIGZvbnQgc2l6ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICB0aGlzLl94ID0gdGhpcy54OyAvLyBTYXZpbmcgb3JpZ2luYWwgeCBhbmQgeVxuICAgICAgICAgICAgdGhpcy5feSA9IHRoaXMueTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLng7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLnk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzRWRpdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIHRvIGZhbHNlIChsaWtlIGRyYWdnaW5nLCByZXNpemluZywgZXRjKSB3aGVuIHRoZSBtb3VzZSBpcyByZWxlYXNlZFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5feCAtIHRoaXMueCkgPiAxIHx8IE1hdGguYWJzKHRoaXMuX3kgLSB0aGlzLnkpID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvL3RoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ01vdmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZXNpemluZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5fc2l6ZTEgLSB0aGlzLl9mb250U2l6ZSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUmVzaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcInN0cmluZyBlZmZlY3QgbXVsU2VsZWN0ZWQ6IFwiICsgdGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC52YWwpO1xuICAgICAgICAvLyBpZih0aGlzLl9jb250ZXh0Lm11bFNlbGVjdGVkLnZhbCl7XG4gICAgICAgIC8vICAgICB0aGlzLmxvZ1NlbGVjdGVkKCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYodGhpcy5pc011bHRpcGxlU2VsZWN0ZWQpe1xuICAgICAgICAvLyAgICAgY29udGV4dC5ldmVudExvZy5wdXNoKG5ldyBTZWxlY3RFdmVudChzZWxlY3RlZEVsZW1zKSk7XG4gICAgICAgIC8vICAgICBtYXN0ZXJMb2cucHVzaChjb250ZXh0LmV2ZW50TG9nW2NvbnRleHQuZXZlbnRMb2cubGVuZ3RoIC0gMV0pO1xuICAgICAgICAvLyAgICAgLy9jb25zb2xlLmxvZyhcIm11bHRpcGxlIHNlbGVjdGVkXCIpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIC8vdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nTW92ZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqL1xuICAgIGdldE1vdXNlUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuX21vdXNlLnggPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS54O1xuICAgICAgICB0aGlzLl9tb3VzZS55ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0NoYW5naW5nRGltcywgYW5kIGlzU2VsZWN0ZWQgdG8gZmFsc2UgaWYgdGhlIG1vdXNlIGNsaWNrcyBvdXRzaWRlIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIGlzTW91c2VPdXRzaWRlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgICAgICBsZXQgbW91c2VZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtb3VzZVggPCByZWN0LmxlZnQgfHwgbW91c2VYID4gcmVjdC5yaWdodCB8fCBtb3VzZVkgPCByZWN0LnRvcCB8fCBtb3VzZVkgPiByZWN0LmJvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSBwYWludCBldmVudFxuICAgICAqL1xuICAgIGxvZ1BhaW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhaW50RXZlbnRfMS5QYWludEV2ZW50KHRoaXMuX251bS50b1N0cmluZygpLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZXNpemUgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dSZXNpemUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplRXZlbnRfMS5SZXNpemVFdmVudCh0aGlzLl9udW0udG9TdHJpbmcoKSArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgTWF0aC5yb3VuZCh0aGlzLl9zaXplMSAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5fZm9udFNpemUgKiAxMDApIC8gMTAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBhIGNsaWNrIGV2ZW50XG4gICAgICovXG4gICAgbG9nQ2xpY2soKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xpY2tFdmVudF8xLkNsaWNrRXZlbnQodGhpcy5fbnVtLnRvU3RyaW5nKCkgKyBcIiB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIGFzc2lnbnMgYW4gSUQgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIGlkIFRoZSBJRCB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIGluaXRJRChpZCkge1xuICAgICAgICB0aGlzLmlkT2JqID0geyBfaWQ6IGlkLCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgICBnZXQgY2FudmFzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gY2FudmFzIFRoZSBjYW52YXMgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBzZXQgY2FudmFzKGNhbnZhcykge1xuICAgICAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gICAgfVxuICAgIGFzdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHggcG9zaXRpb24gb2YgdGhlIG51bWJlclxuICAgICAqL1xuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBudW1iZXJcbiAgICAgKi9cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRGltZW5zaW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgZGltcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZWxsaXBzZSBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAqL1xuICAgIGdldEp1c3REcmFnZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fanVzdERyYWdnZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIGVsbGlwc2UgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBzZXRKdXN0RHJhZ2dlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVsbGlwc2UgaXMgZHJhZ2dpbmdcbiAgICAgKi9cbiAgICBnZXQgaXNEcmFnZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRHJhZ2dpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhpcyBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlclxuICAgICAqL1xuICAgIGdldCBudW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9udW0udmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvYmplY3QgSURcbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRPYmouX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIHNlbGVjdGlvbiBldmVudHNcbiAgICAgKi9cbiAgICB0b1NlbFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiIFwiICsgdGhpcy5fbnVtLnRvU3RyaW5nKCkgKyBcIiB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIGRyYWcgZXZlbnRzXG4gICAgKi9cbiAgICB0b0RyYWdTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fbnVtLnRvU3RyaW5nKCkgKyBcIiB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCkgKyBcIiBmcm9tIFwiICsgdGhpcy5feCArIFwiLCBcIiArIHRoaXMuX3kgKyBcIiB0byBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgSUQgYXNzaWdubWVudCBldmVudHNcbiAgICAgKi9cbiAgICB0b0lEU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaWRPYmouX2lkLnRvU3RyaW5nKCkgKyBcIiB0byBcIiArIHRoaXMuX251bS50b1N0cmluZygpICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbn1cbmV4cG9ydHMuTnVtYmVyRWZmZWN0ID0gTnVtYmVyRWZmZWN0O1xuLyoqXG4gKiBHZXQncyB0aGUgbW91c2UgeCBhbmQgeSBjb29yZGluYXRlcyBpbiByZWxhdGlvbiB0byB0aGUgY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHRoZSBjYW52YXMgb2JqZWN0XG4gKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICovXG5mdW5jdGlvbiBnZXRNb3VzZVBvcyhjYW52YXMsIGV2ZW50KSB7XG4gICAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHgxIHggY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHkxIHkgY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHgyIHggY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSB5MiB5IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgyLCAyKSArIE1hdGgucG93KHkxIC0geTIsIDIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU51bWJlckVmZmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgUGFpbnRFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUGFpbnRFdmVudFwiKTtcbmNvbnN0IFJlc2l6ZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9SZXNpemVFdmVudFwiKTtcbmNvbnN0IENsaWNrRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL0NsaWNrRXZlbnRcIik7XG5jbGFzcyBSZWN0YW5nbGVFZmZlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHJlY3QpIHtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBwcml2YXRlIGJvb2xzXG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JhdGlvID0gMDtcbiAgICAgICAgdGhpcy5fZHJhZ29mZnggPSAwO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IDA7XG4gICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX21vdXNlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiBldmFsdWF0aW5nIG5vZGVzIChTdHJpbmdOb2RlLCBFbGxpcHNlTm9kZSwgZXRjKVxuICAgICAqIFRoaXMgbWV0aG9kIGFzc2lnbnMgYWxsIHBhcmFtcyB0byBwcml2YXRlIHZhcmlhYmxlcyBhbmQgZHJhd3MgdGhlIGluaXRpYWwgb2JqZWN0IHRvIHRoZSBjYW52YXNcbiAgICAgKiBieSBjYWxsaW5nIHVwZGF0ZSgpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIHBhcmVudCBTY29wZSB0aGF0IGNvbnRhaW5zIHRoZSBjYW52YXMgYW1vbmcgb3RoZXIgdGhpbmdzXG4gICAgICogQHBhcmFtIGRpbXMgVGhlIG9iamVjdCdzIGRpbWVuc2lvbnMgaW5jbHVkaW5nIHggYW5kIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gYXN0IFVubmVjZXNzYXJ5IG5vdywgdXNlZCB0byBiZSB0aGUgcGFyZW50IEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNhbnZhcy5pc0RlZmluZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZGltcyA9IGRpbXM7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBjb250ZXh0LmNhbnZhcy5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgbGV0IGN0eCA9IGNvbnRleHQuY2FudmFzLmdldCgpLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dQYWludCgpKTtcbiAgICAgICAgY29udGV4dC5lZmZlY3RzLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGluIG9yZGVyIHRvIGRyYXcgYW5kIHJlZHJhdyB0aGUgb2JqZWN0IHdoZW4gbWFuaXB1bGF0aW9ucyBhcmUgbWFkZVxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnc7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmg7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIC8vdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICAvL3RoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IFwiI2Q1YjhmZlwiO1xuICAgICAgICB0aGlzLl9jdHguc2hhZG93Q29sb3IgPSBcIiM2QzZDNkNcIjtcbiAgICAgICAgdGhpcy5fY3R4LnNoYWRvd0JsdXIgPSAxNTtcbiAgICAgICAgLy90aGlzLl9jdHguc2hhZG93T2Zmc2V0WCA9IDI7XG4gICAgICAgIC8vdGhpcy5fY3R4LnNoYWRvd09mZnNldFkgPSAyO1xuICAgICAgICB0aGlzLl9jdHguZmlsbCgpO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3R3VpZGVzKHgsIHksIHdpZHRoLCBoZWlnaHQsIHRoaXMuX2Nvcm5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gb25lIGZlbGwgc3dvb3BcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7IC8vIGJpbmQgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIG1lYW5pbmcgb2YgJ3RoaXMnXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25TaGlmdERvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25TaGlmdFVwLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5pc01vdXNlT3V0c2lkZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy9tYWtlcyBpdCBzbyB0aGF0IGRvdWJsZSBjbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0ZXh0IG9uIHRoZSBwYWdlXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uIChlKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGZhbHNlOyB9LCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIGluIGFub3RoZXIgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvZiB0aGUgb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgY29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xuICAgICAgICBsZXQgeSA9IHRoaXMueTtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5oO1xuICAgICAgICBpZiAobXggPiB4ICYmIG14IDwgeCArIHcgJiYgbXkgPiB5ICYmIG15IDwgeSArIGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciA+IDAgaWYgdGhlIG1vdXNlIGlzIGluc2lkZSBvbmUgb2YgdGhlIGNvcm5lci9zaWRlIGd1aWRlcywgcmV0dXJucyAwIGlmIG5vdFxuICAgICAqIFRoZSBjb3JuZXIgZ3VpZGVzIGFyZSBudW1iZXJlZCAxLTQgd2l0aCAxIGJlaW5nIHRoZSB0b3AgbGVmdCwgMiBiZWluZyB0aGUgdG9wIHJpZ2h0LCBhbmQgc28gb24uXG4gICAgICogVGhlIG1pZGRsZSBndWlkZXMgYXJlIG51bWJlcmVkIDUtOCwgd2l0aCA1IGJlaW5nIHRoZSB0b3AgbWlkZGxlLCA2IGJlaW5nIHRoZSByaWdodCBtaWRkbGUsIGFuZCBzbyBvbi5cbiAgICAgKiBAcGFyYW0gbXggdGhlIG1vdXNlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBteSB0aGUgbW91c2UgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ3VpZGVDb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGxldCB4ZGlmID0gbXggLSB4O1xuICAgICAgICBsZXQgeWRpZiA9IG15IC0geTtcbiAgICAgICAgLyogQ29ybmVyIEd1aWRlcyAqL1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vdG9wIGxlZnRcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy90b3AgcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gcmlnaHRcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmKSA8PSA1ICYmIE1hdGguYWJzKHlkaWYpIDw9IDUpIHsgLy9ib3R0b20gbGVmdFxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogTWlkZGxlIEd1aWRlcyAqL1xuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0geTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL3RvcCBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtICh4ICsgdyk7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgfVxuICAgICAgICB4ZGlmID0gbXggLSAoeCArIHcgLyAyKTtcbiAgICAgICAgeWRpZiA9IG15IC0gKHkgKyBoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkgeyAvL2JvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICB9XG4gICAgICAgIHhkaWYgPSBteCAtIHg7XG4gICAgICAgIHlkaWYgPSBteSAtICh5ICsgaCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeGRpZikgPD0gNSAmJiBNYXRoLmFicyh5ZGlmKSA8PSA1KSB7IC8vbWlkZGxlIGxlZnRcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGFuZCBndWlkZXMgZm9yIHRoZSBvYmplY3Qgd2hlbiB0aGUgb2JqZWN0IGlzIHNlbGVjdGVkXG4gICAgICogSWYgb25lIG9mIHRoZSBndWlkZXMgaXMgc2VsZWN0ZWQsIGl0IGNvbG9ycyB0aGF0IGd1aWRlIGJsdWVcbiAgICAgKiBAcGFyYW0geCB0aGUgeCBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0geSB0aGUgeSBjb29yZGluYXRlIGZvciB3aGVyZSB0aGUgcmVjdGFuZ2xlIHdpbGwgb3JpZ2luYXRlIGZyb20gKHRvcCBsZWZ0IGNvcm5lcilcbiAgICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb3JuZXIgdGhlIG51bWJlciBvZiB0aGUgY29ybmVyIHRvIGJlIGNvbG9yZWQgYmx1ZSAoaWYgYW55IGF0IGFsbCwgaWYgMCwgYWxsIGFyZSB3aGl0ZSlcbiAgICAgKi9cbiAgICBkcmF3R3VpZGVzKHgsIHksIHcsIGgsIGNvcm5lcikge1xuICAgICAgICB0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKGNvcm5lciAhPT0gMCAmJiBjb3JuZXIgPD0gNCkgeyAvLyBhIGNvcm5lciBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXIpIHsgLy9jb2xvcnMgdGhlIGNvcnJlY3QgZ3VpZGUgYmx1ZVxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3JuZXIgIT09IDApIHsgLy8gYSBtaWRkbGUgZ3VpZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyKSB7IC8vY29sb3JzIHRoZSBjb3JyZWN0IGd1aWRlIGJsdWVcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICdibHVlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoKHggKyB3IC8gMikgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsICh5ICsgaCAvIDIpIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gbWlkZGxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gYm90dG9tIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCArIHcgLSAyLjUsIHkgKyBoIC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSArIGggLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ2JsdWUnKTsgLy8gbWlkZGxlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vaWYgbm8gZ3VpZGVzIGFyZSBzZWxlY3RlZCwgY29sb3JzIGV2ZXJ5dGhpbmcgd2hpdGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnd2hpdGUnKTsgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSgoeCArIHcgLyAyKSAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIHRvcCByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCAoeSArIGggLyAyKSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIG1pZGRsZSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKCh4ICsgdyAvIDIpIC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBtaWRkbGVcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4IC0gMi41LCB5ICsgaCAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7IC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICB0aGlzLmRyYXdTcXVhcmUoeCAtIDIuNSwgKHkgKyBoIC8gMikgLSAyLjUsIDUsIDUsICd3aGl0ZScpOyAvLyBtaWRkbGUgbGVmdFxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBtZXRob2QgdGhhdCBkcmF3cyBhIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB4IHggY29vcmRpbmF0ZSBmb3IgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHkgeSBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gdyB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGggaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29sb3IgY29sb3Igb2YgdGhlIHJlY3RhbmdsZSdzIGZpbGxcbiAgICAgKi9cbiAgICBkcmF3U3F1YXJlKHgsIHksIHcsIGgsIGNvbG9yKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBtb3ZlcyB3aXRoaW4gdGhlIGNhbnZhcy5cbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiwgY2FsbHMgdGhlIG1vZGlmeSBtZXRob2RzIGlmIHRoZSBib29sZWFucyBzYXRpc2Z5IHRoZW0uXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICB0aGlzLmdldE1vdXNlUG9zaXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlEcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZXNpemluZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVJlc2l6ZSh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQ2hhbmdpbmdEaW1zICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q2hhbmdlRGltcyh0aGlzLncgPCAxMCwgdGhpcy5oIDwgMTApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciB0aGUgbW91c2UgY2xpY2tzIGluc2lkZSB0aGUgY2FudmFzLlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdGF0ZSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIG9yIHRoZSBib3VuZGluZyByZWN0IGNvbnRhaW5zIHRoZSBtb3VzZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlZG93biBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW9kaWZ5U3RhdGUodGhpcy5ndWlkZUNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpLCB0aGlzLmNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSB1bmNsaWNrcy5cbiAgICAgKiBDYWxscyBtb2RpZnlSZXNldCB0byByZXNldCBkcmFnZ2luZyBhbmQgcmVzaXppbmcgYm9vbGVhbnMgYW1vbmcgb3RoZXJzLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2V1cCBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VVcChldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyBwcmVzc2VkIGRvd25cbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSBwcmVzc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcmVsZWFzZWRcbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSByZWxlYXNlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdFVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBNb2RpZmljYXRpb24gZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGRyYWcgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBtb2RpZnlEcmFnKCkge1xuICAgICAgICB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSB0aGlzLl9tb3VzZS54IC0gdGhpcy5fZHJhZ29mZng7XG4gICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLl9kcmFnb2ZmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHdoZW4gY2FsbGVkICh3aGVuIGEgY29ybmVyIGd1aWRlIGlzIGNsaWNrZWQgYW5kIGRyYWdnZWQpLlxuICAgICAqXG4gICAgICogSWYgYW55IG9mIHdpZHRoIG9yIGhlaWdodCBpcyB0b28gc21hbGwsIGl0IHNldHMgdGhlbSBlcXVhbCB0byAxMCBhbmQgdGhlIG90aGVyIGVxdWFsIHRvXG4gICAgICogMTAgZGl2aWRlZCBvciBtdWx0aXBsaWVkIGJ5IHRoZSByYXRpbyBvZiB3aWR0aC9oZWlnaHQgdG8ga2VlcCBpdCB0aGUgc2FtZS5cbiAgICAgKlxuICAgICAqIFRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIGlzIGRvbmUgYnkgY2FsbGluZyB0aGUgaGVscGVyIG1ldGhvZCBtb2RpZnlSZXNpemVIZWxwZXIuXG4gICAgICogQHBhcmFtIHdpZHRoVG9vU21hbGwgdHJ1ZSBpZiB0aGUgd2lkdGggZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKiBAcGFyYW0gaGVpZ2h0VG9vU21hbGwgdHJ1ZSBpZiB0aGUgaGVpZ2h0IGRpbWVuc2lvbiBpcyA8IDEwXG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9yZWN0LndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTsgLy8gc2V0IGZvciB0aGUgcHJvZGlyZWN0IG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMCAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fcmVjdC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCgxMCAvIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9yZWN0LmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7IC8vIHNldCBmb3IgdGhlIHByb2RpcmVjdCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2RpbXMud2lkdGguZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgPSAxMCAqIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fcmVjdC53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKDEwICogdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy5fZHJhZ29mZngsIHRoaXMuX2RyYWdvZmZ5KTtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5UmVzaXplSGVscGVyKG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGUgcmVjdGFuZ2xlIG9yaWdpbmF0ZXMgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIGFuZCBub3QgdGhlIGNlbnRlcixcbiAgICAgKiBpdCBjaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFzIHdlbGwgaWYgZ3VpZGVzIDEsIDIsIG9yIDQgYXJlIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3RGlzdGFuY2UgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG1vdXNlIGFuZCB0aGUgbG9jYXRpb24gb3Bwb3NpdGUgdG8gaXRcbiAgICAgKiAoaWYgdG9wIHJpZ2h0IGd1aWRlIGlzIGNsaWNrZWQsIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoYXQgYW5kIHRoZSBib3R0b20gbGVmdCBndWlkZSBpcyBuZXdEaXN0YW5jZSlcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNpemVIZWxwZXIobmV3RGlzdGFuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMudyA+IDEwICYmIHRoaXMuaCA+IDEwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQoKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAvIHRoaXMuX3JhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICB0aGlzLl9yZWN0LndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKE1hdGgucm91bmQodGhpcy53KSk7XG4gICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgLyB0aGlzLl9yYXRpbztcbiAgICAgICAgdGhpcy5fcmVjdC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9iamVjdCB3aGVuIGNhbGxlZC5cbiAgICAgKiBJZiBhbnkgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHRvbyBzbWFsbCwgaXQgc2V0cyB0aGVtIGVxdWFsIHRvIDEwLlxuICAgICAqIENhbGxzIG1vZGlmeUNoYW5nZURpbXNIZWxwZXIgdG8gYWN0dWFsbHkgZG8gdGhlIHdvcmtcbiAgICAgKiBAcGFyYW0gd2lkdGhUb29TbWFsbCB0cnVlIGlmIHRoZSB3aWR0aCBkaW1lbnNpb24gaXMgPCAxMFxuICAgICAqIEBwYXJhbSBoZWlnaHRUb29TbWFsbCB0cnVlIGlmIHRoZSBoZWlnaHQgZGltZW5zaW9uIGlzIDwgMTBcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zKHdpZHRoVG9vU21hbGwsIGhlaWdodFRvb1NtYWxsKSB7XG4gICAgICAgIGxldCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHRoaXMuX2RyYWdvZmZ4LCB0aGlzLl9kcmFnb2ZmeSk7XG4gICAgICAgIGlmICh3aWR0aFRvb1NtYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9yZWN0LndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKDEwKTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0VG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpbXMuaGVpZ2h0LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLl9yZWN0LmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgxMCk7XG4gICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeUNoYW5nZURpbXNIZWxwZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSB3b3JrIG9mIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGUgcmVjdGFuZ2xlIG9yaWdpbmF0ZXMgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIGFuZCBub3QgdGhlIGNlbnRlcixcbiAgICAgKiBpdCBjaGFuZ2VzIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFzIHdlbGwgaWYgZ3VpZGVzIDUgb3IgOCBhcmUgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBtb2RpZnlDaGFuZ2VEaW1zSGVscGVyKCkge1xuICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikge1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmggPiAxMCkgeyAvL2FzIGxvbmcgYXMgdGhlIGhlaWdodCBpcyA+IDEwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCAtPSBNYXRoLnJvdW5kKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGltcy5oZWlnaHQuZXZhbCh0aGlzLl9jb250ZXh0KS52YWwgKz0gbmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdC5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3Qud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCArPSBuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0LmhlaWdodCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZShNYXRoLnJvdW5kKHRoaXMuaCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdGlvID0gdGhpcy53IC8gdGhpcy5oO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLncgPiAxMCkgeyAvLyBhcyBsb25nIGFzIHdpZHRoIGlzID4gMTBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGltcy54LmV2YWwodGhpcy5fY29udGV4dCkudmFsIC09IE1hdGgucm91bmQobmV3RGlzdGFuY2UgLSB0aGlzLl9pbml0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kaW1zLndpZHRoLmV2YWwodGhpcy5fY29udGV4dCkudmFsICs9IG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3Qud2lkdGggPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoTWF0aC5yb3VuZCh0aGlzLncpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMudyAvIHRoaXMuaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyBkZXBlbmRpbmcgb24gdGhlIG1vdXNlIHBvc2l0aW9uIHdoZW4gY2FsbGVkIChvbk1vdXNlRG93bilcbiAgICAgKiBlLmcuIGlmIHRoZSBtb3VzZSBpcyB3aXRoaW4gdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSB3aGVuIHRoaXMgaXMgY2FsbGVkLCBpc1NlbGVjdGVkID0gdHJ1ZVxuICAgICAqIEBwYXJhbSBndWlkZUNvbnRhaW5zXG4gICAgICogQHBhcmFtIGNvbnRhaW5zXG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGUoZ3VpZGVDb250YWlucywgY29udGFpbnMpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHggPSB0aGlzLng7XG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xuICAgICAgICBsZXQgdyA9IHRoaXMudztcbiAgICAgICAgbGV0IGggPSB0aGlzLmg7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7IC8vcHJlcGFyZXMgdGhlIG9iamVjdCBmb3IgZHJhZ2dpbmcgd2hldGhlciBpdCBpcyBwZXJzb25hbGx5IHNlbGVjdGVkIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5feTEgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGd1aWRlQ29udGFpbnMgPiAwICYmIGd1aWRlQ29udGFpbnMgPD0gNCkgeyAvL3Jlc2l6aW5nXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSB0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSk7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQxID0gdGhpcy5oO1xuICAgICAgICAgICAgdGhpcy5fd2lkdGgxID0gdGhpcy53O1xuICAgICAgICAgICAgLy90aGlzLl9zaXplMSA9IE1hdGguc3FydChNYXRoLnBvdyh3LDIpICsgTWF0aC5wb3coaCwyKSk7IC8vIHNpemUgaXMgZGlhZ29uYWwgbGVuZ3RoXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2Nvcm5lcikgeyAvLyBzZXRzIHRoZSBvZmZzZXRzIGRlcGVuZGluZyBvbiB3aGljaCBjb3JuZXIgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIHRvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7IC8vIG9mZnNldCBpcyBib3R0b20gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5ICsgaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiAvLyB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7IC8vIG9mZnNldCBpcyBib3R0b20gbGVmdCwgZXRjXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChndWlkZUNvbnRhaW5zID4gNCkgeyAvL2NoYW5naW5nIHNoYXBlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNDaGFuZ2luZ0RpbXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gZ3VpZGVDb250YWlucztcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fY29ybmVyKSB7IC8vIHNldHMgdGhlIG9mZnNldHMgZGVwZW5kaW5nIG9uIHdoaWNoIG1pZGRsZSBndWlkZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgNTogLy8gdG9wIG1pZGRsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB4ICsgdyAvIDIsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4ICsgdyAvIDI7IC8vIG9mZnNldCBpcyBib3R0b20gbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogLy9yaWdodCBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCwgeSArIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHkgKyBoIC8gMjsgLy8gb2Zmc2V0IGlzIGxlZnQgbWlkZGxlIGV0Y1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnksIHggKyB3IC8gMiwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgeCArIHcsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0geCArIHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWlucykgeyAvLyBkcmFnZ2luZ1xuICAgICAgICAgICAgdGhpcy5feDEgPSB4OyAvLyBTYXZpbmcgb3JpZ2luYWwgeCBhbmQgeVxuICAgICAgICAgICAgdGhpcy5feTEgPSB5O1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nQ2xpY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnggPSB0aGlzLl9tb3VzZS54IC0geDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy5fbW91c2UueSAtIHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHsgLy8gbm90IHNlbGVjdGVkXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCBvZiB0aGUgcHJpdmF0ZSBib29sZWFucyB0byBmYWxzZSAobGlrZSBkcmFnZ2luZywgcmVzaXppbmcsIGV0Yykgd2hlbiB0aGUgbW91c2UgaXMgcmVsZWFzZWRcbiAgICAgKi9cbiAgICBtb2RpZnlSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0gdGhpcy54KSA+IDEgfHwgTWF0aC5hYnModGhpcy5feTEgLSB0aGlzLnkpID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodGhpcy5faXNSZXNpemluZyB8fCB0aGlzLl9pc0NoYW5naW5nRGltcykgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHNpemUyID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMudywgMikgKyBNYXRoLnBvdyh0aGlzLmgsIDIpKTtcbiAgICAgICAgICAgIGlmICgoTWF0aC5hYnModGhpcy5fd2lkdGgxIC0gdGhpcy53KSA+IDApIHx8IChNYXRoLmFicyh0aGlzLl9oZWlnaHQxIC0gdGhpcy5oKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nUmVzaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICovXG4gICAgZ2V0TW91c2VQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbW91c2UueCA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLng7XG4gICAgICAgIHRoaXMuX21vdXNlLnkgPSBnZXRNb3VzZVBvcyh0aGlzLl9jYW52YXMsIGV2ZW50KS55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzQ2hhbmdpbmdEaW1zLCBhbmQgaXNTZWxlY3RlZCB0byBmYWxzZSBpZiB0aGUgbW91c2UgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgaXNNb3VzZU91dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1vdXNlWCA8IHJlY3QubGVmdCB8fCBtb3VzZVggPiByZWN0LnJpZ2h0IHx8IG1vdXNlWSA8IHJlY3QudG9wIHx8IG1vdXNlWSA+IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYW5naW5nRGltcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIHBhaW50IGV2ZW50XG4gICAgICovXG4gICAgbG9nUGFpbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpbnRFdmVudF8xLlBhaW50RXZlbnQoXCJyZWN0YW5nbGVcIiwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcmVjdGFuZ2xlIHJlc2l6ZSBldmVudFxuICAgICAqL1xuICAgIGxvZ1Jlc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVFdmVudF8xLlJlc2l6ZUV2ZW50KFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSwgTWF0aC5yb3VuZCh0aGlzLl93aWR0aDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMuX2hlaWdodDEgKiAxMDApIC8gMTAwLCBNYXRoLnJvdW5kKHRoaXMudyAqIDEwMCkgLyAxMDAsIE1hdGgucm91bmQodGhpcy5oICogMTAwKSAvIDEwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZWN0YW5nbGUgY2xpY2sgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dDbGljaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGlja0V2ZW50XzEuQ2xpY2tFdmVudChcInJlY3RhbmdsZSB3aXRoIElEIFwiICsgdGhpcy5nZXRJRCgpLnRvU3RyaW5nKCksIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIGFzc2lnbnMgYW4gSUQgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIGlkIFRoZSBJRCB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIGluaXRJRChpZCkge1xuICAgICAgICB0aGlzLmlkT2JqID0geyBfaWQ6IGlkIH07XG4gICAgfVxuICAgIGFzdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHggcG9zaXRpb24gb2YgdGhlIHJlY3RcbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldCB3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGltcy53aWR0aC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSByZWN0XG4gICAgICovXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLmhlaWdodC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRGltZW5zaW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgZGltcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgcmVjdFxuICAgICAqL1xuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZE9iai5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJlY3QgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICovXG4gICAgZ2V0SnVzdERyYWdnZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdXN0RHJhZ2dlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSB0byBiZSBhc3NpZ25lZFxuICAgICAqL1xuICAgIHNldEp1c3REcmFnZ2VkKHZhbCkge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVjdCBpcyBkcmFnZ2luZ1xuICAgICAqL1xuICAgIGdldCBpc0RyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEcmFnZ2luZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBzZWxlY3Rpb24gZXZlbnRzXG4gICAgICovXG4gICAgdG9TZWxTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIiByZWN0YW5nbGUgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgYXQgXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXNzZW1ibGVzIGEgc3RyaW5nIGZvciBkcmFnIGV2ZW50c1xuICAgICovXG4gICAgdG9EcmFnU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKFwicmVjdGFuZ2xlIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGZyb20gXCIgKyB0aGlzLl94MSArIFwiLCBcIiArIHRoaXMuX3kxICsgXCIgdG8gXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIElEIGFzc2lnbm1lbnQgZXZlbnRzXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkT2JqLl9pZC50b1N0cmluZygpICsgXCIgdG8gcmVjdGFuZ2xlIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55KTtcbiAgICB9XG59XG5leHBvcnRzLlJlY3RhbmdsZUVmZmVjdCA9IFJlY3RhbmdsZUVmZmVjdDtcbi8qKlxuICogR2V0cyB0aGUgbW91c2UgeCBhbmQgeSBjb29yZGluYXRlcyBpbiByZWxhdGlvbiB0byB0aGUgY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHRoZSBjYW52YXMgb2JqZWN0XG4gKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICovXG5mdW5jdGlvbiBnZXRNb3VzZVBvcyhjYW52YXMsIGV2ZW50KSB7XG4gICAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHgxIHggY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHkxIHkgY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICogQHBhcmFtIHgyIHggY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSB5MiB5IGNvb3JkaW5hdGUgb2Ygc2Vjb25kIHBvaW50XG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgyLCAyKSArIE1hdGgucG93KHkxIC0geTIsIDIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlY3RhbmdsZUVmZmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBhaW50RXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nL1BhaW50RXZlbnRcIik7XG5jb25zdCBSZXNpemVFdmVudF8xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvUmVzaXplRXZlbnRcIik7XG5jb25zdCBDbGlja0V2ZW50XzEgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9DbGlja0V2ZW50XCIpO1xuY2xhc3MgU3RyaW5nRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihzdHIpIHtcbiAgICAgICAgdGhpcy5fZm9udFNpemUgPSAyMDtcbiAgICAgICAgLy9wcml2YXRlIF9zaXplMjogbnVtYmVyO1xuICAgICAgICB0aGlzLl9jb3JuZXIgPSAwO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7IC8vIFByaXZhdGUgYm9vbHNcbiAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzTGlzdGVuaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2p1c3REcmFnZ2VkID0gZmFsc2U7IC8vIEhhcyB0aGlzIG9iamVjdCBqdXN0IGJlZW4gZHJhZ2dlZD9cbiAgICAgICAgLy9wcml2YXRlIF9sb2c6IHN0cmluZ1tdO1xuICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gMDtcbiAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5fbW91c2UgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl90ZXh0TWV0cmljcyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgaW50ZXJ2YWw6IDAsXG4gICAgICAgICAgICBzdHI6IFwiXCIsXG4gICAgICAgICAgICBpbml0TW91c2VQb3M6IDAsXG4gICAgICAgICAgICBjdXJzb3JQb3M6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc3RyID0gc3RyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gZXZhbHVhdGluZyBub2RlcyAoU3RyaW5nTm9kZSwgRWxsaXBzZU5vZGUsIGV0YylcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3NpZ25zIGFsbCBwYXJhbXMgdG8gcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIGRyYXdzIHRoZSBpbml0aWFsIG9iamVjdCB0byB0aGUgY2FudmFzXG4gICAgICogYnkgY2FsbGluZyB1cGRhdGUoKVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBwYXJlbnQgU2NvcGUgdGhhdCBjb250YWlucyB0aGUgY2FudmFzIGFtb25nIG90aGVyIHRoaW5nc1xuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBvYmplY3QncyBkaW1lbnNpb25zIGluY2x1ZGluZyB4IGFuZCB5IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGFzdCBVbm5lY2Vzc2FyeSBub3csIHVzZWQgdG8gYmUgdGhlIHBhcmVudCBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBpZiAoY29udGV4dC5jYW52YXMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IGNvbnRleHQuY2FudmFzLmdldCgpO1xuICAgICAgICAgICAgdGhpcy5fZGltcyA9IGRpbXM7XG4gICAgICAgICAgICBsZXQgY3R4ID0gY29udGV4dC5jYW52YXMuZ2V0KCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIC8vIGxvZ2dpbmdcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1BhaW50KCkpOyAvLyB0aGlzLmNvbnRleHQgb3IgY29udGV4dD9cbiAgICAgICAgICAgIGNvbnRleHQuZWZmZWN0cy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYW52YXMgaXMgTk9UIGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGluIG9yZGVyIHRvIGRyYXcgYW5kIHJlZHJhdyB0aGUgb2JqZWN0IHdoZW4gbWFuaXB1bGF0aW9ucyBhcmUgbWFkZVxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgbGV0IGZvbnREZWV0cyA9IHRoaXMuX2ZvbnRTaXplICsgXCJweCBDb3VyaWVyIE5ld1wiO1xuICAgICAgICB0aGlzLl9jdHguZm9udCA9IGZvbnREZWV0cztcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IFwiIzY3M0FCN1wiO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFRleHQodGhpcy5fc3RyLnZhbCwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICBsZXQgdGV4dERpbXMgPSB0aGlzLl9jdHgubWVhc3VyZVRleHQodGhpcy5fc3RyLnZhbCk7XG4gICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLndpZHRoID0gdGV4dERpbXMud2lkdGg7XG4gICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmhlaWdodCA9IHRoaXMuX2ZvbnRTaXplO1xuICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5zdHIgPSB0aGlzLl9zdHIudmFsO1xuICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5pbnRlcnZhbCA9IHRoaXMuX3RleHRNZXRyaWNzLndpZHRoIC8gdGhpcy5fdGV4dE1ldHJpY3Muc3RyLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1RleHRHdWlkZXModGhpcy54LCB0aGlzLnkgLSB0aGlzLl9mb250U2l6ZSwgdGhpcy5fdGV4dE1ldHJpY3Mud2lkdGgsIHRoaXMuX3RleHRNZXRyaWNzLmhlaWdodCwgdGhpcy5fY29ybmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNFZGl0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycyBpbiBvbmUgZmVsbCBzd29vcFxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTsgLy8gYmluZCBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgbWVhbmluZyBvZiAndGhpcydcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vblNoaWZ0RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vblNoaWZ0VXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmlzTW91c2VPdXRzaWRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL21ha2VzIGl0IHNvIHRoYXQgZG91YmxlIGNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRleHQgb24gdGhlIHBhZ2VcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgZnVuY3Rpb24gKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZmFsc2U7IH0sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgaW4gYW5vdGhlciBmZWxsIHN3b29wXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbW91c2UgaXMgaW5zaWRlIG9mIHRoZSBvYmplY3QncyBib3VuZGluZyByZWN0YW5nbGUsIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSBteCB0aGUgbW91c2UgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIG15IHRoZSBtb3VzZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBjb250YWlucyhteCwgbXkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnggPD0gbXgpICYmICh0aGlzLnggKyB0aGlzLl90ZXh0TWV0cmljcy53aWR0aCA+PSBteCkgJiZcbiAgICAgICAgICAgICh0aGlzLnkgLSB0aGlzLl9mb250U2l6ZSA8PSBteSkgJiYgKHRoaXMueSA+PSBteSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgPiAwIGlmIHRoZSBtb3VzZSBpcyBpbnNpZGUgb25lIG9mIHRoZSBjb3JuZXIvc2lkZSBndWlkZXMsIHJldHVybnMgMCBpZiBub3RcbiAgICAgKiBUaGUgY29ybmVyIGd1aWRlcyBhcmUgbnVtYmVyZWQgMS00IHdpdGggMSBiZWluZyB0aGUgdG9wIGxlZnQsIDIgYmVpbmcgdGhlIHRvcCByaWdodCwgYW5kIHNvIG9uLlxuICAgICAqIFRoZSBtaWRkbGUgZ3VpZGVzIGFyZSBudW1iZXJlZCA1LTgsIHdpdGggNSBiZWluZyB0aGUgdG9wIG1pZGRsZSwgNiBiZWluZyB0aGUgcmlnaHQgbWlkZGxlLCBhbmQgc28gb24uXG4gICAgICogQHBhcmFtIG14IHRoZSBtb3VzZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbXkgdGhlIG1vdXNlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGd1aWRlQ29udGFpbnMobXgsIG15KSB7XG4gICAgICAgIGxldCB4ZGlmID0gbXggLSAodGhpcy54ICsgdGhpcy5fdGV4dE1ldHJpY3Mud2lkdGgpO1xuICAgICAgICBsZXQgeWRpZiA9IG15IC0gKHRoaXMueSAtIHRoaXMuX2ZvbnRTaXplKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHhkaWYpIDw9IDUgJiYgTWF0aC5hYnMoeWRpZikgPD0gNSkge1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBhbmQgZ3VpZGVzIGZvciB0aGUgb2JqZWN0IHdoZW4gdGhlIG9iamVjdCBpcyBzZWxlY3RlZFxuICAgICAqIElmIG9uZSBvZiB0aGUgZ3VpZGVzIGlzIHNlbGVjdGVkLCBpdCBjb2xvcnMgdGhhdCBndWlkZSBibHVlXG4gICAgICogQHBhcmFtIHggdGhlIHggY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHkgdGhlIHkgY29vcmRpbmF0ZSBmb3Igd2hlcmUgdGhlIHJlY3RhbmdsZSB3aWxsIG9yaWdpbmF0ZSBmcm9tICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgICogQHBhcmFtIHcgdGhlIHdpZHRoIG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gY29ybmVyIHRoZSBudW1iZXIgb2YgdGhlIGNvcm5lciB0byBiZSBjb2xvcmVkIGJsdWUgKGlmIGFueSBhdCBhbGwsIGlmIDAsIGFsbCBhcmUgd2hpdGUpXG4gICAgICovXG4gICAgZHJhd1RleHRHdWlkZXMoeCwgeSwgdywgaCwgY29ybmVyKSB7XG4gICAgICAgIHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAoY29ybmVyICE9PSAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvcm5lcikgeyAvL2NvbG9ycyB0aGUgZ3VpZGUgYmx1ZSBpZiBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3U3F1YXJlKHggKyB3IC0gMi41LCB5IC0gMi41LCA1LCA1LCAnYmx1ZScpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1NxdWFyZSh4ICsgdyAtIDIuNSwgeSAtIDIuNSwgNSwgNSwgJ3doaXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltcGxlIG1ldGhvZCB0aGF0IGRyYXdzIGEgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHggeCBjb29yZGluYXRlIGZvciB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geSB5IGNvb3JkaW5hdGUgZm9yIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB3IHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaCBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb2xvciBjb2xvciBvZiB0aGUgcmVjdGFuZ2xlJ3MgZmlsbFxuICAgICAqL1xuICAgIGRyYXdTcXVhcmUoeCwgeSwgdywgaCwgY29sb3IpIHtcbiAgICAgICAgdGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICdncmF5JztcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvKiBFdmVudCBsaXN0ZW5lciBmdW5jdGlvbnMgKi9cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIHdpdGhpbiB0aGUgY2FudmFzLlxuICAgICAqIEdldHMgdGhlIG1vdXNlIHBvc2l0aW9uLCBjYWxscyB0aGUgbW9kaWZ5IG1ldGhvZHMgaWYgdGhlIGJvb2xlYW5zIHNhdGlzZnkgdGhlbS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlbW92ZSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZ2V0TW91c2VQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCAmJiB0aGlzLl9pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX3N0ci52YWwgKyBcIiBpcyBiZWluZyBkcmFnZ2VkLlwiKTtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5RHJhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVzaXppbmcgJiYgdGhpcy5faXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlSZXNpemUodGhpcy5fZm9udFNpemUgPCAxNSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSBjbGlja3MgaW5zaWRlIHRoZSBjYW52YXMuXG4gICAgICogTW9kaWZpZXMgdGhlIHN0YXRlIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBndWlkZXMgY29udGFpbiB0aGUgbW91c2Ugb3IgdGhlIGJvdW5kaW5nIHJlY3QgY29udGFpbnMgdGhlIG1vdXNlLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlICYmIHRoaXMuX2lzU2VsZWN0ZWQgJiYgdGhpcy5jb250YWlucyh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55KSkgeyAvL3RleHQgZWRpdGluZ1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0xpc3RlbmluZykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5tb2RpZnlUZXh0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faXNMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2codGhpcy5fc3RyLnZhbCArIFwiIGlzIHNldHRpbmcgZHJhZ2dpbmcgdG8gZmFsc2VcIik7XG4gICAgICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5pbml0TW91c2VQb3MgPSB0aGlzLl9tb3VzZS54O1xuICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RpZnlTdGF0ZSh0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSkgPiAwLCB0aGlzLmNvbnRhaW5zKHRoaXMuX21vdXNlLngsIHRoaXMuX21vdXNlLnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBtb3VzZSB1bmNsaWNrcy5cbiAgICAgKiBDYWxscyBtb2RpZnlSZXNldCB0byByZXNldCBkcmFnZ2luZyBhbmQgcmVzaXppbmcgYm9vbGVhbnMgYW1vbmcgb3RoZXJzLlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbW91c2V1cCBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VVcChldmVudCkge1xuICAgICAgICB0aGlzLm1vZGlmeVJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIGtleSBpcyBwcmVzc2VkIGRvd25cbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSBwcmVzc2VkIGlzIHRoZSBzaGlmdCBrZXlcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvblNoaWZ0RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjE2XCIpIHsgLy9zaGlmdCBrZXljb2RlXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBrZXkgaXMgcmVsZWFzZWRcbiAgICAgKiBUb2dnbGVzIHRoZSBpc1NlbGVjdGluZ011bHRpcGxlIGJvb2xlYW4gaWYgdGhlIGtleSByZWxlYXNlZCBpcyB0aGUgc2hpZnQga2V5XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBrZXlkb3duIGV2ZW50XG4gICAgICovXG4gICAgb25TaGlmdFVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IFwiMTZcIikgeyAvL3NoaWZ0IGtleWNvZGVcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0aW5nTXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBNb2RpZmljYXRpb24gZnVuY3Rpb25zICovXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGRyYWcgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBtb2RpZnlEcmFnKCkge1xuICAgICAgICAvLyhcInN0cmluZyBkcmFnb2ZmeDogXCIgKyB0aGlzLl9kcmFnb2ZmeCk7XG4gICAgICAgIHRoaXMuX2RpbXMueC5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLl9kcmFnb2ZmeDtcbiAgICAgICAgdGhpcy5fZGltcy55LmV2YWwodGhpcy5fY29udGV4dCkudmFsID0gdGhpcy5fbW91c2UueSAtIHRoaXMuX2RyYWdvZmZ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCBtb3ZlcyB0aGUgdGV4dCBlZGl0IGN1cnNvciBiYXNlZCBvbiB3aGVyZSB0aGUgbW91c2UgaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIG1vZGlmeVRleHRDdXJzb3IoKSB7XG4gICAgICAgIGxldCBsZWZ0V2FsbCA9IHRoaXMueDsgLy8gdGhlIHggcG9zaXRpb24gb2YgdGhlIGxlZnQgbW9zdCBzaWRlIG9mIHRoZSBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgICAgbGV0IHhEaWYgPSB0aGlzLl90ZXh0TWV0cmljcy5pbml0TW91c2VQb3MgLSBsZWZ0V2FsbDsgLy8gZGlmZmVyZW5jZSBiZXR3ZWVuIG1vdXNlIHggYW5kIGxlZnQgd2FsbFxuICAgICAgICBsZXQgaW50ZXJ2YWwgPSB0aGlzLl90ZXh0TWV0cmljcy5pbnRlcnZhbDsgLy8gdGhlIHRleHQgd2lkdGggZGl2aWRlZCBieSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmdcbiAgICAgICAgbGV0IG1vdmVGYWN0b3IgPSAwO1xuICAgICAgICBpZiAoeERpZiA+PSBpbnRlcnZhbCAvIDIgJiYgeERpZiA8PSBpbnRlcnZhbCkge1xuICAgICAgICAgICAgbW92ZUZhY3RvciA9IGxlZnRXYWxsICsgaW50ZXJ2YWw7XG4gICAgICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5jdXJzb3JQb3MgPSBpbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4RGlmIDw9IGludGVydmFsIC8gMikge1xuICAgICAgICAgICAgbW92ZUZhY3RvciA9IGxlZnRXYWxsO1xuICAgICAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuY3Vyc29yUG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4RGlmICUgaW50ZXJ2YWwgPj0gaW50ZXJ2YWwgLyAyKSB7XG4gICAgICAgICAgICBtb3ZlRmFjdG9yID0gbGVmdFdhbGwgKyBpbnRlcnZhbCAqIE1hdGguY2VpbCh4RGlmIC8gaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuY3Vyc29yUG9zID0gaW50ZXJ2YWwgKiBNYXRoLmNlaWwoeERpZiAvIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4RGlmICUgaW50ZXJ2YWwgPCBpbnRlcnZhbCAvIDIpIHtcbiAgICAgICAgICAgIG1vdmVGYWN0b3IgPSBsZWZ0V2FsbCArIGludGVydmFsICogTWF0aC5mbG9vcih4RGlmIC8gaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuY3Vyc29yUG9zID0gaW50ZXJ2YWwgKiBNYXRoLmZsb29yKHhEaWYgLyBpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3R4Lm1vdmVUbyhtb3ZlRmFjdG9yLCB0aGlzLnkgLSB0aGlzLl9mb250U2l6ZSk7XG4gICAgICAgIHRoaXMuX2N0eC5saW5lVG8obW92ZUZhY3RvciwgdGhpcy55KTtcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gXCJncmV5XCI7XG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBlZGl0cyB0aGUgc3RyaW5nIHdoZW4gZWRpdGluZyB0ZXh0XG4gICAgICogQHBhcmFtIGV2ZW50IGtleWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBtb2RpZnlUZXh0KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdEhhbGY7XG4gICAgICAgICAgICBsZXQgc2Vjb25kSGFsZjtcbiAgICAgICAgICAgIGxldCBicmVha1BvaW50ID0gdGhpcy5fdGV4dE1ldHJpY3MuY3Vyc29yUG9zIC8gdGhpcy5fdGV4dE1ldHJpY3MuaW50ZXJ2YWw7XG4gICAgICAgICAgICBmaXJzdEhhbGYgPSB0aGlzLl9zdHIudmFsLnN1YnN0cmluZygwLCBicmVha1BvaW50KTtcbiAgICAgICAgICAgIHNlY29uZEhhbGYgPSB0aGlzLl9zdHIudmFsLnN1YnN0cmluZyhicmVha1BvaW50KTtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDM3ICYmIHRoaXMuX3RleHRNZXRyaWNzLmluaXRNb3VzZVBvcyA+IHRoaXMueCArIHRoaXMuX3RleHRNZXRyaWNzLmludGVydmFsIC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRNZXRyaWNzLmluaXRNb3VzZVBvcyAtPSB0aGlzLl90ZXh0TWV0cmljcy5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmeVRleHRDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzkgJiYgdGhpcy5fdGV4dE1ldHJpY3MuaW5pdE1vdXNlUG9zIDwgdGhpcy54ICsgdGhpcy5fdGV4dE1ldHJpY3Mud2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5pbml0TW91c2VQb3MgKz0gdGhpcy5fdGV4dE1ldHJpY3MuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZnlUZXh0Q3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDggJiYgdGhpcy5fc3RyLnZhbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RIYWxmID0gZmlyc3RIYWxmLnN1YnN0cmluZygwLCBmaXJzdEhhbGYubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyLnN0ciA9IGZpcnN0SGFsZiArIHNlY29uZEhhbGY7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dE1ldHJpY3MuaW5pdE1vdXNlUG9zIC09IHRoaXMuX3RleHRNZXRyaWNzLmludGVydmFsO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGtleU5hbWUgPSBldmVudC5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKGtleU5hbWUubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RIYWxmICs9IGtleU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0ci5zdHIgPSBmaXJzdEhhbGYgKyBzZWNvbmRIYWxmO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0TWV0cmljcy5pbml0TW91c2VQb3MgKz0gdGhpcy5fdGV4dE1ldHJpY3MuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kaWZ5VGV4dEN1cnNvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb2RpZmllcyB0aGUgZm9udCBzaXplIG9mIHRoZSB0ZXh0XG4gICAgICogSWYgdGhlIHRleHQgZm9udCBpcyBzbWFsbGVyIHRoYW4gMTVwdCwgaXQgc2V0J3MgaXQgZXF1YWwgdG8gMTVwdFxuICAgICAqIEBwYXJhbSBpc1Rvb1NtYWxsIHRydWUgaWYgdGhlIGZvbnQgc2l6ZSBpcyA8IDE1XG4gICAgICovXG4gICAgbW9kaWZ5UmVzaXplKGlzVG9vU21hbGwpIHtcbiAgICAgICAgaWYgKGlzVG9vU21hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplID0gMTU7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplICs9IChuZXdEaXN0YW5jZSAtIHRoaXMuX2luaXREaXN0YW5jZSkgKiAwLjI7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLl9tb3VzZS54LCB0aGlzLl9tb3VzZS55LCB0aGlzLl9kcmFnb2ZmeCwgdGhpcy5fZHJhZ29mZnkpO1xuICAgICAgICAgICAgdGhpcy5fZm9udFNpemUgKz0gKG5ld0Rpc3RhbmNlIC0gdGhpcy5faW5pdERpc3RhbmNlKSAqIDAuMjtcbiAgICAgICAgICAgIHRoaXMuX2luaXREaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIGRlcGVuZGluZyBvbiB0aGUgbW91c2UgcG9zaXRpb24gd2hlbiBjYWxsZWQgKG9uTW91c2VEb3duKVxuICAgICAqIGUuZy4gaWYgdGhlIG1vdXNlIGlzIHdpdGhpbiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIHdoZW4gdGhpcyBpcyBjYWxsZWQsIGlzU2VsZWN0ZWQgPSB0cnVlXG4gICAgICogQHBhcmFtIGd1aWRlQ29udGFpbnNcbiAgICAgKiBAcGFyYW0gY29udGFpbnNcbiAgICAgKi9cbiAgICBtb2RpZnlTdGF0ZShndWlkZUNvbnRhaW5zLCBjb250YWlucykge1xuICAgICAgICB0aGlzLl9qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RpbmdNdWx0aXBsZSkgeyAvL3ByZXBhcmVzIHRoZSBvYmplY3QgZm9yIGRyYWdnaW5nIHdoZXRoZXIgaXQgaXMgcGVyc29uYWxseSBzZWxlY3RlZCBvciBub3RcbiAgICAgICAgICAgIGlmIChjb250YWlucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kxID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ4ID0gdGhpcy5fbW91c2UueCAtIHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ29mZnkgPSB0aGlzLl9tb3VzZS55IC0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYodGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC5tdWxTZWwpe1xuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKFwic3RyaW5nIGVmZmVjdCBtdWxTZWxlY3RlZDogXCIgKyB0aGlzLl9jb250ZXh0Lm11bFNlbGVjdGVkLm11bFNlbCk7XG4gICAgICAgICAgICAvLyAgICAgLy9pZih0aGlzLl9jb250ZXh0Lm11bFNlbGVjdGVkLnZhbCl7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nU2VsZWN0ZWQoKSk7XG4gICAgICAgICAgICAvLyAgICAgLy90aGlzLmxvZ1NlbGVjdGVkKCk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3VpZGVDb250YWlucykgeyAvL2lmIHRoZSBjb3JuZXIgZ3VpZGVzIGNvbnRhaW4gdGhlIG1vdXNlIHdlIGFyZSByZXNpemluZ1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb3JuZXIgPSB0aGlzLmd1aWRlQ29udGFpbnModGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2codGhpcy5fc3RyLnZhbCArIFwiaXMgc2VsZWN0ZWQ/XCIgKyB0aGlzLl9zZWxlY3RlZCk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwic3RhdGUgc2VsZWN0aW9uIGlzIFwiICsgdGhpcy5fc3RyLnZhbCk7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMueDtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdvZmZ5ID0gdGhpcy55O1xuICAgICAgICAgICAgdGhpcy5faW5pdERpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5fbW91c2UueCwgdGhpcy5fbW91c2UueSwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zaXplMSA9IHRoaXMuX2ZvbnRTaXplOyAvLyBzYXZpbmcgb2xkIGZvbnQgc2l6ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgICAgICB0aGlzLl94MSA9IHRoaXMueDsgLy8gU2F2aW5nIG9yaWdpbmFsIHggYW5kIHlcbiAgICAgICAgICAgIHRoaXMuX3kxID0gdGhpcy55O1xuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmV2ZW50TG9nLnB1c2godGhpcy5sb2dDbGljaygpKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2codGhpcy5fc3RyLnZhbCArIFwiaXMgc2VsZWN0ZWQ/XCIgKyB0aGlzLl9zZWxlY3RlZCk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwic3RhdGUgc2VsZWN0aW9uIGlzIFwiICsgdGhpcy5fc3RyLnZhbCk7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeCA9IHRoaXMuX21vdXNlLnggLSB0aGlzLng7XG4gICAgICAgICAgICB0aGlzLl9kcmFnb2ZmeSA9IHRoaXMuX21vdXNlLnkgLSB0aGlzLnk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzRWRpdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2codGhpcy5fc3RyLnZhbCArIFwiIGlzIGRyYWdnaW5nPyBcIiArIHRoaXMuX2lzRHJhZ2dpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1NlbGVjdGluZ011bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIG9mIHRoZSBwcml2YXRlIGJvb2xlYW5zIHRvIGZhbHNlIChsaWtlIGRyYWdnaW5nLCByZXNpemluZywgZXRjKSB3aGVuIHRoZSBtb3VzZSBpcyByZWxlYXNlZFxuICAgICAqL1xuICAgIG1vZGlmeVJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZyAmJiB0aGlzLl9pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX3N0ci52YWwgKyBcIiBsb2dnaW5nIGRyYWdcIik7XG4gICAgICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB0aGlzLngpID4gMSB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHRoaXMueSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vdGhpcy5fY29udGV4dC5ldmVudExvZy5wdXNoKHRoaXMubG9nTW92ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jlc2l6aW5nICYmIHRoaXMuX2lzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2codGhpcy5fc3RyLnZhbCArIFwiIGxvZ2dpbmcgcmVzaXplXCIpO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3NpemUxIC0gdGhpcy5fZm9udFNpemUpID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ1Jlc2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJzdHJpbmcgZWZmZWN0IG11bFNlbGVjdGVkOiBcIiArIHRoaXMuX2NvbnRleHQubXVsU2VsZWN0ZWQudmFsKTtcbiAgICAgICAgLy8gaWYodGhpcy5fY29udGV4dC5tdWxTZWxlY3RlZC52YWwpe1xuICAgICAgICAvLyAgICAgdGhpcy5sb2dTZWxlY3RlZCgpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmKHRoaXMuaXNNdWx0aXBsZVNlbGVjdGVkKXtcbiAgICAgICAgLy8gICAgIGNvbnRleHQuZXZlbnRMb2cucHVzaChuZXcgU2VsZWN0RXZlbnQoc2VsZWN0ZWRFbGVtcykpO1xuICAgICAgICAvLyAgICAgbWFzdGVyTG9nLnB1c2goY29udGV4dC5ldmVudExvZ1tjb250ZXh0LmV2ZW50TG9nLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgLy8gICAgIC8vY29uc29sZS5sb2coXCJtdWx0aXBsZSBzZWxlY3RlZFwiKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyAvL3RoaXMuX2NvbnRleHQuZXZlbnRMb2cucHVzaCh0aGlzLmxvZ01vdmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKi9cbiAgICBnZXRNb3VzZVBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLl9tb3VzZS54ID0gZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzLCBldmVudCkueDtcbiAgICAgICAgdGhpcy5fbW91c2UueSA9IGdldE1vdXNlUG9zKHRoaXMuX2NhbnZhcywgZXZlbnQpLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNDaGFuZ2luZ0RpbXMsIGFuZCBpc1NlbGVjdGVkIHRvIGZhbHNlIGlmIHRoZSBtb3VzZSBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBpc01vdXNlT3V0c2lkZShldmVudCkge1xuICAgICAgICBsZXQgbW91c2VYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgbGV0IG1vdXNlWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5fY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobW91c2VYIDwgcmVjdC5sZWZ0IHx8IG1vdXNlWCA+IHJlY3QucmlnaHQgfHwgbW91c2VZIDwgcmVjdC50b3AgfHwgbW91c2VZID4gcmVjdC5ib3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ybmVyID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgcGFpbnQgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dQYWludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWludEV2ZW50XzEuUGFpbnRFdmVudCh0aGlzLl9zdHIudmFsLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgYSByZXNpemUgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dSZXNpemUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplRXZlbnRfMS5SZXNpemVFdmVudCh0aGlzLl9zdHIudmFsICsgXCIgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCBNYXRoLnJvdW5kKHRoaXMuX3NpemUxICogMTAwKSAvIDEwMCwgTWF0aC5yb3VuZCh0aGlzLl9mb250U2l6ZSAqIDEwMCkgLyAxMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgY2xpY2sgZXZlbnRcbiAgICAgKi9cbiAgICBsb2dDbGljaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGlja0V2ZW50XzEuQ2xpY2tFdmVudCh0aGlzLl9zdHIudmFsICsgXCIgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCBhc3NpZ25zIGFuIElEIHRvIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSBpZCBUaGUgSUQgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBpbml0SUQoaWQpIHtcbiAgICAgICAgdGhpcy5pZE9iaiA9IHsgX2lkOiBpZCwgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2FudmFzXG4gICAgICovXG4gICAgZ2V0IGNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGNhbnZhcyBUaGUgY2FudmFzIHRvIGJlIGFzc2lnbmVkXG4gICAgICovXG4gICAgc2V0IGNhbnZhcyhjYW52YXMpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgIH1cbiAgICBhc3QoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBlbGxpcHNlXG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaW1zLnguZXZhbCh0aGlzLl9jb250ZXh0KS52YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIGVsbGlwc2VcbiAgICAgKi9cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXMueS5ldmFsKHRoaXMuX2NvbnRleHQpLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRGltZW5zaW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgZGltcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZWxsaXBzZSBoYXMganVzdCBiZWVuIGRyYWdnZWRcbiAgICAqL1xuICAgIGdldEp1c3REcmFnZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fanVzdERyYWdnZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIGVsbGlwc2UgaGFzIGp1c3QgYmVlbiBkcmFnZ2VkXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gYmUgYXNzaWduZWRcbiAgICAgKi9cbiAgICBzZXRKdXN0RHJhZ2dlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5fanVzdERyYWdnZWQgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVsbGlwc2UgaXMgZHJhZ2dpbmdcbiAgICAgKi9cbiAgICBnZXQgaXNEcmFnZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRHJhZ2dpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhpcyBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0cmluZ1xuICAgICAqL1xuICAgIGdldCBzdHIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHIudmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvYmplY3QgSURcbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRPYmouX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYSBzdHJpbmcgZm9yIHNlbGVjdGlvbiBldmVudHNcbiAgICAgKi9cbiAgICB0b1NlbFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiIFwiICsgdGhpcy5fc3RyLnZhbCArIFwiIHdpdGggSUQgXCIgKyB0aGlzLmdldElEKCkudG9TdHJpbmcoKSArIFwiIGF0IFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgZHJhZyBldmVudHNcbiAgICAqL1xuICAgIHRvRHJhZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9zdHIudmFsICsgXCIgd2l0aCBJRCBcIiArIHRoaXMuZ2V0SUQoKS50b1N0cmluZygpICsgXCIgZnJvbSBcIiArIHRoaXMuX3gxICsgXCIsIFwiICsgdGhpcy5feTEgKyBcIiB0byBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhIHN0cmluZyBmb3IgSUQgYXNzaWdubWVudCBldmVudHNcbiAgICAgKi9cbiAgICB0b0lEU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaWRPYmouX2lkLnRvU3RyaW5nKCkgKyBcIiB0byBcIiArIHRoaXMuX3N0ci52YWwgKyBcIiBhdCBcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJpbmdFZmZlY3QgPSBTdHJpbmdFZmZlY3Q7XG4vKipcbiAqIEdldCdzIHRoZSBtb3VzZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGluIHJlbGF0aW9uIHRvIHRoZSBjYW52YXNcbiAqIEBwYXJhbSBjYW52YXMgdGhlIGNhbnZhcyBvYmplY3RcbiAqIEBwYXJhbSBldmVudCB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGdldE1vdXNlUG9zKGNhbnZhcywgZXZlbnQpIHtcbiAgICBsZXQgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0LFxuICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gcmVjdC50b3BcbiAgICB9O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0geDEgeCBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geTEgeSBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0geDIgeCBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICogQHBhcmFtIHkyIHkgY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDIsIDIpICsgTWF0aC5wb3coeTEgLSB5MiwgMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RyaW5nRWZmZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUmV0dXJuRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3R1cmFsL1JldHVybkVycm9yXCIpO1xuY29uc3Qgc3BhY2VfbGlmdF8xID0gcmVxdWlyZShcInNwYWNlLWxpZnRcIik7XG4vLyBBcHBsaWNhdGlvbiBvZiBhIGZ1bmN0aW9uLiBBc3N1bWVzIGFyZyB2YWx1ZXMgcGFzc2VkIGluIHNhbWUgb3JkZXIgYXMgRnVuRGVmIGFyZ3NcbmNsYXNzIEZ1bkFwcCB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBhIGZ1bmN0aW9uIGFwcGxpY2F0aW9uXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGFyZ3MgRnVuY3Rpb24gYXJndW1lbnRzLCBpZiBhcHBsaWNhYmxlXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uLCBpZiBhbnlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBhcmdzLCB3cywgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5fYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyB0aGUgZnVuY3Rpb24gYXBwbGljYXRpb25cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgZnVuZGVmID0gY29udGV4dC5sb29rdXAodGhpcy5fbmFtZSwgY29udGV4dCk7IC8vIGxvb2tpbmcgdXAgZnVuY3Rpb25cbiAgICAgICAgLy9sZXQgY2hpbGQgPSBuZXcgU2NvcGUoZnVuZGVmLnNjb3BlKTsgLy8gYXZvaWRpbmcgb3ZlcndyaXRlOyBuZWVkIHRvIHRvc3MgYWZ0ZXIgcmV0dXJuaW5nXG4gICAgICAgIGxldCBjaGlsZCA9IGZ1bmRlZi5zY29wZS5jb3B5KCk7IC8vIENvcHlpbmcgZGVmaW5pdGlvbiBzY29wZVxuICAgICAgICAvLyBBc3NpZ25zIGFyZyB2YWx1ZXMgdG8gZGVmaW5pdGlvbiBhcmd1bWVudHNcbiAgICAgICAgaWYgKHRoaXMuX2FyZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hcmdzLmxlbmd0aDsgaSsrKSB7IC8vbG9va3Vwcz9cbiAgICAgICAgICAgICAgICAvL2NoaWxkLmRlY2xhcmUodGhpcy5fZnVuY3QuYXJnc1tpXSk7IC8vIHJlZGVjbGFyZT9cbiAgICAgICAgICAgICAgICBjaGlsZC5hc3NpZ24oZnVuZGVmLmFyZ3NbaV0sIHRoaXMuX2FyZ3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpZCA9IGNvbnRleHQuZ2xvYmFsRnVuSUQ7IC8vIEFzc2lnbnMgYW4gSUQgdG8gdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsRnVuSUQrKztcbiAgICAgICAgY2hpbGQucmV0VmFsSUQgPSBzcGFjZV9saWZ0XzEuU29tZShpZCk7IC8vIG5ldyBtZXRob2RcbiAgICAgICAgLy8gd2Ugb25seSByZXR1cm4gYSB2YWx1ZSB3aXRoIGZ1bmN0aW9uIGFwcGxpY2F0aW9uXG4gICAgICAgIC8vIGlmIGl0IGlzIGV4cGxpY2l0bHkgcmV0dXJuZWQgdXNpbmcgYSByZXR1cm4gc3RhdGVtZW50O1xuICAgICAgICAvLyB3ZSBhYnVzZSBKUyBleGNlcHRpb25zIGZvciB0aGlzIHB1cnBvc2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNoaWxkLmhhZEZ1bkV2YWwgPSB0cnVlO1xuICAgICAgICAgICAgZnVuZGVmLmJvZHkuZXZhbChjaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB3ZSBjYXRjaCBvbmx5IHRoZSBlcnJvciBpbnRlbmRlZCBmb3IgdXNcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmV0dXJuRXJyb3JfMS5SZXR1cm5FcnJvciAmJiBwYXJzZUludChlLklEKSA9PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLnJldFZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVycm9yIHdhcyBub3QgaW50ZW5kZWQgZm9yIHVzOyByZXRocm93XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIC8vcmV0dXJuIGZ1bmRlZi5ib2R5LmV2YWwoY2hpbGQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmdW5jdGlvbiBhcHBsaWNhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgYXJnc0xpc3QgPSAnJztcbiAgICAgICAgaWYgKHRoaXMuX2FyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hcmdzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NMaXN0ICs9IHRoaXMuX2FyZ3NbaV0udG9TdHJpbmcoKSArIFwiLCBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3NMaXN0ICs9IHRoaXMuX2FyZ3NbdGhpcy5fYXJncy5sZW5ndGggLSAxXS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMubmFtZSArICcoJyArIGFyZ3NMaXN0ICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gYXBwbGljYXRpb25zIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhIGZ1bmN0aW9uIGFwcGxpY2F0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBkaXJlY3RseSBvbiBmdW5jdGlvbnNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcmd1bWVudHMgb2YgdGhlIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZ2V0IGFyZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcmdzO1xuICAgIH1cbn1cbmV4cG9ydHMuRnVuQXBwID0gRnVuQXBwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnVuQXBwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU2NvcGVfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3R1cmFsL1Njb3BlXCIpO1xuY2xhc3MgRnVuRGVmIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBib2R5LCBhcmdzLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX2JvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLl9hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvLyBCaW5kcyBhcmdzIGluIGNvbnRleHQgb2YgZGVmaW5pdGlvbjsgbm8gdmFsdWVzXG4gICAgLy8gQmluZHMgbmFtZSB0byBwYXJlbnQgY29udGV4dCAoY3VyIGNvbnRleHQgaXMgbmV3IGNvbnRleHQpXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2Z1blNjb3BlID0gbmV3IFNjb3BlXzEuU2NvcGUoY29udGV4dCk7IC8vICoqKioqKioqKioqKiogY29weT8/Pz9cbiAgICAgICAgdGhpcy5fZnVuU2NvcGUuY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgICAgIHRoaXMuX2Z1blNjb3BlLmV2ZW50TG9nID0gY29udGV4dC5ldmVudExvZztcbiAgICAgICAgdGhpcy5fZnVuU2NvcGUuZWZmZWN0cyA9IGNvbnRleHQuZWZmZWN0cztcbiAgICAgICAgLypcbiAgICAgICAgaWYodGhpcy5fYXJncyAhPSBudWxsKXtcbiAgICAgICAgICAgIGZvcihsZXQgZW50cnkgb2YgdGhpcy5fYXJncyl7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVuU2NvcGUuZGVjbGFyZShlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgY29udGV4dC5kZWNsYXJlKHRoaXMuX25hbWUpOyAvLyBhc3NpZ24gd2l0aCB2YWwgZnVuY3Rpb25cbiAgICAgICAgY29udGV4dC5hc3NpZ24odGhpcy5fbmFtZSwgdGhpcyk7IC8vIHBhcmVudCBvciBjdXJyZW50P1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgYXJnc0xpc3QgPSAnJztcbiAgICAgICAgaWYgKHRoaXMuX2FyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hcmdzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NMaXN0ICs9IHRoaXMuX2FyZ3NbaV0gKyBcIiwgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzTGlzdCArPSB0aGlzLl9hcmdzW3RoaXMuX2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJmdW4gXCIgKyB0aGlzLl9uYW1lICsgXCIoXCIgKyBhcmdzTGlzdCArICcpJyArICcge1xcbiAnICsgdGhpcy5fYm9keS50b1N0cmluZygpICsgJ30nO1xuICAgIH1cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgZGlyZWN0bHkgb24gZnVuY3Rpb25zXCIpO1xuICAgIH1cbiAgICAvLyBHZXQgbWV0aG9kc1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgZ2V0IGJvZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib2R5O1xuICAgIH1cbiAgICBnZXQgYXJncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FyZ3M7XG4gICAgfVxuICAgIGdldCBzY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Z1blNjb3BlO1xuICAgIH1cbn1cbmV4cG9ydHMuRnVuRGVmID0gRnVuRGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnVuRGVmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgTGlzdE5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhbiBhcnJheS1saWtlIGxpc3RcbiAgICAgKiBAcGFyYW0gbGlzdCBUaGUgbGlzdCwgc3RvcmVkIGluIGEgVFMgYXJyYXlcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsaXN0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xpc3QgPSBsaXN0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIGVhY2ggZWxlbWVudCBvZiB0aGUgbGlzdCBhbmQgcHVzaGVzIGl0IG9udG8gdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGV2YWxMaXN0ID0gW107XG4gICAgICAgIGZvciAobGV0IGV4cHIgb2YgdGhpcy5fbGlzdCkge1xuICAgICAgICAgICAgZXZhbExpc3QucHVzaChleHByLmV2YWwoY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGlzdE5vZGUoZXZhbExpc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsaXN0XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBsaXN0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbGlzdC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3QgKz0gdGhpcy5fbGlzdFtpXS50b1N0cmluZygpICsgXCIsIFwiO1xuICAgICAgICB9XG4gICAgICAgIGxpc3QgKz0gdGhpcy5fbGlzdFt0aGlzLl9saXN0Lmxlbmd0aCAtIDFdLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArICdbJyArIGxpc3QgKyAnXSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgbGlzdCBlcXVhbHMgYW5vdGhlciBsaXN0XG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhIExpc3ROb2RlKVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBMaXN0Tm9kZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLmxpc3RbaV0uZXF1YWxzVmFsKHJpZ2h0Lmxpc3RbaV0pKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3IGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBsaXN0XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRyYXcgYSBMaXN0Tm9kZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGlzdFxuICAgICAqL1xuICAgIGdldCBsaXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGlzdDtcbiAgICB9XG59XG5leHBvcnRzLkxpc3ROb2RlID0gTGlzdE5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaXN0Tm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ0V2ZW50XzEgPSByZXF1aXJlKFwiLi9Mb2dFdmVudFwiKTtcbmNsYXNzIENsZWFyRXZlbnQgZXh0ZW5kcyBMb2dFdmVudF8xLkxvZ0V2ZW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIENsZWFyIEV2ZW50LCB3aGljaCBsb2dzIHdoZW4gdGhlIGNhbnZhcyBpcyBjbGVhcmVkXG4gICAgICogQHBhcmFtIHRvTG9nIFdoYXQgdG8gbG9nIChzcG9pbGVyOiBub3RoaW5nKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRvTG9nKSB7XG4gICAgICAgIHN1cGVyKHRvTG9nKTtcbiAgICAgICAgdGhpcy50YWcgPSBcImNsZWFyXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhbmQgcmV0dXJucyBtZXNzYWdlIFwiQ29uc29sZSBjbGVhcmVkXCIgd2l0aCBkYXRlIGFuZCB0aW1lIGF0dGFjaGVkXG4gICAgICovXG4gICAgYXNzZW1ibGVMb2coKSB7XG4gICAgICAgIGxldCB0b1ByaW50ID0gXCJDb25zb2xlIGNsZWFyZWRcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nSXRlbSh0b1ByaW50KTtcbiAgICB9XG59XG5leHBvcnRzLkNsZWFyRXZlbnQgPSBDbGVhckV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xlYXJFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ0V2ZW50XzEgPSByZXF1aXJlKFwiLi9Mb2dFdmVudFwiKTtcbmNsYXNzIENsaWNrRXZlbnQgZXh0ZW5kcyBMb2dFdmVudF8xLkxvZ0V2ZW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBDbGljayBFdmVudCwgd2hpY2ggbG9ncyB3aGVuIGFuIG9iamVjdCBvbiB0aGUgY2FudmFzIGlzIGNsaWNrZWRcbiAgICAgKiBAcGFyYW0gdG9Mb2cgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0IHRvIGxvZ1xuICAgICAqIEBwYXJhbSB4MSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBvYmplY3QgdG8gbG9nXG4gICAgICogQHBhcmFtIHkxIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdCB0byBsb2dcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b0xvZywgeDEsIHkxKSB7XG4gICAgICAgIHN1cGVyKHRvTG9nLCB4MSwgeTEpO1xuICAgICAgICB0aGlzLnRhZyA9IFwiY2xpY2tcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGFuZCByZXR1cm5zIG1lc3NhZ2Ugb2YgZm9ybSBcIkNsaWNrZWQgb24gb2JqIGF0IHgsIHlcIiB3aXRoIGRhdGUgYW5kIHRpbWUgYXR0YWNoZWRcbiAgICAgKi9cbiAgICBhc3NlbWJsZUxvZygpIHtcbiAgICAgICAgbGV0IHRvUHJpbnQgPSBcIkNsaWNrZWQgb24gXCIgKyB0aGlzLnRvTG9nICsgXCIgYXQgXCIgKyB0aGlzLngxLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLnkxLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0l0ZW0odG9QcmludCk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGlja0V2ZW50ID0gQ2xpY2tFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNsaWNrRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMb2dFdmVudF8xID0gcmVxdWlyZShcIi4vTG9nRXZlbnRcIik7XG5jbGFzcyBEcmFnRXZlbnQgZXh0ZW5kcyBMb2dFdmVudF8xLkxvZ0V2ZW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBEcmFnIEV2ZW50LCB3aGljaCBsb2dzIHdoZW4gYW4gb2JqZWN0IG9uIHRoZSBjYW52YXMgaXMgZHJhZ2dlZFxuICAgICAqIEBwYXJhbSB0b0xvZyBUaGUgZWZmZWN0IHRvIGxvZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRvTG9nKSB7XG4gICAgICAgIHN1cGVyKHRvTG9nKTtcbiAgICAgICAgdGhpcy50YWcgPSBcImRyYWdcIjtcbiAgICAgICAgdGhpcy5fdG9QcmludCA9IHRoaXMuYXNzZW1ibGVTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGEgbG9nIHN0cmluZyB1c2luZyB0aGUgRWZmZWN0J3MgdG9EcmFnU3RyaW5nKCkgbWV0aG9kXG4gICAgICovXG4gICAgYXNzZW1ibGVTdHJpbmcoKSB7XG4gICAgICAgIHRoaXMuX3RvUHJpbnQgPSB0aGlzLnRvTG9nLnRvRHJhZ1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9QcmludDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIGFuZCByZXR1cm5zIGZpbmFsIGxvZyBtZXNzYWdlIG9mIGZvcm0gXCJEcmFnZ2VkIG9iaiBmcm9tIHgxLCB5MSB0byB4MiwgeTJcIlxuICAgICAqIHdpdGggZGF0ZSBhbmQgdGltZSBhdHRhY2hlZFxuICAgICAqL1xuICAgIGFzc2VtYmxlTG9nKCkge1xuICAgICAgICBsZXQgcHJpbnQgPSBcIkRyYWdnZWQgXCIgKyB0aGlzLl90b1ByaW50O1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dJdGVtKHByaW50KTtcbiAgICB9XG59XG5leHBvcnRzLkRyYWdFdmVudCA9IERyYWdFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURyYWdFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ0V2ZW50XzEgPSByZXF1aXJlKFwiLi9Mb2dFdmVudFwiKTtcbmNsYXNzIElERXZlbnQgZXh0ZW5kcyBMb2dFdmVudF8xLkxvZ0V2ZW50IHtcbiAgICAvKipcbiAgICAgKiBBIGNvbnN0cnVjdG9yIGZvciBhbiBJRCBldmVudCwgdXNlZCB3aGVuIGFuIG9iamVjdCBnZXRzIGFzc2lnbmVkIGFuIElEXG4gICAgICogQHBhcmFtIHRvTG9nIFRoZSBlZmZlY3QgdG8gbG9nXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9Mb2cpIHtcbiAgICAgICAgc3VwZXIodG9Mb2cpO1xuICAgICAgICB0aGlzLnRhZyA9IFwiSURcIjtcbiAgICAgICAgdGhpcy5fdG9QcmludCA9IHRoaXMuYXNzZW1ibGVTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZW1ibGVzIHN0cmluZyB1c2luZyB0aGUgZWZmZWN0J3MgdG9JRFN0cmluZygpIG1ldGhvZFxuICAgICAqL1xuICAgIGFzc2VtYmxlU3RyaW5nKCkge1xuICAgICAgICB0aGlzLl90b1ByaW50ID0gdGhpcy50b0xvZy50b0lEU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl90b1ByaW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgbWVzc2FnZSBvZiBmb3JtIFwiQXNzaWduZWQgSUQgIyB0byBvYmogYXQgeCwgeVwiIHdpdGggZGF0ZSBhbmQgdGltZSBhdHRhY2hlZFxuICAgICAqL1xuICAgIGFzc2VtYmxlTG9nKCkge1xuICAgICAgICBsZXQgcHJpbnQgPSBcIkFzc2lnbmVkIElEIFwiICsgdGhpcy5fdG9QcmludDtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nSXRlbShwcmludCk7XG4gICAgfVxufVxuZXhwb3J0cy5JREV2ZW50ID0gSURFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlERXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBMb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQWJzdHJhY3QgY2xhc3MgY29uc3RydWN0b3IgZm9yIGEgTG9nIEV2ZW50LiBSZWdpc3RlcnMgZXZlbnQgdGltZS5cbiAgICAgKiBAcGFyYW0gdG9Mb2cgVGhlIHN0cmluZywgb2JqZWN0LCBvciBhcnJheSBvZiBvYmplY3RzIHRvIGJlIGxvZ2dlZFxuICAgICAqIEBwYXJhbSB4MSBJbml0aWFsIHggcG9zaXRpb24sIGlmIGFwcGxpY2FibGVcbiAgICAgKiBAcGFyYW0geTEgSW5pdGlhbCB5IHBvc2l0aW9uLCBpZiBhcHBsaWNhYmxlXG4gICAgICogQHBhcmFtIHgyIEZpbmFsIHggcG9zaXRpb24sIGlmIGFwcGxpY2FibGVcbiAgICAgKiBAcGFyYW0geTIgRmluYWwgeSBwb3NpdGlvbiwgaWYgYXBwbGljYWJsZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRvTG9nLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICBsZXQgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLl9kYXRlID0gdG9kYXkuZ2V0RnVsbFllYXIoKSArICctJyArICh0b2RheS5nZXRNb250aCgpICsgMSkgKyAnLScgKyB0b2RheS5nZXREYXRlKCk7XG4gICAgICAgIHRoaXMuX3RpbWUgPSB0b2RheS5nZXRIb3VycygpICsgXCI6XCIgKyB0b2RheS5nZXRNaW51dGVzKCkgKyBcIjpcIiArIHRvZGF5LmdldFNlY29uZHMoKTtcbiAgICAgICAgdGhpcy5fZGF0ZVRpbWUgPSB0aGlzLl9kYXRlICsgJyAnICsgdGhpcy5fdGltZTtcbiAgICAgICAgdGhpcy5fdG9Mb2cgPSB0b0xvZztcbiAgICAgICAgLy90aGlzLl90b0xvZ0FycmF5ID0gdG9Mb2dBcnJheTtcbiAgICAgICAgdGhpcy5feDEgPSB4MTtcbiAgICAgICAgdGhpcy5feTEgPSB5MTtcbiAgICAgICAgdGhpcy5feDIgPSB4MjtcbiAgICAgICAgdGhpcy5feTIgPSB5MjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgZGF0ZSBhbmQgdGltZSB0byBsb2cgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB0b0xvZyBUaGUgbG9nIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBsb2dJdGVtKHRvTG9nKSB7XG4gICAgICAgIHJldHVybiBcIiBcIiArIHRoaXMuX2RhdGVUaW1lICsgXCI6IFwiICsgdG9Mb2c7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0ZS10aW1lIHN0cmluZ1xuICAgICAqL1xuICAgIGdldCBkYXRlVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyBvciBlZmZlY3QocykgdG8gYmUgbG9nZ2VkXG4gICAgICovXG4gICAgZ2V0IHRvTG9nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9Mb2c7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZXZlbnQgdGFnXG4gICAgICovXG4gICAgZ2V0IHRhZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0YWcgc3RyaW5nXG4gICAgICovXG4gICAgc2V0IHRhZyh0YWcpIHtcbiAgICAgICAgdGhpcy5fdGFnID0gdGFnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHgxXG4gICAgICovXG4gICAgZ2V0IHgxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgeTFcbiAgICAgKi9cbiAgICBnZXQgeTEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl95MTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB4MlxuICAgICAqL1xuICAgIGdldCB4MigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3gyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHkyXG4gICAgICovXG4gICAgZ2V0IHkyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feTI7XG4gICAgfVxufVxuZXhwb3J0cy5Mb2dFdmVudCA9IExvZ0V2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9nRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMb2dFdmVudF8xID0gcmVxdWlyZShcIi4vTG9nRXZlbnRcIik7XG5jbGFzcyBQYWludEV2ZW50IGV4dGVuZHMgTG9nRXZlbnRfMS5Mb2dFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgUGFpbnQgRXZlbnQsIHVzZWQgd2hlbiBhbiBvYmplY3QgaXMgcGFpbnRlZCBvbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHRvTG9nIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCB0byBiZSBsb2dnZWRcbiAgICAgKiBAcGFyYW0geDEgVGhlIHggcG9zaXRpb24gb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB5MSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9Mb2csIHgxLCB5MSkge1xuICAgICAgICBzdXBlcih0b0xvZywgeDEsIHkxKTtcbiAgICAgICAgdGhpcy50YWcgPSBcInBhaW50XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlcyBhbmQgcmV0dXJucyBtZXNzYWdlIG9mIGZvcm0gXCJQYWludGVkIG9iaiBhdCB4LCB5XCIgd2l0aCBkYXRlIGFuZCB0aW1lIGF0dGFjaGVkXG4gICAgICovXG4gICAgYXNzZW1ibGVMb2coKSB7XG4gICAgICAgIGxldCB0b1ByaW50ID0gXCJQYWludGVkIFwiICsgdGhpcy50b0xvZyArIFwiIGF0IFwiICsgdGhpcy54MS50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy55MS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dJdGVtKHRvUHJpbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGFpbnRFdmVudCA9IFBhaW50RXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYWludEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0xvZ0V2ZW50XCIpO1xuY2xhc3MgUmVzaXplRXZlbnQgZXh0ZW5kcyBMb2dFdmVudF8xLkxvZ0V2ZW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgUmVzaXplIEV2ZW50LCB1c2VkIHdoZW4gYW4gb2JqZWN0IG9uIHRoZSBjYW52YXMgaXMgcmVzaXplZFxuICAgICAqIEBwYXJhbSB0b0xvZyBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCB0byBiZSBsb2dnZWRcbiAgICAgKiBAcGFyYW0geDEgSW5pdGlhbCB4IGRpbWVuc2lvbiBvZiB0aGUgb2JqZWN0LCBvciBpbml0aWFsIGZvbnQgc2l6ZVxuICAgICAqIEBwYXJhbSB5MSBJbml0aWFsIHkgZGltZW5zaW9uIG9mIHRoZSBvYmplY3QsIG9yIGZpbmFsIGZvbnQgc2l6ZVxuICAgICAqIEBwYXJhbSB4MiBGaW5hbCB4IGRpbWVuc2lvbiBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHkyIEZpbmFsIHkgZGltZW5zaW9uIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b0xvZywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgc3VwZXIodG9Mb2csIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgdGhpcy50YWcgPSBcInJlc2l6ZVwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgbG9nIG1lc3NhZ2Ugb2YgZm9ybSBcIlJlc2l6ZWQgb2JqIGZyb20gc2l6ZSB4MSwgeTEgdG8gc2l6ZSB4MSwgeTJcIiBmb3IgcmVjdHMgYW5kIGVsbGlwc2VzXG4gICAgICogb3Igb2YgZm9ybSBcIlJlc2l6ZWQgb2JqIGZyb20gc2l6ZSB4MSB0byBzaXplIHkxXCIgZm9yIHN0cmluZ3NcbiAgICAgKiBIYXMgZGF0ZSBhbmQgdGltZSBhdHRhY2hlZFxuICAgICAqL1xuICAgIGFzc2VtYmxlTG9nKCkge1xuICAgICAgICBpZiAodGhpcy54MiAhPSB1bmRlZmluZWQgJiYgdGhpcy55MiAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudG9QcmludCA9IFwiUmVzaXplZCBcIiArIHRoaXMudG9Mb2cgKyBcIiBmcm9tIHNpemUgXCIgKyB0aGlzLngxLnRvU3RyaW5nKCkgKyBcIiBieSBcIiArIHRoaXMueTEudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICsgXCIgdG8gc2l6ZSBcIiArIHRoaXMueDIudG9TdHJpbmcoKSArIFwiIGJ5IFwiICsgdGhpcy55Mi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b1ByaW50ID0gXCJSZXNpemVkIFwiICsgdGhpcy50b0xvZyArIFwiIGZyb20gc2l6ZSBcIiArIHRoaXMueDEudG9TdHJpbmcoKSArIFwiIHRvIHNpemUgXCIgKyB0aGlzLnkxLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9nSXRlbSh0aGlzLnRvUHJpbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzaXplRXZlbnQgPSBSZXNpemVFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlc2l6ZUV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0xvZ0V2ZW50XCIpO1xuY2xhc3MgU2VsZWN0RXZlbnQgZXh0ZW5kcyBMb2dFdmVudF8xLkxvZ0V2ZW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBTZWxlY3Rpb24gRXZlbnQsIHVzZWQgd2hlbiBtdWx0aXBsZSBvYmplY3RzIG9uIHRoZSBjYW52YXMgYXJlIHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHRvTG9nIFRoZSBhcnJheSBvZiBvYmplY3RzIHNlbGVjdGVkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9Mb2cpIHtcbiAgICAgICAgc3VwZXIodG9Mb2cpO1xuICAgICAgICB0aGlzLnRhZyA9IFwic2VsZWN0XCI7XG4gICAgICAgIHRoaXMuX3RvUHJpbnQgPSB0aGlzLmFzc2VtYmxlU3RyaW5ncygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZXMgYW5kIHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYWxsIHRoZSBvYmplY3RzIHNlbGVjdGVkXG4gICAgICovXG4gICAgYXNzZW1ibGVTdHJpbmdzKCkge1xuICAgICAgICBsZXQgbG9nU3RyaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBlbGVtIG9mIHRoaXMudG9Mb2cpIHtcbiAgICAgICAgICAgIGxvZ1N0cmluZ3MucHVzaChlbGVtLnRvU2VsU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlNlbGVjdGVkXCIgKyBsb2dTdHJpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlIHdpdGggZGF0ZSBhbmQgdGltZSBhdHRhY2hlZFxuICAgICAqL1xuICAgIGFzc2VtYmxlTG9nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dJdGVtKHRoaXMuX3RvUHJpbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VsZWN0RXZlbnQgPSBTZWxlY3RFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlbGVjdEV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNsYXNzIEFuZCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGxvZ2ljYWwgJ2FuZCcgKCYmKSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbGVmdCBzaWRlIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIG9wZXJhdGlvbiBhbmQgcmV0dXJucyBhIGJvb2xlYW4gb2YgdGhlIHJlc3VsdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgbGhzID0gdGhpcy5fbGVmdC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBsZXQgcmhzID0gdGhpcy5fcmlnaHQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgaWYgKGxocyBpbnN0YW5jZW9mIEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUgJiYgcmhzIGluc3RhbmNlb2YgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKGxocy52YWwgJiYgcmhzLnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJndW1lbnRzIHRvIHRoZSAnYW5kJyBvcGVyYXRvciBtdXN0IGJlIGJvb2xlYW5zLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5fbGVmdC50b1N0cmluZygpICsgJyBhbmQgJyArIHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gdGhlICdhbmQnIG9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlICdhbmQnIG9wZXJhdGlvbiBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIG9wXG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByaWdodCBzaWRlIG9mIHRoZSBvcFxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbn1cbmV4cG9ydHMuQW5kID0gQW5kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QW5kLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNsYXNzIEVxdWFscyB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGVxdWFsaXR5ICg9PSkgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgc2lkZSBvZiB0aGUgZXF1YWxpdHlcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5XG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgY29tcGFyaXNvbiBhbmQgZXZhbHVhdGVzIHRvIGEgQm9vbGVhbk5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgbGhzID0gdGhpcy5fbGVmdC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBsZXQgcmhzID0gdGhpcy5fcmlnaHQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKGxocy5lcXVhbHNWYWwocmhzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVxdWFsaXR5IG9wXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArICcgZXF1YWxzICcgKyB0aGlzLl9yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW4ndCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYW4gZXF1YWxpdHkgb3BcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2VsbCB0aGlzIGlzIG1ldGFcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFsaXR5IG9wcyBjYW4ndCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbn1cbmV4cG9ydHMuRXF1YWxzID0gRXF1YWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXF1YWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgR3JlYXRlclRoYW4ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBHcmVhdGVyVGhhbiAoPikgb3BcbiAgICAgKiBAcGFyYW0gbGVmdCBMZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0IFJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBHcmVhdGVyVGhhbiBjb21wYXJpc29uIGFuZCByZXR1cm5zIEJvb2xlYW5Ob2RlIHJlcHJlc2VudGF0aW9uIG9mIHJlc3VsdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgbGhzID0gdGhpcy5fbGVmdC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBsZXQgcmhzID0gdGhpcy5fcmlnaHQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgaWYgKGxocyBpbnN0YW5jZW9mIE51bWJlck5vZGVfMS5OdW1iZXJOb2RlICYmIHJocyBpbnN0YW5jZW9mIE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gKG5ldyBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKGxocy52YWwgPiByaHMudmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJndW1lbnRzIHRvIHRoZSA+IG9wZXJhdG9yIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArIFwiID4gXCIgKyB0aGlzLl9yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIEdyZWF0ZXJUaGFuIG9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR3JlYXRlclRoYW4gb3AgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG4gICAgfVxufVxuZXhwb3J0cy5HcmVhdGVyVGhhbiA9IEdyZWF0ZXJUaGFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JlYXRlclRoYW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jbGFzcyBHcmVhdGVyVGhhbkVxIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgR3JlYXRlclRoYW5FcSAoZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvLCA+PSkgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgTGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSByaWdodCBSaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgR3JlYXRlclRoYW5FcSBvcGVyYXRpb24gYW5kIHJldHVybnMgQm9vbGVhbk5vZGUgd2l0aCByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgbGhzID0gdGhpcy5fbGVmdC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBsZXQgcmhzID0gdGhpcy5fcmlnaHQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgaWYgKGxocyBpbnN0YW5jZW9mIE51bWJlck5vZGVfMS5OdW1iZXJOb2RlICYmIHJocyBpbnN0YW5jZW9mIE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gKG5ldyBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKGxocy52YWwgPj0gcmhzLnZhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50cyB0byB0aGUgPj0gb3BlcmF0b3IgbXVzdCBiZSBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5fbGVmdC50b1N0cmluZygpICsgJyA+PSAnICsgdGhpcy5fcmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBHcmVhdGVyVGhhbkVxIG9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR3JlYXRlclRoYW5FcSBvcCBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKi9cbiAgICBkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3IG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLkdyZWF0ZXJUaGFuRXEgPSBHcmVhdGVyVGhhbkVxO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JlYXRlclRoYW5FcS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIExlc3NUaGFuIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgTGVzc1RoYW4gKDwpIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBsZWZ0IExlZnQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gcmlnaHQgUmlnaHQgc2lkZSBvZiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBMZXNzVGhhbiBjb21wYXJpc29uIGFuZCByZXR1cm5zIEJvb2xlYW5Ob2RlIHdpdGggcmVzdWx0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5fbGVmdC5ldmFsKGNvbnRleHQpICsgXCIgaXMgbGVzcyB0aGFuIFwiICsgdGhpcy5fcmlnaHQuZXZhbChjb250ZXh0KSk7XG4gICAgICAgIGxldCBsaHMgPSB0aGlzLl9sZWZ0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGxldCByaHMgPSB0aGlzLl9yaWdodC5ldmFsKGNvbnRleHQpO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUgJiYgcmhzIGluc3RhbmNlb2YgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJUaGV5J3JlIGJvdGggbnVtYmVyIG5vZGVzXCIpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhsaHMudmFsICsgXCI8XCIgKyByaHMudmFsKTtcbiAgICAgICAgICAgIC8vbGV0IGJvb2w6IGJvb2xlYW4gPSBsaHMudmFsIDwgcmhzLnZhbDtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJib29sOiBcIiArIGJvb2wpO1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMudmFsIDwgcmhzLnZhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnRzIHRvIGxlc3MgdGhhbiBtdXN0IHByb2R1Y2UgbnVtZXJpYyB2YWx1ZXMuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdC50b1N0cmluZygpICsgJyA8ICcgKyB0aGlzLl9yaWdodC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIExlc3NUaGFuIG9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVzc1RoYW4gb3AgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzVGhhbiA9IExlc3NUaGFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc1RoYW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jbGFzcyBMZXNzVGhhbkVxIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgTGVzc1RoYW5FcSAobGVzcyB0aGFuIG9yIGVxdWFsIHRvLCA8PSkgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgc2lkZSBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBMZXNzVGhhbkVxIGNvbXBhcmlzb24gYW5kIHJldHVybnMgQm9vbGVhbk5vZGUgd2l0aCByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSAmJiByaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMudmFsIDw9IHJocy52YWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudHMgdG8gdGhlIDw9IG9wZXJhdG9yIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX2xlZnQudG9TdHJpbmcoKSArIFwiIDw9IFwiICsgdGhpcy5fcmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBMZXNzVGhhbkVxIG9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVzc1RoYW5FcSBvcHMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzVGhhbkVxID0gTGVzc1RoYW5FcTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NUaGFuRXEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCb29sZWFuTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL0Jvb2xlYW5Ob2RlXCIpO1xuY2xhc3MgTm90IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIGxvZ2ljYWwgTm90ICghKSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gZXhwciBUaGUgZXhwcmVzc2lvbiB0byBiZSBvcGVyYXRlZCBvbiAobXVzdCBiZSBhIEJvb2xlYW5Ob2RlKVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGV4cHIsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZXhwciA9IGV4cHI7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgTm90IG9wZXJhdGlvbiBhbmQgcmV0dXJucyBCb29sZWFuTm9kZSB3aXRoIHJlc3VsdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICBsZXQgZSA9IHRoaXMuX2V4cHIuZXZhbChjb250ZXh0KTtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUoIWUudmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudCB0byB0aGUgISBvcGVyYXRvciBtdXN0IGJlIGJvb2xlYW4uXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyBcIm5vdCBcIiArIHRoaXMuX2V4cHIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhIE5vdCBvcFxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdCBvcGVyYXRpb25zIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZXhwcmVzc2lvbiB0byBiZSBvcGVyYXRlZCBvblxuICAgICAqL1xuICAgIGdldCBleHByKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhwcjtcbiAgICB9XG59XG5leHBvcnRzLk5vdCA9IE5vdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5vdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJvb2xlYW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvQm9vbGVhbk5vZGVcIik7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNsYXNzIE5vdEVxdWFsIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgTm90RXF1YWwgKCE9KSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGVmdCBMZWZ0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJpZ2h0IFJpZ2h0IHNpZGUgb2Ygb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBOb3RFcXVhbCBvcGVyYXRpb24gYW5kIHJldHVybnMgQm9vbGVhbk5vZGUgd2l0aCByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSAmJiByaHMgaW5zdGFuY2VvZiBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMudmFsICE9PSByaHMudmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJndW1lbnRzIHRvIHRoZSAhPSBvcGVyYXRvciBtdXN0IGJlIG51bWVyaWMuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyB0aGlzLl9sZWZ0LnRvU3RyaW5nKCkgKyBcIiBub3QgZXF1YWxzIFwiICsgdGhpcy5fcmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhIE5vdEVxdWFsIG9wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBsb2dpY2FsIG9wc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90RXF1YWwgb3BzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbn1cbmV4cG9ydHMuTm90RXF1YWwgPSBOb3RFcXVhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5vdEVxdWFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNsYXNzIE9yIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgbG9naWNhbCAnb3InICh8fCkgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGxlZnQgTGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSByaWdodCBSaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgT3Igb3BlcmF0aW9uIGFuZCByZXR1cm5zIEJvb2xlYW5Ob2RlIHdpdGggcmVzdWx0XG4gICAgICogQHBhcmFtIGNvbnRleHQgQ3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxocyA9IHRoaXMuX2xlZnQuZXZhbChjb250ZXh0KTtcbiAgICAgICAgbGV0IHJocyA9IHRoaXMuX3JpZ2h0LmV2YWwoY29udGV4dCk7XG4gICAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBCb29sZWFuTm9kZV8xLkJvb2xlYW5Ob2RlICYmIHJocyBpbnN0YW5jZW9mIEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhbk5vZGVfMS5Cb29sZWFuTm9kZShsaHMudmFsIHx8IHJocy52YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50cyB0byB0aGUgJ29yJyBvcGVyYXRvciBtdXN0IGJlIGJvb2xlYW5zLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5fbGVmdC50b1N0cmluZygpICsgJyBvciAnICsgdGhpcy5fcmlnaHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBPciBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIGxvZ2ljYWwgb3BzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPciBvcGVyYXRpb25zIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gbG9naWNhbCBvcHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGVmdCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByaWdodCBzaWRlIG9mIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgIH1cbn1cbmV4cG9ydHMuT3IgPSBPcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU2NvcGVfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3R1cmFsL1Njb3BlXCIpO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xuY2xhc3MgRm9yTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgRm9yIGxvb3BcbiAgICAgKiBAcGFyYW0gaW5pdCBJbml0aWFsaXplcyB0aGUgdmFyaWFibGUgdXNlZCBpbiB0aGUgY29uZGl0aW9uXG4gICAgICogQHBhcmFtIGNvbmQgVGhlIGNvbmRpdGlvbiAobXVzdCBldmFsdWF0ZSB0byBCb29sZWFuTm9kZSlcbiAgICAgKiBAcGFyYW0gcG9zdCBUaGUgcG9zdGV2YWx1YXRpb24gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIGJvZHkgVGhlIGJvZHkgb2YgdGhlIGxvb3BcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihpbml0LCBjb25kLCBwb3N0LCBib2R5LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faW5pdCA9IGluaXQ7XG4gICAgICAgIHRoaXMuX2NvbmQgPSBjb25kO1xuICAgICAgICB0aGlzLl9wb3N0ID0gcG9zdDtcbiAgICAgICAgdGhpcy5fYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgdGhlIEZvciBsb29wXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBjaGlsZEN0eCA9IG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQsIGNvbnRleHQuZWZmZWN0cywgY29udGV4dC5ldmVudExvZyk7XG4gICAgICAgIGNoaWxkQ3R4LmNhbnZhcyA9IHNwYWNlX2xpZnRfMS5Tb21lKGNvbnRleHQuY2FudmFzLmdldCgpKTtcbiAgICAgICAgdGhpcy5faW5pdC5ldmFsKGNoaWxkQ3R4KTsgLy8gaW5pdGlhbGl6ZSB2YXJcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMuX2NvbmQuZXZhbChjaGlsZEN0eCk7XG4gICAgICAgIGlmICghKHJlcyBpbnN0YW5jZW9mIEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29uZGl0aW9uIG11c3QgYmUgYSBib29sZWFuIGV4cHJlc3Npb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXQ7XG4gICAgICAgIHdoaWxlIChyZXMudmFsKSB7XG4gICAgICAgICAgICByZXQgPSB0aGlzLl9ib2R5LmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICAgICAgdGhpcy5fcG9zdC5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgICAgIHJlcyA9IHRoaXMuX2NvbmQuZXZhbChjaGlsZEN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gRm9yTm9kZVxuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gRm9yIGxvb3BcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvck5vZGVzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBGb3IgbG9vcFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmb3IgbG9vcFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyAnZm9yKCcgKyB0aGlzLl9pbml0LnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLl9jb25kLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLl9wb3N0LnRvU3RyaW5nKCkgKyBcIikge1xcbiBcIlxuICAgICAgICAgICAgKyB0aGlzLl9ib2R5LnRvU3RyaW5nKCkgKyBcIn1cIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuRm9yTm9kZSA9IEZvck5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gb3JOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU2NvcGVfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3R1cmFsL1Njb3BlXCIpO1xuY29uc3QgQm9vbGVhbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9Cb29sZWFuTm9kZVwiKTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xuY2xhc3MgV2hpbGVOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBXaGlsZSBsb29wXG4gICAgICogQHBhcmFtIGNvbmQgVGhlIFdoaWxlIGxvb3AgY29uZGl0aW9uXG4gICAgICogQHBhcmFtIGJvZHkgVGhlIGJvZHkgb2YgdGhlIGxvb3BcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25kLCBib2R5LCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY29uZCA9IGNvbmQ7XG4gICAgICAgIHRoaXMuX2JvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBib2R5IG9mIHRoZSBsb29wIHdoaWxlIHRoZSBjb25kaXRpb24gaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCBjaGlsZEN0eCA9IG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQsIGNvbnRleHQuZWZmZWN0cywgY29udGV4dC5ldmVudExvZyk7XG4gICAgICAgIGNoaWxkQ3R4LmNhbnZhcyA9IHNwYWNlX2xpZnRfMS5Tb21lKGNvbnRleHQuY2FudmFzLmdldCgpKTtcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMuX2NvbmQuZXZhbChjaGlsZEN0eCk7XG4gICAgICAgIGlmICghKHJlcyBpbnN0YW5jZW9mIEJvb2xlYW5Ob2RlXzEuQm9vbGVhbk5vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29uZGl0aW9uIG11c3QgYmUgYSBib29sZWFuIGV4cHJlc3Npb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXQ7XG4gICAgICAgIHdoaWxlIChyZXMudmFsKSB7XG4gICAgICAgICAgICByZXQgPSB0aGlzLl9ib2R5LmV2YWwoY2hpbGRDdHgpO1xuICAgICAgICAgICAgcmVzID0gdGhpcy5fY29uZC5ldmFsKGNoaWxkQ3R4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBXaGlsZU5vZGVzXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBXaGlsZSBsb29wXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGlsZU5vZGVzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2Fubm90IGNhbGwgZHJhdyBvbiBXaGlsZSBsb29wXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFdoaWxlIGxvb3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJ3aGlsZShcIiArIHRoaXMuX2NvbmQudG9TdHJpbmcoKSArIFwiKSB7XFxuIFwiICsgdGhpcy5fYm9keS50b1N0cmluZygpICsgXCJ9XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLldoaWxlTm9kZSA9IFdoaWxlTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdoaWxlTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhdGlvbiwgY29udGVudCwgdG9wLCBsZWZ0KSB7XG4gICAgICAgIHRoaXMuX2xvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLl90b3AgPSB0b3A7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgIH1cbn1cbmV4cG9ydHMuSW5zdHJ1Y3Rpb24gPSBJbnN0cnVjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUluc3RydWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvbkZvdXJDcE9uZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImw0YzFcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsNGMyJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBZb3UndmUgbWFkZSBpdCB0byB0aGUgRklOQUwgQ0hBTExFTkdFUyEgQ29tcGxldGUgdGhlc2UgY2hhbGxlbmdlcyB0byBlYXJuIEVURVJOQUwgR0xPUlkhIDwvcD5cbiAgICA8cD4gVGhyb3VnaG91dCB0aGlzIEhvdXIgb2YgQ29kZSwgeW91IGhhdmUgbGVhcm5lZDogPC9wPlxuICAgIDxwPiAtIEhvdyB0byBwcmludCBhIHdvcmQsIGNpcmNsZSwgcmVjdGFuZ2xlLCBhbmQgY3VydmUuIDwvcD5cbiAgICA8cD4gLSBIb3cgdG8gc3RvcmUgYW55IG9mIHRoZSB2YWx1ZSBhYm92ZSBpbiBhIHZhcmlhYmxlLiA8L3A+XG4gICAgPHA+IC0gSG93IHRvIHVzZSBpZi9lbHNlIHN0YXRlbWVudCB0byBjaGVjayBhIGNvbmRpdGlvbiBhYm91dCBhIHZhcmlhYmxlLiA8L3A+XG4gICAgPHA+IEVhY2ggb2YgdGhlIGZvbGxvd2luZyBjaGFsbGVuZ2VzIHdpbGwgdGVzdCB0aGVzZSBjb25jZXB0cy4gTGV0J3MgZGl2ZSByaWdodCBpbiEgPC9wPlxuICAgIDxwPiBQcmludCBhIGNpcmNsZSBhbmQgcHV0IGl0cyBoZWlnaHQgYW5kIHdpZHRoIGluIG9uZSBvZiB0aGUgYm94ZXMgdG8gdGhlIHNpZGUuIFRoZW4gcHJpbnQgYSByZWN0YW5nbGUgYW5kIHB1dCBpdHMgaGVpZ2h0IGFuZCB3aWR0aCBpbiB0aGUgYm94LiA8L3A+XG4gICAgPHA+IENIQUxMRU5HRTogUHJpbnQgYSBjaXJjbGUgYW5kIHJlY3RhbmdsZS4gUHV0IHRoZWlyIHJlc3BlY3RpdmUgd2lkdGggYW5kIGhlaWdodCBpbiB0aGUgYm94ZXMgcHJvdmlkZWQuIDwvcD5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiBsZWFkaW5nIGludG8gY29uZGl0aW9uYWxzXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvcHJpbnRcXHMqXFwoXFxzKmVsbGlwc2VcXHMqXFwoXFxzKlsxLTldWzAtOV0qXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqXFwpXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqLFxccypbMS05XVswLTldKlxccypcXCk7LztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Gb3VyQ3BPbmUgPSBMZXNzb25Gb3VyQ3BPbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Gb3VyQ3BPbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFbGxpcHNlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9FbGxpcHNlRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uRm91ckNwVHdvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDRjMlwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2w0YzInO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFllcyEgWW91IGdvdCB0aGlzISA8L3A+XG4gICAgPHA+IE5vdyBsZXQncyBwdXQgdGhvc2Ugc2tpbGxzIGluIGlmL2Vsc2Ugc3RhdGVtZW50cyB0byB3b3JrISA8L3A+XG4gICAgPHA+IENyZWF0ZSBhIHBhaXIgb2YgaWYvZWxzZSBzdGF0ZW1lbnRzIHRvIHByaW50IG91dCB0byB0aGUgQ0FOVkFTIGEgY2xhaW0gb2Ygd2hldGhlciB0aGUgY2lyY2xlIGlzIHBvc2l0aW9uZWQgQUJPVkUgb3IgQkVMT1cgdGhlIHJlY3RhbmdsZS4gPC9wPlxuICAgIDxwPiBDSEFMTEVOR0U6IFByaW50IGEgY2xhaW0gdGhhdCBzdGF0ZXMgd2hldGhlciBjaXJjbGUgaXMgQUJPVkUgb3IgQkVMT1cgdGhlIHJlY3RhbmdsZS4gPC9wPlxuICAgIDxwPiBISU5UOiBSZW1lbWJlciB0aGF0IHRoZSBudW1iZXJzIGluIHRoZSBwcmludCgpIHN0YXRlbWVudHMgZGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2hhcGVzIGJlaW5nIHByaW50ZWQuIDwvcD5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiBsZWFkaW5nIGludG8gY29uZGl0aW9uYWxzXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvcHJpbnRcXHMqXFwoXFxzKmVsbGlwc2VcXHMqXFwoXFxzKlsxLTldWzAtOV0qXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqXFwpXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqLFxccypbMS05XVswLTldKlxccypcXCk7LztcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Gb3VyQ3BUd28gPSBMZXNzb25Gb3VyQ3BUd287XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Gb3VyQ3BUd28uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3Nvbk9uZUNwRm91ciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwxYzRcIjtcbiAgICAgICAgdGhpcy5fcHJldk1vZHVsZSA9ICdsMWMyJztcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsMmMxJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdjYW52YXMnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IE5vdGUgdGhhdCBjaGFuZ2luZyB0aGUgZmlyc3QgbnVtYmVyIGluIHRoZSBwcmludCBzdGF0ZW1lbnQgbW92ZXMgdGhlIHdvcmRzIGxlZnQgb3IgcmlnaHQsIHdoaWxlIGNoYW5naW5nIHRoZSBzZWNvbmQgbnVtYmVyIG1vdmUgdGhlbSB1cCBvciBkb3duLiA8L3A+XG4gICAgPHA+IE5vdyB0aW1lIGZvciBhIGNoYWxsZW5nZSEgUHJpbnQgdGhlIHdvcmQgXCJtb29cIiBvbiB0aGUgQ0FOVkFTLCBhbmQgcHV0IGl0IHJpZ2h0IGluIHRoZSBjZW50ZXIgb2YgdGhlIGVudGlyZSBDQU5WQVMuIDwvcD5cbiAgICA8cD4gQ0hBTExFTkdFOiBQcmludCB0aGUgd29yZCBcIm1vb1wiIGluIHRoZSBjZW50ZXIgb2YgdGhlIENBTlZBUy4gPC9wPlxuICAgIDxwPiBISU5UOiBXcml0ZSBwcmludChcIm1vb1wiLCA1MCwgNTApIGluIHRoZSBDT0RFIGFyZWEgZmlyc3QsIHRoZW4gY2hhbmdlIHRoZSBudW1iZXJzIGluc2lkZSB0aGF0IHByaW50IHN0YXRlbWVudC4gPC9wPmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudCBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0ICYmIGVmZmVjdC5zdHIgPT09IFwibW9vXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGVmZmVjdC54ID4gMjAwICYmIGVmZmVjdC54IDwgMzAwKSAmJiAoZWZmZWN0LnkgPiAyMDAgJiYgZWZmZWN0LnkgPCAzMDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3Nvbk9uZUNwRm91ciA9IExlc3Nvbk9uZUNwRm91cjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3Nvbk9uZUNwRm91ci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEluc3RydWN0aW9uXzEgPSByZXF1aXJlKFwiLi9JbnN0cnVjdGlvblwiKTtcbmNsYXNzIExlc3Nvbk9uZUNwT25lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDFjMVwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wxYzInO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IENvbXB1dGVycyBjYW4gZG8gd29uZGVyZnVsIHRoaW5ncywgYnV0IHRoZXkgdW5mb3J0dW5hdGVseSBkb24ndCB1bmRlcnN0YW5kIEVuZ2xpc2guIDwvcD5cbiAgICA8cD4gSG93ZXZlciwgdGhleSB1bmRlcnN0YW5kIGNvbXB1dGVyIGNvZGUsIHNvIGxldCdzIGxlYXJuIGhvdyB0byB3cml0ZSBjb2RlIHRoYXQgaW5zdHJ1Y3QgdGhlIGNvbXB1dGVyIHRvIGRvIHRoaW5ncyEgPC9wPlxuICAgIDxwPiBPbiB0aGUgQ09ERSBhcmVhIGFib3ZlLCB3cml0ZSBwcmludChcIkhlbGxvXCIpIDwvcD5cbiAgICA8cD4gR09BTDogV3JpdGUgJ0hlbGxvJyBvbiB0aGUgQ0FOVkFTLiA8L3A+YDtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcyA9IFtdO1xuICAgICAgICB0aGlzLl9pbnN0ckluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCA9IDA7XG4gICAgICAgIGxldCBjb250ZW50ID0gXCJGaXJzdCwgbGV0J3MgdGVsbCB0aGUgY29tcHV0ZXIgdG8gcHJpbnQgc29tZXRoaW5nIG9uIHRoZSBDQU5WQVMuIENsaWNrIG9uIHRoZSBDT0RFIGJveC5cIjtcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjb2RlJywgY29udGVudCwgXCIzMCVcIiwgXCIxMCVcIikpO1xuICAgICAgICBjb250ZW50ID0gJ05vdyB0eXBlIGBwcmludChcIkhlbGxvXCIpYCBpbiB0aGlzIENPREUgYm94Lic7XG4gICAgICAgIHRoaXMuX2luc3RyQm94ZXMucHVzaChuZXcgSW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbignY29kZScsIGNvbnRlbnQsIFwiMzAlXCIsIFwiMTAlXCIpKTtcbiAgICAgICAgY29udGVudCA9ICdOb3RpY2UgdGhhdCB3aGF0IHlvdSB0eXBlZCBjYXVzZXMgdGhlIGNvbXB1dGVyIHRvIHByaW50IHRoZSB3b3JkIFwiSGVsbG9cIiBvbiB0aGUgQ0FOVkFTIGhlcmUuIENvbmdyYXR1bGF0aW9ucyEgWW91IGp1c3Qgd3JvdGUgeW91ciBmaXJzdCBsaW5lIG9mIGNvZGUhJztcbiAgICAgICAgdGhpcy5faW5zdHJCb3hlcy5wdXNoKG5ldyBJbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKCdjYW52YXMnLCBjb250ZW50LCBcIjY1JVwiLCBcIjEwJVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IHdyaXRlIGFueSBzdHJpbmcgb24gQ0FOVkFTXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIGxldCBpbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnB1dCcpO1xuICAgICAgICBsZXQgcmVnZXggPSAvcHJpbnRcXHMqXFwoXFxzKlxcXCJIZWxsb1xcXCJcXHMqXFwpLztcbiAgICAgICAgbGV0IG1hdGNoID0gaW5wdXQudmFsdWUubWF0Y2gocmVnZXgpO1xuICAgICAgICBpZiAobWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8qXG4gICAgICAgIGNvbnNvbGUubG9nKFwiaW5zdHJJbmRleCBpbiBjaGVja0dvYWw6IFwiICsgdGhpcy5faW5zdHJJbmRleCk7XG4gICAgICAgIHN3aXRjaCh0aGlzLl9pbnN0ckluZGV4KSB7XG5cbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gaW5wdXQgJiYgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCA9PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xhdGVzdEluc3RySW5kZXgrKztcbiAgICAgICAgICAgICAgdGhpcy5uZXh0SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBsZXQgcmVnZXg6IFJlZ0V4cCA9IC9wcmludFxccypcXChcXHMqXFxcIkhlbGxvXFxcIlxccypcXCkvO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gaW5wdXQudmFsdWUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICE9IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMCAmJiB0aGlzLl9sYXRlc3RJbnN0ckluZGV4ID09IDEpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCsrO1xuICAgICAgICAgICAgICB0aGlzLm5leHRJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAqL1xuICAgIH1cbiAgICBuZXh0SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5faW5zdHJJbmRleCA9ICh0aGlzLl9pbnN0ckluZGV4ICsgMSA8IHRoaXMuX2luc3RyQm94ZXMubGVuZ3RoKSA/IHRoaXMuX2luc3RySW5kZXggKyAxIDogdGhpcy5faW5zdHJJbmRleDtcbiAgICAgICAgdGhpcy5yZW5kZXJJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgfVxuICAgIHByZXZJbnN0cnVjdGlvbihkb2N1bWVudCkge1xuICAgICAgICB0aGlzLl9pbnN0ckluZGV4ID0gKHRoaXMuX2luc3RySW5kZXggLSAxID49IDApID8gdGhpcy5faW5zdHJJbmRleCAtIDEgOiB0aGlzLl9pbnN0ckluZGV4O1xuICAgICAgICB0aGlzLnJlbmRlckluc3RydWN0aW9uKGRvY3VtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmVuZGVyIHRoZSBjdXJyZW50IGluc3RydWN0aW9uIG9mIHRoaXMgY2hlY2twb2ludFxuICAgICAqIEBwYXJhbSBkb2N1bWVudCBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqL1xuICAgIHJlbmRlckluc3RydWN0aW9uKGRvY3VtZW50KSB7XG4gICAgICAgIGxldCBjdXJJbnN0cnVjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5zdHJ1Y3Rpb25cIik7XG4gICAgICAgIGlmIChjdXJJbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdXJJbnN0cnVjdGlvbi5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5zdHJ1Y3Rpb24gPSB0aGlzLl9pbnN0ckJveGVzW3RoaXMuX2luc3RySW5kZXhdO1xuICAgICAgICBsZXQgaW5zdHJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBpbnN0ckRpdi5jbGFzc05hbWUgPSBcImluc3RydWN0aW9uXCI7XG4gICAgICAgIGluc3RyRGl2LmlkID0gJ2luc3RydWN0aW9uJztcbiAgICAgICAgaW5zdHJEaXYuaW5uZXJUZXh0ID0gaW5zdHJ1Y3Rpb24uX2NvbnRlbnQ7XG4gICAgICAgIGluc3RyRGl2LnN0eWxlLnRvcCA9IGluc3RydWN0aW9uLl90b3A7XG4gICAgICAgIGluc3RyRGl2LnN0eWxlLmxlZnQgPSBpbnN0cnVjdGlvbi5fbGVmdDtcbiAgICAgICAgaW5zdHJEaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgbGV0IHByZXZJbnN0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIHByZXZJbnN0ci5pZCA9ICdwcmV2aW91cy1pbnN0cnVjdGlvbic7XG4gICAgICAgIHByZXZJbnN0ci5pbm5lclRleHQgPSBcIjxcIjtcbiAgICAgICAgbGV0IHRoaXNNb2R1bGUgPSB0aGlzO1xuICAgICAgICBwcmV2SW5zdHIub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW5zdHJJbmRleCBcIiArIHRoaXNNb2R1bGUuX2luc3RySW5kZXgpO1xuICAgICAgICAgICAgdGhpc01vZHVsZS5wcmV2SW5zdHJ1Y3Rpb24oZG9jdW1lbnQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5faW5zdHJJbmRleCA9PSAwKSB7XG4gICAgICAgICAgICBwcmV2SW5zdHIuc3R5bGUuYmFja2dyb3VuZCA9IFwiI0Q4RDhEOFwiO1xuICAgICAgICAgICAgcHJldkluc3RyLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0ckRpdi5hcHBlbmRDaGlsZChwcmV2SW5zdHIpO1xuICAgICAgICBsZXQgbmV4dEluc3RyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgbmV4dEluc3RyLmlkID0gJ25leHQtaW5zdHJ1Y3Rpb24nO1xuICAgICAgICBuZXh0SW5zdHIuaW5uZXJUZXh0ID0gXCI+XCI7XG4gICAgICAgIG5leHRJbnN0ci5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbnN0ckluZGV4IFwiICsgdGhpc01vZHVsZS5faW5zdHJJbmRleCk7XG4gICAgICAgICAgICB0aGlzTW9kdWxlLm5leHRJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9pbnN0ckluZGV4ID09IHRoaXMuX2luc3RyQm94ZXMubGVuZ3RoIHx8IHRoaXMuX2luc3RySW5kZXggPT0gdGhpcy5fbGF0ZXN0SW5zdHJJbmRleCkge1xuICAgICAgICAgICAgbmV4dEluc3RyLnN0eWxlLmJhY2tncm91bmQgPSBcIiNEOEQ4RDhcIjtcbiAgICAgICAgICAgIG5leHRJbnN0ci5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdHJEaXYuYXBwZW5kQ2hpbGQobmV4dEluc3RyKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaW5zdHJ1Y3Rpb24uX2xvY2F0aW9uKS5hcHBlbmRDaGlsZChpbnN0ckRpdik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3Nvbk9uZUNwT25lID0gTGVzc29uT25lQ3BPbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25PbmVDcE9uZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uT25lQ3BUaHJlZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwxYzNcIjtcbiAgICAgICAgdGhpcy5fcHJldk1vZHVsZSA9ICdsMWMyJztcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsMWM0JztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdjYW52YXMnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFllcCEgTW92aW5nIHRoZSB3b3JkcyBhY3R1YWxseSBjaGFuZ2UgdGhlIG51bWJlcnMgaW4geW91ciBDT0RFLiA8L3A+XG4gICAgPHA+IE5vdyB0aGUgQ0FOVkFTIGhhcyBiZWVuIGZyb3plbiEgVHJ5IGNoYW5naW5nIHlvdXIgQ09ERSB0byBzZWUgaWYgeW91IGNhbiBtb3ZlIHRoZSB3b3JkcyB0byB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lci4gPC9wPlxuICAgIDxwPiBHT0FMOiBNb3ZlIHRoZSB3b3JkcyB0byB0aGUgYm90dG9tIHJpZ2h0IG9mIHRoZSBDQU5WQVMuIDwvcD5cbiAgICA8cD4gSElOVDogQ2hhbmdlIG9uZSBvZiB0aGUgMiBudW1iZXJzIGF0IGEgdGltZSwgdGhlbiBjbGljayBSVU4gdG8gc2VlIGhvdyB0aGF0IGNoYW5nZXMgdGhlIENBTlZBUy5gO1xuICAgICAgICB0aGlzLnggPSAxMDtcbiAgICAgICAgdGhpcy55ID0gNDMwO1xuICAgIH1cbiAgICBkcmF3R3VpZGVzKGN0eCkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5yZWN0KHRoaXMueCwgdGhpcy55LCAxMDAsIDEwMCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguZm9udCA9IDIwICsgXCJweCBDb3VyaWVyIE5ld1wiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICBjdHguZmlsbFRleHQoXCJQdXQgdGV4dFwiLCB0aGlzLngsIDM5MCk7XG4gICAgICAgIGN0eC5maWxsVGV4dChcImluIGhlcmVcIiwgdGhpcy54LCA0MTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC54ID4gdGhpcy54ICYmIGVmZmVjdC54IDwgdGhpcy54ICsgMTAwICYmIGVmZmVjdC55ID4gdGhpcy55ICYmIGVmZmVjdC55IDwgdGhpcy55ICsgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3Nvbk9uZUNwVGhyZWUgPSBMZXNzb25PbmVDcFRocmVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uT25lQ3BUaHJlZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uT25lQ3BUd28ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMWMyXCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDFjMyc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnY29kZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gWW91IGp1c3QgdG9sZCB0aGUgY29tcHV0ZXIgdG8gd3JpdGUgd29yZHMgb24gdGhlIENBTlZBUyEgPC9wPlxuICAgIDxwPiBOb3cgbGV0J3MgZG8gc29tZXRoaW5nIG1vcmUgaW50ZXJlc3Rpbmc6IGNsaWNrIG9uIHRoZSB3b3JkcyBvbiB0aGUgQ0FOVkFTLCB0aGVuIGRyYWcgaXQgaW5zaWRlIHRoZSBib3ggYXQgdGhlIHRvcC1yaWdodCBjb3JuZXIuIE9ic2VydmUgd2hhdCBoYXBwZW5zIHRvIHlvdXIgY29kZS4gPC9wPlxuICAgIDxwPiBHT0FMOiBNb3ZlIHRoZSB3b3JkcyB5b3UganVzdCBjcmVhdGVkIGluc2lkZSB0aGUgdG9wLXJpZ2h0IGJveC4gPC9wPmA7XG4gICAgICAgIHRoaXMueCA9IDM5MDtcbiAgICAgICAgdGhpcy55ID0gMTA7XG4gICAgfVxuICAgIGRyYXdHdWlkZXMoY3R4KSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3QodGhpcy54LCB0aGlzLnksIDEwMCwgMTAwKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5mb250ID0gMjAgKyBcInB4IENvdXJpZXIgTmV3XCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgIGN0eC5maWxsVGV4dChcIlB1dCB0ZXh0XCIsIDM5MCwgMTMwKTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KFwiaW4gaGVyZVwiLCAzOTAsIDE1MCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudCBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0ICYmIGVmZmVjdC5zdHIgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LnggPiB0aGlzLnggJiYgZWZmZWN0LnggPCB0aGlzLnggKyAxMDAgJiYgZWZmZWN0LnkgPiB0aGlzLnkgJiYgZWZmZWN0LnkgPCB0aGlzLnkgKyAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uT25lQ3BUd28gPSBMZXNzb25PbmVDcFR3bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3Nvbk9uZUNwVHdvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3RyaW5nRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9TdHJpbmdFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25UaHJlZUNwRml2ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwzYzVcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsM2M2JztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBTbyB3ZSBwcmludCBhIG1lc3NhZ2UgdG8gdGhlIENBTlZBUyBhbnl0aW1lIGMgaXMgZXhhY3RseSBlcXVhbCB0byA4LiA8L3A+XG4gICAgPHA+IFdoYXQgaWYgd2Ugd2FudCB0byBwcmludCBhbm90aGVyIG1lc3NhZ2UsIFwiYyBpcyBub3QgZXF1YWwgdG8gOFwiIGFueSB0aW1lIGMgaXMgbm90IGVxdWFsIHRvIDg/IDwvcD5cbiAgICA8cD4gV2UgZG8gc28gYnkgdXNpbmcgYW4gZWxzZSBzdGF0ZW1lbnQuIE9ic2VydmUgdGhlIENPREUgYWJvdmUuIDwvcD5cbiAgICA8cD4gV2hlbiB0aGUgY29uZGl0aW9uIGluc2lkZSB0aGUgaWYoKSBzdGF0ZW1lbnQgaXMgc2F0aXNmaWVkLCB0aGUgY29kZSBibG9jayBpbnNpZGUgdGhlIHt9IHJpZ2h0IGFmdGVyIGl0IHdvdWxkIHJ1bi4gPC9wPlxuICAgIDxwPiBXaGVuIHRoYXQgY29uZGl0aW9uIGlzIG5vdCBzYXRpc2ZpZWQsIHRoZSBjb2RlIGJsb2NrIGluc2lkZSB0aGUge30gYWZ0ZXIgdGhlIGVsc2Ugc3RhdGVtZW50IHdvdWxkIHJ1bi4gPC9wPlxuICAgIDxwPiBHT0FMOiBDaGFuZ2UgdGhlIHZhbHVlIG9mIGMgc28gdGhhdCB0aGUgbGluZSBcImMgaXMgTk9UIGVxdWFsIHRvIDguXCIgaXMgcHJpbnRlZCBvbiB0aGUgQ0FOVkFTLiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgYyA9IDg7XG5pZihjID09IDgpIHtcbiAgcHJpbnQoXCJjIGlzIGVxdWFsIHRvIDguXCIsIDEwMywgMTQzKTtcbn0gZWxzZSB7XG4gIHByaW50KFwiYyBpcyBOT1QgZXF1YWwgdG8gOC5cIiwgMTAzLCAxNDMpO1xufWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIGxlYWRpbmcgaW50byBjb25kaXRpb25hbHNcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRcIikudmFsdWU7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZWdleCA9IC9jXFxzKj1cXHMqW144XVxccyovO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gY29kZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgbGV0IGNhbnZhc0lzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyID09PSBcImMgaXMgTk9UIGVxdWFsIHRvIDguXCIpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNJc0NvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVGhyZWVDcEZpdmUgPSBMZXNzb25UaHJlZUNwRml2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblRocmVlQ3BGaXZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3RyaW5nRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9TdHJpbmdFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25UaHJlZUNwRm91ciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwzYzRcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsM2M1JztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBZb3UgY2FuIHB1dCBhbiBpbmVxdWFsaXR5IGNvbmRpdGlvbiBpbiB0aGUgaWYoKSBjbGF1c2UsIHN1Y2ggYXMgXCJhIDwgNVwiIG9yIFwiYiA+IDIwXCIuIDwvcD5cbiAgICA8cD4gWW91IGNhbiBhbHNvIHVzZSBhbiBlcXVhbGl0eSBjb25kaXRpb24uIE9ic2VydmUgdGhlIENPREUgYWJvdmUgd2l0aCBcImMgPT0gOFwiLiBUaGUgMiBlcXVhbCBzaWducyBtZWFuIHRoYXQgeW91IGFyZSBjaGVja2luZyB3aGV0aGVyIGMgaXMgZXhhY3RseSBlcXVhbCB0byA4IG9yIG5vdC4gPC9wPlxuICAgIDxwPiBDaGFuZ2UgdGhlIHZhbHVlIG9mIGMgc28gdGhhdCB0aGUgbGluZSBcImMgaXMgZXF1YWwgdG8gOC5cIiBpcyBwcmludGVkIG9uIHRoZSBDQU5WQVMuIDwvcD5cbiAgICA8cD4gR09BTDogQ2hhbmdlIHRoZSB2YWx1ZSBvZiBjIHNvIHRoYXQgdGhlIGxpbmUgXCJjIGlzIGVxdWFsIHRvIDguXCIgaXMgcHJpbnRlZCBvbiB0aGUgQ0FOVkFTLiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgYyA9IDEwMDtcbmlmKGMgPT0gOCkge1xuICBwcmludChcImMgaXMgZXF1YWwgdG8gOC5cIiwgMTAzLCAxNDMpO1xufWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIGxlYWRpbmcgaW50byBjb25kaXRpb25hbHNcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ09ERVxuICAgICAgICBsZXQgY29kZUlzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRcIikudmFsdWU7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZWdleCA9IC9jXFxzKj1cXHMqOFxccyovO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gY29kZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgbGV0IGNhbnZhc0lzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyID09PSBcImMgaXMgZXF1YWwgdG8gOC5cIikge1xuICAgICAgICAgICAgICAgIGNhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25UaHJlZUNwRm91ciA9IExlc3NvblRocmVlQ3BGb3VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVGhyZWVDcEZvdXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIExlc3NvblRocmVlQ3BPbmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsM2MxXCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDNjMic7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gV2UgbGVhcm5lZCB0byB0ZWxsIHRoZSBjb21wdXRlciB0byBwcmludCBhIGxvdCBvZiB0aGluZ3MuIFVuZm9ydHVuYXRlbHksIHRoZSBjb21wdXRlciBpcyBraW5kYSBiYWQgYXQgbWF0aC4gPC9wPlxuICAgIDxwPiBMb29rIGF0IHRoZSBDT0RFIGFib3ZlLiBXZSBsZXQgYSA9IDUsIHRoZW4gd2UgcHJpbnQgdGhlIHZhbHVlIG9mIGEgdG8gdGhlIENBTlZBUy4gVGhlbiB3ZSBwcmludCB0aGUgbGluZSBcImEgaXMgbGVzcyB0aGFuIDEwXCIuIDwvcD5cbiAgICA8cD4gU2luY2UgYSA9IDUsIGFuZCA1IDwgMTAsIHdlIGtub3cgdGhhdCBhIGlzIGxlc3MgdGhhbiAxMC4gQnV0IHdoYXQgd291bGQgaGFwcGVuIGlmIHdlIGNoYW5nZSB0aGUgdmFsdWUgb2YgYSB0bywgc2F5LCAxMj8gPC9wPlxuICAgIDxwPiBHT0FMOiBjaGFuZ2UgdGhlIHZhbHVlIG9mIGEgdG8gMTIuIDwvcD5cbiAgICA8cD4gSElOVDogWW91IGNhbiBkbyB0aGlzIGJ5IGNoYW5naW5nIHRoZSBsaW5lIGEgPSA1IGluIHRoZSBDT0RFIGFyZWEsIG9yIHlvdSBjYW4gY2xpY2sgb24gdGhlIG51bWJlciA1IG9uIHRoZSBDQU5WQVMuIDwvcD5gO1xuICAgICAgICB0aGlzLl9zdGFydGVyQ29kZSA9IGBhID0gNTtcbnByaW50KGEsIDExOCwgNjMpO1xucHJpbnQoXCJhIGlzIGxlc3MgdGhhbiAxMFwiLCAxMDMsIDE0Myk7YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gbGVhZGluZyBpbnRvIGNvbmRpdGlvbmFsc1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dFwiKS52YWx1ZTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gL2FcXHMqPVxccyoxMlxccyovO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gY29kZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgbGV0IGNhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0ICYmIGVmZmVjdC5zdHIgPT09IFwiYSBpcyBsZXNzIHRoYW4gMTBcIikge1xuICAgICAgICAgICAgICAgIC8vY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvL2JyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlSXNDb3JyZWN0ICYmIGNhbnZhc0lzQ29ycmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVGhyZWVDcE9uZSA9IExlc3NvblRocmVlQ3BPbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25UaHJlZUNwT25lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVGhyZWVDcFNpeCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwzYzZcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsNGMxJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBOb3cgdGhhdCB5b3Uga25vdyBob3cgdG8gdXNlIGlmL2Vsc2Ugc3RhdGVtZW50cywgbGV0J3MgcHV0IHRoZW0gYWxsIHRvZ2V0aGVyISA8L3A+XG4gICAgPHA+IEFib3ZlIHdlIGhhdmUgdGhlIENPREUgdG8gZHJhdyAyIGNpcmNsZXM6IGNpcmNsZSBBIGhhcyBoZWlnaHQgYW5kIHdpZHRoIGEsIGFuZCBjaXJjbGUgQiBoYXMgaGVpZ2h0IGFuZCB3aWR0aCBiLiA8L3A+XG4gICAgPHA+IEhvd2V2ZXIsIGN1cnJlbnRseSB0aGUgY2xhaW0gdGhhdCBcIkNpcmNsZSBBIGlzIHNtYWxsZXIgdGhhbiBjaXJjbGUgQi5cIiByZWdhcmRsZXNzIG9mIHRoZSBjaXJjbGVzJyBhY3R1YWwgc2l6ZXMuIDwvcD5cbiAgICA8cD4gQ3JlYXRlIGFuIGlmL2Vsc2Ugc3RhdGVtZW50IHRvIHByaW50IFwiQ2lyY2xlIEEgaXMgc21hbGxlciB0aGFuIGNpcmNsZSBCLlwiIHdoZW4gaXQgaXMgYWN0dWFsbHkgc28sIGFuZCBwcmludCBcIkNpcmNsZSBBIGlzIGJpZ2dlciB0aGFuIGNpcmNsZSBCXCIgb3RoZXJ3aXNlLiA8L3A+XG4gICAgPHA+IENIQUxMRU5HRTogQ3JlYXRlIGFuIGlmL2Vsc2Ugc3RhdGVtZW50IHRvIHByaW50IHRoZSBjb3JyZWN0IGNsYWltIGFib3V0IHRoZSBzaXplcyBvZiB0aGUgMiBjaXJjbGVzLiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgYSA9IDIwMDtcbnByaW50KGEsIDExMSwgMTAzKTtcbnByaW50KGVsbGlwc2UoYSwgYSksIDEzMSwgMjYzKTtcbmIgPSAxMDA7XG5wcmludChiLCAzMzcsIDEwNCk7XG5wcmludChlbGxpcHNlKGIsIGIpLCAzNzEsIDI0OCk7XG5wcmludChcIkNpcmNsZSBBIGlzIHNtYWxsZXIgdGhhbiBjaXJjbGUgQi5cIiwgNDUsIDQ1Myk7XG5gO1xuICAgICAgICB0aGlzLnhBID0gMjA7XG4gICAgICAgIHRoaXMueUEgPSAxNTA7XG4gICAgICAgIHRoaXMueEIgPSB0aGlzLnhBICsgMjI1ICsgMTA7XG4gICAgICAgIHRoaXMueUIgPSAxNTA7XG4gICAgfVxuICAgIGRyYXdHdWlkZXMoY3R4KSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3QodGhpcy54QSwgdGhpcy55QSwgMjI1LCAyMjUpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmZvbnQgPSAyMCArIFwicHggQ291cmllciBOZXdcIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjNkM2QzZDJztcbiAgICAgICAgY3R4LmZpbGxUZXh0KFwiQ2lyY2xlIEFcIiwgdGhpcy54QSwgdGhpcy55QSAtIDIwKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucmVjdCh0aGlzLnhCLCB0aGlzLnlCLCAyMjUsIDIyNSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KFwiQ2lyY2xlIEJcIiwgdGhpcy54QiwgdGhpcy55QiAtIDIwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gbGVhZGluZyBpbnRvIGNvbmRpdGlvbmFsc1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dFwiKS52YWx1ZTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGlmKGEgPCBiKSB7XG4gICAgICAgICAgICAgIHByaW50KFwiQ2lyY2xlIEEgaXMgc21hbGxlciB0aGFuIGNpcmNsZSBCLlwiLCA0NSwgNDUzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByaW50KFwiQ2lyY2xlIEEgaXMgYmlnZ2VyIHRoYW4gY2lyY2xlIEIuXCIsIDQ1LCA0NTMpO1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICBsZXQgcmVnZXgxID0gL2lmXFxzKlxcKFxccyphXFxzKls8Pl1cXHMqYlxccypcXCkvO1xuICAgICAgICAgICAgbGV0IHJlZ2V4MiA9IC9pZlxccypcXChcXHMqYlxccypbPD5dXFxzKmFcXHMqXFwpLztcbiAgICAgICAgICAgIGxldCBtYXRjaDEgPSBjb2RlLm1hdGNoKHJlZ2V4MSk7XG4gICAgICAgICAgICBsZXQgbWF0Y2gyID0gY29kZS5tYXRjaChyZWdleDIpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IChtYXRjaDEgIT0gbnVsbCAmJiBtYXRjaDEubGVuZ3RoID4gMCkgfHwgKG1hdGNoMiAhPSBudWxsICYmIG1hdGNoMi5sZW5ndGggPiAwKTtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjYW52YXNJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNpcmNsZUEgPSBudWxsO1xuICAgICAgICBsZXQgY2lyY2xlQiA9IG51bGw7XG4gICAgICAgIC8vbG9vayBmb3IgY2lyY2xlcyBBIGFuZCBCXG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LnggPiB0aGlzLnhBICYmIGVmZmVjdC54IDwgdGhpcy54QSArIDIyNSAmJiBlZmZlY3QueSA+IHRoaXMueUEgJiYgZWZmZWN0LnkgPCB0aGlzLnlBICsgMjI1KSB7XG4gICAgICAgICAgICAgICAgICAgIGNpcmNsZUEgPSBlZmZlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC54ID4gdGhpcy54QiAmJiBlZmZlY3QueCA8IHRoaXMueEIgKyAyMjUgJiYgZWZmZWN0LnkgPiB0aGlzLnlCICYmIGVmZmVjdC55IDwgdGhpcy55QiArIDIyNSkge1xuICAgICAgICAgICAgICAgICAgICBjaXJjbGVCID0gZWZmZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2lyY2xlQSAhPSBudWxsICYmIGNpcmNsZUIgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHIgPSBlZmZlY3Quc3RyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHN0ciA9PT0gXCJDaXJjbGUgQSBpcyBzbWFsbGVyIHRoYW4gY2lyY2xlIEIuXCIgJiYgY2lyY2xlQS53IDwgY2lyY2xlQi53ICYmIGNpcmNsZUEuaCA8IGNpcmNsZUIuaClcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IChzdHIgPT09IFwiQ2lyY2xlIEEgaXMgYmlnZ2VyIHRoYW4gY2lyY2xlIEIuXCIgJiYgY2lyY2xlQS53ID4gY2lyY2xlQi53ICYmIGNpcmNsZUEuaCA+IGNpcmNsZUIuaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblRocmVlQ3BTaXggPSBMZXNzb25UaHJlZUNwU2l4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVGhyZWVDcFNpeC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVGhyZWVDcFRocmVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDNjM1wiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wzYzQnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IGlmIHN0YXRlbWVudHMgYWxsb3cgeW91IHRvIHJ1biBhIGJsb2NrIG9mIGNvZGUgaW5zaWRlIHRoZSBjdXJseSBicmFjZXMge30gT05MWSB3aGVuIHRoZSBjb25kaXRpb24gaW5zaWRlIHRoZSBpZigpIGNsYXVzZSBpcyB0cnVlLiA8L3A+XG4gICAgPHA+IExldCdzIGhhdmUgYSBxdWljayBjaGFsbGVuZ2U6IG9ic2VydmUgdGhlIENPREUgYWJvdmUuIE1ha2UgaXQgc28gdGhhdCB0aGUgbGluZSBcImIgaXMgZ3JlYXRlciB0aGFuIDIwXCIgaXMgb25seSBwcmludGVkIG9uIHRoZSBDQU5WQVMgd2hlbiBiIGlzIGFjdHVhbGx5IGdyZWF0ZXIgdGhhbiAyMC4gPC9wPlxuICAgIDxwPiBHT0FMOiBNYWtlIHRoZSBsaW5lIFwiYiBpcyBncmVhdGVyIHRoYW4gMjBcIiBvbmx5IGJlIHByaW50ZWQgb24gdGhlIENBTlZBUyB3aGVuIGIgaXMgYWN0dWFsbHkgZ3JlYXRlciB0aGFuIDIwLiBDaGFuZ2UgYiB0byB0ZXN0IHRoZSBpZigpIHN0YXRlbWVudC4gPC9wPmA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZXJDb2RlID0gYGIgPSA4O1xuaWYoYiA8IDEwKSB7XG4gIHByaW50KFwiYiBpcyBncmVhdGVyIHRoYW4gMjAuXCIsIDEwMywgMTQzKTtcbn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiBsZWFkaW5nIGludG8gY29uZGl0aW9uYWxzXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvaWZcXHMqXFwoXFxzKmJcXHMqPlxccyoyMFxccypcXCkvO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gY29kZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgbGV0IGNhbnZhc0lzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCAmJiBlZmZlY3Quc3RyID09PSBcImIgaXMgZ3JlYXRlciB0aGFuIDIwLlwiKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblRocmVlQ3BUaHJlZSA9IExlc3NvblRocmVlQ3BUaHJlZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblRocmVlQ3BUaHJlZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVGhyZWVDcFR3byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwzYzJcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsM2MzJztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBEaWQgeW91IG5vdGljZSB0aGUgY2xhaW0gdGhhdCBcImEgaXMgbGVzcyB0aGFuIDEwXCIgZGlkIG5vdCBjaGFuZ2U/IGEgaXMgbm93IDEyIGFuZCBjbGVhcmx5IGdyZWF0ZXIgdGhhbiAxMCEgPC9wPlxuICAgIDxwPiBXaGF0IHdlIHdhbnQgaXMgZm9yIHRoZSBjb21wdXRlciB0byBvbmx5IHByaW50IFwiYSBpcyBsZXNzIHRoYW4gMTBcIiBPTkxZIHdoZW4gdGhlIHZhbHVlIG9mIGEgaXMgdHJ1bHkgbGVzcyB0aGFuIDEwLiA8L3A+XG4gICAgPHA+IFRvIGRvIHNvLCB3ZSB1c2UgYW4gaWYgc3RhdGVtZW50LiBPYnNlcnZlIHRoZSBDT0RFIGFib3ZlLiBBbGwgd2UgY2hhbmdlZCB3YXMgdG8gcHV0IGluIGFuIGlmIHN0YXRlbWVudCB0aGF0IGNoZWNrcyB3aGV0aGVyIGEgPCAxMC4gSWYgYSBpcywgdGhlIGNvZGUgaW5zaWRlIHRoZSBjdXJseSBicmFjZXMge30gYXJlIGV4ZWN1dGVkLiA8L3A+XG4gICAgPHA+IENoYW5nZSB0aGUgdmFsdWUgb2YgYSB0byAxMiwgMTAsIDggYW5kIG9ic2VydmUgd2hhdCBoYXBwZW5zLiA8L3A+XG4gICAgPHA+IEdPQUw6IFJVTiB0aGUgQ09ERSB3aXRoIGEgPSAxMiBvciAxMCBvciA4LiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgYSA9IDEyO1xucHJpbnQoYSwgMTE4LCA2Myk7XG5pZihhIDwgMTApIHtcbiAgcHJpbnQoXCJhIGlzIGxlc3MgdGhhbiAxMFwiLCAxMDMsIDE0Myk7XG59YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gbGVhZGluZyBpbnRvIGNvbmRpdGlvbmFsc1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dFwiKS52YWx1ZTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gL2FcXHMqPVxccyo4XFxzKi87XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBjb2RlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgIGNvZGVJc0NvcnJlY3QgPSBtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDQU5WQVMgZWZmZWN0c1xuICAgICAgICBsZXQgY2FudmFzSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0ICYmIGVmZmVjdC5zdHIgPT09IFwiYSBpcyBsZXNzIHRoYW4gMTBcIikge1xuICAgICAgICAgICAgICAgIGNhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25UaHJlZUNwVHdvID0gTGVzc29uVGhyZWVDcFR3bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblRocmVlQ3BUd28uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFbGxpcHNlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9FbGxpcHNlRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVHdvQ3BGaXZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDJjNVwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wyYzYnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IERpZCB5b3Ugc2VlIHRoZSBDQU5WQVMgY2hhbmdlZD8gPC9wPlxuICAgIDxwPiBJbiBvdXIgY29kZSwgd2UgbWFrZSB2YXJpYWJsZSBhIHJlZmVyIHRvIHRoZSB3b3JkcyBcIm1vbyBtb29cIiwgYW5kIHZhcmlhYmxlIGIgcmVmZXIgdG8gYW4gZWxsaXBzZSgxMDAsIDEwMCkuIDwvcD5cbiAgICA8cD4gQXMgYSByZXN1bHQsIHdoZW4gd2UgdGVsbCB0aGUgY29tcHV0ZXIgdG8gcHJpbnQgYSwgaXQgd2lsbCBwcmludCBcIm1vbyBtb29cIiwgYW5kIHdoZW4gd2UgdGVsbCB0aGUgY29tcHV0ZXIgdG8gcHJpbnQgYiwgaXQgd2lsbCBwcmludCBhIGNpcmNsZS4gPC9wPlxuICAgIDxwPiBMZXQncyB0YWtlIHRoaXMgb25lIHN0ZXAgZnVydGhlcjogQ3JlYXRlIGEgbmV3IHZhcmlhYmxlIGMsIGFuZCBtYWtlIGl0IHJlZmVyIHRvIGFuIGVsbGlwc2UoMTAwLCAxMDApLiBUaGVuIHdyaXRlIDIgc3RhdGVtZW50cyB0byBwcmludCBjLiBXaGF0IGRvIHlvdSB0aGluayB3b3VsZCBoYXBwZW4/IDwvcD5cbiAgICA8cD4gR09BTDogQ3JlYXRlIGEgdmFyaWFibGUgYyByZWZlcnJpbmcgdG8gYW4gZWxsaXBzZSgxMDAsIDEwMCksIHRoZW4gd3JpdGUgMiBwcmludCBzdGF0ZW1lbnRzIHRvIHByaW50IGMuIDwvcD5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxlc3NvbiB0byBwcmludCBhIHN0cmluZ1xuICAgICAqIGdvYWxzOiBtb3ZpbmcgdGhlIHRleHQgYW5kIG9ic2VydmUgdGhlIGNvZGVcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQ6IFRoZSBIVE1MIGRvY3VtZW50XG4gICAgICogQHBhcmFtIGVmZmVjdHM6IHRoZSBsaXN0IG9mIGVmZmVjdHMgY3VycmVudGx5IG9uIHRoZSBDQU5WQVNcbiAgICAgKi9cbiAgICBjaGVja0dvYWwoZG9jdW1lbnQsIGVmZmVjdHMpIHtcbiAgICAgICAgLy9jaGVjayBmb3IgY29ycmVjdCBDT0RFXG4gICAgICAgIGxldCBjb2RlSXNDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dFwiKS52YWx1ZTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGFzc2lnbm1lbnQgPSAvY1xccyo9XFxzKmVsbGlwc2VcXHMqXFwoXFxzKlsxLTldWzAtOV0qXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqXFwpXFxzKi9nO1xuICAgICAgICAgICAgbGV0IG1hdGNoQXNzaWduID0gY29kZS5tYXRjaChhc3NpZ25tZW50KTtcbiAgICAgICAgICAgIGxldCBwcmludCA9IC9wcmludFxccypcXChcXHMqY1xccyosXFxzKlsxLTldWzAtOV0qXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqXFwpL2c7XG4gICAgICAgICAgICBsZXQgbWF0Y2hQcmludCA9IGNvZGUubWF0Y2gocHJpbnQpO1xuICAgICAgICAgICAgY29kZUlzQ29ycmVjdCA9IG1hdGNoQXNzaWduICE9IG51bGwgJiYgbWF0Y2hBc3NpZ24ubGVuZ3RoID4gMCAmJiBtYXRjaFByaW50ICE9IG51bGwgJiYgbWF0Y2hQcmludC5sZW5ndGggPj0gMjtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENBTlZBUyBlZmZlY3RzXG4gICAgICAgIGxldCBjaXJjbGVDb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBjaXJjbGVDb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlSXNDb3JyZWN0ICYmIGNpcmNsZUNvdW50ID49IDI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblR3b0NwRml2ZSA9IExlc3NvblR3b0NwRml2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblR3b0NwRml2ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEVsbGlwc2VFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VsbGlwc2VFZmZlY3RcIik7XG5jbGFzcyBMZXNzb25Ud29DcEZvdXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMmM0XCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDJjNSc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gVGhlcmUncyBubyBsaW1pdCB0byBob3cgbWFueSBwcmludCBzdGF0ZW1lbnRzIHRoZSBjb21wdXRlciBjYW4gdW5kZXJzdGFuZCwgc28geW91IGNhbiB3cml0ZSAxMDAwIHByaW50IHN0YXRlbWVudHMsIGFuZCB0aGUgY29tcHV0ZXIgd2lsbCBkcmF3IDEwMDAgdGhpbmdzIG9uIHRoZSBDQU5WQVMgZm9yIHlvdSEgPC9wPlxuICAgIDxwPiBUaW1lIHRvIHRha2UgeW91ciBjb2RpbmcgdG8gdGhlIG5leHQgbGV2ZWwuIExldCdzIGxlYXJuIGFib3V0IHZhcmlhYmxlcy4gPC9wPlxuICAgIDxwPiBWYXJpYWJsZXMgYXJlIHNpbXBseSBuYW1lcyB5b3UgZ2l2ZSB0byB0aGUgdGhpbmdzIHRoYXQgeW91IGRyYXcuIDwvcD5cbiAgICA8cD4gRm9yIGV4YW1wbGUsIHRha2UgYSBsb29rIGF0IHRoZSBjb2RlIGFib3ZlLiBDaGFuZ2UgdGhlIGEgaW4gdGhlIHByaW50IHN0YXRlbWVudCB0byBiLCBhbmQgb2JzZXJ2ZSB3aGF0IGhhcHBlbmVkIG9uIHRoZSBDQU5WQVMuIDwvcD5cbiAgICA8cD4gR09BTDogQ2hhbmdlIGEgdG8gYiBpbiB0aGUgcHJpbnQgc3RhdGVtZW50LiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgYSA9IFwibW9vIG1vb1wiO1xcbmIgPSBlbGxpcHNlKDEwMCwgMTAwKTtcXG5wcmludChhLCA1MCwgNzApO2A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvcHJpbnRcXHMqXFwoXFxzKmJcXHMqLFxccypbMS05XVswLTldKlxccyosXFxzKlsxLTldWzAtOV0qXFxzKlxcKTsvO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gY29kZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgbGV0IGNhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoIWNhbnZhc0lzQ29ycmVjdCAmJiBlZmZlY3QgaW5zdGFuY2VvZiBFbGxpcHNlRWZmZWN0XzEuRWxsaXBzZUVmZmVjdCkge1xuICAgICAgICAgICAgICAgIGNhbnZhc0lzQ29ycmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVJc0NvcnJlY3QgJiYgY2FudmFzSXNDb3JyZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Ud29DcEZvdXIgPSBMZXNzb25Ud29DcEZvdXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Ud29DcEZvdXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFbGxpcHNlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9FbGxpcHNlRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVHdvQ3BPbmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMmMxXCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDJjMic7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gUHJpbnRpbmcgb25seSB3b3JkcyBpcyBraW5kYSBib3JpbmcsIHNvIGxldCdzIGxlYXJuIHRvIHByaW50IHNvbWUgc2hhcGVzIG9uIHRoZSBDQU5WQVMhIDwvcD5cbiAgICA8cD4gSW4gdGhlIHByaW50IHN0YXRlbWVudCwgcmVwbGFjZSBcIm1vb1wiIHdpdGggZWxsaXBzZSgxMDAsMTAwKS4gSGl0IHRoZSBSVU4gYnV0dG9uIHRvIHNlZSB3aGF0IGhhcHBlbnMuIDwvcD5cbiAgICA8cD4gR09BTDogcmVwbGFjZSBcIm1vb1wiIHdpdGggZWxsaXBzZSgxMDAsMTAwKSBpbiB0aGUgcHJpbnQgc3RhdGVtZW50IGFib3ZlLiA8L3A+XG4gICAgPHA+IEhJTlQ6IEhpZ2hsaWdodCBcIm1vb1wiIC0gaW5jbHVkaW5nIHRoZSBkb3VibGUgcXVvdGVzIFwiLCBhbmQgcmVwbGFjZSB0aGF0IHdpdGggZWxsaXBzZSgxMDAsIDEwMCkuIEtFRVAgRVZFUllUSElORyBFTFNFIFRIRSBTQU1FLiA8L3A+YDtcbiAgICAgICAgdGhpcy5fc3RhcnRlckNvZGUgPSBgXG4gICAgcHJpbnQoXCJtb29cIiwgNTAsIDcwKWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICAvL2NoZWNrIGZvciBjb3JyZWN0IENPREVcbiAgICAgICAgbGV0IGNvZGVJc0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0XCIpLnZhbHVlO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvcHJpbnRcXHMqXFwoXFxzKmVsbGlwc2VcXHMqXFwoXFxzKlsxLTldWzAtOV0qXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqXFwpXFxzKixcXHMqWzEtOV1bMC05XSpcXHMqLFxccypbMS05XVswLTldKlxccypcXCkvO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gY29kZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICBjb2RlSXNDb3JyZWN0ID0gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIGNvcnJlY3QgQ0FOVkFTIGVmZmVjdHNcbiAgICAgICAgbGV0IGNhbnZhc0lzQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIEVsbGlwc2VFZmZlY3RfMS5FbGxpcHNlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgY2FudmFzSXNDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZUlzQ29ycmVjdCAmJiBjYW52YXNJc0NvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgZ2V0IGluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkxlc3NvblR3b0NwT25lID0gTGVzc29uVHdvQ3BPbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Ud29DcE9uZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlckVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvTnVtYmVyRWZmZWN0XCIpO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwU2V2ZW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJsMmM3XCI7XG4gICAgICAgIHRoaXMuX25leHRNb2R1bGUgPSAnbDNjMSc7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnQgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IGA8cD4gQ2hhbmdpbmcgb25lIGNpcmNsZSBjaGFuZ2VzIGMsIHdoaWNoIHdpbGwgdGhlbiBpbiB0dXJuIGNoYW5nZSB0aGUgb3RoZXIgY2lyY2xlISA8L3A+XG4gICAgPHA+IE5vdyBsZXQncyBwdXQgYWxsIHdlIGhhdmUgbGVhcm5lZCB0byBwcmFjdGljZS4gPC9wPlxuICAgIDxwPiBDcmVhdGUgYSBjaXJjbGUsIGFuZCBwcmludCBvdXQgdGhlIHNpemUgb2YgdGhhdCBjaXJjbGUgaW4gdGhlIGdpdmVuIGJveC4gPC9wPlxuICAgIDxwPiBJRiB3ZSBldmVyIGNoYW5nZSB0aGUgY2lyY2xlLCB3ZSB3YW50IHRoZSBudW1iZXIgaW4gdGhlIGJveCB0byBjaGFuZ2UsIHRvbyEgPC9wPlxuICAgIDxwPiBDSEFMTEVOR0U6IENyZWF0ZSBhIGNpcmNsZSBhbmQgcHJpbnQgaXRzIHNpemUgaW4gdGhlIGdpdmVuIGJveC4gPC9wPmA7XG4gICAgICAgIHRoaXMueCA9IDEwO1xuICAgICAgICB0aGlzLnkgPSA0MzA7XG4gICAgfVxuICAgIGRyYXdHdWlkZXMoY3R4KSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3QodGhpcy54LCB0aGlzLnksIDEwMCwgMTAwKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyM2QzZDNkMnO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5mb250ID0gMjAgKyBcInB4IENvdXJpZXIgTmV3XCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgIGN0eC5maWxsVGV4dChcIlB1dCBjaXJjbGUncyBzaXplXCIsIHRoaXMueCwgMzkwKTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KFwiaW4gaGVyZVwiLCB0aGlzLngsIDQxMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudDogVGhlIEhUTUwgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gZWZmZWN0czogdGhlIGxpc3Qgb2YgZWZmZWN0cyBjdXJyZW50bHkgb24gdGhlIENBTlZBU1xuICAgICAqL1xuICAgIGNoZWNrR29hbChkb2N1bWVudCwgZWZmZWN0cykge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdCBpbnN0YW5jZW9mIE51bWJlckVmZmVjdF8xLk51bWJlckVmZmVjdCAmJiBlZmZlY3QubnVtICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LnggPiB0aGlzLnggJiYgZWZmZWN0LnggPCB0aGlzLnggKyAxMDAgJiYgZWZmZWN0LnkgPiB0aGlzLnkgJiYgZWZmZWN0LnkgPCB0aGlzLnkgKyAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IGVmZmVjdC5udW07XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdDIgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVmZmVjdDIgaW5zdGFuY2VvZiBFbGxpcHNlRWZmZWN0XzEuRWxsaXBzZUVmZmVjdCAmJiAodmFsID09IGVmZmVjdDIudyB8fCB2YWwgPT0gZWZmZWN0Mi5oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVHdvQ3BTZXZlbiA9IExlc3NvblR3b0NwU2V2ZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Ud29DcFNldmVuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwU2l4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDJjNlwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wyYzcnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ2NvZGUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IE5vdyB0aGF0IHlvdSBoYXZlIGRyYXduIDIgY2lyY2xlcyBib3RoIGFyZSBjYWxsZWQgYywgbGV0J3Mgc2VlIHdoYXQgaGFwcGVucyB3aGVuIHlvdSB0cnkgdG8gbW9kaWZ5IG9uZSBvZiB0aGVtLiA8L3A+XG4gICAgPHA+IENsaWNrIG9uIG9uZSBvZiB0aGUgY2lyY2xlcyBvbiB0aGUgQ0FOVkFTLCBhbmQgdHJ5IG1ha2UgaXQgYmlnZ2VyLiBPYnNlcnZlIHdoYXQgaGFwcGVucyB0byB5b3VyIGRlY2xhcmF0aW9uIG9mIGMuIDwvcD5cbiAgICA8cD4gR09BTDogRW5sYXJnZSBvbmUgb2YgdGhlIGNpcmNsZXMgcmVmZXJyZWQgdG8gYnkgYyBvbiB0aGUgQ0FOVkFTLiA8L3A+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LncgPiAyNTAgJiYgZWZmZWN0LmggPiAyNTApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVHdvQ3BTaXggPSBMZXNzb25Ud29DcFNpeDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlc3NvblR3b0NwU2l4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNvbnN0IFN0cmluZ0VmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvU3RyaW5nRWZmZWN0XCIpO1xuY2xhc3MgTGVzc29uVHdvQ3BUaHJlZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImwyYzNcIjtcbiAgICAgICAgdGhpcy5fbmV4dE1vZHVsZSA9ICdsMmM0JztcbiAgICAgICAgdGhpcy5fY29uc3RyYWludCA9ICdub25lJztcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zID0gYDxwPiBTbyB3ZSBjYW4gZHJhdyBhIGNpcmNsZSBhbmQgY2hhbmdlIGl0LiBCdXQgd2hhdCBpZiB3ZSB3YW50IHRvIGRyYXcgYm90aCBjaXJjbGVzIGFuZCB3b3Jkcz8gPC9wPlxuICAgIDxwPiBXZWxsLCBzaW1wbGUhIEp1c3Qgd3JpdGUgbW9yZSBwcmludCBzdGF0ZW1lbnRzIGluIHRoZSBDT0RFIGFyZWEhIDwvcD5cbiAgICA8cD4gR09BTDogRHJhdyAyIGNpcmNsZXMgYW5kIGEgd29yZCBvbiB0aGUgQ0FOVkFTLiA8L3A+XG4gICAgPHA+IEhJTlQ6IFJlbWVtYmVyIHRoYXQgdGhlIG51bWJlcnMgcmlnaHQgaW5zaWRlIHRoZSBlbGxpcHNlKF8sXykgc3RhdGVtZW50IGNoYW5nZSB0aGUgY2lyY2xlJ3Mgc2l6ZXMuYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsZXNzb24gdG8gcHJpbnQgYSBzdHJpbmdcbiAgICAgKiBnb2FsczogbW92aW5nIHRoZSB0ZXh0IGFuZCBvYnNlcnZlIHRoZSBjb2RlXG4gICAgICogQHBhcmFtIGRvY3VtZW50OiBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIGxldCBzdHJpbmdFeGlzdHMgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNpcmNsZUNvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmICghc3RyaW5nRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nRXhpc3RzID0gZWZmZWN0IGluc3RhbmNlb2YgU3RyaW5nRWZmZWN0XzEuU3RyaW5nRWZmZWN0ICYmIGVmZmVjdC5zdHIgIT09IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBjaXJjbGVDb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdFeGlzdHMgJiYgY2lyY2xlQ291bnQgPj0gMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZHVsZSBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVzc29uVHdvQ3BUaHJlZSA9IExlc3NvblR3b0NwVGhyZWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZXNzb25Ud29DcFRocmVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRWxsaXBzZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvRWxsaXBzZUVmZmVjdFwiKTtcbmNsYXNzIExlc3NvblR3b0NwVHdvIHtcbiAgICAvKlxuICAgIGA8cD4gU28gd2UgY2FuIGRyYXcgYSBjaXJjbGUgYW5kIGNoYW5nZSBpdC4gQnV0IHdoYXQgaWYgd2Ugd2FudCB0byBkcmF3IGJvdGggYSBjaXJjbGUgYW5kIGEgd29yZD8gPC9wPlxuICAgIDxwPiBXZWxsLCBzaW1wbGUhIEp1c3Qgd3JpdGUgYW5vdGhlciBwcmludCBzdGF0ZW1lbnQgaW4gdGhlIENPREUgYXJlYSEgPC9wPlxuICAgIDxwPiBHT0FMOiBEcmF3IDIgY2lyY2xlcyBhbmQgYSB3b3JkIG9uIHRoZSBDQU5WQVMuIDwvcD5cbiAgICA8cD4gSElOVDogUmVtZW1iZXIgdGhhdCB0aGUgbnVtYmVycyByaWdodCBpbnNpZGUgdGhlIGVsbGlwc2UoXyxfKSBzdGF0ZW1lbnQgY2hhbmdlIHRoZSBjaXJjbGUncyBzaXplcy5gO1xuKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibDJjMlwiO1xuICAgICAgICB0aGlzLl9uZXh0TW9kdWxlID0gJ2wyYzMnO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50ID0gJ2NvZGUnO1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSBgPHA+IFdlIGNhbiB3cml0ZSBlbGxpcHNlKDEwMCwgMTAwKSBpbiB0aGUgcHJpbnQgc3RhdGVtZW50IHRvIGRyYXcgYSBjaXJjbGUgb24gdGhlIENBTlZBUy4gPC9wPlxuICAgIDxwPiBXaGF0IGFyZSB0aGUgbnVtYmVycyAoMTAwLCAxMDApIGZvcj8gSSdtIGdsYWQgeW91IGFza2VkLi4uIDwvcD5cbiAgICA8cD4gQmVjYXVzZSB0aGUgQ09ERSBhcmVhIGlzIGZyb3plbiBhZ2FpbiEgRHJhZyBvbmUgb2YgdGhlIDkgd2hpdGUgdGlwcyBhcm91bmQgdGhlIGNpcmNsZSBvbiB0aGUgQ0FOVkFTIHRvIHNlZSBob3cgdGhlIG51bWJlciBjaGFuZ2VzISA8L3A+XG4gICAgPHA+IEdPQUw6IE1ha2UgdGhlIGNpcmNsZSB3aWRlciBidXQgc2hvcnRlci4gPC9wPmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGVzc29uIHRvIHByaW50IGEgc3RyaW5nXG4gICAgICogZ29hbHM6IG1vdmluZyB0aGUgdGV4dCBhbmQgb2JzZXJ2ZSB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBkb2N1bWVudCBUaGUgSFRNTCBkb2N1bWVudFxuICAgICAqIEBwYXJhbSBlZmZlY3RzOiB0aGUgbGlzdCBvZiBlZmZlY3RzIGN1cnJlbnRseSBvbiB0aGUgQ0FOVkFTXG4gICAgICovXG4gICAgY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0IGluc3RhbmNlb2YgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LncgPiAyMDAgJiYgZWZmZWN0LmggPCA4MCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kdWxlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGdldCBpbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5MZXNzb25Ud29DcFR3byA9IExlc3NvblR3b0NwVHdvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVzc29uVHdvQ3BUd28uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBpbmRleF8xID0gcmVxdWlyZShcIi4uLy4uL2luZGV4XCIpO1xuY29uc3QgaW5kZXhfMiA9IHJlcXVpcmUoXCIuLi8uLi9pbmRleFwiKTtcbmNvbnN0IGluZGV4XzMgPSByZXF1aXJlKFwiLi4vLi4vaW5kZXhcIik7XG5jb25zdCBpbmRleF80ID0gcmVxdWlyZShcIi4uLy4uL2luZGV4XCIpO1xuY2xhc3MgTW9kdWxlR2VuZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihpc0RNKSB7XG4gICAgICAgIHRoaXMuZG1Db25zdHJ1Y3RvcnMgPSBuZXcgTWFwKFtcbiAgICAgICAgICAgIFsnbDFjMScsICgpID0+IG5ldyBpbmRleF8xLkxlc3Nvbk9uZUNwT25lKCldLFxuICAgICAgICAgICAgWydsMWMyJywgKCkgPT4gbmV3IGluZGV4XzEuTGVzc29uT25lQ3BUd28oKV0sXG4gICAgICAgICAgICBbJ2wxYzMnLCAoKSA9PiBuZXcgaW5kZXhfMS5MZXNzb25PbmVDcFRocmVlKCldLFxuICAgICAgICAgICAgWydsMWM0JywgKCkgPT4gbmV3IGluZGV4XzEuTGVzc29uT25lQ3BGb3VyKCldLFxuICAgICAgICAgICAgWydsMmMxJywgKCkgPT4gbmV3IGluZGV4XzIuTGVzc29uVHdvQ3BPbmUoKV0sXG4gICAgICAgICAgICBbJ2wyYzInLCAoKSA9PiBuZXcgaW5kZXhfMi5MZXNzb25Ud29DcFR3bygpXSxcbiAgICAgICAgICAgIFsnbDJjMycsICgpID0+IG5ldyBpbmRleF8yLkxlc3NvblR3b0NwVGhyZWUoKV0sXG4gICAgICAgICAgICBbJ2wyYzQnLCAoKSA9PiBuZXcgaW5kZXhfMi5MZXNzb25Ud29DcEZvdXIoKV0sXG4gICAgICAgICAgICBbJ2wyYzUnLCAoKSA9PiBuZXcgaW5kZXhfMi5MZXNzb25Ud29DcEZpdmUoKV0sXG4gICAgICAgICAgICBbJ2wyYzYnLCAoKSA9PiBuZXcgaW5kZXhfMi5MZXNzb25Ud29DcFNpeCgpXSxcbiAgICAgICAgICAgIFsnbDJjNycsICgpID0+IG5ldyBpbmRleF8yLkxlc3NvblR3b0NwU2V2ZW4oKV0sXG4gICAgICAgICAgICBbJ2wzYzEnLCAoKSA9PiBuZXcgaW5kZXhfMy5MZXNzb25UaHJlZUNwT25lKCldLFxuICAgICAgICAgICAgWydsM2MyJywgKCkgPT4gbmV3IGluZGV4XzMuTGVzc29uVGhyZWVDcFR3bygpXSxcbiAgICAgICAgICAgIFsnbDNjMycsICgpID0+IG5ldyBpbmRleF8zLkxlc3NvblRocmVlQ3BUaHJlZSgpXSxcbiAgICAgICAgICAgIFsnbDNjNCcsICgpID0+IG5ldyBpbmRleF8zLkxlc3NvblRocmVlQ3BGb3VyKCldLFxuICAgICAgICAgICAgWydsM2M1JywgKCkgPT4gbmV3IGluZGV4XzMuTGVzc29uVGhyZWVDcEZpdmUoKV0sXG4gICAgICAgICAgICBbJ2wzYzYnLCAoKSA9PiBuZXcgaW5kZXhfMy5MZXNzb25UaHJlZUNwU2l4KCldLFxuICAgICAgICAgICAgWydsNGMxJywgKCkgPT4gbmV3IGluZGV4XzQuTGVzc29uRm91ckNwT25lKCldLFxuICAgICAgICAgICAgWydsNGMyJywgKCkgPT4gbmV3IGluZGV4XzQuTGVzc29uRm91ckNwVHdvKCldXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLm5vbkRtQ29uc3RydWN0b3JzID0gbmV3IE1hcChbXG4gICAgICAgICAgICBbJ2wxYzEnLCAoKSA9PiBuZXcgaW5kZXhfMS5MZXNzb25PbmVDcE9uZSgpXSxcbiAgICAgICAgICAgIFsnbDFjMicsICgpID0+IG5ldyBpbmRleF8xLkxlc3Nvbk9uZUNwVGhyZWUoKV0sXG4gICAgICAgICAgICBbJ2wxYzMnLCAoKSA9PiBuZXcgaW5kZXhfMS5MZXNzb25PbmVDcEZvdXIoKV0sXG4gICAgICAgICAgICBbJ2wyYzEnLCAoKSA9PiBuZXcgaW5kZXhfMi5MZXNzb25Ud29DcE9uZSgpXSxcbiAgICAgICAgICAgIFsnbDJjMicsICgpID0+IG5ldyBpbmRleF8yLkxlc3NvblR3b0NwVGhyZWUoKV0sXG4gICAgICAgICAgICBbJ2wyYzMnLCAoKSA9PiBuZXcgaW5kZXhfMi5MZXNzb25Ud29DcEZvdXIoKV0sXG4gICAgICAgICAgICBbJ2wyYzQnLCAoKSA9PiBuZXcgaW5kZXhfMi5MZXNzb25Ud29DcEZpdmUoKV0sXG4gICAgICAgICAgICBbJ2wyYzUnLCAoKSA9PiBuZXcgaW5kZXhfMi5MZXNzb25Ud29DcFNldmVuKCldLFxuICAgICAgICAgICAgWydsM2MxJywgKCkgPT4gbmV3IGluZGV4XzMuTGVzc29uVGhyZWVDcE9uZSgpXSxcbiAgICAgICAgICAgIFsnbDNjMicsICgpID0+IG5ldyBpbmRleF8zLkxlc3NvblRocmVlQ3BUd28oKV0sXG4gICAgICAgICAgICBbJ2wzYzMnLCAoKSA9PiBuZXcgaW5kZXhfMy5MZXNzb25UaHJlZUNwVGhyZWUoKV0sXG4gICAgICAgICAgICBbJ2wzYzQnLCAoKSA9PiBuZXcgaW5kZXhfMy5MZXNzb25UaHJlZUNwRm91cigpXSxcbiAgICAgICAgICAgIFsnbDNjNScsICgpID0+IG5ldyBpbmRleF8zLkxlc3NvblRocmVlQ3BGaXZlKCldLFxuICAgICAgICAgICAgWydsM2M2JywgKCkgPT4gbmV3IGluZGV4XzMuTGVzc29uVGhyZWVDcFNpeCgpXSxcbiAgICAgICAgICAgIFsnbDRjMScsICgpID0+IG5ldyBpbmRleF80Lkxlc3NvbkZvdXJDcE9uZSgpXSxcbiAgICAgICAgICAgIFsnbDRjMicsICgpID0+IG5ldyBpbmRleF80Lkxlc3NvbkZvdXJDcFR3bygpXVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5jaGVja3BvaW50cyA9IG5ldyBNYXAoW1xuICAgICAgICAgICAgWydsMWMxJywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wxYzInLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDFjMycsIG51bGxdLFxuICAgICAgICAgICAgWydsMWM0JywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wyYzEnLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDJjMicsIG51bGxdLFxuICAgICAgICAgICAgWydsMmMzJywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wyYzQnLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDJjNScsIG51bGxdLFxuICAgICAgICAgICAgWydsMmM2JywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wyYzcnLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDNjMScsIG51bGxdLFxuICAgICAgICAgICAgWydsM2MyJywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wzYzMnLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDNjNCcsIG51bGxdLFxuICAgICAgICAgICAgWydsM2M1JywgbnVsbF0sXG4gICAgICAgICAgICBbJ2wzYzYnLCBudWxsXSxcbiAgICAgICAgICAgIFsnbDRjMScsIG51bGxdLFxuICAgICAgICAgICAgWydsNGMyJywgbnVsbF1cbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChpc0RNKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckNvbnN0cnVjdG9ycyA9IHRoaXMuZG1Db25zdHJ1Y3RvcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1ckNvbnN0cnVjdG9ycyA9IHRoaXMubm9uRG1Db25zdHJ1Y3RvcnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2VuZXJhdGVDaGVja3BvaW50KGNwKSB7XG4gICAgICAgIGxldCBjaGVja3BvaW50ID0gdGhpcy5jaGVja3BvaW50cy5nZXQoY3ApO1xuICAgICAgICBpZiAoY2hlY2twb2ludCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2twb2ludDtcbiAgICAgICAgfVxuICAgICAgICBjaGVja3BvaW50ID0gdGhpcy5jdXJDb25zdHJ1Y3RvcnMuZ2V0KGNwKSgpO1xuICAgICAgICB0aGlzLmNoZWNrcG9pbnRzLnNldChjcCwgY2hlY2twb2ludCk7XG4gICAgICAgIHJldHVybiBjaGVja3BvaW50O1xuICAgIH1cbn1cbmV4cG9ydHMuTW9kdWxlR2VuZXJhdG9yID0gTW9kdWxlR2VuZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW9kdWxlR2VuZXJhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcGFudHNfMSA9IHJlcXVpcmUoXCJwYW50c1wiKTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi4vLi4vaW5kZXhcIik7XG5jb25zdCBzcGFjZV9saWZ0XzEgPSByZXF1aXJlKFwic3BhY2UtbGlmdFwiKTtcbnZhciBQYXJzZXI7XG4oZnVuY3Rpb24gKFBhcnNlcikge1xuICAgIC8qKlxuICAgICAqIHRvIGJlIG1vdmVkIHRvIFBhbnRzXG4gICAgICogbnVtYmVyIHBhcnNlcyBudW1iZXJzIGJ5IHJlcGVhdGVkbHkgYXBwbHlpbmcgdGhlIGRpZ2l0IHBhcnNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvID0gcGFudHNfMS5QcmltaXRpdmVzLm1hbnkxKHBhbnRzXzEuUHJpbWl0aXZlcy5kaWdpdCgpKShpc3RyZWFtKTtcbiAgICAgICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGRpZ2l0IG9mIG8ucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzICs9IGRpZ2l0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBwYW50c18xLlByaW1pdGl2ZXMuU3VjY2VzcyhvLmlucHV0c3RyZWFtLCBwYXJzZUZsb2F0KHMpKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgUGFyc2VyLm51bWJlciA9IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiB0byBiZSBtb3ZlZCB0byBQYW50c1xuICAgICAqIHN0cmluZyBpcyBhbiBhcmJpdHJhcnkgc3RyaW5nIHBhcnNlciB0aGF0IHJlcGVhdGVkbHkgYXBwbGllcyB0aGUgbGV0dGVyIHByaW1pdGl2ZVxuICAgICAqIHJldHVybnMgYSBDaGFyU3RyZWFtIHJlcHJlc2VudGluZyB0aGUgZW50aXJlIHBhcnNlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpbmcoKSB7XG4gICAgICAgIGxldCBwID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMubWFueTEocGFudHNfMS5QcmltaXRpdmVzLmxldHRlcigpKSk7XG4gICAgICAgIGxldCBmID0gKHhzKSA9PiBwYW50c18xLkNoYXJVdGlsLkNoYXJTdHJlYW0uY29uY2F0KHhzKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocCkoZik7XG4gICAgfVxuICAgIFBhcnNlci5zdHJpbmcgPSBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogdG8gYmUgbW92ZWQgdG8gUGFudHNcbiAgICAgKiBwdW5jdHVhdGlvbiBwYXJzZXMgYWxsIHBvc3NpYmxlIHB1bmN0dWF0aW9uIGNoYXJhY3RlcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdW5jdHVhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zYXQoeCA9PiB4ID09IFwiIVwiXG4gICAgICAgICAgICB8fCB4ID09IFwiLlwiXG4gICAgICAgICAgICB8fCB4ID09ICcsJ1xuICAgICAgICAgICAgfHwgeCA9PSBcIjtcIlxuICAgICAgICAgICAgfHwgeCA9PSAnPydcbiAgICAgICAgICAgIHx8IHggPT0gXCItXCJcbiAgICAgICAgICAgIHx8IHggPT0gXCImXCJcbiAgICAgICAgICAgIHx8IHggPT0gJyQnXG4gICAgICAgICAgICB8fCB4ID09ICc6J1xuICAgICAgICAgICAgfHwgeCA9PSAnLydcbiAgICAgICAgICAgIHx8IHggPT0gJ3wnXG4gICAgICAgICAgICB8fCB4ID09ICclJ1xuICAgICAgICAgICAgfHwgeCA9PSAnIydcbiAgICAgICAgICAgIHx8IHggPT0gXCJAXCJcbiAgICAgICAgICAgIHx8IHggPT0gXCJ+XCJcbiAgICAgICAgICAgIHx8IHggPT0gJ2AnXG4gICAgICAgICAgICB8fCB4ID09ICcqJ1xuICAgICAgICAgICAgfHwgeCA9PSAnXidcbiAgICAgICAgICAgIHx8IHggPT0gJ3snXG4gICAgICAgICAgICB8fCB4ID09ICd9J1xuICAgICAgICAgICAgfHwgeCA9PSBcIltcIlxuICAgICAgICAgICAgfHwgeCA9PSAnXSdcbiAgICAgICAgICAgIHx8IHggPT0gJygnXG4gICAgICAgICAgICB8fCB4ID09IFwiKVwiXG4gICAgICAgICAgICB8fCB4ID09IFwiJ1wiXG4gICAgICAgICAgICB8fCB4ID09IFwiX1wiKTtcbiAgICB9XG4gICAgUGFyc2VyLnB1bmN0dWF0aW9uID0gcHVuY3R1YXRpb247XG4gICAgbGV0IGlkID0gKHgpID0+IHg7XG4gICAgLy9sZXQgZWZmZWN0czogRWZmZWN0PGFueT5bXSA9IFtdO1xuICAgIC8qKlxuICAgICAqIHBhcnNlIGlzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyB0aGUgaW5wdXQgdGV4dCBpbiBhIENoYXJTdHJlYW1cbiAgICAgKiBhbmQgcGFzc2VzIGl0IHRvIHRoZSB1cHBlci1sZXZlbCBwYXJzZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBwcm9ncmFtIGEgc3RyaW5nIHJlcHJlc2VudGluZyBwcm9ncmFtIHRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZShwcm9ncmFtKSB7XG4gICAgICAgIHByb2dyYW0gKz0gXCJcXG5cIjtcbiAgICAgICAgLy9wcmludE9mZnNldCA9IC0xO1xuICAgICAgICAvL3RoaXMuZWZmZWN0cyA9IGVmZmVjdHM7XG4gICAgICAgIGxldCBvID0gUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIobmV3IHBhbnRzXzEuQ2hhclV0aWwuQ2hhclN0cmVhbShwcm9ncmFtKSk7XG4gICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYWNlX2xpZnRfMS5Tb21lKG8ucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYWNlX2xpZnRfMS5Ob25lO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBhcnNlci5wYXJzZSA9IHBhcnNlO1xuICAgIC8qKlxuICAgICAqIEV4cHJlc3Npb24gcGFyc2VyIGZpcnN0IHNlYXJjaGVzIGZvciB0aGUgZmlyc3QgZXhwcmVzc2lvbiBvZiBhIHNlcXVlbmNlIGFuZCBlaXRoZXJcbiAgICAgKiBhbm90aGVyIGV4cHJlc3Npb24gb3IgdGhlIGVuZCBvZiB0aGUgcHJvZ3JhbSAoTk9QKSBhbmQgcmV0dXJucyBhIHNlcXVlbmNlIG5vZGVcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIGJ1ZyBvZiBlYWdlciBwYXJzaW5nXG4gICAgICovXG4gICAgUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIgPSBpID0+IHtcbiAgICAgICAgbGV0IGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuU2VxdWVuY2VOb2RlKHR1cFswXSwgdHVwWzFdKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHAgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9TZXEpKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCc7JykpKHBhbnRzXzEuUHJpbWl0aXZlcy5ubCgpKSkocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyKSkocGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoXyA9PiBuZXcgaW5kZXhfMS5OT1AoKSkpKSkoZik7XG4gICAgICAgIHJldHVybiBwKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhyb3VnaCBhbGwgcG9zc2libGUgZXhwcmVzc2lvbnMgZXhjZXB0IGZvciBzZXF1ZW5jZXNcbiAgICAgKiB1c2VkIHRvIGF2b2lkIGluZmluaXRlIGxvb3BpbmcgaW4gdXBwZXIgbGV2ZWwgcGFyc2VcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIGJ1ZyBvZiBlYWdlciBwYXJzaW5nXG4gICAgICovXG4gICAgUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSA9IGkgPT4ge1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKGxOdW1iZXIoKSkobHN0cmluZzIoKSk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UodmFyTmFtZVBhcnNlKCkpKHAxKTtcbiAgICAgICAgbGV0IHAzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShCb29sUGFyc2UoKSkocDIpO1xuICAgICAgICBsZXQgcDQgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHZhckRlY1BhcnNlKCkpKHAzKTtcbiAgICAgICAgbGV0IHA1ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIudW5PcHNFeHByKShwNCk7XG4gICAgICAgIGxldCBwNiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoRGVjbGFyZSgpKShwNSk7XG4gICAgICAgIGxldCBwNyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmJpbk9wRXhwcikocDYpO1xuICAgICAgICBsZXQgcDggPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKExvZ2ljRXhwcigpKShwNyk7XG4gICAgICAgIGxldCBwOSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLkxpc3RIZWFkKShwOCk7XG4gICAgICAgIGxldCBwMTAgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5mdW5BcHApKHA5KTtcbiAgICAgICAgbGV0IHAxMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLnJldHVyblBhcnNlcikocDEwKTtcbiAgICAgICAgbGV0IHAxMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmNvbmRQYXJzZSkocDExKTtcbiAgICAgICAgbGV0IHAxMyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLldoaWxlTG9vcCkocDEyKTtcbiAgICAgICAgbGV0IHAxNCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLkZvckxvb3ApKHAxMyk7XG4gICAgICAgIGxldCBwMTUgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5mdW5EZWYpKHAxNCk7XG4gICAgICAgIHJldHVybiBwMTUoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aHJvdWdoIGFsbCBwb3NzaWJsZSBleHByZXNzaW9ucyBleGNlcHQgZm9yIGJpbk9wIGV4cHJlc3Npb25zXG4gICAgICogdXNlZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIGluIHRoZSBiaW5hcnkgZXhwcmVzc2lvbiBwYXJzZXJcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIGJ1ZyBvZiBlYWdlciBwYXJzaW5nXG4gICAgICovXG4gICAgUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb0Jpbk9wID0gaSA9PiB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UobE51bWJlcigpKShsc3RyaW5nMigpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZSh2YXJOYW1lUGFyc2UoKSkocDEpO1xuICAgICAgICBsZXQgcDMgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKEJvb2xQYXJzZSgpKShwMik7XG4gICAgICAgIGxldCBwNCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UodmFyRGVjUGFyc2UoKSkocDMpO1xuICAgICAgICBsZXQgcDUgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci51bk9wc0V4cHIpKHA0KTtcbiAgICAgICAgbGV0IHA2ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShEZWNsYXJlKCkpKHA1KTtcbiAgICAgICAgbGV0IHA3ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuTGlzdEhlYWQpKHA2KTtcbiAgICAgICAgbGV0IHA4ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuZnVuQXBwKShwNyk7XG4gICAgICAgIGxldCBwOSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLnJldHVyblBhcnNlcikocDgpO1xuICAgICAgICBsZXQgcDEwID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuY29uZFBhcnNlKShwOSk7XG4gICAgICAgIGxldCBwMTEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5XaGlsZUxvb3ApKHAxMCk7XG4gICAgICAgIGxldCBwMTIgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5Gb3JMb29wKShwMTEpO1xuICAgICAgICBsZXQgcDEzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuZnVuRGVmKShwMTIpO1xuICAgICAgICByZXR1cm4gcDEzKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhyb3VnaCBhbGwgcG9zc2libGUgZXhwcmVzc2lvbnMgZXhjZXB0IGZvciBsb2dpY2FsIGV4cHJlc3Npb25zXG4gICAgICogdXNlZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIGluIHRoZSBsb2dpY2FsIGV4cHJlc3Npb24gcGFyc2VyXG4gICAgICogQHBhcmFtIGkgYSBub25zZW5zZSBwYXJhbWV0ZXIgdXNlZCB0byBhdm9pZCBidWcgb2YgZWFnZXIgcGFyc2luZ1xuICAgICAqL1xuICAgIFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9Mb2dpYyA9IGkgPT4ge1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKGxOdW1iZXIoKSkobHN0cmluZzIoKSk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UodmFyTmFtZVBhcnNlKCkpKHAxKTtcbiAgICAgICAgbGV0IHAzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShCb29sUGFyc2UoKSkocDIpO1xuICAgICAgICBsZXQgcDQgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHZhckRlY1BhcnNlKCkpKHAzKTtcbiAgICAgICAgbGV0IHA1ID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIudW5PcHNFeHByKShwNCk7XG4gICAgICAgIGxldCBwNiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoRGVjbGFyZSgpKShwNSk7XG4gICAgICAgIGxldCBwNyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmJpbk9wRXhwcikocDYpO1xuICAgICAgICBsZXQgcDggPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5MaXN0SGVhZCkocDcpO1xuICAgICAgICBsZXQgcDkgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5mdW5BcHApKHA4KTtcbiAgICAgICAgbGV0IHAxMCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLnJldHVyblBhcnNlcikocDkpO1xuICAgICAgICBsZXQgcDExID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuY29uZFBhcnNlKShwMTApO1xuICAgICAgICBsZXQgcDEyID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuV2hpbGVMb29wKShwMTEpO1xuICAgICAgICBsZXQgcDEzID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShQYXJzZXIuRm9yTG9vcCkocDEyKTtcbiAgICAgICAgbGV0IHAxNCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UoUGFyc2VyLmZ1bkRlZikocDEzKTtcbiAgICAgICAgcmV0dXJuIHAxNChpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGxOdW1iZXIgaXMgdXNlZCB0byB3cmFwIHBhcnNlZCBudW1iZXJzIGluIE51bWJlck5vZGVzIGZvciB0aGUgQVNUXG4gICAgICovXG4gICAgZnVuY3Rpb24gbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgbyA9IG51bWJlcigpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGFudHNfMS5QcmltaXRpdmVzLlN1Y2Nlc3Moby5pbnB1dHN0cmVhbSwgbmV3IGluZGV4XzEuTnVtYmVyTm9kZShvLnJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQYXJzZXIubE51bWJlciA9IGxOdW1iZXI7XG4gICAgLyoqXG4gICAgICogYmluT3BzQ2hhciBwYXJzZXMgYWxsIHBvc3NpYmxlIGJpbmFyeSBvcGVyYXRvcnMsIHN1Y2ggYXMgKyBvciAtXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluT3BzQ2hhcigpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuc2F0KHggPT4geCA9PSBcIitcIlxuICAgICAgICAgICAgICAgIHx8IHggPT0gXCItXCJcbiAgICAgICAgICAgICAgICB8fCB4ID09IFwiL1wiXG4gICAgICAgICAgICAgICAgfHwgeCA9PSBcIj1cIlxuICAgICAgICAgICAgICAgIHx8IHggPT0gXCIqXCIpKShpc3RyZWFtKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUGFyc2VyLmJpbk9wc0NoYXIgPSBiaW5PcHNDaGFyO1xuICAgIC8qKlxuICAgICAqIGJpbk9wc1Nob3J0IHJldHVybnMgYSB0dXBsZSB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgYmluYXJ5IG9wZXJhdG9yIChDaGFyU3RyZWFtKVxuICAgICAqIGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgdGhlIGV4cHJlc3Npb24gdG8gdGhlIHJpZ2h0IG9mIHRoZSBvcGVyYXRvciAoRXhwcmVzc2lvbjx7fT4pXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluT3BTaG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEoYmluT3BzQ2hhcigpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKSgoeCkgPT4geCk7XG4gICAgfVxuICAgIFBhcnNlci5iaW5PcFNob3J0ID0gYmluT3BTaG9ydDtcbiAgICAvKipcbiAgICAgKiBiaW5PcEV4cHIgcGFyc2VzIGFsbCBwb3NzaWJsZSBiaW5hcnkgb3BlcmF0aW9uIGV4cHJlc3Npb25zIGFuZCByZXR1cm5zIHRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgQVNUIG5vZGUgY29uc3RydWN0IChhbHNvIHBhcnNlcyBwb3N0Zml4IGluY3JlbWVudHMvZGVjcmVtZW50cyBsaWtlIGkrKylcbiAgICAgKiBAcGFyYW0gaSBhIG5vbnNlbnNlIHBhcmFtZXRlciB1c2VkIHRvIGF2b2lkIHRoZSBidWcgd2l0aCBlYWdlciBldmFsdWF0aW9uXG4gICAgICovXG4gICAgUGFyc2VyLmJpbk9wRXhwciA9IGkgPT4ge1xuICAgICAgICB2YXIgZiA9ICh0dXApID0+IHtcbiAgICAgICAgICAgIGxldCBsaHMgPSB0dXBbMF07XG4gICAgICAgICAgICBsZXQgb3AgPSB0dXBbMV1bMF07XG4gICAgICAgICAgICBsZXQgcmhzID0gdHVwWzFdWzFdO1xuICAgICAgICAgICAgc3dpdGNoIChvcC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLlBsdXNPcChsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5NaW51c09wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkRpdk9wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLk11bE9wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkFzc2lnbk9wKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmluYXJ5IE9wZXJhdGlvbiBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9CaW5PcCkodmFyRGVjUGFyc2UoKSk7XG4gICAgICAgIGxldCBwMiA9IGJpbk9wU2hvcnQoKTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwb3N0UGx1cyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vQmluT3ApKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCcrKycpKSh0dXAgPT4geyByZXR1cm4gbmV3IGluZGV4XzEuSW5jcmVtZW50KHR1cFswXSwgd3MpOyB9KTtcbiAgICAgICAgbGV0IHBvc3RNaW51cyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vQmluT3ApKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCctLScpKSh0dXAgPT4geyByZXR1cm4gbmV3IGluZGV4XzEuRGVjcmVtZW50KHR1cFswXSwgd3MpOyB9KTtcbiAgICAgICAgbGV0IGJpbk9wID0gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHAxKSkocDIpKGYpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShiaW5PcCkocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwb3N0UGx1cykocG9zdE1pbnVzKSkoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB1bk9wc0NoYXIgcGFyc2VzIGFsbCBwb3NzaWJsZSB1bmFyeSBvcGVyYXRvcnNcbiAgICAgKiBPbmx5IG5lZ2F0aW9ucyBhcmUgc3VwcG9ydGVkLCBidXQgbW9yZSBjYW4gYmUgYWRkZWQgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIGkgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIudW5PcHNDaGFyID0gaSA9PiB7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKFwiLVwiKSkoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB1bk9wc0V4cHIgd3JhcHMgYSB1bmFyeSBvcGVyYXRpb24gZXhwcmVzc2lvbiBpbiB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIEFTVCBub2RlIGFuZCByZXR1cm5zIGl0XG4gICAgICogQHBhcmFtIGkgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIudW5PcHNFeHByID0gaSA9PiB7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLk5lZ09wKHR1cFsxXSwgd3MpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgd3MgPSBcIlwiO1xuICAgICAgICBsZXQgcHJlY2VkaW5nV1MgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKSh4ID0+IHdzID0geC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShQYXJzZXIudW5PcHNDaGFyKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSkoZikoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBsc3RyaW5nIHBhcnNlcyB2YWxpZCBzdHJpbmdzIGluIHRoZSBTV0VMTCBsYW5ndWFnZVxuICAgICAqIGEgdmFsaWQgc3RyaW5nIGlzIHN1cnJvdW5kZWQgYnkgcXVvdGF0aW9ucyBhbmQgY29uc2lzdHMgb2YgbGV0dGVycywgbnVtYmVycywgcHVuY3R1YXRpb24sIGFuZC9vciB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbHN0cmluZygpIHtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHBhbnRzXzEuUHJpbWl0aXZlcy5sZXR0ZXIoKSkocGFudHNfMS5QcmltaXRpdmVzLndzMSgpKSkocGFudHNfMS5QcmltaXRpdmVzLmRpZ2l0KCkpO1xuICAgICAgICAvL2xldCBwMSA9IFByaW1pdGl2ZXMuY2hvaWNlKFByaW1pdGl2ZXMubGV0dGVyKCkpKFByaW1pdGl2ZXMud3MxKCkpO1xuICAgICAgICBsZXQgcCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoXCJcXFwiXCIpKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKFwiXFxcIlwiKSkocGFudHNfMS5QcmltaXRpdmVzLm1hbnkocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMSkocHVuY3R1YXRpb24oKSkpKTtcbiAgICAgICAgbGV0IGYgPSAoeHMpID0+IHBhbnRzXzEuQ2hhclV0aWwuQ2hhclN0cmVhbS5jb25jYXQoeHMpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwKShmKTtcbiAgICB9XG4gICAgUGFyc2VyLmxzdHJpbmcgPSBsc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIGxzdHJpbmcyIHdyYXBzIHN0cmluZ3MgcGFyc2VkIGJ5IGxzdHJpbmcgaW4gU3RyaW5Ob2RlIG9iamVjdHMgYW5kIHJldHVybnMgdGhlbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxzdHJpbmcyKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgICAgICBsZXQgcHJlY2VkaW5nV1MgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKSh4ID0+IHdzID0geC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGxldCBvID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShsc3RyaW5nKCkpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGFudHNfMS5QcmltaXRpdmVzLlN1Y2Nlc3Moby5pbnB1dHN0cmVhbSwgbmV3IGluZGV4XzEuU3RyaW5nTm9kZShvLnJlc3VsdC50b1N0cmluZygpLCB3cykpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQYXJzZXIubHN0cmluZzIgPSBsc3RyaW5nMjtcbiAgICAvKipcbiAgICAgKiB2YXJOYW1lUGFyc2UgcGFyc2VzIHZhbGlkIHZhcmlhYmxlIG5hbWVzXG4gICAgICogdmFyaWFibGUgbmFtZXMgaW4gU1dFTEwgYmVnaW4gd2l0aCBhIGxvd2VyY2FzZSBjaGFyIGFuZCBhcmUgZm9sbG93ZWRcbiAgICAgKiBieSBsZXR0ZXJzIG9yIGRpZ2l0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhck5hbWVQYXJzZSgpIHtcbiAgICAgICAgdmFyIGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuVmFyaWFibGVOb2RlKHR1cFswXS50b1N0cmluZygpICsgcGFudHNfMS5DaGFyVXRpbC5DaGFyU3RyZWFtLmNvbmNhdCh0dXBbMV0pLnRvU3RyaW5nKCksIHdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBmaXJzdENoYXIgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5sb3dlcigpKTtcbiAgICAgICAgbGV0IG5leHRDaGFycyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55KHBhbnRzXzEuUHJpbWl0aXZlcy5jaG9pY2UocGFudHNfMS5QcmltaXRpdmVzLmRpZ2l0KCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5sZXR0ZXIoKSkpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShmaXJzdENoYXIpKG5leHRDaGFycykoZik7XG4gICAgfVxuICAgIFBhcnNlci52YXJOYW1lUGFyc2UgPSB2YXJOYW1lUGFyc2U7XG4gICAgLyoqXG4gICAgICogdmFyRGVjUGFyc2UgcGFyc2VzIHZhbGlkIHZhcmlhYmxlIGRlY2xhcmF0aW9ucyBpbiB0aGUgZm9ybSBcInZhciB4XCJcbiAgICAgKiB0aGUgcGFyc2VyIHRoZW4gd3JhcHMgdGhlIHBhcnNlZCB2YWx1ZSBpbiBhIHZhcmlhYmxlIG5vZGUgZm9yIHRoZSBBU1RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YXJEZWNQYXJzZSgpIHtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cihcInZhclwiKSk7XG4gICAgICAgIGxldCB2YXJOYW1lID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzMSgpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkodmFyTmFtZVBhcnNlKCkpO1xuICAgICAgICBsZXQgcCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocDEpKHZhck5hbWUpKHR1cCA9PiB0dXBbMV0pO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgUGFyc2VyLnZhckRlY1BhcnNlID0gdmFyRGVjUGFyc2U7XG4gICAgLyoqXG4gICAgICogRGVjbGFyZSBwYXJzZXMgdmFyaWFibGUgZGVjbGFyYXRpb25zIGluIHRoZSBmb3JtIFwidmFyIHggPSAyXCJcbiAgICAgKiBhbmQgcmV0dXJucyBhIERlY2xhcmVPcCBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjbGFyZSgpIHtcbiAgICAgICAgbGV0IGVxID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignPScpKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLmxlZnQodmFyRGVjUGFyc2UoKSkoZXEpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwMSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSkodHVwID0+IHsgcmV0dXJuIG5ldyBpbmRleF8xLkRlY2xhcmVPcCh0dXBbMF0sIHR1cFsxXSk7IH0pO1xuICAgIH1cbiAgICBQYXJzZXIuRGVjbGFyZSA9IERlY2xhcmU7XG4gICAgLyoqXG4gICAgICogTGlzdEhlYWQgcGFyc2VzIGFsbCBsaXN0cyBpbiB0aGUgU1dFTEwgbGFuZ3VhZ2UsIGluY2x1ZGluZyBlbXB0eSBsaXN0c1xuICAgICAqIExpc3RzIGFyZSBzdXJyb3VuZGVkIGJ5IHNxdWFyZSBicmFja2V0cyBhbmQgZWFjaCBlbGVtZW50IGlzIHNlcGFyYXRlZCBieSBhIGNvbW1hXG4gICAgICogcmV0dXJucyBhIGxpc3ROb2RlIG9iamVjdFxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIuTGlzdEhlYWQgPSBpID0+IHtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwMCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCdbJykpKShwMCk7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgbGV0IGhkID0gdHVwWzBdO1xuICAgICAgICAgICAgbGV0IHJlcyA9IFtoZF07XG4gICAgICAgICAgICBsZXQgdGFpbCA9IHR1cFsxXTtcbiAgICAgICAgICAgIGZvciAobGV0IGVsZW0gb2YgdGFpbCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkxpc3ROb2RlKHJlcywgd3MpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHAxKShMaXN0VGFpbCgpKShmKTtcbiAgICAgICAgbGV0IHAzID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ1tdJykpKShfID0+IG5ldyBpbmRleF8xLkxpc3ROb2RlKFtdLCB3cykpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMykocDIpKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTGlzdCBUYWlsIHBhcnNlcyBzZWNvbmQgdGhyb3VnaCBsYXN0IGVsZW1lbnRzIG9mIGEgbGlzdCwgZWFjaCBzZXBhcmF0ZWQgYnkgYSBjb21tYVxuICAgICAqIHJldHVybnMgYW4gYXJyYXkgb2YgRXhwcmVzc2lvbnMgdGhhdCB3aWxsIGJlIGFjY2Vzc2VkIGJ5IExpc3RIZWFkXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGlzdFRhaWwoKSB7XG4gICAgICAgIGxldCBwMCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMuY2hhcignLCcpKShwMCk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5sZWZ0KHBhbnRzXzEuUHJpbWl0aXZlcy5tYW55KHAxKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ10nKSk7XG4gICAgICAgIHJldHVybiBwMjtcbiAgICB9XG4gICAgUGFyc2VyLkxpc3RUYWlsID0gTGlzdFRhaWw7XG4gICAgLyoqXG4gICAgICogZnVuRGVmQXJnTGlzdCBwYXJzZXMgYXJndW1lbnQgbGlzdHMgZm9yIGZ1bmN0aW9uIGRlZmluaXRpb25zLFxuICAgICAqIHN1cnJvdW5kZWQgYnkgcGFyZW5zIGFuZCBzZXBhcmF0ZWQgYnkgY29tbWFzXG4gICAgICogcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bkRlZkFyZ0xpc3QoKSB7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKCcpKShzdHJpbmcoKSk7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgbGV0IGhkID0gdHVwWzBdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgcmVzID0gW2hkXTtcbiAgICAgICAgICAgIGxldCB0YWlsID0gdHVwWzFdO1xuICAgICAgICAgICAgZm9yIChsZXQgZWxlbSBvZiB0YWlsKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goZWxlbS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocDEpKGZ1bkRlZkFyZ0xpc3RUYWlsKCkpKGYpO1xuICAgICAgICBsZXQgcDMgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJygpJykpKF8gPT4gW10pO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMykocDIpO1xuICAgIH1cbiAgICBQYXJzZXIuZnVuRGVmQXJnTGlzdCA9IGZ1bkRlZkFyZ0xpc3Q7XG4gICAgLyoqXG4gICAgICogZnVuRGVmQXJnTGlzdFRhaWwgcGFyc2VzIHRoZSBzZWNvbmQgdGhyb3VnaCBsYXN0IGVsZW1lbnRzIG9mIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBwYXJhbWV0ZXIgbGlzdFxuICAgICAqIHBhcmFtZXRlcnMgYXJlIHNlcGFyYXRlZCBieSBjb21tYXMgYW5kIGVuZCB3aXRoIGEgY2xvc2luZyBwYXJlbnNcbiAgICAgKiByZXR1cm5zIGFuIGFycmF5IG9mIHBhcmFtZXRlcnMsIHdoaWNoIGlzIGFjY2Vzc2VkIGJ5IGZ1bkRlZkFyZ0xpc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5EZWZBcmdMaXN0VGFpbCgpIHtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcsJykpKHN0cmluZygpKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmxlZnQocGFudHNfMS5QcmltaXRpdmVzLm1hbnkocDEpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKScpKTtcbiAgICAgICAgcmV0dXJuIHAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmdW5BcHBBcmdMaXN0IHBhcnNlcyBhcmd1bWVudCBsaXN0cyBmb3IgZnVuY3Rpb24gYXBwbGljYXRpb25zLCBpbmNsdWRpbmcgZW1wdHkgYXJncyBsaXN0c1xuICAgICAqIHRoZSBwYXJzZXIgcmV0dXJucyBhbiBhcnJheSBvZiBFeHByZXNzaW9uIG9iamVjdHMgdGhhdCByZXByZXNlbnQgdGhlIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bkFwcEFyZ0xpc3QoKSB7XG4gICAgICAgIGxldCBleHByID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcoJykpKGV4cHIpO1xuICAgICAgICB2YXIgZiA9ICh0dXApID0+IHtcbiAgICAgICAgICAgIGxldCBoZCA9IHR1cFswXTtcbiAgICAgICAgICAgIGxldCByZXMgPSBbaGRdO1xuICAgICAgICAgICAgbGV0IHRhaWwgPSB0dXBbMV07XG4gICAgICAgICAgICBmb3IgKGxldCBlbGVtIG9mIHRhaWwpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocDEpKGZ1bkFwcEFyZ0xpc3RUYWlsKCkpKGYpO1xuICAgICAgICBsZXQgcDMgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJygpJykpKF8gPT4gW10pO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwMykocDIpO1xuICAgIH1cbiAgICBQYXJzZXIuZnVuQXBwQXJnTGlzdCA9IGZ1bkFwcEFyZ0xpc3Q7XG4gICAgLyoqXG4gICAgICogZnVuQXBwQXJnTGlzdFRhaWwgcGFyc2VzIHRoZSBzZWNvbmQgdGhyb3VnaCBsYXN0IGVsZW1lbnRzIG9mIGFuIGFyZ3VtZW50IGxpc3RcbiAgICAgKiBlYWNoIGVsZW1lbnQgaXMgc2VwYXJhdGVkIGJ5IGEgY29tbWFcbiAgICAgKiByZXR1cm5zIGFuIGFycmF5IG9mIEV4cHJlc3Npb24gb2JqZWN0cywgbGF0ZXIgYWNjZXNzZWQgYnkgZnVuQXBwQXJnc0xpc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5BcHBBcmdMaXN0VGFpbCgpIHtcbiAgICAgICAgbGV0IGNvbW1hID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignLCcpKTtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KGNvbW1hKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IHAyID0gcGFudHNfMS5QcmltaXRpdmVzLmxlZnQocGFudHNfMS5QcmltaXRpdmVzLm1hbnkocDEpKShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcpJykpKTtcbiAgICAgICAgcmV0dXJuIHAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXR1cm5QYXJzZXIgcGFyc2VzIHZhbGlkIHJldHVybiBzdGF0ZW1lbnRzIGluIHRoZSBmb3JtIFwicmV0dXJuIHhcIlxuICAgICAqIHdyYXBzIHRoZSBwYXJzZWQgdmFsdWUgaW4gYSBSZXR1cm4gbm9kZSBmb3IgdGhlIEFTVFxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIucmV0dXJuUGFyc2VyID0gaSA9PiB7XG4gICAgICAgIGxldCBleHByID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwID0gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cigncmV0dXJuJykpKShleHByKTtcbiAgICAgICAgdmFyIGYgPSAoZSkgPT4geyByZXR1cm4gbmV3IGluZGV4XzEuUmV0dXJuKGUsIHdzKTsgfTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocCkoZikoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBmdW5EZWYgcGFyc2VzIHZhbGlkIGZ1bmN0aW9uIGRlZmluaXRpb25zIGluIHRoZSBmb3JtIFwiZnVuIGZ1bmN0aW9uTmFtZShhcmdMaXN0KXsgYm9keTt9XCJcbiAgICAgKiB0aGUgcGFyc2VyIHJldHVybnMgYSBmdW5EZWYgbm9kZSBmb3IgdGhlIEFTVFxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIuZnVuRGVmID0gaSA9PiB7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cignZnVuJykpKShwYW50c18xLlByaW1pdGl2ZXMuc2VxKFxuICAgICAgICAvKiBmdW5jdGlvbiBuYW1lICovXG4gICAgICAgIHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4oc3RyaW5nKCkpKGNzID0+IGNzLnRvU3RyaW5nKCkpKShwYW50c18xLlByaW1pdGl2ZXMuc2VxKFxuICAgICAgICAvKiBmdW5jdGlvbiBhcmd1bWVudHMgKi9cbiAgICAgICAgZnVuRGVmQXJnTGlzdCgpKShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQoXG4gICAgICAgIC8qIGZ1bmN0aW9uIGJvZHkgKi9cbiAgICAgICAgcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcigneycpKSkocGFudHNfMS5QcmltaXRpdmVzLmxlZnQocGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlcikpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCd9JykpKSkoaWQpKShcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBBU1Qgbm9kZVxuICAgICAgICAodHVwKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm5hbWUgPSB0dXBbMF07XG4gICAgICAgICAgICBsZXQgYXJncyA9IHR1cFsxXVswXTtcbiAgICAgICAgICAgIGxldCBib2R5ID0gdHVwWzFdWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkZ1bkRlZihmbmFtZSwgYm9keSwgYXJncywgd3MpO1xuICAgICAgICB9KSkoaSk7XG4gICAgfTtcbiAgICBsZXQgcHJpbnRPZmZzZXQgPSAtMTtcbiAgICBsZXQgYm91bmRpbmdSZWN0cyA9IFtdO1xuICAgIC8vVE9ET1xuICAgIGZ1bmN0aW9uIGdldE5vbk92ZXJsYXBwaW5nQ29vcmRzKCkge1xuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH1cbiAgICBQYXJzZXIuZ2V0Tm9uT3ZlcmxhcHBpbmdDb29yZHMgPSBnZXROb25PdmVybGFwcGluZ0Nvb3JkcztcbiAgICAvKipcbiAgICAgKiBmdW5BcHAgcGFyc2VzIHZhbGlkIGZ1bmN0aW9uIGFwcGxpY2F0aW9ucyBpbiB0aGUgZm9ybSBcImZ1bmN0aW9uTmFtZShhcmdzTGlzdClcIiBhbmQgcmV0dXJucyBhIGZ1bkFwcCBub2RlXG4gICAgICogcGFyc2VyIGNoZWNrcyBmb3IgYnVpbHQtaW4gZnVuY3Rpb25zLCBsaWtlIHByaW50LCBlbGxpcHNlLCBhbmQgcmVjdDsgYW5kIHJldHVybnMgdGhlIHZhbGlkIEFTVCBub2RlXG4gICAgICogQHBhcmFtIGkgYSBub25zZW5zZSBwYXJhbWV0ZXIgdXNlZCB0byBhdm9pZCB0aGUgYnVnIHdpdGggZWFnZXIgZXZhbHVhdGlvblxuICAgICAqL1xuICAgIFBhcnNlci5mdW5BcHAgPSBpID0+IHtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykoc3RyaW5nKCkpKShmdW5BcHBBcmdMaXN0KCkpKHR1cCA9PiB7XG4gICAgICAgICAgICBsZXQgZm5hbWUgPSB0dXBbMF0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicHJpbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1cFsxXS5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9ib3VuZGluZ1JlY3RzLnB1c2goW3R1cFsxXVswXS53aWR0aCwgdHVwWzFdWzBdLmhlaWdodCwgdHVwWzFdWzFdLCB0dXBbMV1bMl1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5QcmludE5vZGUodHVwWzFdWzBdLCBuZXcgaW5kZXhfMS5EaW1lbnNpb25zKHR1cFsxXVsxXSwgdHVwWzFdWzJdLCBuZXcgaW5kZXhfMS5OdW1iZXJOb2RlKDEpKSwgd3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByaW50T2Zmc2V0ID0gKHByaW50T2Zmc2V0ICsgMSkgJSAxMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJwcmludE9mZnNldDogXCIgKyBwcmludE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5QcmludE5vZGUodHVwWzFdWzBdLCBuZXcgaW5kZXhfMS5EaW1lbnNpb25zKG5ldyBpbmRleF8xLk51bWJlck5vZGUoMTAwICsgMTAwICogKHByaW50T2Zmc2V0ICUgMykpLCBuZXcgaW5kZXhfMS5OdW1iZXJOb2RlKDEwMCArIDEwMCAqIChwcmludE9mZnNldCAvIDQpKSwgbmV3IGluZGV4XzEuTnVtYmVyTm9kZSgxKSksIHdzKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZWxsaXBzZVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHVwWzFdLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuRWxsaXBzZU5vZGUodHVwWzFdWzBdLCB0dXBbMV1bMV0sIHdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0dXBbMV0ubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5SZWN0YW5nbGVOb2RlKHR1cFsxXVswXSwgdHVwWzFdWzFdLCB3cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHVwWzFdLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuTGluZU5vZGUodHVwWzFdWzBdLCB0dXBbMV1bMV0sIHdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJjdXJ2ZVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHVwWzFdLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuQ3VydmVOb2RlKHR1cFsxXVswXSwgdHVwWzFdWzFdLCB0dXBbMV1bMl0sIHdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJlcGhcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1cFsxXS5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkVwaE5vZGUodHVwWzFdWzBdLCB0dXBbMV1bMV0sIHdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFyZ3MgPSB0dXBbMV07XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuRnVuQXBwKGZuYW1lLCBhcmdzLCB3cyk7XG4gICAgICAgIH0pKGkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQm9vbFBhcnNlIHBhcnNlcyB2YWxpZCBib29sZWFucywgdHJ1ZSBhbmQgZmFsc2UsIGFuZCByZXR1cm5zIGEgQm9vbGVhbk5vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb29sUGFyc2UoKSB7XG4gICAgICAgIGxldCB3cyA9IFwiXCI7XG4gICAgICAgIGxldCBwcmVjZWRpbmdXUyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHggPT4gd3MgPSB4LnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cigndHJ1ZScpKSkoXyA9PiBuZXcgaW5kZXhfMS5Cb29sZWFuTm9kZSh0cnVlLCB3cykpO1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cignZmFsc2UnKSkpKF8gPT4gbmV3IGluZGV4XzEuQm9vbGVhbk5vZGUoZmFsc2UsIHdzKSk7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHAxKShwMik7XG4gICAgfVxuICAgIFBhcnNlci5Cb29sUGFyc2UgPSBCb29sUGFyc2U7XG4gICAgLyoqXG4gICAgICogbG9naWNDaGFyIHBhcnNlcyBhbGwgbG9naWNhbCBvcGVyYXRvcnMgaW4gdGhlIFNXRUxMIGxhbmd1YWdlIGFuZCByZXR1cm5zIHRoZSBjb25zdW1lZCBvcGVyYXRvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZ2ljQ2hhcigpIHtcbiAgICAgICAgdmFyIGxvZ2ljQ2hhciA9IFtcImVxdWFsc1wiLCAnPT0nLCAnYW5kJywgJz4nLCAnPCcsICdub3QgZXF1YWxzJywgJ29yJ107XG4gICAgICAgIHZhciBsb2dpY0NoYXIyID0gWyc+PScsICc8PSddO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHJTYXQobG9naWNDaGFyKSk7XG4gICAgICAgIGxldCBwMiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLnN0clNhdChsb2dpY0NoYXIyKSk7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKHAyKShwMSk7XG4gICAgfVxuICAgIFBhcnNlci5sb2dpY0NoYXIgPSBsb2dpY0NoYXI7XG4gICAgLyoqXG4gICAgICogbG9naWNTaG9ydCByZXR1cm5zIGEgdHVwbGUsIHdoZXJlIHRoZSBmaXJzdCBlbGVtZW50IHJlcHJlc2VudHMgdGhlIGxvZ2ljYWwgb3BlcmF0b3IgYW5kXG4gICAgICogdGhlIHNlY29uZCBlbGVtZW50IGlzIHRoZSBleHByZXNzaW9uIHRvIHRoZSByaWdodCBvZiB0aGUgb3BlcmF0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2dpY1Nob3J0KCkge1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShsb2dpY0NoYXIoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSkoKHgpID0+IHgpO1xuICAgIH1cbiAgICBQYXJzZXIubG9naWNTaG9ydCA9IGxvZ2ljU2hvcnQ7XG4gICAgLyoqXG4gICAgICogbG9naWNFeHByIHBhcnNlcyBsb2dpY2FsIGV4cHJlc3Npb25zIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIEFTVCBub2RlXG4gICAgICogQHBhcmFtIGkgYSBub25zZW5zZSBwYXJhbWV0ZXIgdXNlZCB0byBhdm9pZCB0aGUgYnVnIHdpdGggZWFnZXIgZXZhbHVhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZ2ljRXhwcigpIHtcbiAgICAgICAgLy8gVE9ETzogRGFuICgyMDE4LTExLTE5KSwgc2hvdWxkbid0IHBhcmFtZXRlcml6ZWQgdHlwZSBiZSBCb29sZWFuTm9kZT9cbiAgICAgICAgdmFyIGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICBsZXQgbGhzID0gdHVwWzBdO1xuICAgICAgICAgICAgbGV0IG9wID0gdHVwWzFdWzBdO1xuICAgICAgICAgICAgbGV0IHJocyA9IHR1cFsxXVsxXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3AudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcXVhbHNcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkVxdWFscyhsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI9PVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuRXF1YWxzKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFuZFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuQW5kKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkdyZWF0ZXJUaGFuKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkxlc3NUaGFuKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIj49XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5HcmVhdGVyVGhhbkVxKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIjw9XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5MZXNzVGhhbkVxKGxocywgcmhzLCB3cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5PcihsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJub3QgZXF1YWxzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5Ob3RFcXVhbChsaHMsIHJocywgd3MpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvZ2ljYWwgZXhwcmVzc2lvbiBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgd3MgPSBcIlwiO1xuICAgICAgICBsZXQgcHJlY2VkaW5nV1MgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKSh4ID0+IHdzID0geC50b1N0cmluZygpKTtcbiAgICAgICAgbGV0IG5vdCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwcmVjZWRpbmdXUykocGFudHNfMS5QcmltaXRpdmVzLnN0cignbm90JykpO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMucmlnaHQobm90KShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IG5vdEV4cHIgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHAxKSh4ID0+IG5ldyBpbmRleF8xLk5vdCh4LCB3cykpO1xuICAgICAgICBsZXQgbG9naWNFeHByID0gcGFudHNfMS5QcmltaXRpdmVzLnNlcShwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyTm9Mb2dpYykpKGxvZ2ljU2hvcnQoKSkoZik7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuY2hvaWNlKG5vdEV4cHIpKGxvZ2ljRXhwcik7XG4gICAgfVxuICAgIFBhcnNlci5Mb2dpY0V4cHIgPSBMb2dpY0V4cHI7XG4gICAgLyoqXG4gICAgICogSWZQYXJzZSBwYXJzZXMgdmFsaWQgaWYgc3RhdGVtZW50cyBpbiB0aGUgZm9ybSBcImlmKGNvbmRpdGlvbil7IGJvZHk7IH1cIlxuICAgICAqIHJldHVybnMgYW4gYXJyYXkgd2hlcmUgdGhlIGZpcnN0IGVsZW0gaXMgdGhlIGNvbmRpdGlvbiBhbmQgdGhlIHNlY29uZCBpcyB0aGUgYm9keVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIElmUGFyc2UoKSB7XG4gICAgICAgIGxldCBleHByID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlck5vU2VxKTtcbiAgICAgICAgbGV0IGJvZHlQYXJzZSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIpO1xuICAgICAgICBsZXQgcDEgPSBwYW50c18xLlByaW1pdGl2ZXMuc2VxKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ2lmJykpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcoJykpKHggPT4geCk7XG4gICAgICAgIGxldCBjb25kID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocDEpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCcpJykpKGV4cHIpO1xuICAgICAgICBsZXQgY3VybHkgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5jaGFyKCd7JykpO1xuICAgICAgICBsZXQgYm9keSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKGN1cmx5KShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignfScpKShib2R5UGFyc2UpO1xuICAgICAgICByZXR1cm4gcGFudHNfMS5QcmltaXRpdmVzLnNlcShjb25kKShib2R5KSh4ID0+IHgpO1xuICAgIH1cbiAgICBQYXJzZXIuSWZQYXJzZSA9IElmUGFyc2U7XG4gICAgLyoqXG4gICAgICAqIElmRWxzZVBhcnNlIHBhcnNlcyB2YWxpZCBpZiBlbHNlIHN0YXRlbWVudHMgaW4gdGhlIGZvcm0gXCJpZihjb25kaXRpb24peyBib2R5OyB9IGVsc2V7IGJvZHkyO31cIlxuICAgICAgKiByZXR1cm5zIGFuIGFycmF5IHdoZXJlIHRoZSBmaXJzdCBlbGVtIGlzIHRoZSBjb25kaXRpb24gYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGZpcnN0IGJvZHkgYW5kIHRoZSB0aGlyZCBpcyBib2R5MlxuICAgICAgKi9cbiAgICBmdW5jdGlvbiBJZkVsc2VQYXJzZSgpIHtcbiAgICAgICAgbGV0IGUgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ2Vsc2UnKSk7XG4gICAgICAgIGxldCBib2R5ID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShQYXJzZXIuRXhwcmVzc2lvblBhcnNlcik7XG4gICAgICAgIGxldCBib2R5MiA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ3snKSkocGFudHNfMS5QcmltaXRpdmVzLnN0cignfScpKShib2R5KTtcbiAgICAgICAgbGV0IGVsc2VQYXJzZSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChlKShib2R5Mik7XG4gICAgICAgIHZhciBmID0gKHR1cCkgPT4ge1xuICAgICAgICAgICAgdHVwWzBdLnB1c2godHVwWzFdKTtcbiAgICAgICAgICAgIHJldHVybiB0dXBbMF07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuc2VxKElmUGFyc2UoKSkoZWxzZVBhcnNlKShmKTtcbiAgICB9XG4gICAgUGFyc2VyLklmRWxzZVBhcnNlID0gSWZFbHNlUGFyc2U7XG4gICAgLyoqXG4gICAgICogY29uZFBhcnNlIHBhcnNlcyBwb3NzaWJsZSBjb25kaXRpb25hbCBzdGF0ZW1lbnRzLCBpbmNsdWRpbmcgaWYgYW5kIGlmL2Vsc2Ugc3RhdGVtZW50c1xuICAgICAqIHJldHVybnMgYSBDb25kaXRpb25hbCBub2RlXG4gICAgICogQHBhcmFtIGkgYSBub25zZW5zZSBwYXJhbWV0ZXIgdXNlZCB0byBhdm9pZCB0aGUgYnVnIHdpdGggZWFnZXIgZXZhbHVhdGlvblxuICAgICAqL1xuICAgIFBhcnNlci5jb25kUGFyc2UgPSBpID0+IHtcbiAgICAgICAgdmFyIGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICBpZiAodHVwLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkNvbmRpdGlvbmFsKHR1cFswXSwgdHVwWzFdLCB0dXBbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLkNvbmRpdGlvbmFsKHR1cFswXSwgdHVwWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5hcHBmdW4ocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShJZkVsc2VQYXJzZSgpKShJZlBhcnNlKCkpKShmKShpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoaWxlTG9vcCBwYXJzZXMgdmFsaWQgd2hpbGUgbG9vcHMgaW4gdGhlIGZvcm0gXCJ3aGlsZShjb25kaXRpb24pIHsgYm9keTt9XCJcbiAgICAgKiByZXR1cm5zIGEgV2hpbGVOb2RlIGZvciB0aGUgQVNUXG4gICAgICovXG4gICAgUGFyc2VyLldoaWxlTG9vcCA9IGkgPT4ge1xuICAgICAgICBsZXQgZXhwciA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXJOb1NlcSk7XG4gICAgICAgIGxldCBib2R5UGFyc2UgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKFBhcnNlci5FeHByZXNzaW9uUGFyc2VyKTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocGFudHNfMS5QcmltaXRpdmVzLnJpZ2h0KHByZWNlZGluZ1dTKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKFwid2hpbGVcIikpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKCcpKSh4ID0+IHgpO1xuICAgICAgICBsZXQgY29uZCA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHAxKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignKScpKShleHByKTtcbiAgICAgICAgbGV0IGN1cmx5ID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLndzKCkpKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMuY2hhcigneycpKTtcbiAgICAgICAgbGV0IGJvZHkgPSBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihjdXJseSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ30nKSkoYm9keVBhcnNlKTtcbiAgICAgICAgdmFyIGYgPSAodHVwKSA9PiB7IHJldHVybiBuZXcgaW5kZXhfMS5XaGlsZU5vZGUodHVwWzBdLCB0dXBbMV0sIHdzKTsgfTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEoY29uZCkoYm9keSkoZikoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3JMb29wIHBhcnNlcyB2YWxpZCBmb3IgbG9vcHMgaW4gdGhlIGZvcm0gXCJmb3IoaW5pdGlhbCwgY29uZGl0aW9uLCBwb3N0KSB7IGJvZHk7fVwiIGFuZCByZXR1cm5zIGEgRm9yTm9kZVxuICAgICAqIEBwYXJhbSBpIGEgbm9uc2Vuc2UgcGFyYW1ldGVyIHVzZWQgdG8gYXZvaWQgdGhlIGJ1ZyB3aXRoIGVhZ2VyIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBQYXJzZXIuRm9yTG9vcCA9IGkgPT4ge1xuICAgICAgICBsZXQgYXJncyA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoZnVuQXBwQXJnTGlzdCgpKTtcbiAgICAgICAgbGV0IHdzID0gXCJcIjtcbiAgICAgICAgbGV0IHByZWNlZGluZ1dTID0gcGFudHNfMS5QcmltaXRpdmVzLmFwcGZ1bihwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoeCA9PiB3cyA9IHgudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBwMSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5yaWdodChwYW50c18xLlByaW1pdGl2ZXMucmlnaHQocHJlY2VkaW5nV1MpKHBhbnRzXzEuUHJpbWl0aXZlcy5zdHIoJ2ZvcicpKSkoYXJncyk7XG4gICAgICAgIGxldCBjdXJseSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKHBhbnRzXzEuUHJpbWl0aXZlcy53cygpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLmNoYXIoJ3snKSk7XG4gICAgICAgIGxldCBleHByID0gcGFudHNfMS5QcmltaXRpdmVzLmJldHdlZW4ocGFudHNfMS5QcmltaXRpdmVzLmNob2ljZShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkocGFudHNfMS5QcmltaXRpdmVzLm5sKCkpKShwYW50c18xLlByaW1pdGl2ZXMud3MoKSkoUGFyc2VyLkV4cHJlc3Npb25QYXJzZXIpO1xuICAgICAgICBsZXQgYm9keSA9IHBhbnRzXzEuUHJpbWl0aXZlcy5iZXR3ZWVuKGN1cmx5KShwYW50c18xLlByaW1pdGl2ZXMuY2hhcignfScpKShleHByKTtcbiAgICAgICAgdmFyIGYgPSAodHVwKSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5pdCA9IHR1cFswXVswXTtcbiAgICAgICAgICAgIGxldCBjb25kID0gdHVwWzBdWzFdO1xuICAgICAgICAgICAgbGV0IHBvc3QgPSB0dXBbMF1bMl07XG4gICAgICAgICAgICBsZXQgYm9keSA9IHR1cFsxXTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5Gb3JOb2RlKGluaXQsIGNvbmQsIHBvc3QsIGJvZHksIHdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhbnRzXzEuUHJpbWl0aXZlcy5zZXEocDEpKGJvZHkpKGYpKGkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gc2luZ2xlQ29tbWVudCgpIHtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLm1hbnkxKHBhbnRzXzEuUHJpbWl0aXZlcy5pdGVtKCkpO1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHAxKSh4cyA9PiBwYW50c18xLkNoYXJVdGlsLkNoYXJTdHJlYW0uY29uY2F0KHhzKSk7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMuc3RyKCcvLycpKShwYW50c18xLlByaW1pdGl2ZXMubmwoKSkocDIpO1xuICAgICAgICAvL3JldHVybiBQcmltaXRpdmVzLnNlcTxDaGFyVXRpbC5DaGFyU3RyZWFtLCBDaGFyVXRpbC5DaGFyU3RyZWFtLCBDaGFyVXRpbC5DaGFyU3RyZWFtW10+KFByaW1pdGl2ZXMuc3RyKCcvLycpKShQcmltaXRpdmVzLm5sKCkpKHg9PngpO1xuICAgIH1cbiAgICBQYXJzZXIuc2luZ2xlQ29tbWVudCA9IHNpbmdsZUNvbW1lbnQ7XG4gICAgZnVuY3Rpb24gbXVsdGlMaW5lQ29tbWVudCgpIHtcbiAgICAgICAgbGV0IHAxID0gcGFudHNfMS5QcmltaXRpdmVzLm1hbnkxKHBhbnRzXzEuUHJpbWl0aXZlcy5pdGVtKCkpO1xuICAgICAgICBsZXQgcDIgPSBwYW50c18xLlByaW1pdGl2ZXMuYXBwZnVuKHAxKSh4cyA9PiBwYW50c18xLkNoYXJVdGlsLkNoYXJTdHJlYW0uY29uY2F0KHhzKSk7XG4gICAgICAgIHJldHVybiBwYW50c18xLlByaW1pdGl2ZXMuYmV0d2VlbihwYW50c18xLlByaW1pdGl2ZXMuc3RyKCdcXC8qKicpKShwYW50c18xLlByaW1pdGl2ZXMuc3RyKCcqXFwvJykpKHAyKTtcbiAgICB9XG4gICAgUGFyc2VyLm11bHRpTGluZUNvbW1lbnQgPSBtdWx0aUxpbmVDb21tZW50O1xufSkoUGFyc2VyID0gZXhwb3J0cy5QYXJzZXIgfHwgKGV4cG9ydHMuUGFyc2VyID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEJvb2xlYW5Ob2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgQm9vbGVhbk5vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYSBib29sZWFuXG4gICAgICogQHBhcmFtIHZhbCBUaGUgYm9vbGVhbiB2YWx1ZSBvZiB0aGUgQm9vbGVhbk5vZGVcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlIHNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFsLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBCb29sZWFuTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQm9vbGVhbk5vZGVzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBCb29sZWFuTm9kZSBlcXVhbHMgYW5vdGhlclxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgQm9vbGVhbk5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbCA9PT0gcmlnaHQudmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQm9vbGVhbk5vZGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5fdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBib29sZWFuIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IHZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm9vbGVhbiB2YWx1ZVxuICAgICAqL1xuICAgIHNldCB2YWwodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFsID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkJvb2xlYW5Ob2RlID0gQm9vbGVhbk5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cb29sZWFuTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIE5PUCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qIEEgTk9QIGlzIGEgcGxhY2Vob2xkZXIgb3BlcmF0aW9uIHRoYXQgZXZhbHVhdGVzIHRvIG5vdGhpbmcgKi9cbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE5PUFxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOT1BzIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTk9QcyBjYW5ub3QgYmUgZHJhd24uXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBOT1BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIE5PUCBlcXVhbHMgYW5vdGhlciAoc3BvaWxlcjogaXQgZG9lc24ndClcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5OT1AgPSBOT1A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OT1AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL051bWJlckVmZmVjdFwiKTtcbi8vIE5vZGVzIHJlcHJlc2VudGluZyBudW1iZXJzXG4vLyBTaG91bGQgYWJzdHJhY3QgTm9kZSBjbGFzcyBpbXBsZW1lbnQgRXhwcmVzc2lvbj9cbmNsYXNzIE51bWJlck5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIE51bWJlck5vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYSBudW1iZXJcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSBudW1iZXIgdmFsdWVcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2YWwsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdmFsID0gdmFsO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBOdW1iZXJOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOdW1iZXJOb2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGxldCBlID0gbmV3IE51bWJlckVmZmVjdF8xLk51bWJlckVmZmVjdCh0aGlzKTtcbiAgICAgICAgZS5kcmF3KGNvbnRleHQsIGRpbXMsIGFzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIE51bWJlck5vZGUgZXF1YWxzIGFub3RoZXIgTnVtYmVyTm9kZVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHkgKG11c3QgYmUgYSBOdW1iZXJOb2RlKVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBOdW1iZXJOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWwgPT09IHJpZ2h0LnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIE51bWJlck5vZGVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgdGhpcy5fdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgc3RvcmVkIGluIHRoZSBub2RlXG4gICAgICovXG4gICAgZ2V0IHZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIG51bWJlciBzdG9yZWQgaW4gdGhlIG5vZGVcbiAgICAgKi9cbiAgICBzZXQgdmFsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5OdW1iZXJOb2RlID0gTnVtYmVyTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU51bWJlck5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTdHJpbmdFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1N0cmluZ0VmZmVjdFwiKTtcbmNsYXNzIFN0cmluZ05vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIFN0cmluZ05vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gc3RyIFRoZSBzdHJpbmcgc3RvcmVkIGluIHRoZSBub2RlXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RyLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0ciA9IHN0cjtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBTdHJpbmdOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgU3RyaW5nIHVzaW5nIFN0cmluZ0VmZmVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBzdHJpbmcgdG8gYmUgZHJhd25cbiAgICAgKiBAcGFyYW0gYXN0IFRoZSBwcm9ncmFtIEFTVFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIGxldCBlID0gbmV3IFN0cmluZ0VmZmVjdF8xLlN0cmluZ0VmZmVjdCh0aGlzKTtcbiAgICAgICAgZS5kcmF3KGNvbnRleHQsIGRpbXMsIGFzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIFN0cmluZ05vZGUgZXF1YWxzIGFub3RoZXIgU3RyaW5nTm9kZVxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZXF1YWxpdHksIG11c3QgYmUgYSBTdHJpbmdOb2RlXG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIFN0cmluZ05vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbCA9PT0gcmlnaHQudmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgU3RyaW5nTm9kZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyAnXFxcIicgKyB0aGlzLl9zdHIgKyAnXFxcIic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmluZyBzdG9yZWQgaW4gdGhlIG5vZGVcbiAgICAgKi9cbiAgICBzZXQgc3RyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3N0ciA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgc3RvcmVkIGluIHRoZSBub2RlXG4gICAgICovXG4gICAgZ2V0IHZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaW5nTm9kZSA9IFN0cmluZ05vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdHJpbmdOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQ29sb3JOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBDb2xvck5vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYW4gUkdCIGNvbG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVkLCBncmVlbiwgYmx1ZSkge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JlZCA9IHJlZDtcbiAgICAgICAgdGhpcy5fZ3JlZW4gPSBncmVlbjtcbiAgICAgICAgdGhpcy5fYmx1ZSA9IGJsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgaW50byBhIHN0cmluZyBSR0IgdmFsdWVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZCArIFwiIFwiICsgdGhpcy5fZ3JlZW4gKyBcIiBcIiArIHRoaXMuX2JsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbG9yTm9kZXMgY2Fubm90IGN1cnJlbnRseSBiZSBkcmF3blxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXNcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBDb2xvck5vZGUgZXF1YWxzIGFub3RoZXIgQ29sb3JOb2RlXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhIEJvb2xlYW5Ob2RlKVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBDb2xvck5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5yZWQgPT09IHJpZ2h0LnJlZCAmJiB0aGlzLmdyZWVuID09PSByaWdodC5ncmVlbiAmJiB0aGlzLmJsdWUgPT09IHJpZ2h0LmJsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQ29sb3JOb2RlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZWQgdmFsdWVcbiAgICAgKi9cbiAgICBnZXQgcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByZWQgdmFsdWVcbiAgICAgKi9cbiAgICBzZXQgcmVkKHJlZCkge1xuICAgICAgICB0aGlzLl9yZWQgPSByZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGdyZWVuIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IGdyZWVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JlZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdyZWVuIHZhbHVlXG4gICAgICovXG4gICAgc2V0IGdyZWVuKGdyZWVuKSB7XG4gICAgICAgIHRoaXMuX2dyZWVuID0gZ3JlZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJsdWUgdmFsdWVcbiAgICAgKi9cbiAgICBnZXQgYmx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJsdWUgdmFsdWVcbiAgICAgKi9cbiAgICBzZXQgYmx1ZShibHVlKSB7XG4gICAgICAgIHRoaXMuX2JsdWUgPSBibHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5Db2xvck5vZGUgPSBDb2xvck5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvck5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOdW1iZXJOb2RlXzEgPSByZXF1aXJlKFwiLi4vcHJpbXMvTnVtYmVyTm9kZVwiKTtcbmNvbnN0IEN1cnZlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9DdXJ2ZUVmZmVjdFwiKTtcbmNsYXNzIEN1cnZlTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgQ3VydmVOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgY3VydmVcbiAgICAgKiBAcGFyYW0gZHggdGhlIHJ1biBvZiB0aGUgY3VydmVcbiAgICAgKiBAcGFyYW0gZHkgdGhlIHJpc2Ugb2YgdGhlIGN1cnZlXG4gICAgICogQHBhcmFtIGN1cnZhdHVyZSBob3cgbXVjaCB0aGUgY3VydmUsIHVtbSwgY3VydmVzXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZHgsIGR5LCBjdXJ2YXR1cmUsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZHggPSBkeDtcbiAgICAgICAgdGhpcy5fZHkgPSBkeTtcbiAgICAgICAgdGhpcy5fY3VydmF0dXJlID0gY3VydmF0dXJlO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIEN1cnZlTm9kZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqL1xuICAgIGV2YWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGN1cnZlIHVzaW5nIEN1cnZlRWZmZWN0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXMgVGhlIGxpbmUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSBhc3QgVGhlIHByb2dyYW0gQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgZGltcy53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl9keC5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGRpbXMuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMuX2R5LmV2YWwoY29udGV4dCkudmFsLCBcIlwiKTtcbiAgICAgICAgZGltcy5jdXJ2YXR1cmUgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5fY3VydmF0dXJlLmV2YWwoY29udGV4dCkudmFsLCBcIlwiKTtcbiAgICAgICAgbGV0IGUgPSBuZXcgQ3VydmVFZmZlY3RfMS5DdXJ2ZUVmZmVjdCh0aGlzKTtcbiAgICAgICAgZS5kcmF3KGNvbnRleHQsIGRpbXMsIGFzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIEN1cnZlTm9kZSBlcXVhbHMgYW5vdGhlciAoaWYgdGhlaXIgZHgsIGR5LCBhbmQgY3VydmF0dXJlIGFyZSBlcXVhbClcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5IChtdXN0IGJlIGEgQ3VydmVOb2RlKVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBDdXJ2ZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5keC5lcXVhbHNWYWwocmlnaHQuZHgpICYmIHRoaXMuZHkuZXF1YWxzVmFsKHJpZ2h0LmR5KSAmJiB0aGlzLmN1cnZhdHVyZS5lcXVhbHNWYWwocmlnaHQuY3VydmF0dXJlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtb3ZlKCkgeyB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VydmVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJjdXJ2ZShcIiArIHRoaXMuX2R4LnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLl9keS50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5fY3VydmF0dXJlLnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcnVuIG9mIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIGdldCBkeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBydW4gb2YgdGhlIGN1cnZlXG4gICAgICovXG4gICAgc2V0IGR4KGR4KSB7XG4gICAgICAgIHRoaXMuX2R4ID0gZHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJpc2Ugb2YgdGhlIGN1cnZlXG4gICAgICovXG4gICAgZ2V0IGR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJpc2Ugb2YgdGhlIGN1cnZlXG4gICAgICovXG4gICAgc2V0IGR5KGR5KSB7XG4gICAgICAgIHRoaXMuX2R5ID0gZHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnZhdHVyZSBvZiB0aGUgY3VydmVcbiAgICAgKi9cbiAgICBnZXQgY3VydmF0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VydmF0dXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJ2YXR1cmUgb2YgdGhlIGN1cnZlXG4gICAgICovXG4gICAgc2V0IGN1cnZhdHVyZShjdXJ2YXR1cmUpIHtcbiAgICAgICAgdGhpcy5fY3VydmF0dXJlID0gY3VydmF0dXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5DdXJ2ZU5vZGUgPSBDdXJ2ZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DdXJ2ZU5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFbGxpcHNlRWZmZWN0XzEgPSByZXF1aXJlKFwiLi4vZWZmZWN0cy9FbGxpcHNlRWZmZWN0XCIpO1xuY2xhc3MgRWxsaXBzZU5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhbiBFbGxpcHNlTm9kZSwgYSBub2RlIHJlcHJlc2VudGluZyBhbiBlbGxpcHNlXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgZWxsaXBzZVxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgZWxsaXBzZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIEVsbGlwc2VOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgZWxsaXBzZSBvbiB0aGUgY2FudmFzIHVzaW5nIEVsbGlwc2VFZmZlY3RcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltcyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgZWxsaXBzZVxuICAgICAqIEBwYXJhbSBhc3QgVGhlIHByb2dyYW0gQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgZGltcy53aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICBkaW1zLmhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgbGV0IGUgPSBuZXcgRWxsaXBzZUVmZmVjdF8xLkVsbGlwc2VFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBFbGxpcHNlTm9kZSBlcXVhbHMgYW5vdGhlciBFbGxpcHNlTm9kZSAoaWYgdGhlaXIgd2lkdGhzIGFuZCBoZWlnaHRzIGFyZSBlcXVhbClcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5IChtdXN0IGJlIGFuIEVsbGlwc2VOb2RlKVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBFbGxpcHNlTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoLmVxdWFsc1ZhbChyaWdodC53aWR0aCkgJiYgdGhpcy5oZWlnaHQuZXF1YWxzVmFsKHJpZ2h0LmhlaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZWxsaXBzZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyBcImVsbGlwc2UoXCIgKyB0aGlzLl93aWR0aC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5faGVpZ2h0LnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9XG4gICAgbW92ZSgpIHsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVsbGlwc2Ugd2lkdGhcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZWxsaXBzZSB3aWR0aFxuICAgICAqL1xuICAgIHNldCB3aWR0aCh3aWR0aCkge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhlIGVsbGlwc2UgaGVpZ2h0XG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBlbGxpcHNlIGhlaWdodFxuICAgICAqL1xuICAgIHNldCBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuRWxsaXBzZU5vZGUgPSBFbGxpcHNlTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVsbGlwc2VOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBFcGhFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL0VwaEVmZmVjdFwiKTtcbmNsYXNzIEVwaE5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhbiBFcGhOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIHNvbWV0aGluZyB2ZXJ5IHNwZWNpYWxcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBFcGhOb2RlXG4gICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBFcGhOb2RlXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICAvL3RoaXMuX2ltYWdlID0gaW1hZ2U7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fd3MgPSB3cztcbiAgICAgICAgaWYgKHdzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd3MgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBFcGhOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgcmVjdGFuZ2xlIHVzaW5nIEVwaEVmZmVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IHByb2dyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zIFRoZSByZWN0YW5nbGUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSBhc3QgVGhlIHByb2dyYW0gQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgZGltcy53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl93aWR0aC5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGRpbXMuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMuX2hlaWdodC5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGxldCBlID0gbmV3IEVwaEVmZmVjdF8xLkVwaEVmZmVjdCh0aGlzKTtcbiAgICAgICAgZS5kcmF3KGNvbnRleHQsIGRpbXMsIGFzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIEVwaE5vZGUgZXF1YWxzIGFub3RoZXIgKGlmIHRoZWlyIHdpZHRocyBhbmQgaGVpZ2h0cyBhcmUgZXF1YWwpXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBzaWRlIG9mIHRoZSBlcXVhbGl0eSAobXVzdCBiZSBhbiBFcGhOb2RlKVxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBFcGhOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMud2lkdGguZXF1YWxzVmFsKHJpZ2h0LndpZHRoKSAmJiB0aGlzLmhlaWdodC5lcXVhbHNWYWwocmlnaHQuaGVpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtb3ZlKCkgeyB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgRXBoTm9kZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyBcImVwaChcIiArIHRoaXMuX3dpZHRoLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLl9oZWlnaHQudG9TdHJpbmcoKSArIFwiKVwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgRXBoTm9kZVxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB3aWR0aCBvZiB0aGUgRXBoTm9kZVxuICAgICAqL1xuICAgIHNldCB3aWR0aCh3aWR0aCkge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIEVwaE5vZGVcbiAgICAgKi9cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgdGhlIEVwaE5vZGVcbiAgICAgKi9cbiAgICBzZXQgaGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLkVwaE5vZGUgPSBFcGhOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXBoTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY29uc3QgTGluZUVmZmVjdF8xID0gcmVxdWlyZShcIi4uL2VmZmVjdHMvTGluZUVmZmVjdFwiKTtcbmNsYXNzIExpbmVOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBMaW5lTm9kZSwgYSBub2RlIHJlcHJlc2VudGluZyBhIGxpbmVcbiAgICAgKiBAcGFyYW0gZHggdGhlIHJ1biBvZiB0aGUgbGluZVxuICAgICAqIEBwYXJhbSBkeSB0aGUgcmlzZSBvZiB0aGUgbGluZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGR4LCBkeSwgd3MpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9keCA9IGR4O1xuICAgICAgICB0aGlzLl9keSA9IGR5O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExpbmVOb2RlXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgbGluZSB1c2luZyBMaW5lRWZmZWN0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXMgVGhlIGxpbmUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSBhc3QgVGhlIHByb2dyYW0gQVNUXG4gICAgICovXG4gICAgZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpIHtcbiAgICAgICAgZGltcy53aWR0aCA9IG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSh0aGlzLl9keC5ldmFsKGNvbnRleHQpLnZhbCwgXCJcIik7XG4gICAgICAgIGRpbXMuaGVpZ2h0ID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMuX2R5LmV2YWwoY29udGV4dCkudmFsLCBcIlwiKTtcbiAgICAgICAgbGV0IGUgPSBuZXcgTGluZUVmZmVjdF8xLkxpbmVFZmZlY3QodGhpcyk7XG4gICAgICAgIGUuZHJhdyhjb250ZXh0LCBkaW1zLCBhc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBMaW5lTm9kZSBlcXVhbHMgYW5vdGhlciAoaWYgdGhlaXIgZHggYW5kIGR5IGFyZSBlcXVhbClcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5IChtdXN0IGJlIGEgTGluZU5vZGUpXG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIExpbmVOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZHguZXF1YWxzVmFsKHJpZ2h0LmR4KSAmJiB0aGlzLmR5LmVxdWFsc1ZhbChyaWdodC5keSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW92ZSgpIHsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxpbmVcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJsaW5lKFwiICsgdGhpcy5fZHgudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuX2R5LnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcnVuIG9mIHRoZSBsaW5lXG4gICAgICovXG4gICAgZ2V0IGR4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJ1biBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIHNldCBkeChkeCkge1xuICAgICAgICB0aGlzLl9keCA9IGR4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByaXNlIG9mIHRoZSBsaW5lXG4gICAgICovXG4gICAgZ2V0IGR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJpc2Ugb2YgdGhlIGxpbmVcbiAgICAgKi9cbiAgICBzZXQgZHkoZHkpIHtcbiAgICAgICAgdGhpcy5fZHkgPSBkeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuTGluZU5vZGUgPSBMaW5lTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmVOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jb25zdCBSZWN0YW5nbGVFZmZlY3RfMSA9IHJlcXVpcmUoXCIuLi9lZmZlY3RzL1JlY3RhbmdsZUVmZmVjdFwiKTtcbmNsYXNzIFJlY3RhbmdsZU5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIFJlY3RhbmdsZU5vZGUsIGEgbm9kZSByZXByZXNlbnRpbmcgYSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIFJlY3RhbmdsZU5vZGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSByZWN0YW5nbGUgdXNpbmcgUmVjdGFuZ2xlRWZmZWN0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIGRpbXMgVGhlIHJlY3RhbmdsZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIGFzdCBUaGUgcHJvZ3JhbSBBU1RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICBkaW1zLndpZHRoID0gbmV3IE51bWJlck5vZGVfMS5OdW1iZXJOb2RlKHRoaXMuX3dpZHRoLmV2YWwoY29udGV4dCkudmFsLCBcIlwiKTtcbiAgICAgICAgZGltcy5oZWlnaHQgPSBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUodGhpcy5faGVpZ2h0LmV2YWwoY29udGV4dCkudmFsLCBcIlwiKTtcbiAgICAgICAgbGV0IGUgPSBuZXcgUmVjdGFuZ2xlRWZmZWN0XzEuUmVjdGFuZ2xlRWZmZWN0KHRoaXMpO1xuICAgICAgICBlLmRyYXcoY29udGV4dCwgZGltcywgYXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgUmVjdGFuZ2xlTm9kZSBlcXVhbHMgYW5vdGhlciAoaWYgdGhlaXIgd2lkdGhzIGFuZCBoZWlnaHRzIGFyZSBlcXVhbClcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVxdWFsaXR5IChtdXN0IGJlIGEgUmVjdGFuZ2xlTm9kZSlcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgUmVjdGFuZ2xlTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoLmVxdWFsc1ZhbChyaWdodC53aWR0aCkgJiYgdGhpcy5oZWlnaHQuZXF1YWxzVmFsKHJpZ2h0LmhlaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW92ZSgpIHsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3MgKyBcInJlY3QoXCIgKyB0aGlzLl93aWR0aC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5faGVpZ2h0LnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICovXG4gICAgc2V0IHdpZHRoKHdpZHRoKSB7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBzZXQgaGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLlJlY3RhbmdsZU5vZGUgPSBSZWN0YW5nbGVOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVjdGFuZ2xlTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE51bWJlck5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wcmltcy9OdW1iZXJOb2RlXCIpO1xuY2xhc3MgRGltZW5zaW9ucyB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIERpbWVuc2lvbnMsIHdoaWNoIHN0b3JlcyBvYmplY3QgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB4IFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB5IFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSBzY2FsZSBUaGUgc2NhbGUgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSByYWRpdXMgVGhlIHJhZGl1cyBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeCwgeSwgc2NhbGUsIHJhZGl1cykge1xuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIHRoaXMuX3NjYWxlID0gc2NhbGU7XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IHJhZGl1cyB8fCBuZXcgTnVtYmVyTm9kZV8xLk51bWJlck5vZGUoMzAsIFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkaW1lbnNpb25zXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLngudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMueS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgeCBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgeCh2YWwpIHtcbiAgICAgICAgdGhpcy5feCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgeSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgc2V0IHkodmFsKSB7XG4gICAgICAgIHRoaXMuX3kgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJhZGl1cyBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IHJhZGl1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmFkaXVzIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgcmFkaXVzKHZhbCkge1xuICAgICAgICB0aGlzLl9yYWRpdXMgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNjYWxlIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgc2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2NhbGUgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIHNldCBzY2FsZSh2YWwpIHtcbiAgICAgICAgdGhpcy5fc2NhbGUgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd2lkdGggb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIHNldCB3aWR0aCh2YWwpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgaGVpZ2h0KHZhbCkge1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnZhdHVyZSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0IGN1cnZhdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnZhdHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VydmF0dXJlIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgY3VydmF0dXJlKHZhbCkge1xuICAgICAgICB0aGlzLl9jdXJ2YXR1cmUgPSB2YWw7XG4gICAgfVxufVxuZXhwb3J0cy5EaW1lbnNpb25zID0gRGltZW5zaW9ucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpbWVuc2lvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBQcmludE5vZGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIFByaW50Tm9kZSwgcmVwcmVzZW50aW5nIGFuIG9iamVjdCB0byBiZSBwcmludGVkXG4gICAgICogQHBhcmFtIHRvUHJpbnQgVGhlIG9iamVjdCB0byBiZSBwcmludGVkXG4gICAgICogQHBhcmFtIGRpbWVuc2lvbnMgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9iamVjdCB0byBiZSBwcmludGVkXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9QcmludCwgZGltZW5zaW9ucywgd3MpIHtcbiAgICAgICAgdGhpcy5fc2NhbGUgPSAxO1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RvUHJpbnQgPSB0b1ByaW50O1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGltcyA9IGRpbWVuc2lvbnMgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0IHRvIGJlIHByaW50ZWRcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCJwcmludChcIiArIHRoaXMudG9QcmludC50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5kaW1zLnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gYSBQcmludE5vZGVcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIFByaW50Tm9kZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpbnROb2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcoKSBvbiBwcmludE9wXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgdGhlIG9iamVjdCB0byBiZSBwcmludGVkIGFuZCBkcmF3cyBpdFxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCByZXMgPSB0aGlzLl90b1ByaW50LmV2YWwoY29udGV4dCk7XG4gICAgICAgIHJlcy5kcmF3KGNvbnRleHQsIHRoaXMuX2RpbXMsIHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvYmplY3QgdG8gYmUgcHJpbnRlZFxuICAgICAqL1xuICAgIGdldCB0b1ByaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9QcmludDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb2JqZWN0IHRvIGJlIHByaW50ZWRcbiAgICAgKi9cbiAgICBnZXQgZGltcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZSAodHJ1ZSkgb3Igc2VtaWNvbG9uIChmYWxzZSlcbiAgICAgKi9cbiAgICBuZXdMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3TGluZTtcbiAgICB9XG59XG5leHBvcnRzLlByaW50Tm9kZSA9IFByaW50Tm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByaW50Tm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFJldHVybkVycm9yXzEgPSByZXF1aXJlKFwiLi9SZXR1cm5FcnJvclwiKTtcbmNsYXNzIFJldHVybiB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgUmV0dXJuIG9iamVjdCwgcmVwcmVzZW50aW5nIHNvbWV0aGluZyB0byBiZSByZXR1cm5lZCBpbiBhIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGV4cHIgVGhlIGV4cHJlc3Npb24gdG8gYmUgcmV0dXJuZWRcbiAgICAgKiBAcGFyYW0gd3MgUHJlY2VkaW5nIHdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihleHByLCB3cykge1xuICAgICAgICB0aGlzLl9uZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2V4cHIgPSBleHByO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSBleHByZXNzaW9uIHRvIGJlIHJldHVybmVkIGFuZCByZXR1cm5zIHZpYSBhIFJldHVybkVycm9cbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgLy8gSWYgcmV0dXJuIHZhbCBpcyBhIHZhciwgcmV0dXJucyB0aGF0IHZhcidzIHZhbHVlXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9leHByLmV2YWwoY29udGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBSZXR1cm5FcnJvcl8xLlJldHVybkVycm9yKHJlc3VsdCwgY29udGV4dC5yZXRJRExvb2t1cCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gUmV0dXJuIG5vZGVzXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBSZXR1cm5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFJldHVybiBub2RlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIFwicmV0dXJuIFwiICsgdGhpcy5fZXhwci50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBub2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gUmV0dXJuXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmV0dXJuID0gUmV0dXJuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmV0dXJuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgUmV0dXJuRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIFJldHVybkVycm9yLCBhIGN1c3RvbSBlcnJvciBjbGFzcyB0aGF0IHdlIGFidXNlIHRvIHJldHVybiB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gcmV0VmFsIFRoZSB2YWx1ZSB0byBiZSByZXR1cm5lZFxuICAgICAqIEBwYXJhbSBJRCBUaGUgSUQgb2YgdGhlIHZhbHVlIHRvIGJlIHJldHVybmVkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmV0VmFsLCBJRCkge1xuICAgICAgICBzdXBlcihJRCk7XG4gICAgICAgIHRoaXMucmV0VmFsID0gcmV0VmFsO1xuICAgICAgICB0aGlzLklEID0gSUQ7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBSZXR1cm5FcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmV0dXJuRXJyb3IgPSBSZXR1cm5FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJldHVybkVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgc3BhY2VfbGlmdF8xID0gcmVxdWlyZShcInNwYWNlLWxpZnRcIik7XG5jbGFzcyBTY29wZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIFNjb3BlLCBhbiBvYmplY3Qga2VlcGluZyB0cmFjayBvZiBvYmplY3RzIHdpdGhpbiBhIHBhcnRpY3VsYXIgY29udGV4dFxuICAgICAqIEBwYXJhbSBwYXJlbnQgVGhlIHBhcmVudCBTY29wZVxuICAgICAqIEBwYXJhbSBlZmZlY3RzIEVmZmVjdHMgd2l0aGluIHRoaXMgU2NvcGVcbiAgICAgKiBAcGFyYW0gbXlTdGF0ZSBUaGUgc2NvcGUgc3RhdGVcbiAgICAgKiBAcGFyYW0gZXZlbnRMb2cgVGhlIGxvZyBvZiBldmVudHMgdGhhdCBvY2N1cnJlZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgZWZmZWN0cywgZXZlbnRMb2cpIHtcbiAgICAgICAgdGhpcy5fcmV0VmFsSUQgPSBzcGFjZV9saWZ0XzEuTm9uZTtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gc3BhY2VfbGlmdF8xLk5vbmU7XG4gICAgICAgIHRoaXMuX2V2ZW50TG9nID0gW107IC8vIFRoZSBldmVudCBsb2dcbiAgICAgICAgdGhpcy5faGFkRnVuRXZhbCA9IGZhbHNlOyAvLyBXYXMgdGhpcyBjcmVhdGVkIGluIGEgZnVuY3Rpb24/XG4gICAgICAgIC8vcHVibGljIGdsb2JhbEZ1bklEID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgdGhpcy5nbG9iYWxGdW5JRCA9IDEwMDAwMDAwOyAvLyBUaGUgZ2xvYmFsIElEIGZvciBmdW5jdGlvbnMgaW4gdGhpcyBjb250ZXh0XG4gICAgICAgIHRoaXMuX3ZhckJpbmRpbmdzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuX2VmZmVjdHMgPSBlZmZlY3RzIHx8IG51bGw7XG4gICAgICAgIHRoaXMuX2V2ZW50TG9nID0gZXZlbnRMb2c7XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQgIT0gbnVsbCAmJiB0aGlzLl9wYXJlbnQuX2hhZEZ1bkV2YWwpXG4gICAgICAgICAgICB0aGlzLl9oYWRGdW5FdmFsID0gdHJ1ZTsgLy8gY29weSBmdW5jdGlvbiBldmFsIGZsYWcgZnJvbSBwYXJlbnRcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIGluZm9ybWF0aW9uIGZyb20gdGhpcyBTY29wZSBpbnRvIGFub3RoZXIgU2NvcGUgYW5kIHJldHVybnMgdGhlIG5ldyBTY29wZVxuICAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIGxldCBzID0gbmV3IFNjb3BlKHRoaXMuX3BhcmVudCwgdGhpcy5fZWZmZWN0cywgdGhpcy5fZXZlbnRMb2cpO1xuICAgICAgICBzLnZhckJpbmRpbmdzID0gbmV3IE1hcCh0aGlzLl92YXJCaW5kaW5ncyk7XG4gICAgICAgIHMuY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAgIHMuZXZlbnRMb2cgPSB0aGlzLmV2ZW50TG9nO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjbGFyZXMgYSBuZXcgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gYmUgZGVjbGFyZWRcbiAgICAgKi9cbiAgICBkZWNsYXJlKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZhckJpbmRpbmdzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2NvcGUgYWxyZWFkeSBoYXMgdmFyIHdpdGggbmFtZSBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhckJpbmRpbmdzLnNldChuYW1lLCBzcGFjZV9saWZ0XzEuTm9uZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgYSB2YWx1ZSB0byBhIHZhcmlhYmxlIGluIHRoaXMgQ29udGV4dFxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZVxuICAgICAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZVxuICAgICAqL1xuICAgIGFzc2lnbihuYW1lLCB2YWwpIHtcbiAgICAgICAgdGhpcy5fdmFyQmluZGluZ3Muc2V0KG5hbWUsIHNwYWNlX2xpZnRfMS5Tb21lKHZhbCkpOyAvL1NvbWUodmFsKT9cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3MgdXAgYSB2YWx1ZSB3aXRoaW4gdGhlIFNjb3BlIGFuZCBhbGwgaXRzIGFuY2VzdG9yIFNjb3Blc1xuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHNlYXJjaCB3aXRoaW5cbiAgICAgKi9cbiAgICBsb29rdXAobmFtZSwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dC52YXJCaW5kaW5ncy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnZhckJpbmRpbmdzLmdldChuYW1lKS5pc0RlZmluZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoY29udGV4dC52YXJCaW5kaW5ncy5nZXQobmFtZSkuZ2V0KCkpOyAvL2V4dHJhIGdldCB0byBtYW5hZ2UgU29tZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoY29udGV4dC5wYXJlbnQgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvb2t1cChuYW1lLCBjb250ZXh0LnBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgY291bGQgbm90IGJlIGZvdW5kLlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3MgdXAgYW5kIHJldHVybnMgdGhlIHJldHVybiBJRCB2YWx1ZVxuICAgICAqL1xuICAgIHJldElETG9va3VwKCkge1xuICAgICAgICBpZiAodGhpcy5fcmV0VmFsSUQuaXNEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXRWYWxJRC5nZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50LnJldElETG9va3VwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNhbGxlci5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTWFwIG9mIHZhcmlhYmxlIGJpbmRpbmdzXG4gICAgICovXG4gICAgZ2V0IHZhckJpbmRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFyQmluZGluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIE1hcCBvZiB2YXJpYWJsZSBiaW5kaW5nc1xuICAgICAqL1xuICAgIHNldCB2YXJCaW5kaW5ncyhtKSB7XG4gICAgICAgIHRoaXMuX3ZhckJpbmRpbmdzID0gbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFyZW50IFNjb3BlXG4gICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmV0dXJuIHZhbHVlIElEXG4gICAgICovXG4gICAgZ2V0IHJldFZhbElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV0VmFsSUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJldHVybiB2YWx1ZSBJRFxuICAgICAqL1xuICAgIHNldCByZXRWYWxJRCh2YWwpIHtcbiAgICAgICAgdGhpcy5fcmV0VmFsSUQgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEhUTUwgY2FudmFzXG4gICAgICovXG4gICAgZ2V0IGNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgSFRNTCBjYW52YXNcbiAgICAgKi9cbiAgICBzZXQgY2FudmFzKHZhbCkge1xuICAgICAgICB0aGlzLl9jYW52YXMgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVmZmVjdHMgYXJyYXlcbiAgICAgKi9cbiAgICBnZXQgZWZmZWN0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VmZmVjdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGVmZmVjdHMgYXJyYXlcbiAgICAgKi9cbiAgICBzZXQgZWZmZWN0cyhhcnIpIHtcbiAgICAgICAgdGhpcy5fZWZmZWN0cyA9IGFycjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZXZlbnQgbG9nXG4gICAgICovXG4gICAgZ2V0IGV2ZW50TG9nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRMb2c7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGV2ZW50IGxvZ1xuICAgICAqL1xuICAgIHNldCBldmVudExvZyh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRMb2cgPSB1cGRhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFycmF5IG9mIGVmZmVjdHNcbiAgICAgKi9cbiAgICBnZXQgbXVsU2VsQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tdWxTZWxBcnJheTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYXJyYXkgb2YgZWZmZWN0c1xuICAgICAqL1xuICAgIHNldCBtdWxTZWxBcnJheSh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbXVsU2VsQXJyYXkgPSB1cGRhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIFNjb3BlIHdhcyBjcmVhdGVkIGluIGEgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBnZXQgaGFkRnVuRXZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhZEZ1bkV2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciB0aGlzIFNjb3BlIHdhcyBjcmVhdGVkIGluIGEgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBzZXQgaGFkRnVuRXZhbCh2YWwpIHtcbiAgICAgICAgdGhpcy5faGFkRnVuRXZhbCA9IHZhbDtcbiAgICB9XG59XG5leHBvcnRzLlNjb3BlID0gU2NvcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY29wZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNjb3BlXzEgPSByZXF1aXJlKFwiLi9TY29wZVwiKTtcbmNvbnN0IHNwYWNlX2xpZnRfMSA9IHJlcXVpcmUoXCJzcGFjZS1saWZ0XCIpO1xuY2xhc3MgU2VxdWVuY2VOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBTZXF1ZW5jZU5vZGUsIHRoZSBidWlsZGluZyBibG9jayBvZiB0aGUgQVNUXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgc2lkZSBvZiB0aGUgU2VxdWVuY2VcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIFNlcXVlbmNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdGhpcy5fbmV3TGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgdGhlIGNoaWxkcmVuIGluIHBvc3RvcmRlciAobGVmdCwgcmlnaHQsIHBhcmVudClcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBwcm9ncmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBldmFsKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxlZnRTY29wZSA9IG5ldyBTY29wZV8xLlNjb3BlKGNvbnRleHQsIGNvbnRleHQuZWZmZWN0cywgY29udGV4dC5ldmVudExvZyk7XG4gICAgICAgIGxlZnRTY29wZS5jYW52YXMgPSBzcGFjZV9saWZ0XzEuU29tZShjb250ZXh0LmNhbnZhcy5nZXQoKSk7XG4gICAgICAgIC8vdGhyb3dpbmcgYXdheSBhZnRlciBldmFsaW5nXG4gICAgICAgIHRoaXMuX2xlZnRWYWwgPSB0aGlzLl9sZWZ0LmV2YWwobGVmdFNjb3BlKTtcbiAgICAgICAgdGhpcy5fcmlnaHRWYWwgPSB0aGlzLl9yaWdodC5ldmFsKGxlZnRTY29wZSk7IC8vIGxlZnRTY29wZSBtYXkgYmUgbW9kaWZpZWQgbm93XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcXVlbmNlTm9kZXMgY2Fubm90IGJlIGRpcmVjdGx5IGRyYXduXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBkcmF3KCkgb24gU2VxdWVuY2VOb2Rlc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBkaXJlY3RseSBjYWxsZWQgb24gU2VxdWVuY2VOb2Rlc1xuICAgICAqIEBwYXJhbSByaWdodFxuICAgICAqL1xuICAgIGVxdWFsc1ZhbChyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBlcXVhbHMgb24gU2VxdWVuY2VOb2RlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBBU1RcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuX2xlZnQudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMuX2xlZnQubmV3TGluZSgpID09IHRydWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIjtcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcmlnaHQubmV3TGluZSgpID09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5fcmlnaHQudG9TdHJpbmcoKSArIFwiO1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuX3JpZ2h0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVmdCBjaGlsZFxuICAgICAqL1xuICAgIHNldCBsZWZ0KGxlZnQpIHtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxlZnQgY2hpbGRcbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJpZ2h0IGNoaWxkXG4gICAgICovXG4gICAgc2V0IHJpZ2h0KHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJpZ2h0IGNoaWxkXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBsZWZ0IGNoaWxlXG4gICAgICovXG4gICAgZ2V0IGxlZnRWYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0VmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgcmlnaHQgY2hpbGVcbiAgICAgKi9cbiAgICBnZXQgcmlnaHRWYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodFZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdMaW5lO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VxdWVuY2VOb2RlID0gU2VxdWVuY2VOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VxdWVuY2VOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi8uLi9pbmRleFwiKTtcbmNvbnN0IGluZGV4XzIgPSByZXF1aXJlKFwiLi4vLi4vaW5kZXhcIik7XG5jb25zdCBzcGFjZV9saWZ0XzEgPSByZXF1aXJlKFwic3BhY2UtbGlmdFwiKTtcbmxldCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbmxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xubGV0IGlucHV0Qm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lucHV0Jyk7XG5sZXQgbGFzdFdvcmtpbmdJbnB1dFRleHQgPSBcIlwiO1xubGV0IHN0YXJDb3VudCA9IDA7XG4vL3RoZSBlZmZlY3RzIGFycmF5IHRoYXQgaG9sZHMgYWxsIHRoZSB0ZXh0LCBlbGxpcHNlcywgYW5kIHJlY3RhbmdsZXNcbmxldCBlZmZlY3RzID0gW107XG5sZXQgYXN0O1xubGV0IGNvbnRleHQ7XG5sZXQgc2hvd0RlYnVnID0gdHJ1ZTsgLy8gZmxhZyB0byBzaG93IG9yIGhpZGUgZGVidWcgYnV0dG9uXG5sZXQgbWFzdGVyTG9nID0gW107XG5sZXQgc2VsZWN0ZWRFbGVtcyA9IFtdO1xubGV0IGNoZWNrcG9pbnQgPSBudWxsO1xubGV0IG1vZEdlbiA9IG5ldyBpbmRleF8yLk1vZHVsZUdlbmVyYXRvcihmYWxzZSk7XG5sZXQgY2hlY2twb2ludElzQWN0aXZlID0gZmFsc2U7XG5sZXQgdGV4dEJveFNlbGVjdGVkOyAvL3NlZXMgaWYgdGhlIHRleHQgYm94IGlzIHNlbGVjdGVkXG5sZXQgY2FudmFzSXNEaXNhYmxlZCA9IGZhbHNlO1xubGV0IHNlbGVjdGVkID0gMDsgLy90aGUgbnVtYmVyIG9mIHNlbGVjdGVkIGVmZmVjdHMgaWYgbXVsdGlwbHkgc2VsZWN0aW5nXG5sZXQgYWxyZWFkeUxvZ2dlZCA9IGZhbHNlO1xubGV0IG51bUxvZ2dlZCA9IDA7XG5sZXQgZ2xvYmFsSUQgPSAxO1xubGV0IGVwaDtcbi8qXG5sZXQgYnVnQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlYnVnJyk7XG5pZighc2hvd0RlYnVnKXtcbiAgICBidWdCdXR0b24uc3R5bGUudmlzaWJpbGl0eT0naGlkZGVuJztcbn1cblxuYnVnQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbigpe1xuICAgIHByaW50TG9nKCk7XG59XG4qL1xuLyoqXG4gKiA8ZGl2IGNsYXNzPVwiY29sLWl0ZW1cIj5cbiAqICA8YnV0dG9uIGlkPSdwYWludCcgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiNERkI1MzRcIj4gUnVuIDwvYnV0dG9uPlxuICogPC9kaXY+XG4gKlxuICogUHV0IHRoaXMgaW4gaHRtbCBmaWxlIGZvciBSdW4gYnV0dG9uJ3Mgc3R5bGluZ1xuICovXG4vL2xldCBwYWludEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYWludCcpO1xuLyoqXG4gKiBtYWtlcyB0aGUgcGFpbnQgYnV0dG9uIHBhaW50IHRleHQgZnJvbSB0aGUgdGV4dGFyZWEgdG8gdGhlIGNhbnZhcyFcbiAqL1xuLypcbnBhaW50QnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWZmZWN0cy5sZW5ndGggPSAwOyAvLyBzbGlnaHRseSBza2V0Y2ggY2xlYXJpbmcgbWV0aG9kIHRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBhcnJheVxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgIGlzUGFpbnRpbmcgPSB0cnVlO1xuICAgIGxldCBpbnB1dFRleHQgPSBpbnB1dEJveC52YWx1ZTtcblxuICAgIGxldCBhc3RPcHQgPSBQYXJzZXIucGFyc2UoaW5wdXRUZXh0KTtcbiAgICBpZihhc3RPcHQuaXNEZWZpbmVkKCkpe1xuICAgICAgICBhc3QgPSBhc3RPcHQuZ2V0KCk7XG4gICAgICAgIGNvbnRleHQgPSBuZXcgU2NvcGUobnVsbCwgZWZmZWN0cywgbWFzdGVyTG9nKTtcbiAgICAgICAgY29udGV4dC5jYW52YXMgPSBTb21lKGNhbnZhcyk7XG4gICAgICAgIGFzdC5ldmFsKGNvbnRleHQpOyAvL3RoaXMgaXMgd2hlcmUgd2UgZHJhdyB0aGUgb2JqZWN0cyB0byB0aGUgc2NyZWVuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGVycm9yID0gXCJlcnJvciB0ZXh0XCI7XG4gICAgICAgIGFsZXJ0KFwiUXVhbjogc28gc29tZXRoaW5nIHdpdGggdGhpcyBzeW50YXggZXJyb3I6IFwiICsgZXJyb3IpO1xuICAgIH1cblxuICAgIC8vbGV0IHBhaW50RXZ0ID0gbmV3IFBhaW50RXZlbnQoaW5wdXRUZXh0KTsgLy8gd2lsbCBuZWVkIHRvIGdldCBmcm9tIGFzdCB3aGVuIHRoYXQncyBpbXBsZW1lbnRlZFxuXG4gICAgLy8gQWRkaW5nIGNvbnRleHQgbG9nIHRvIG1hc3RlciBsb2dcbiAgICAvL2xvZ0V2ZW50LnB1c2gocGFpbnRFdnQuYXNzZW1ibGVMb2coKSk7XG4gICAgcHJpbnRMb2coKTtcbiAgICAvL2V2ZW50MS5sb2dJdGVtKCk7XG4gICAgLy8gfVxufTtcbiovXG4vL2NsZWFycyB0aGUgY2FudmFzIVxubGV0IHJlc2V0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlc2V0Jyk7XG5yZXNldEJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjaGVja3BvaW50Ll9zdGFydGVyQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHRleHRCb3hTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlucHV0Qm94LnZhbHVlID0gY2hlY2twb2ludC5fc3RhcnRlckNvZGU7XG4gICAgfVxuICAgIGNvbnRleHQuZXZlbnRMb2cucHVzaChuZXcgaW5kZXhfMi5DbGVhckV2ZW50KCkpO1xuICAgIG1hc3RlckxvZy5wdXNoKGNvbnRleHQuZXZlbnRMb2dbY29udGV4dC5ldmVudExvZy5sZW5ndGggLSAxXSk7IC8vIERvZXMgdGhpcyBhY3R1YWxseSB3b3JrP1xuICAgIHByaW50TG9nKCk7XG4gICAgLy9sZXQgY2xlYXJFdnQgPSBuZXcgQ2xlYXJFdmVudCgpO1xuICAgIC8vbG9nRXZlbnQucHVzaChjbGVhckV2dC5hc3NlbWJsZUxvZygpKTtcbiAgICAvL2NvbnNvbGUubG9nKFwiTG9nOiBcIiArIGxvZ0V2ZW50KTtcbn07XG5sZXQgdGltZXIgPSBudWxsO1xuaW5wdXRCb3gub25rZXlkb3duID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aW1lciAhPSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgfVxuICAgIHRpbWVyID0gc2V0VGltZW91dChwYXJzZSwgMjAwKTtcbn07XG5mdW5jdGlvbiBwYXJzZSgpIHtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgbGV0IGlucHV0VGV4dCA9IGlucHV0Qm94LnZhbHVlO1xuICAgIGxldCBhc3RPcHQgPSBpbmRleF8xLlBhcnNlci5wYXJzZShpbnB1dFRleHQpO1xuICAgIGVmZmVjdHMubGVuZ3RoID0gMDsgLy8gc2xpZ2h0bHkgc2tldGNoIGNsZWFyaW5nIG1ldGhvZCB0byBtYWludGFpbiByZWZlcmVuY2UgdG8gb3JpZ2luYWwgYXJyYXlcbiAgICBpZiAoYXN0T3B0LmlzRGVmaW5lZCgpKSB7XG4gICAgICAgIGFzdCA9IGFzdE9wdC5nZXQoKTtcbiAgICAgICAgY29udGV4dCA9IG5ldyBpbmRleF8yLlNjb3BlKG51bGwsIGVmZmVjdHMsIG1hc3RlckxvZyk7XG4gICAgICAgIGNvbnRleHQuY2FudmFzID0gc3BhY2VfbGlmdF8xLlNvbWUoY2FudmFzKTtcbiAgICAgICAgYXN0LmV2YWwoY29udGV4dCk7IC8vdGhpcyBpcyB3aGVyZSB3ZSBkcmF3IHRoZSBvYmplY3RzIHRvIHRoZSBzY3JlZW5cbiAgICAgICAgbGFzdFdvcmtpbmdJbnB1dFRleHQgPSBpbnB1dFRleHQ7XG4gICAgfVxuICAgIC8vbGV0IHBhaW50RXZ0ID0gbmV3IFBhaW50RXZlbnQoaW5wdXRUZXh0KTsgLy8gd2lsbCBuZWVkIHRvIGdldCBmcm9tIGFzdCB3aGVuIHRoYXQncyBpbXBsZW1lbnRlZFxuICAgIC8vIEFkZGluZyBjb250ZXh0IGxvZyB0byBtYXN0ZXIgbG9nXG4gICAgLy9sb2dFdmVudC5wdXNoKHBhaW50RXZ0LmFzc2VtYmxlTG9nKCkpO1xuICAgIHByaW50TG9nKCk7XG4gICAgLy9ldmVudDEubG9nSXRlbSgpO1xuICAgIC8vIH1cbn1cbi8qKlxuICogVGhlIGFuaW1hdGlvbiBmdW5jdGlvbiB0aGF0IGJhc2ljYWxseSByZWN1cnNpdmVseSBjYWxscyBpdHNlbGYsIGNsZWFyaW5nIGFuZFxuICogcmVkcmF3aW5nIHRvIHRoZSBjYW52YXMgYXQgNjBmcHMuXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsgLy9jbGVhcnMgY2FudmFzXG4gICAgc2VsZWN0ZWQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWZmZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlZmZlY3RzW2ldLnVwZGF0ZSgpO1xuICAgICAgICBpZiAoZWZmZWN0c1tpXS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRFbGVtcy5wdXNoKGVmZmVjdHNbaV0pO1xuICAgICAgICAgICAgc2VsZWN0ZWQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0c1tpXS5nZXRKdXN0RHJhZ2dlZCgpKSB7IC8vIExvZ3MgZHJhZyBldmVudFxuICAgICAgICAgICAgY29udGV4dC5ldmVudExvZy5wdXNoKG5ldyBpbmRleF8yLkRyYWdFdmVudChlZmZlY3RzW2ldKSk7XG4gICAgICAgICAgICBtYXN0ZXJMb2cucHVzaChjb250ZXh0LmV2ZW50TG9nW2NvbnRleHQuZXZlbnRMb2cubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgZWZmZWN0c1tpXS5zZXRKdXN0RHJhZ2dlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdHNbaV0uaWRPYmogPT0gdW5kZWZpbmVkKSB7IC8vIEdpdmVzIG9iamVjdCBhbiBJRCBpZiBpdCBkb2Vzbid0IGhhdmUgb25lXG4gICAgICAgICAgICBlZmZlY3RzW2ldLmluaXRJRChnbG9iYWxJRCk7XG4gICAgICAgICAgICBjb250ZXh0LmV2ZW50TG9nLnB1c2gobmV3IGluZGV4XzIuSURFdmVudChlZmZlY3RzW2ldKSk7IC8vIExvZ3MgSURcbiAgICAgICAgICAgIGdsb2JhbElEKys7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVmZmVjdHNbaV0uZ2V0SUQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYoKChlZmZlY3RzW2ldIGFzIEVsbGlwc2VFZmZlY3QpLmp1c3REcmFnZ2VkKSl7XG4gICAgICAgIC8vICAgICAvL2NvbnRleHQuZXZlbnRMb2cucHVzaChuZXcgRHJhZ0V2ZW50KGVmZmVjdHNbaV0pKTtcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBoYXZlIGl0ZXJhdGVkIHRocm91Z2ggYWxsIGVmZmVjdHMgYW5kIGhhdmUgY29tcGxldGUgbGlzdCB0byBsb2dcbiAgICBpZiAoc2VsZWN0ZWQgIT0gbnVtTG9nZ2VkKSB7IC8vIGlmIHNlbGVjdGlvbnMgaGF2ZSBjaGFuZ2VkLCBzaG91bGQgbG9nIGFnYWluXG4gICAgICAgIGFscmVhZHlMb2dnZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFhbHJlYWR5TG9nZ2VkICYmIHNlbGVjdGVkID49IDIpIHsgLy8gbG9ncyBpZiBoYXNuJ3QgYWxyZWFkeVxuICAgICAgICBudW1Mb2dnZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgY29udGV4dC5ldmVudExvZy5wdXNoKG5ldyBpbmRleF8yLlNlbGVjdEV2ZW50KHNlbGVjdGVkRWxlbXMpKTtcbiAgICAgICAgbWFzdGVyTG9nLnB1c2goY29udGV4dC5ldmVudExvZ1tjb250ZXh0LmV2ZW50TG9nLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgYWxyZWFkeUxvZ2dlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vVGhpcyBkb2VzIHRoZSBwcm9kaXJlY3QgbWFuaXB1bGF0aW9uLCBwYXNzaW5nIHRoZSBuZXcgc3RyaW5ncyB0byB0aGUgdGV4dCBib3hcbiAgICBpZiAoYXN0ICE9IHVuZGVmaW5lZCAmJiAhdGV4dEJveFNlbGVjdGVkKSB7XG4gICAgICAgIGxldCBuZXdJbnB1dCA9IGFzdC50b1N0cmluZygpO1xuICAgICAgICBpbnB1dEJveC52YWx1ZSA9IG5ld0lucHV0O1xuICAgIH1cbiAgICBpZiAoY2hlY2twb2ludElzQWN0aXZlKSB7XG4gICAgICAgIGNoZWNrcG9pbnRDaGVja3NHb2FsKCk7XG4gICAgfVxuICAgIGlmIChjaGVja3BvaW50ICE9IG51bGwgJiYgY2hlY2twb2ludC5kcmF3R3VpZGVzICE9IG51bGwpIHtcbiAgICAgICAgY2hlY2twb2ludC5kcmF3R3VpZGVzKGN0eCk7XG4gICAgICAgIC8qXG4gICAgICAgICAgICAgIGlmIChjaGVja3BvaW50Ll9uYW1lID09IFwibDFjM1wiKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZWN0KDEwLCA0MzAsIDEwMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IDIwICsgXCJweCBDb3VyaWVyIE5ld1wiO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzZDNkM2Qyc7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFwiUHV0IHRleHRcIiwgMTAsIDM5MCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFwiaW4gaGVyZVwiLCAxMCwgNDEwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAqL1xuICAgIH1cbiAgICBzZWxlY3RlZEVsZW1zID0gW107XG59XG4vL2NoZWNrcyB0byBzZWUgd2hldGhlciB0aGUgdGV4dCBib3ggaXMgc2VsZWN0ZWRcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBpc0lucHV0Qm94U2VsZWN0ZWQpO1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIG1hbmFnZXMgdGhlIHN0YXRlIG9mIHRoZSBVSSB3aGVuIHRoZSB0ZXh0IGJveCBpcyBzZWxlY3RlZCBhbmQgd2hlbiBpdCBpc24ndC5cbiAqIElmIGl0IGlzIGluc2lkZSB0aGUgdGV4dCBib3gsIGlzUGFpbnRpbmcgaXMgZmFsc2UgYW5kIHRleHRCb3hTZWxlY3RlZCBpcyB0cnVlLlxuICogSWYgaXQncyBub3QsIGlmIGl0J3MgaW5zaWRlIHRoZSBwYWludCBidXR0b24sIHRoZW4gaXNQYWludGluZyA9IHRydWUuXG4gKiBAcGFyYW0gZXZlbnQgdGhlIG1vdXNlIGRvd24gZXZlbnRcbiAqL1xuZnVuY3Rpb24gaXNJbnB1dEJveFNlbGVjdGVkKGV2ZW50KSB7XG4gICAgbGV0IG1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgbGV0IG1vdXNlWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgbGV0IHJlY3QgPSBpbnB1dEJveC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAobW91c2VYID4gcmVjdC5sZWZ0ICYmIG1vdXNlWCA8IHJlY3QucmlnaHQgJiYgbW91c2VZID4gcmVjdC50b3AgJiYgbW91c2VZIDwgcmVjdC5ib3R0b20pIHtcbiAgICAgICAgdGV4dEJveFNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRleHRCb3hTZWxlY3RlZCA9IGZhbHNlO1xuICAgIH1cbn1cbi8vY2hlY2tzIHRvIHNlZSB3aGV0aGVyIHRoZSB0ZXh0IGJveCBpcyBzZWxlY3RlZFxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGRpc2FibGVkQ2FudmFzSXNTZWxlY3RlZCk7XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyB0aGUgY2FzZSB3aGVuIGEgZGlzYWJsZWQgY2FudmFzIGlzIHNlbGVjdGVkLlxuICogQHBhcmFtIGV2ZW50IHRoZSBtb3VzZSBkb3duIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVkQ2FudmFzSXNTZWxlY3RlZChldmVudCkge1xuICAgIGxldCBtb3VzZVggPSBldmVudC5jbGllbnRYO1xuICAgIGxldCBtb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBwb3BVcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwb3B1cCcpO1xuICAgIGlmIChjYW52YXNJc0Rpc2FibGVkICYmIG1vdXNlWCA+IHJlY3QubGVmdCAmJiBtb3VzZVggPCByZWN0LnJpZ2h0ICYmIG1vdXNlWSA+IHJlY3QudG9wICYmIG1vdXNlWSA8IHJlY3QuYm90dG9tKSB7XG4gICAgICAgIHBvcFVwLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9wVXAuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG59XG5mdW5jdGlvbiBwcmludExvZygpIHtcbiAgICBjb25zb2xlLmxvZyhcIkxvZzogXCIpO1xuICAgIGZvciAobGV0IGVsZW0gb2YgbWFzdGVyTG9nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVsZW0uYXNzZW1ibGVMb2coKSk7XG4gICAgfVxufVxubGV0IHBhbGV0dGVCdXR0b25zID0gW1xuICAgIFwiZWxsaXBzZVwiLCBcInJlY3RcIiwgXCJzdHJpbmdcIiwgXCJudW1iZXJcIixcbiAgICBcImxpbmVcIiwgXCJjdXJ2ZVwiXG5dO1xuZm9yIChsZXQgYnV0dG9uTmFtZSBvZiBwYWxldHRlQnV0dG9ucykge1xuICAgIGxldCBwYWxldHRlQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYnV0dG9uTmFtZSk7XG4gICAgcGFsZXR0ZUJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0ZXh0Qm94U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBwcmludE5ld05vZGUoYnV0dG9uTmFtZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHByaW50TmV3Tm9kZShidXR0b25OYW1lKSB7XG4gICAgbGV0IHByaW50TGluZSA9IFwiXCI7XG4gICAgc3dpdGNoIChidXR0b25OYW1lKSB7XG4gICAgICAgIGNhc2UgXCJlbGxpcHNlXCI6XG4gICAgICAgICAgICBwcmludExpbmUgPSBcInByaW50KGVsbGlwc2UoMTAwLDEwMCkpO1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWN0XCI6XG4gICAgICAgICAgICBwcmludExpbmUgPSBcInByaW50KHJlY3QoMTAwLDEwMCkpO1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHByaW50TGluZSA9ICdwcmludChcIm5ld1dvcmRcIik7JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBwcmludExpbmUgPSBcInByaW50KDEwKTtcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICAgICAgcHJpbnRMaW5lID0gXCJwcmludChsaW5lKDEwMCwxMDApKTtcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY3VydmVcIjpcbiAgICAgICAgICAgIHByaW50TGluZSA9IFwicHJpbnQoY3VydmUoMTAwLDEwMCwxMDApKTtcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQcm9ibGVtIHdpdGggXCIgKyBidXR0b25OYW1lKTtcbiAgICB9XG4gICAgaW5wdXRCb3gudmFsdWUgKz0gcHJpbnRMaW5lO1xuICAgIHBhcnNlKCk7XG59XG5sZXQgaW5zdHJ1Y3Rpb25zID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dvYWwnKTtcbmxldCByZXdhcmRCb3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmV3YXJkLWNvbnRhaW5lcicpO1xubGV0IGluc3RyTGFiZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5zdHItbGFiZWwnKTtcbi8vTWFwIG1haW50YWluaW5nIGNvZGUgbGFzdCB1c2VkIGF0IGEgY2hlY2twb2ludFxubGV0IGNwQ29kZSA9IG5ldyBNYXAoW1xuICAgIFsnbDFjMScsIFwiXCJdLFxuICAgIFsnbDFjMicsIFwiXCJdLFxuICAgIFsnbDFjMycsIFwiXCJdLFxuICAgIFsnbDFjNCcsIFwiXCJdLFxuICAgIFsnbDJjMScsIFwiXCJdLFxuICAgIFsnbDJjMicsIFwiXCJdLFxuICAgIFsnbDJjMycsIFwiXCJdLFxuICAgIFsnbDJjNCcsIFwiXCJdLFxuICAgIFsnbDJjNScsIFwiXCJdLFxuICAgIFsnbDJjNicsIFwiXCJdLFxuICAgIFsnbDJjNycsIFwiXCJdLFxuICAgIFsnbDNjMScsIFwiXCJdLFxuICAgIFsnbDNjMicsIFwiXCJdLFxuICAgIFsnbDNjMycsIFwiXCJdLFxuICAgIFsnbDNjNCcsIFwiXCJdLFxuICAgIFsnbDNjNScsIFwiXCJdLFxuICAgIFsnbDNjNicsIFwiXCJdLFxuICAgIFsnbDRjMScsIFwiXCJdLFxuICAgIFsnbDRjMicsIFwiXCJdXG5dKTtcbi8vTWFwIG1haW50YWluaW5nIHdoZXRoZXIgYSBjaGVja3BvaW50IGhhcyBiZWVuIGNvbXBsZXRlZFxubGV0IGNwQ29tcGxldGlvbiA9IG5ldyBNYXAoW1xuICAgIFsnbDFjMScsIGZhbHNlXSxcbiAgICBbJ2wxYzInLCBmYWxzZV0sXG4gICAgWydsMWMzJywgZmFsc2VdLFxuICAgIFsnbDFjNCcsIGZhbHNlXSxcbiAgICBbJ2wyYzEnLCBmYWxzZV0sXG4gICAgWydsMmMyJywgZmFsc2VdLFxuICAgIFsnbDJjMycsIGZhbHNlXSxcbiAgICBbJ2wyYzQnLCBmYWxzZV0sXG4gICAgWydsMmM1JywgZmFsc2VdLFxuICAgIFsnbDJjNicsIGZhbHNlXSxcbiAgICBbJ2wyYzcnLCBmYWxzZV0sXG4gICAgWydsM2MxJywgZmFsc2VdLFxuICAgIFsnbDNjMicsIGZhbHNlXSxcbiAgICBbJ2wzYzMnLCBmYWxzZV0sXG4gICAgWydsM2M0JywgZmFsc2VdLFxuICAgIFsnbDNjNScsIGZhbHNlXSxcbiAgICBbJ2wzYzYnLCBmYWxzZV0sXG4gICAgWydsNGMxJywgZmFsc2VdLFxuICAgIFsnbDRjMicsIGZhbHNlXVxuXSk7XG5sZXQgY3BOYW1lcyA9IFtcbiAgICAnbDFjMScsICdsMWMyJywgJ2wxYzMnLFxuICAgICdsMmMxJywgJ2wyYzInLCAnbDJjMycsICdsMmM0JywgJ2wyYzUnLFxuICAgICdsM2MxJywgJ2wzYzInLCAnbDNjMycsICdsM2M0JywgJ2wzYzUnLCAnbDNjNicgLyosXG4gICAgJ2w0YzEnLCAnbDRjMicqL1xuXTtcbmZvciAobGV0IGNwIG9mIGNwTmFtZXMpIHtcbiAgICBsZXQgY3BCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjcCk7XG4gICAgY3BCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5pdENoZWNrcG9pbnQoY3ApO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtb2R1bGUgY29ycmVzcG9uZGluZyB0byBhIGNoZWNrcG9pbnQgcGFzc2VkIGluLlxuICogU2V0cyB1cCB0aGUgaW5zdHJ1Y3Rpb24sIENPREUgYXJlYSwgYW5kIGdvYWwgYm94IGFjY29yZGluZ2x5LlxuICogQHBhcmFtIGNwOiB0aGUgbmFtZSBvZiB0aGUgY2hlY2twb2ludFxuICovXG5mdW5jdGlvbiBpbml0Q2hlY2twb2ludChjcCkge1xuICAgIC8vc3RvcmUgQ09ERSBvZiBvbGQgY2hlY2twb2ludFxuICAgIGlmIChjaGVja3BvaW50ICE9IG51bGwpIHtcbiAgICAgICAgY3BDb2RlLnNldChjaGVja3BvaW50Ll9uYW1lLCBpbnB1dEJveC52YWx1ZSk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFwiSW5pdGlhdGluZyBjaGVja3BvaW50IFwiICsgY3ApO1xuICAgIGNoZWNrcG9pbnQgPSBtb2RHZW4uZ2VuZXJhdGVDaGVja3BvaW50KGNwKTtcbiAgICBpbnN0ckxhYmVsLmlubmVySFRNTCA9IGNwICsgXCIgLSBHT0FMXCI7XG4gICAgaW5zdHJ1Y3Rpb25zLmlubmVySFRNTCA9IGNoZWNrcG9pbnQuX2luc3RydWN0aW9ucztcbiAgICAvL3NldCB1cCB0aGUgQ09ERSBhbmQgQ0FOVkFTIGFyZWFzXG4gICAgaWYgKGNoZWNrcG9pbnQuX2NvbnN0cmFpbnQgPT0gJ2NvZGUnKSB7XG4gICAgICAgIGlucHV0Qm94LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgaW5wdXRCb3guc3R5bGUub3BhY2l0eSA9ICcwLjUnO1xuICAgICAgICBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgICAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9ICcjRUJFQkVCJztcbiAgICAgICAgY2FudmFzSXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGVja3BvaW50Ll9jb25zdHJhaW50ID09ICdjYW52YXMnKSB7XG4gICAgICAgIGlucHV0Qm94LnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgaW5wdXRCb3guc3R5bGUub3BhY2l0eSA9ICcxLjAnO1xuICAgICAgICBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9ICcjQzBDMEMwJztcbiAgICAgICAgY2FudmFzSXNEaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbnB1dEJveC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgIGlucHV0Qm94LnN0eWxlLm9wYWNpdHkgPSAnMS4wJztcbiAgICAgICAgY2FudmFzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSAnI0VCRUJFQic7XG4gICAgICAgIGNhbnZhc0lzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHBvcFVwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BvcHVwJyk7XG4gICAgcG9wVXAuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZiAoY3BDb2RlLmdldChjaGVja3BvaW50Ll9uYW1lKSAhPT0gXCJcIikge1xuICAgICAgICB0ZXh0Qm94U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpbnB1dEJveC52YWx1ZSA9IGNwQ29kZS5nZXQoY2hlY2twb2ludC5fbmFtZSk7XG4gICAgfVxuICAgIC8vc2V0IHVwIHRoZSBpbnN0cnVjdGlvbiBhbmQgZ29hbCBib3hlc1xuICAgIGlmIChjcENvbXBsZXRpb24uZ2V0KGNwKSkge1xuICAgICAgICB1cGRhdGVSZXdhcmRCb3goKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChjaGVja3BvaW50Ll9zdGFydGVyQ29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0ZXh0Qm94U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaW5wdXRCb3gudmFsdWUgPSBjaGVja3BvaW50Ll9zdGFydGVyQ29kZTtcbiAgICAgICAgICAgIHBhcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1ckluc3RydWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnN0cnVjdGlvblwiKTtcbiAgICAgICAgaWYgKGN1ckluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN1ckluc3RydWN0aW9uLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja3BvaW50Ll9uYW1lID09PSBcImwxYzFcIikge1xuICAgICAgICAgICAgY2hlY2twb2ludC5yZW5kZXJJbnN0cnVjdGlvbihkb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV3YXJkQm94LnN0eWxlLmJhY2tncm91bmQgPSAnI0MwQzBDMCc7XG4gICAgICAgIGxldCByZXdhcmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmV3YXJkLXRleHQnKTtcbiAgICAgICAgcmV3YXJkLnN0eWxlLmNvbG9yID0gJ2JsYWNrJztcbiAgICAgICAgcmV3YXJkLmlubmVySFRNTCA9ICdDb21wbGV0ZSBnb2FsIHRvIGVhcm4gYSBzdGFyISc7XG4gICAgICAgIGxldCByZXdhcmRJbWcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmV3YXJkLWltYWdlJyk7XG4gICAgICAgIHJld2FyZEltZy5zcmMgPSAncGljcy9ncmV5c3Rhci5zdmcnO1xuICAgICAgICByZXdhcmRJbWcuYWx0ID0gJ2Egc3RhciB0byBiZSBlYXJuZWQnO1xuICAgICAgICBsZXQgbmV4dEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZXh0Jyk7XG4gICAgICAgIG5leHRCdG4uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgaW5zdHJ1Y3Rpb25zLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIGNoZWNrcG9pbnRJc0FjdGl2ZSA9IHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2twb2ludENoZWNrc0dvYWwoKSB7XG4gICAgaWYgKGNoZWNrcG9pbnQuY2hlY2tHb2FsKGRvY3VtZW50LCBlZmZlY3RzKSkge1xuICAgICAgICB1cGRhdGVSZXdhcmRCb3goKTtcbiAgICAgICAgY3BDb21wbGV0aW9uLnNldChjaGVja3BvaW50Ll9uYW1lLCB0cnVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVSZXdhcmRCb3goKSB7XG4gICAgcmV3YXJkQm94LnN0eWxlLmJhY2tncm91bmQgPSAnIzY3M0FCNyc7XG4gICAgY29uc29sZS5sb2coZG9jdW1lbnQpO1xuICAgIGxldCByZXdhcmRUZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jld2FyZC10ZXh0Jyk7XG4gICAgcmV3YXJkVGV4dC5zdHlsZS5jb2xvciA9ICcjRDhEOEQ4JztcbiAgICByZXdhcmRUZXh0LmlubmVySFRNTCA9IFwiR29hbCBtZXQhIENsaWNrICdOZXh0JyB0byBnbyB0byBuZXh0IGNoZWNrcG9pbnQhXCI7XG4gICAgbGV0IHJld2FyZEltZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXdhcmQtaW1hZ2UnKTtcbiAgICByZXdhcmRJbWcuc3JjID0gJ3BpY3Mvc3Rhci5zdmcnO1xuICAgIHJld2FyZEltZy5hbHQgPSAnc3RhciBlYXJuZWQnO1xuICAgIGxldCBuZXh0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25leHQnKTtcbiAgICBuZXh0QnRuLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGluc3RydWN0aW9ucy5zY3JvbGxUb3AgPSBpbnN0cnVjdGlvbnMuc2Nyb2xsSGVpZ2h0O1xuICAgIGNoZWNrcG9pbnRJc0FjdGl2ZSA9IGZhbHNlO1xufVxubGV0IG5leHRCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmV4dCcpO1xubmV4dEJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBuZXh0TW9kdWxlID0gY2hlY2twb2ludC5fbmV4dE1vZHVsZTtcbiAgICBpZiAobmV4dE1vZHVsZSAhPSAnJykge1xuICAgICAgICBpbml0Q2hlY2twb2ludChuZXh0TW9kdWxlKTtcbiAgICB9XG59O1xubGV0IHByZXZCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJldicpO1xucHJldkJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBwcmV2TW9kdWxlID0gY2hlY2twb2ludC5fcHJldk1vZHVsZTtcbiAgICBpZiAocHJldk1vZHVsZSAhPSAnJykge1xuICAgICAgICBpbml0Q2hlY2twb2ludChwcmV2TW9kdWxlKTtcbiAgICB9XG59O1xuLy9jYWxsIHRvIGFuaW1hdGVcbmFuaW1hdGUoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpLW5vbmRtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgVW5hcnlPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL1VuYXJ5T3BlcmF0aW9uXCIpO1xuY29uc3QgTnVtYmVyTm9kZV8xID0gcmVxdWlyZShcIi4uL3ByaW1zL051bWJlck5vZGVcIik7XG5jbGFzcyBOZWdPcCBleHRlbmRzIFVuYXJ5T3BlcmF0aW9uXzEuVW5hcnlPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBhIE5lZ2F0aW9uT3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gYmUgbmVnYXRlZCAobXVzdCBiZSBhIE51bWJlck5vZGUpXG4gICAgICogQHBhcmFtIHdzIFByZWNlZGluZyB3aGl0ZXNwYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFsLCB3cykge1xuICAgICAgICBzdXBlcih2YWwpO1xuICAgICAgICB0aGlzLl93cyA9IHdzO1xuICAgICAgICBpZiAod3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIHRoZSB2YWx1ZSBpbnRvIHRoZSBuZWdhdGl2ZSB2ZXJzaW9uXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIGxldCB2ID0gdGhpcy52YWwuZXZhbChjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJOb2RlXzEuTnVtYmVyTm9kZSgtdi52YWwsIFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOZWdPcHMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZWdhdGlvbiBvcHMgY2Fubm90IGJlIGRyYXduIGRpcmVjdGx5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVhbHMgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSBvbiBhIE5lZ09wXG4gICAgICogQHBhcmFtIHJpZ2h0XG4gICAgICovXG4gICAgZXF1YWxzVmFsKHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGVxdWFscyBvbiBOZWdPcFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgTmVnT3BcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzICsgXCItXCIgKyB0aGlzLnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHRlcm1pbmF0ZWQgYnkgYSBuZXdsaW5lICh0cnVlKSBvciBzZW1pY29sb24gKGZhbHNlKVxuICAgICAqL1xuICAgIG5ld0xpbmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLk5lZ09wID0gTmVnT3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OZWdPcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFVuYXJ5T3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBBYnN0cmFjdCBjbGFzcyBjb25zdHJ1Y3RvciBmb3IgVW5hcnkgT3BlcmF0aW9uc1xuICAgICAqIEBwYXJhbSBfdmFsIFRoZSBvYmplY3QgdG8gYmUgb3BlcmF0ZWQgb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfdmFsKSB7XG4gICAgICAgIHRoaXMuX3ZhbCA9IF92YWw7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IGRyYXcgbWV0aG9kIGZvciB1bmRyYXdhYmxlIFVuYXJ5T3BzXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZGltc1xuICAgICAqIEBwYXJhbSBhc3RcbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIGRpbXMsIGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFyeSBPcGVyYXRpb25zIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1YWxzIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgb24gVW5hcnlPcHNcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgZXF1YWxzIG9uIFVuYXJ5T3BcIik7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFVuYXJ5T3AgdmFsdWVcbiAgICAgKi9cbiAgICBnZXQgdmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBVbmFyeU9wIHZhbHVlXG4gICAgICovXG4gICAgc2V0IHZhbCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWwgPSB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLlVuYXJ5T3BlcmF0aW9uID0gVW5hcnlPcGVyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VbmFyeU9wZXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFZhcmlhYmxlTm9kZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGEgVmFyaWFibGVOb2RlLCBhIG5vZGUgcmVwcmVzZW50aW5nIGEgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgdmFyaWFibGUgbmFtZVxuICAgICAqIEBwYXJhbSB3cyBQcmVjZWRpbmcgd2hpdGVzcGFjZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHdzKSB7XG4gICAgICAgIHRoaXMuX25ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIGlmICh3cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyB1cCB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlIGluIHRoZSBjb250ZXh0XG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgcHJvZ3JhbSBjb250ZXh0XG4gICAgICovXG4gICAgZXZhbChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0Lmxvb2t1cCh0aGlzLl9uYW1lLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFyaWFibGVOb2RlcyBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSBkaW1zXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgZGltcywgYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGRyYXcgb24gdmFyaWFibGUgbm9kZXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWFscyBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5IG9uIFZhcmlhYmxlTm9kZXNcbiAgICAgKiBAcGFyYW0gcmlnaHRcbiAgICAgKi9cbiAgICBlcXVhbHNWYWwocmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRpcmVjdGx5IGNvbXBhcmUgdmFycywgZXZhbCBmaXJzdFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFyaWFibGVOb2RlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyArIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGVybWluYXRlZCBieSBhIG5ld2xpbmUgKHRydWUpIG9yIHNlbWljb2xvbiAoZmFsc2UpXG4gICAgICovXG4gICAgbmV3TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0xpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5WYXJpYWJsZU5vZGUgPSBWYXJpYWJsZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WYXJpYWJsZU5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgU2hhbGxvdyB1cGRhdGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4vKiogUGVyZm9ybXMgYSBzaGFsbG93IHVwZGF0ZSBvZiBhbiBvYmplY3QgdXNpbmcgYSBwYXJ0aWFsIG9iamVjdCBvZiB0aGUgc2FtZSBzaGFwZS4gQSBuZXcgb2JqZWN0IGlzIHJldHVybmVkLiAqL1xuZnVuY3Rpb24gdXBkYXRlKGhvc3QsIHNwZWMpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2xvbmUoaG9zdCk7XG4gICAgZm9yICh2YXIga2V5IGluIHNwZWMpIHtcbiAgICAgICAgdmFyIHNwZWNWYWx1ZSA9IHNwZWNba2V5XTtcbiAgICAgICAgaWYgKHNwZWNWYWx1ZSA9PT0gZXhwb3J0cy5ERUxFVEUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gc3BlY1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnVwZGF0ZSA9IHVwZGF0ZTtcbi8vIFdlIGxpZSBhYm91dCB0aGUgcHVibGljIHR5cGUgc28gdGhhdCBvbmx5IGEgcHJvcGVydHkgdGhhdCBpcyBvcHRpb25hbCBvciB0aGF0IGNhbiBiZSBhc3NpZ25lZCB0byB1bmRlZmluZWQgY2FuIGJlIERFTEVURSdkXG4vKiogTWFya2VyIHVzZWQgdG8gZGVsZXRlIGEga2V5ICovXG5leHBvcnRzLkRFTEVURSA9IHt9O1xudmFyIF9VcGRhdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9VcGRhdGVyKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGtleU9ySW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfVXBkYXRlcih7IHR5cGU6ICdhdCcsIHBhcmVudDogdGhpcywgZmllbGQ6IGtleU9ySW5kZXggfSk7XG4gICAgfTtcbiAgICBfVXBkYXRlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkb1NldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5jbG9uZUZvclVwZGF0ZSh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5uYW1lID09PSAnYWJvcnRlZCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIHZhciBjbG9uZWRUYXJnZXQgPSByZXN1bHQuY2xvbmVkVGFyZ2V0LCBsZWFmSG9zdCA9IHJlc3VsdC5sZWFmSG9zdCwgZmllbGQgPSByZXN1bHQuZmllbGQ7XG4gICAgICAgICAgICB2YWx1ZSA9PT0gZXhwb3J0cy5ERUxFVEUgPyBkZWxldGUgbGVhZkhvc3RbZmllbGRdIDogbGVhZkhvc3RbZmllbGRdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkVGFyZ2V0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYm91bmRUYXJnZXQgPSB0aGlzLmZpbmRCb3VuZFRhcmdldCgpO1xuICAgICAgICByZXR1cm4gYm91bmRUYXJnZXRcbiAgICAgICAgICAgID8gZG9TZXQoYm91bmRUYXJnZXQpXG4gICAgICAgICAgICA6IGRvU2V0O1xuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLm1vZGlmeSA9IGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZG9Nb2RpZnkgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMuY2xvbmVGb3JVcGRhdGUodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubmFtZSA9PT0gJ2Fib3J0ZWQnKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB2YXIgY2xvbmVkVGFyZ2V0ID0gcmVzdWx0LmNsb25lZFRhcmdldCwgbGVhZkhvc3QgPSByZXN1bHQubGVhZkhvc3QsIGZpZWxkID0gcmVzdWx0LmZpZWxkO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbW9kaWZpZXIobGVhZkhvc3RbZmllbGRdKTtcbiAgICAgICAgICAgIHZhbHVlID09PSBleHBvcnRzLkRFTEVURSA/IGRlbGV0ZSBsZWFmSG9zdFtmaWVsZF0gOiBsZWFmSG9zdFtmaWVsZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZWRUYXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBib3VuZFRhcmdldCA9IHRoaXMuZmluZEJvdW5kVGFyZ2V0KCk7XG4gICAgICAgIHJldHVybiBib3VuZFRhcmdldFxuICAgICAgICAgICAgPyBkb01vZGlmeShib3VuZFRhcmdldClcbiAgICAgICAgICAgIDogZG9Nb2RpZnk7XG4gICAgfTtcbiAgICBfVXBkYXRlci5wcm90b3R5cGUud2l0aERlZmF1bHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfVXBkYXRlcih7IHR5cGU6ICd3aXRoRGVmYXVsdCcsIHBhcmVudDogdGhpcywgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KTtcbiAgICB9O1xuICAgIF9VcGRhdGVyLnByb3RvdHlwZS5hYm9ydElmVW5kZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1VwZGF0ZXIoeyB0eXBlOiAnYWJvcnRJZlVuZGVmJywgcGFyZW50OiB0aGlzIH0pO1xuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLmZpbmRCb3VuZFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuZGF0YS50eXBlID09PSAncm9vdCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZGF0YS5ib3VuZFRhcmdldDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmRhdGEucGFyZW50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVXBkYXRlci5wcm90b3R5cGUucGFyZW50VXBkYXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1cGRhdGVycyA9IFt0aGlzXTtcbiAgICAgICAgdmFyIHBhcmVudFVwZGF0ZXIgPSB0aGlzLmRhdGEucGFyZW50O1xuICAgICAgICAvLyBJZ25vcmUgdGhlIHJvb3QgdXBkYXRlclxuICAgICAgICB3aGlsZSAocGFyZW50VXBkYXRlciAmJiBwYXJlbnRVcGRhdGVyLmRhdGEucGFyZW50KSB7XG4gICAgICAgICAgICB1cGRhdGVycy51bnNoaWZ0KHBhcmVudFVwZGF0ZXIpO1xuICAgICAgICAgICAgcGFyZW50VXBkYXRlciA9IHBhcmVudFVwZGF0ZXIuZGF0YS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVwZGF0ZXJzO1xuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLmdldE5leHRWYWx1ZSA9IGZ1bmN0aW9uIChwcmV2aW91c0hvc3QsIGhvc3QsIGZpZWxkLCBpc0xhc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS50eXBlID09PSAnYXQnKSB7XG4gICAgICAgICAgICB2YXIgbmV3RmllbGQgPSB0aGlzLmRhdGEuZmllbGQ7XG4gICAgICAgICAgICB2YXIgdmFsdWVfMSA9IGhvc3RbbmV3RmllbGRdO1xuICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IGlzT2JqZWN0T3JBcnJheSh2YWx1ZV8xKSA/IGNsb25lKHZhbHVlXzEpIDogdmFsdWVfMTtcbiAgICAgICAgICAgIHZhciBuZXdIb3N0XzEgPSBpc0xhc3QgPyBob3N0IDogbmV4dFZhbHVlO1xuICAgICAgICAgICAgaG9zdFt0aGlzLmRhdGEuZmllbGRdID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgaG9zdDogbmV3SG9zdF8xLCBmaWVsZDogbmV3RmllbGQgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBwcmV2aW91c0hvc3RbZmllbGRdO1xuICAgICAgICBpZiAodGhpcy5kYXRhLnR5cGUgPT09ICdhYm9ydElmVW5kZWYnICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGhvc3Q6IGhvc3QsIGZpZWxkOiBmaWVsZCwgYWJvcnRlZDogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhdGEudHlwZSA9PT0gJ3dpdGhEZWZhdWx0JyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gdGhpcy5kYXRhLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIHZhciBuZXdIb3N0XzIgPSBpc0xhc3QgPyBwcmV2aW91c0hvc3QgOiBuZXh0VmFsdWU7XG4gICAgICAgICAgICBwcmV2aW91c0hvc3RbZmllbGRdID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgaG9zdDogbmV3SG9zdF8yLCBmaWVsZDogZmllbGQgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3SG9zdCA9IGlzTGFzdCA/IHByZXZpb3VzSG9zdCA6IGhvc3Q7XG4gICAgICAgIHJldHVybiB7IGhvc3Q6IG5ld0hvc3QsIGZpZWxkOiBmaWVsZCB9O1xuICAgIH07XG4gICAgX1VwZGF0ZXIucHJvdG90eXBlLmNsb25lRm9yVXBkYXRlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB2YXIgdXBkYXRlcnMgPSB0aGlzLnBhcmVudFVwZGF0ZXJzKCk7XG4gICAgICAgIHZhciBvYmogPSBjbG9uZSh0YXJnZXQpO1xuICAgICAgICB2YXIgcHJldmlvdXNIb3N0ID0gb2JqO1xuICAgICAgICB2YXIgaG9zdCA9IG9iajtcbiAgICAgICAgdmFyIGZpZWxkID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB1cGRhdGVyc1tpXS5nZXROZXh0VmFsdWUocHJldmlvdXNIb3N0LCBob3N0LCBmaWVsZCwgaSA9PT0gdXBkYXRlcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogJ2Fib3J0ZWQnIH07XG4gICAgICAgICAgICBwcmV2aW91c0hvc3QgPSBob3N0O1xuICAgICAgICAgICAgaG9zdCA9IHJlc3VsdC5ob3N0O1xuICAgICAgICAgICAgZmllbGQgPSByZXN1bHQuZmllbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdyZXN1bHQnLFxuICAgICAgICAgICAgY2xvbmVkVGFyZ2V0OiBvYmosXG4gICAgICAgICAgICBsZWFmSG9zdDogaG9zdCxcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIF9VcGRhdGVyO1xufSgpKTtcbmZ1bmN0aW9uIGlzT2JqZWN0T3JBcnJheShvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufVxuZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSlcbiAgICAgICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICAgIHZhciBjbG9uZWQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBjbG9uZWRba2V5XSA9IG9ialtrZXldOyB9KTtcbiAgICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gZGVlcFVwZGF0ZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gbmV3IF9VcGRhdGVyKHsgdHlwZTogJ3Jvb3QnLCBib3VuZFRhcmdldDogdGFyZ2V0IH0pO1xufVxuZXhwb3J0cy5kZWVwVXBkYXRlID0gZGVlcFVwZGF0ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENoYXJVdGlsO1xuKGZ1bmN0aW9uIChDaGFyVXRpbCkge1xuICAgIGNsYXNzIENoYXJTdHJlYW0ge1xuICAgICAgICBjb25zdHJ1Y3RvcihzLCBzdGFydHBvcywgZW5kcG9zLCBoYXNFT0YpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzRU9GID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBzO1xuICAgICAgICAgICAgaWYgKGhhc0VPRiAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0VPRiA9IGhhc0VPRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydHBvcyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0cG9zID0gMDsgLy8gbm90IHNwZWNpZmllZDsgc2V0IGRlZmF1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0cG9zID4gcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0cG9zID0gcy5sZW5ndGg7IC8vIHNlZWsgdG9vIGZhcjsgc2V0IEVPRlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydHBvcyA9IHN0YXJ0cG9zOyAvLyBzcGVjaWZpZWQgYW5kIGluIGJvdW5kc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZHBvcyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvcyA9IHMubGVuZ3RoOyAvLyBub3Qgc3BlY2lmaWVkOyBzZXQgZGVmYXVsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kcG9zID4gcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvcyA9IHMubGVuZ3RoOyAvLyBzZWVrIHRvbyBmYXI7IHNldCBFT0ZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9zID0gZW5kcG9zOyAvLyBzcGVjaWZpZWQgYW5kIGluIGJvdW5kc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRwb3MgPiB0aGlzLmVuZHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRwb3MgPSB0aGlzLmVuZHBvczsgLy8gaWYgdGhlIHVzZXIgZmxpcHBlZCBwb3NpdGlvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIG9mIHRoZSBlbmQgb2YgdGhlIGlucHV0IGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpc0VPRigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0VPRiAmJiB0aGlzLnN0YXJ0cG9zID09IHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgSmF2c2NyaXB0IHByaW1pdGl2ZSBzdHJpbmcgb2YgdGhlIHNsaWNlIG9mIGlucHV0XG4gICAgICAgICAqIHJlcHJlc2VudGVkIGJ5IHRoaXMgQ2hhclN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQuc3Vic3RyaW5nKHRoaXMuc3RhcnRwb3MsIHRoaXMuZW5kcG9zKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBDaGFyU3RyZWFtIHJlcHJlc2VudGluZyB0aGUgaW5wdXQgZnJvbSB0aGVcbiAgICAgICAgICogY3VycmVudCBzdGFydCBwb3NpdGlvbiB0byBhbiBlbmQgcG9zaXRpb24gbnVtIGNoYXJzIGZyb21cbiAgICAgICAgICogdGhlIGN1cnJlbnQgc3RhcnQgcG9zaXRpb24uICBJZiBzdGFydHBvcyArIG51bSA+IGVuZHBvcyxcbiAgICAgICAgICogdGhlIGN1cnJlbnQgQ2hhclN0cmVhbSBpcyByZXR1cm5lZC5cbiAgICAgICAgICogQHBhcmFtIG51bVxuICAgICAgICAgKi9cbiAgICAgICAgcGVlayhudW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0cG9zICsgbnVtID4gdGhpcy5lbmRwb3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXdIYXNFT0YgPSB0aGlzLnN0YXJ0cG9zICsgbnVtID09IHRoaXMuZW5kcG9zICYmIHRoaXMuaGFzRU9GO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbSh0aGlzLmlucHV0LCB0aGlzLnN0YXJ0cG9zLCB0aGlzLnN0YXJ0cG9zICsgbnVtLCBuZXdIYXNFT0YpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IENoYXJTdHJlYW0gcmVwcmVzZW50aW5nIHRoZSBzdHJpbmcgYWZ0ZXJcbiAgICAgICAgICogc2Vla2luZyBudW0gY2hhcmFjdGVycyBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gbnVtXG4gICAgICAgICAqL1xuICAgICAgICBzZWVrKG51bSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRwb3MgKyBudW0gPiB0aGlzLmVuZHBvcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbSh0aGlzLmlucHV0LCB0aGlzLmVuZHBvcywgdGhpcy5lbmRwb3MsIHRoaXMuaGFzRU9GKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbSh0aGlzLmlucHV0LCB0aGlzLnN0YXJ0cG9zICsgbnVtLCB0aGlzLmVuZHBvcywgdGhpcy5oYXNFT0YpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IENoYXJTdHJlYW0gcmVwcmVzZW50aW5nIHRoZSBoZWFkIG9mIHRoZSBpbnB1dCBhdFxuICAgICAgICAgKiB0aGUgY3VycmVudCBwb3NpdGlvbi4gIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIENoYXJTdHJlYW0gaXNcbiAgICAgICAgICogZW1wdHkuXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hhc0VPRiA9IHRoaXMuc3RhcnRwb3MgKyAxID09IHRoaXMuZW5kcG9zICYmIHRoaXMuaGFzRU9GO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbSh0aGlzLmlucHV0LCB0aGlzLnN0YXJ0cG9zLCB0aGlzLnN0YXJ0cG9zICsgMSwgbmV3SGFzRU9GKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGhlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBDaGFyU3RyZWFtIHJlcHJlc2VudGluZyB0aGUgdGFpbCBvZiB0aGUgaW5wdXQgYXRcbiAgICAgICAgICogdGhlIGN1cnJlbnQgcG9zaXRpb24uICBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBDaGFyU3RyZWFtIGlzXG4gICAgICAgICAqIGVtcHR5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGFpbCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENoYXJTdHJlYW0odGhpcy5pbnB1dCwgdGhpcy5zdGFydHBvcyArIDEsIHRoaXMuZW5kcG9zLCB0aGlzLmhhc0VPRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSB0YWlsIG9mIGFuIGVtcHR5IHN0cmluZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gaXMgZW1wdHkuIE5vdGVcbiAgICAgICAgICogdGhhdCBhIENoYXJTdHJlYW0gYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgY29udGFpbnMgYW4gZW1wdHlcbiAgICAgICAgICogc3RyaW5nIGJ1dCB0aGF0IGFuIGVtcHR5IHN0cmluZyBtYXkgbm90IGJlIHRoZSBlbmQtb2YtZmlsZSAoaS5lLixcbiAgICAgICAgICogaXNFT0YgaXMgZmFsc2UpLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNFbXB0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0cG9zID09IHRoaXMuZW5kcG9zO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyByZW1haW5pbmcgYXRcbiAgICAgICAgICogdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBsZW5ndGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmRwb3MgLSB0aGlzLnN0YXJ0cG9zO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzdWJzdHJpbmcgYmV0d2VlbiBzdGFydCBhbmQgZW5kIGF0IHRoZVxuICAgICAgICAgKiBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gc3RhcnQgdGhlIHN0YXJ0IGluZGV4IG9mIHRoZSBzdWJzdHJpbmcsIGluY2x1c2l2ZVxuICAgICAgICAgKiBAcGFyYW0gZW5kIHRoZSBlbmQgaW5kZXggb2YgdGhlIHN1YnN0cmluZywgZXhjbHVzaXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdWJzdHJpbmcoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQyID0gdGhpcy5zdGFydHBvcyArIHN0YXJ0O1xuICAgICAgICAgICAgY29uc3QgZW5kMiA9IHRoaXMuc3RhcnRwb3MgKyBlbmQ7XG4gICAgICAgICAgICBjb25zdCBuZXdIYXNFT0YgPSB0aGlzLmVuZHBvcyA9PSBlbmQyICYmIHRoaXMuaGFzRU9GO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFyU3RyZWFtKHRoaXMuaW5wdXQsIHN0YXJ0MiwgZW5kMiwgbmV3SGFzRU9GKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgY3VycmVudCBDaGFyU3RyZWFtIHdpdGhcbiAgICAgICAgICogdGhlIGdpdmVuIENoYXJTdHJlYW0uIE5vdGU6IHJldHVybmVkIG9iamVjdCBkb2VzIG5vdFxuICAgICAgICAgKiByZXVzZSBvcmlnaW5hbCBpbnB1dCBzdHJpbmcsIGFuZCBzdGFydHBvcyBhbmQgZW5kcG9zXG4gICAgICAgICAqIGFyZSByZXNldC4gSWYgdGhlIGdpdmVuIENoYXJTdHJlYW0gY29udGFpbnMgRU9GLCB0aGVcbiAgICAgICAgICogY29uY2F0ZW5hdGVkIENoYXJTdHJlYW0gd2lsbCBhbHNvIGNvbnRhaW4gRU9GLlxuICAgICAgICAgKiBAcGFyYW0gY3MgdGhlIENoYXJTdHJlYW0gdG8gY29uY2F0IHRvIHRoaXMgQ2hhclN0cmVhbVxuICAgICAgICAgKi9cbiAgICAgICAgY29uY2F0KGNzKSB7XG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy50b1N0cmluZygpICsgY3MudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhclN0cmVhbShzLCAwLCBzLmxlbmd0aCwgY3MuaGFzRU9GKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uY2F0ZW5hdGUgYW4gYXJyYXkgb2YgQ2hhclN0cmVhbSBvYmplY3RzIGludG8gYSBzaW5nbGVcbiAgICAgICAgICogQ2hhclN0cmVhbSBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSBjc3MgYSBDaGFyU3RyZWFtW11cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjb25jYXQoY3NzKSB7XG4gICAgICAgICAgICBpZiAoY3NzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFyU3RyZWFtKFwiXCIsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjcyA9IGNzc1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjcyA9IGNzLmNvbmNhdChjc3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2hhclV0aWwuQ2hhclN0cmVhbSA9IENoYXJTdHJlYW07XG59KShDaGFyVXRpbCA9IGV4cG9ydHMuQ2hhclV0aWwgfHwgKGV4cG9ydHMuQ2hhclV0aWwgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhcnN0cmVhbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcmltaXRpdmVzXzEgPSByZXF1aXJlKFwiLi9wcmltaXRpdmVzXCIpO1xuZXhwb3J0cy5QcmltaXRpdmVzID0gcHJpbWl0aXZlc18xLlByaW1pdGl2ZXM7XG52YXIgY2hhcnN0cmVhbV8xID0gcmVxdWlyZShcIi4vY2hhcnN0cmVhbVwiKTtcbmV4cG9ydHMuQ2hhclV0aWwgPSBjaGFyc3RyZWFtXzEuQ2hhclV0aWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNoYXJzdHJlYW1fMSA9IHJlcXVpcmUoXCIuL2NoYXJzdHJlYW1cIik7XG52YXIgUHJpbWl0aXZlcztcbihmdW5jdGlvbiAoUHJpbWl0aXZlcykge1xuICAgIGNsYXNzIEVPRk1hcmsge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgICAgICBzdGF0aWMgZ2V0IEluc3RhbmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlIHx8ICh0aGlzLl9pbnN0YW5jZSA9IG5ldyB0aGlzKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuRU9GTWFyayA9IEVPRk1hcms7XG4gICAgUHJpbWl0aXZlcy5FT0YgPSBFT0ZNYXJrLkluc3RhbmNlO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdWNjZXNzZnVsIHBhcnNlLlxuICAgICAqL1xuICAgIGNsYXNzIFN1Y2Nlc3Mge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgc3VjY2Vzc2Z1bCBwYXJzZS5cbiAgICAgICAgICogQHBhcmFtIGlzdHJlYW0gVGhlIHJlbWFpbmluZyBzdHJpbmcuXG4gICAgICAgICAqIEBwYXJhbSByZXMgVGhlIHJlc3VsdCBvZiB0aGUgcGFyc2VcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKGlzdHJlYW0sIHJlcykge1xuICAgICAgICAgICAgdGhpcy50YWcgPSBcInN1Y2Nlc3NcIjtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzdHJlYW0gPSBpc3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSByZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUHJpbWl0aXZlcy5TdWNjZXNzID0gU3VjY2VzcztcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgZmFpbGVkIHBhcnNlLlxuICAgICAqL1xuICAgIGNsYXNzIEZhaWx1cmUge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZmFpbGVkIHBhcnNlLlxuICAgICAgICAgKiBAcGFyYW0gaXN0cmVhbSBUaGUgc3RyaW5nLCB1bm1vZGlmaWVkLCB0aGF0IHdhcyBnaXZlbiB0byB0aGUgcGFyc2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoaXN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy50YWcgPSBcImZhaWx1cmVcIjtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzdHJlYW0gPSBpc3RyZWFtO1xuICAgICAgICB9XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuRmFpbHVyZSA9IEZhaWx1cmU7XG4gICAgLyoqXG4gICAgICogcmVzdWx0IHN1Y2NlZWRzIHdpdGhvdXQgY29uc3VtaW5nIGFueSBpbnB1dCwgYW5kIHJldHVybnMgdi5cbiAgICAgKiBAcGFyYW0gdiBUaGUgcmVzdWx0IG9mIHRoZSBwYXJzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQodikge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IG5ldyBTdWNjZXNzKGlzdHJlYW0sIHYpO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAvKipcbiAgICAgKiB6ZXJvIGZhaWxzIHdpdGhvdXQgY29uc3VtaW5nIGFueSBpbnB1dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6ZXJvKCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnplcm8gPSB6ZXJvO1xuICAgIC8qKlxuICAgICAqIGl0ZW0gc3VjY2Vzc2Z1bGx5IGNvbnN1bWVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaWYgdGhlIGlucHV0XG4gICAgICogc3RyaW5nIGlzIG5vbi1lbXB0eSwgb3RoZXJ3aXNlIGl0IGZhaWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl0ZW0oKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzdHJlYW0uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKGlzdHJlYW0udGFpbCgpLCBpc3RyZWFtLmhlYWQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuaXRlbSA9IGl0ZW07XG4gICAgLyoqXG4gICAgICogYmluZCBpcyBhIGN1cnJpZWQgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHBhcnNlciBwIGFuZCByZXR1cm5zXG4gICAgICogYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgcGFyc2VyIGYgd2hpY2ggcmV0dXJucyB0aGUgY29tcG9zaXRpb25cbiAgICAgKiBvZiBwIGFuZCBmLiAgSWYgX2FueV8gb2YgdGhlIHBhcnNlcnMgZmFpbCwgdGhlIG9yaWdpbmFsIGlucHV0c3RyZWFtXG4gICAgICogaXMgcmV0dXJuZWQgaW4gdGhlIEZhaWx1cmUgb2JqZWN0IChpLmUuLCBiaW5kIGJhY2t0cmFja3MpLlxuICAgICAqIEBwYXJhbSBwIEEgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZChwKSB7XG4gICAgICAgIHJldHVybiAoZikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHIgPSBwKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoci50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvID0gZihyLnJlc3VsdCkoci5pbnB1dHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG8udGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjogcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90ZTogYmFja3RyYWNrcywgcmV0dXJuaW5nIG9yaWdpbmFsIGlzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOiByZXR1cm4gbmV3IEZhaWx1cmUoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5iaW5kID0gYmluZDtcbiAgICBmdW5jdGlvbiBkZWxheShwKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBwO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmRlbGF5ID0gZGVsYXk7XG4gICAgLyoqXG4gICAgICogc2VxIGlzIGEgY3VycmllZCBmdW5jdGlvbiB0aGF0IHRha2VzIGEgcGFyc2VyIHAsIGEgcGFyc2VyIHEsXG4gICAgICogYW5kIGEgZnVuY3Rpb24gZi4gSXQgYXBwbGllcyBwIHRvIHRoZSBpbnB1dCwgcGFzc2luZyB0aGVcbiAgICAgKiByZW1haW5pbmcgaW5wdXQgc3RyZWFtIHRvIHE7IHEgaXMgdGhlbiBhcHBsaWVkLiAgVGhlIGZ1bmN0aW9uXG4gICAgICogZiB0YWtlcyB0aGUgcmVzdWx0IG9mIHAgYW5kIHEsIGFzIGEgdHVwbGUsIGFuZCByZXR1cm5zXG4gICAgICogYSBzaW5nbGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwIEEgcGFyc2VyXG4gICAgICovXG4gICAgLy8gZXhwb3J0IGxldCBzZXEgPSBmdW5jdGlvbjxULFUsVj4ocDogSVBhcnNlcjxUPikge1xuICAgIC8vICAgICByZXR1cm4gKHE6IElQYXJzZXI8VT4pID0+IHtcbiAgICAvLyAgICAgICAgIHJldHVybiAoZjogKGU6IFtULFVdKSA9PiBWKSA9PiB7XG4gICAgLy8gICAgICAgICAgICAgcmV0dXJuIGJpbmQ8VCxWPihwKSgoeCkgPT4ge1xuICAgIC8vICAgICAgICAgICAgICAgICByZXR1cm4gYmluZDxVLFY+KHEpKCh5KSA9PiB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBsZXQgdHVwIDogW1QsVV0gPSBbeCx5XTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ8Vj4oZih0dXApKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgfSk7XG4gICAgLy8gICAgICAgICAgICAgfSk7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH07XG4gICAgLy8gfVxuICAgIGZ1bmN0aW9uIHNlcShwKSB7XG4gICAgICAgIHJldHVybiAocSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChmKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQocCkoKHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQocSkoKHkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0dXAgPSBbeCwgeV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0KGYodHVwKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5zZXEgPSBzZXE7XG4gICAgLyoqXG4gICAgICogc2F0IHRha2VzIGEgcHJlZGljYXRlIGFuZCB5aWVsZHMgYSBwYXJzZXIgdGhhdCBjb25zdW1lcyBhXG4gICAgICogc2luZ2xlIGNoYXJhY3RlciBpZiB0aGUgY2hhcmFjdGVyIHNhdGlzZmllcyB0aGUgcHJlZGljYXRlLFxuICAgICAqIG90aGVyd2lzZSBpdCBmYWlscy5cbiAgICAgKiBAcGFyYW0gcHJlZCBhIGNoYXJhY3RlciBwcmVkaWNhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYXQocHJlZCkge1xuICAgICAgICBsZXQgcHJlZDIgPSAoY3MpID0+IHByZWQoY3MudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBhID0gaXRlbSgpO1xuICAgICAgICBsZXQgYiA9ICh4KSA9PiB7XG4gICAgICAgICAgICBpZiAocHJlZDIoeCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0KHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGJpbmQoYSkoYik7XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuc2F0ID0gc2F0O1xuICAgIC8qKlxuICAgICAqIGNoYXIgdGFrZXMgYSBjaGFyYWN0ZXIgYW5kIHlpZWxkcyBhIHBhcnNlciB0aGF0IGNvbnN1bWVcbiAgICAgKiB0aGF0IGNoYXJhY3Rlci4gVGhlIHJldHVybmVkIHBhcnNlciBzdWNjZWVkcyBpZiB0aGUgbmV4dFxuICAgICAqIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQgc3RyZWFtIGlzIGMsIG90aGVyd2lzZSBpdCBmYWlscy5cbiAgICAgKiBAcGFyYW0gY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYXIoYykge1xuICAgICAgICBpZiAoYy5sZW5ndGggIT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hhciBwYXJzZXIgdGFrZXMgYSBzdHJpbmcgb2YgbGVuZ3RoIDEgKGkuZS4sIGEgY2hhcilcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNhdCh4ID0+IHggPT0gYyk7XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuY2hhciA9IGNoYXI7XG4gICAgLyoqXG4gICAgICogbGV0dGVyIHJldHVybnMgYSBwYXJzZXIgdGhhdCBjb25zdW1lcyBhIHNpbmdsZSBhbHBoYWJldGljXG4gICAgICogY2hhcmFjdGVyLCBmcm9tIGEteiwgcmVnYXJkbGVzcyBvZiBjYXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxldHRlcigpIHtcbiAgICAgICAgbGV0IGNvbnRhaW5zX2xldHRlciA9ICh4KSA9PiB7XG4gICAgICAgICAgICBsZXQgYV9sZXR0ZXIgPSAvW0EtWmEtel0vO1xuICAgICAgICAgICAgcmV0dXJuIHgubWF0Y2goYV9sZXR0ZXIpICE9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNhdChjb250YWluc19sZXR0ZXIpO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmxldHRlciA9IGxldHRlcjtcbiAgICAvKipcbiAgICAgKiBkaWdpdCByZXR1cm5zIGEgcGFyc2VyIHRoYXQgY29uc3VtZXMgYSBzaW5nbGUgbnVtZXJpY1xuICAgICAqIGNoYXJhY3RlciwgZnJvbSAwLTkuICBOb3RlIHRoYXQgdGhlIHR5cGUgb2YgdGhlIHJlc3VsdFxuICAgICAqIGlzIGEgc3RyaW5nLCBub3QgYSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlnaXQoKSB7XG4gICAgICAgIHJldHVybiBzYXQoeCA9PiB4ID09IFwiMFwiXG4gICAgICAgICAgICB8fCB4ID09IFwiMVwiXG4gICAgICAgICAgICB8fCB4ID09IFwiMlwiXG4gICAgICAgICAgICB8fCB4ID09IFwiM1wiXG4gICAgICAgICAgICB8fCB4ID09IFwiNFwiXG4gICAgICAgICAgICB8fCB4ID09IFwiNVwiXG4gICAgICAgICAgICB8fCB4ID09IFwiNlwiXG4gICAgICAgICAgICB8fCB4ID09IFwiN1wiXG4gICAgICAgICAgICB8fCB4ID09IFwiOFwiXG4gICAgICAgICAgICB8fCB4ID09IFwiOVwiKTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5kaWdpdCA9IGRpZ2l0O1xuICAgIC8qKlxuICAgICAqIHVwcGVyIHJldHVybnMgYSBwYXJzZXIgdGhhdCBjb25zdW1lcyBhIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICAgKiBpZiB0aGF0IGNoYXJhY3RlciBpcyB1cHBlcmNhc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBwZXIoKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgbGV0IG8xID0gbGV0dGVyKCkoaXN0cmVhbSk7XG4gICAgICAgICAgICBzd2l0Y2ggKG8xLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIGxldCBvMiA9IHNhdCh4ID0+IHggPT0geC50b1VwcGVyQ2FzZSgpKShvMS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG8yLnRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFpbHVyZShpc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZXZlciBoYXBwZW5zXCIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnVwcGVyID0gdXBwZXI7XG4gICAgLyoqXG4gICAgICogbG93ZXIgcmV0dXJucyBhIHBhcnNlciB0aGF0IGNvbnN1bWVzIGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAqIGlmIHRoYXQgY2hhcmFjdGVyIGlzIGxvd2VyY2FzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb3dlcigpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgbzEgPSBsZXR0ZXIoKShpc3RyZWFtKTtcbiAgICAgICAgICAgIHN3aXRjaCAobzEudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgbGV0IG8yID0gc2F0KHggPT4geCA9PSB4LnRvTG93ZXJDYXNlKCkpKG8xLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobzIudGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5ldmVyIGhhcHBlbnNcIik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMubG93ZXIgPSBsb3dlcjtcbiAgICAvKipcbiAgICAgKiBjaG9pY2Ugc3BlY2lmaWVzIGFuIG9yZGVyZWQgY2hvaWNlIGJldHdlZW4gdHdvIHBhcnNlcnMsXG4gICAgICogcDEgYW5kIHAyLiBUaGUgcmV0dXJuZWQgcGFyc2VyIHdpbGwgZmlyc3QgYXBwbHlcbiAgICAgKiBwYXJzZXIgcDEuICBJZiBwMSBzdWNjZWVkcywgcDEncyBPdXRjb21lIGlzIHJldHVybmVkLlxuICAgICAqIElmIHAxIGZhaWxzLCBwMiBpcyBhcHBsaWVkIGFuZCB0aGUgT3V0Y29tZSBvZiBwMiBpcyByZXR1cm5lZC5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBnaXZlbiB0byBwMSBhbmQgcDIgaXMgZXhhY3RseVxuICAgICAqIHRoZSBzYW1lIGlucHV0IHN0cmVhbS5cbiAgICAgKiBAcGFyYW0gcDEgQSBwYXJzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hvaWNlKHAxKSB7XG4gICAgICAgIHJldHVybiAocDIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBvID0gcDEoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDIoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5jaG9pY2UgPSBjaG9pY2U7XG4gICAgLyoqXG4gICAgICogYXBwZnVuIGFsbG93cyB0aGUgdXNlciB0byBhcHBseSBhIGZ1bmN0aW9uIGYgdG9cbiAgICAgKiB0aGUgcmVzdWx0IG9mIGEgcGFyc2VyIHAsIGFzc3VtaW5nIHRoYXQgcCBpcyBzdWNjZXNzZnVsLlxuICAgICAqIEBwYXJhbSBwIEEgcGFyc2VyLiAgVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgfD4+XG4gICAgICogZnVuY3Rpb24gZnJvbSBGUGFyc2VjLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFwcGZ1bihwKSB7XG4gICAgICAgIHJldHVybiAoZikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG8gPSBwKGlzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoby50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2VzcyhvLmlucHV0c3RyZWFtLCBmKG8ucmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmFwcGZ1biA9IGFwcGZ1bjtcbiAgICAvKipcbiAgICAgKiBtYW55IHJlcGVhdGVkbHkgYXBwbGllcyB0aGUgcGFyc2VyIHAgdW50aWwgcCBmYWlscy4gbWFueSBhbHdheXNcbiAgICAgKiBzdWNjZWVkcywgZXZlbiBpZiBpdCBtYXRjaGVzIG5vdGhpbmcuICBtYW55IHRyaWVzIHRvIGd1YXJkXG4gICAgICogYWdhaW5zdCBhbiBpbmZpbml0ZSBsb29wIGJ5IHJhaXNpbmcgYW4gZXhjZXB0aW9uIGlmIHAgc3VjY2VlZHNcbiAgICAgKiB3aXRob3V0IGNoYW5naW5nIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICogQHBhcmFtIHBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYW55KHApIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgaXN0cmVhbTIgPSBpc3RyZWFtO1xuICAgICAgICAgICAgbGV0IG91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBzdWNjZWVkcyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoIWlzdHJlYW0yLmlzRW1wdHkoKSAmJiBzdWNjZWVkcykge1xuICAgICAgICAgICAgICAgIGxldCBvID0gcChpc3RyZWFtMik7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzdHJlYW0yID09IG8uaW5wdXRzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZXIgbG9vcHMgaW5maW5pdGVseS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3RyZWFtMiA9IG8uaW5wdXRzdHJlYW07XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2goby5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZWVkcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKGlzdHJlYW0yLCBvdXRwdXRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5tYW55ID0gbWFueTtcbiAgICAvKipcbiAgICAgKiBtYW55MSByZXBlYXRlZGx5IGFwcGxpZXMgdGhlIHBhcnNlciBwIHVudGlsIHAgZmFpbHMuIG1hbnkxIG11c3RcbiAgICAgKiBzdWNjZWVkIGF0IGxlYXN0IG9uY2UuICBtYW55MSB0cmllcyB0byBndWFyZCBhZ2FpbnN0IGFuIGluZmluaXRlXG4gICAgICogbG9vcCBieSByYWlzaW5nIGFuIGV4Y2VwdGlvbiBpZiBwIHN1Y2NlZWRzIHdpdGhvdXQgY2hhbmdpbmcgdGhlXG4gICAgICogcGFyc2VyIHN0YXRlLlxuICAgICAqIEBwYXJhbSBwXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFueTEocCkge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzZXEocCkobWFueShwKSkodHVwID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaGQgPSB0dXBbXCIwXCJdO1xuICAgICAgICAgICAgICAgIGxldCB0bCA9IHR1cFtcIjFcIl07XG4gICAgICAgICAgICAgICAgdGwudW5zaGlmdChoZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRsO1xuICAgICAgICAgICAgfSkoaXN0cmVhbSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMubWFueTEgPSBtYW55MTtcbiAgICAvKipcbiAgICAgKiBzdHIgeWllbGRzIGEgcGFyc2VyIGZvciB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICAqIEBwYXJhbSBzIEEgc3RyaW5nXG4gICAgICovXG4gICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYWN0dWFsbHkgYmUgYSBzZXF1ZW5jZSBvZiBwYXJzZXJzIGNvbnN0cnVjdGVkXG4gICAgLy8gZnJvbSB0aGUgc3RyaW5nIHNcbiAgICBmdW5jdGlvbiBzdHIocykge1xuICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIC8vIGVzY2FwZSByZWdleCBtZXRhY2hhcmFjdGVyc1xuICAgICAgICAgICAgLy8gKHRoaXMgbGlrZWx5IG5lZWRzIHdvcmspXG4gICAgICAgICAgICBsZXQgczIgPSBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4gICAgICAgICAgICBsZXQgcmUgPSBuZXcgUmVnRXhwKFwiXlwiICsgczIpO1xuICAgICAgICAgICAgaWYgKGlzdHJlYW0udG9TdHJpbmcoKS5tYXRjaChyZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW0gPSBpc3RyZWFtLnN1YnN0cmluZyhzLmxlbmd0aCwgaXN0cmVhbS5sZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gaXN0cmVhbS5zdWJzdHJpbmcoMCwgcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2VzcyhyZW0sIHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhaWx1cmUoaXN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuc3RyID0gc3RyO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwYXJzZXIgdGhhdCBzdWNjZWVkcyBvbmx5IGlmIHRoZSBlbmQgb2YgdGhlXG4gICAgICogaW5wdXQgaGFzIGJlZW4gcmVhY2hlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlb2YoKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzdHJlYW0uaXNFT0YoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2Vzcyhpc3RyZWFtLCBQcmltaXRpdmVzLkVPRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhaWx1cmUoaXN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuZW9mID0gZW9mO1xuICAgIC8qKlxuICAgICAqIGZyZXN1bHQgcmV0dXJucyBhIHBhcnNlciB0aGF0IGFwcGxpZXMgdGhlIHBhcnNlciBwLFxuICAgICAqIGFuZCBpZiBwIHN1Y2NlZWRzLCByZXR1cm5zIHRoZSB2YWx1ZSB4LlxuICAgICAqIEBwYXJhbSBwIGEgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJlc3VsdChwKSB7XG4gICAgICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQocCkoKHQpID0+IHJlc3VsdCh4KSkoaXN0cmVhbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmZyZXN1bHQgPSBmcmVzdWx0O1xuICAgIC8qKlxuICAgICAqIGxlZnQgcmV0dXJucyBhIHBhcnNlciB0aGF0IGFwcGxpZXMgdGhlIHBhcnNlciBwLFxuICAgICAqIHRoZW4gdGhlIHBhcnNlciBxLCBhbmQgaWYgYm90aCBhcmUgc3VjY2Vzc2Z1bCxcbiAgICAgKiByZXR1cm5zIHRoZSByZXN1bHQgb2YgcC5cbiAgICAgKiBAcGFyYW0gcCBhIHBhcnNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlZnQocCkge1xuICAgICAgICByZXR1cm4gKHEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiaW5kKHApKCh0KSA9PiBmcmVzdWx0KHEpKHQpKShpc3RyZWFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMubGVmdCA9IGxlZnQ7XG4gICAgLyoqXG4gICAgICogcmlnaHQgcmV0dXJucyBhIHBhcnNlciB0aGF0IGFwcGxpZXMgdGhlIHBhcnNlciBwLFxuICAgICAqIHRoZW4gdGhlIHBhcnNlciBxLCBhbmQgaWYgYm90aCBhcmUgc3VjY2Vzc2Z1bCxcbiAgICAgKiByZXR1cm5zIHRoZSByZXN1bHQgb2YgcS5cbiAgICAgKiBAcGFyYW0gcCBhIHBhcnNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJpZ2h0KHApIHtcbiAgICAgICAgcmV0dXJuIChxKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluZChwKShfID0+IHEpKGlzdHJlYW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy5yaWdodCA9IHJpZ2h0O1xuICAgIC8qKlxuICAgICAqIGJldHdlZW4gcmV0dXJucyBhIHBhcnNlciB0aGF0IGFwcGxpZXMgdGhlIHBhcnNlclxuICAgICAqIHBvcGVuLCBwLCBhbmQgcGNsb3NlIGluIHNlcXVlbmNlLCBhbmQgaWYgYWxsIGFyZVxuICAgICAqIHN1Y2Nlc3NmdWwsIHJldHVybnMgdGhlIHJlc3VsdCBvZiBwLlxuICAgICAqIEBwYXJhbSBwb3BlbiB0aGUgZmlyc3QgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmV0d2Vlbihwb3Blbikge1xuICAgICAgICByZXR1cm4gKHBjbG9zZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChwKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGwgPSBsZWZ0KHApKHBjbG9zZSk7XG4gICAgICAgICAgICAgICAgbGV0IHIgPSByaWdodChwb3BlbikobCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLmJldHdlZW4gPSBiZXR3ZWVuO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWJ1ZyBwYXJzZXIgdGFrZXMgYSBwYXJzZXIgcCBhbmQgYSBkZWJ1ZyBzdHJpbmcsXG4gICAgICogcHJpbnRpbmcgdGhlIGRlYnVnIHN0cmluZyBhcyBhIHNpZGUtZWZmZWN0IGJlZm9yZVxuICAgICAqIGFwcGx5aW5nIHAgdG8gdGhlIGlucHV0LlxuICAgICAqIEBwYXJhbSBwIGEgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVidWcocCkge1xuICAgICAgICByZXR1cm4gKGxhYmVsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGlzdHJlYW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImFwcGx5OiBcIiArIGxhYmVsKTtcbiAgICAgICAgICAgICAgICBsZXQgbyA9IHAoaXN0cmVhbSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzdWNjZXNzOiBcIiArIGxhYmVsICsgXCIsIHN0YXJ0cG9zOiBcIiArIGlzdHJlYW0uc3RhcnRwb3MgKyBcIiwgZW5kcG9zOiBcIiArIGlzdHJlYW0uZW5kcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJmYWlsdXJlOiBcIiArIGxhYmVsICsgXCIsIHN0YXJ0cG9zOiBcIiArIGlzdHJlYW0uc3RhcnRwb3MgKyBcIiwgZW5kcG9zOiBcIiArIGlzdHJlYW0uZW5kcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaW1pdGl2ZXMuZGVidWcgPSBkZWJ1ZztcbiAgICBsZXQgd3NjaGFycyA9IGNob2ljZShzYXQoYyA9PiBjID09ICcgJyB8fCBjID09ICdcXHQnKSkobmwoKSk7XG4gICAgLyoqXG4gICAgICogd3MgbWF0Y2hlcyB6ZXJvIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnM6XG4gICAgICogJyAnLCAnXFx0JywgJ1xcbicsIG9yICdcXHJcXG4nXG4gICAgICogd3MgcmV0dXJucyBtYXRjaGVkIHdoaXRlc3BhY2UgaW4gYSBzaW5nbGUgQ2hhclN0cmVhbSByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3MoKSB7XG4gICAgICAgIHJldHVybiAoaXN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgbGV0IG8gPSBtYW55KHdzY2hhcnMpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2VzcyhvLmlucHV0c3RyZWFtLCBjaGFyc3RyZWFtXzEuQ2hhclV0aWwuQ2hhclN0cmVhbS5jb25jYXQoby5yZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAvLyB3cyBuZXZlciBmYWlsc1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLndzID0gd3M7XG4gICAgLyoqXG4gICAgICogd3MxIG1hdGNoZXMgb25lIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnM6XG4gICAgICogJyAnLCAnXFx0JywgJ1xcbicsIG9yICdcXHJcXG4nXG4gICAgICogd3MxIHJldHVybnMgbWF0Y2hlZCB3aGl0ZXNwYWNlIGluIGEgc2luZ2xlIENoYXJTdHJlYW0gcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdzMSgpIHtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBsZXQgbyA9IG1hbnkxKHdzY2hhcnMpKGlzdHJlYW0pO1xuICAgICAgICAgICAgc3dpdGNoIChvLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VjY2VzcyhvLmlucHV0c3RyZWFtLCBjaGFyc3RyZWFtXzEuQ2hhclV0aWwuQ2hhclN0cmVhbS5jb25jYXQoby5yZXN1bHQpKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpbWl0aXZlcy53czEgPSB3czE7XG4gICAgLyoqXG4gICAgICogbmwgbWF0Y2hlcyBhbmQgcmV0dXJucyBhIG5ld2xpbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmwoKSB7XG4gICAgICAgIHJldHVybiBQcmltaXRpdmVzLmNob2ljZShQcmltaXRpdmVzLnN0cihcIlxcblwiKSkoUHJpbWl0aXZlcy5zdHIoXCJcXHJcXG5cIikpO1xuICAgIH1cbiAgICBQcmltaXRpdmVzLm5sID0gbmw7XG4gICAgZnVuY3Rpb24gZ3JvdXBCeShsaXN0LCBrZXlHZXR0ZXIpIHtcbiAgICAgICAgbGV0IG0gPSBuZXcgTWFwKCk7XG4gICAgICAgIGxpc3QuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5R2V0dGVyKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKCFtLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbS5zZXQoa2V5LCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY29sbGVjdGlvbiA9IG0uZ2V0KGtleSk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2goaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyU2F0KHN0cnMpIHtcbiAgICAgICAgLy8gc29ydCBzdHJpbmdzIGZpcnN0IGJ5IGxlbmd0aCwgYW5kIHRoZW4gbGV4aWNvZ3JhcGljYWxseTtcbiAgICAgICAgLy8gc2xpY2UoKSBjYWxsZWQgaGVyZSBzbyBhcyBub3QgdG8gbW9kaWZ5IG9yaWdpbmFsIGFycmF5XG4gICAgICAgIGxldCBzbWFwID0gZ3JvdXBCeShzdHJzLCBzID0+IHMubGVuZ3RoKTtcbiAgICAgICAgbGV0IHNpemVzID0gW107XG4gICAgICAgIC8vIGZpbmQgc2l6ZSBjbGFzc2VzO1xuICAgICAgICAvLyBhbHNvIHNvcnQgZWFjaCBzZXQgb2YgZXF1aXZhbGVudC1sZW5ndGggdmFsdWVzXG4gICAgICAgIHNtYXAuZm9yRWFjaCgodmFscywga2V5LCBtKSA9PiB7XG4gICAgICAgICAgICBzaXplcy5wdXNoKGtleSk7XG4gICAgICAgICAgICB2YWxzLnNvcnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNpemVzLnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIChpc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAvLyBzdGFydCB3aXRoIHRoZSBzbWFsbGVzdCBzaXplIGNsYXNzICAgICAgIFxuICAgICAgICAgICAgZm9yIChsZXQgcGVla0luZGV4ID0gMDsgcGVla0luZGV4IDwgc2l6ZXMubGVuZ3RoOyBwZWVrSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIHNpemUgY2xhc3MsIHRyeSBtYXRjaGluZyBhbGwgb2ZcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3RyaW5nczsgaWYgb25lIGlzIGZvdW5kLCByZXR1cm4gdGhlXG4gICAgICAgICAgICAgICAgLy8gYXBwcm9wcmlhdGUgQ2hhclN0cmVhbTsgaWYgbm90LCBmYWlsLlxuICAgICAgICAgICAgICAgIGxldCBwZWVrID0gaXN0cmVhbS5wZWVrKHNpemVzW3BlZWtJbmRleF0pO1xuICAgICAgICAgICAgICAgIGxldCB0YWlsID0gaXN0cmVhbS5zZWVrKHNpemVzW3BlZWtJbmRleF0pO1xuICAgICAgICAgICAgICAgIGxldCBjYW5kaWRhdGVzID0gc21hcC5nZXQoc2l6ZXNbcGVla0luZGV4XSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY0luZGV4ID0gMDsgY0luZGV4IDwgY2FuZGlkYXRlcy5sZW5ndGg7IGNJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGVzW2NJbmRleF0gPT09IHBlZWsudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKHRhaWwsIHBlZWspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGlzdHJlYW0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcmltaXRpdmVzLnN0clNhdCA9IHN0clNhdDtcbn0pKFByaW1pdGl2ZXMgPSBleHBvcnRzLlByaW1pdGl2ZXMgfHwgKGV4cG9ydHMuUHJpbWl0aXZlcyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmltaXRpdmVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0XzEgPSByZXF1aXJlKFwiLi4vbGlmdFwiKTtcbi8qKlxuICogQ29udmVydHMgYW4gQXJyYXktbGlrZSBvYmplY3QgKHN1Y2ggYXMgYW4gYXJndW1lbnRzIG9yIE5vZGVMaXN0IGluc3RhbmNlKSB0byBhIHJlZ3VsYXIgQXJyYXlcbiAqL1xuZnVuY3Rpb24gZnJvbUFycmF5TGlrZShhcnJheUxpa2UpIHtcbiAgICByZXR1cm4gbmV3IGxpZnRfMS5BcnJheU9wcyhbXS5zbGljZS5jYWxsKGFycmF5TGlrZSkpO1xufVxuZXhwb3J0cy5mcm9tQXJyYXlMaWtlID0gZnJvbUFycmF5TGlrZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0XzEgPSByZXF1aXJlKFwiLi4vbGlmdFwiKTtcbi8qXG4qIFJldHVybnMgYSBudW1iZXJbXSB3cmFwcGVyIHdpdGggYWxsIG51bWJlcnMgZnJvbSBzdGFydCB0byBzdG9wIChpbmNsdXNpdmUpLFxuKiBpbmNyZW1lbnRlZCBvciBkZWNyZW1lbnRlZCBieSBzdGVwLlxuKi9cbmZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RvcCA9IGFyZ3VtZW50c1swXSAtIDE7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGluY3JlYXNpbmcgPSBzdGVwID4gMDtcbiAgICB2YXIgbmV4dCA9IHN0YXJ0O1xuICAgIHdoaWxlICgoaW5jcmVhc2luZyAmJiBuZXh0IDw9IHN0b3ApIHx8ICghaW5jcmVhc2luZyAmJiBuZXh0ID49IHN0b3ApKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5leHQpO1xuICAgICAgICBuZXh0ID0gbmV4dCArIHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgbGlmdF8xLkFycmF5T3BzKHJlc3VsdCk7XG59XG5leHBvcnRzLnJhbmdlID0gcmFuZ2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5mdW5jdGlvbiB0dXBsZShhcnIpIHtcbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0cy50dXBsZSA9IHR1cGxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGlzXzEgPSByZXF1aXJlKFwiLi4vb2JqZWN0L2lzXCIpO1xudmFyIGN1cnJlbnRNZW1vSWQgPSAwO1xuLyoqXG4gKiBNZW1vaXplcyBhIGZ1bmN0aW9uIG9mIGFyYml0cmFyeSBhcml0eS5cbiAqIFRoaXMgaGFzIHR3byBtYWluIHVzZXM6XG4gKiAgIDEpIFJlZHVjaW5nIHRoZSBDUFUgdGltZSB0YWtlbiBieSBleHBlbnNpdmUgY2FsY3VsYXRpb25zIGF0IHRoZSBjb3N0IG9mIHNvbWUgbWVtb3J5IG92ZXJoZWFkXG4gKiAgIDIpIFByb2R1Y2luZyBzdGFibGUgcmVmZXJlbmNlcyBmb3IgYSBnaXZlbiBzZXQgb2YgYXJndW1lbnRzLiBVc2VmdWwgd2hlbiByZWx5aW5nIG9uIHJlZmVyZW5jZSBlcXVhbGl0eS5cbiAqXG4gKiBNZW1vaXplZCBmdW5jdGlvbnMga2VlcCBpbnRlcm5hbCBzdGF0ZS4gSWYgeW91IHdpc2ggdG8gY2xlYXIgdGhhdCBzdGF0ZSBlbnRpcmVseSwgeW91IGNhbiByZWNyZWF0ZSB0aGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuLCBvcHRpb25zKSB7XG4gICAgLy8gVGhlIHVuaXF1ZSBwcm9wZXJ0eSBuYW1lIHVzZWQgYnkgdGhpcyBtZW1vaXplIGZ1bmN0aW9uIGluc3RhbmNlLlxuICAgIC8vIFRoaXMgaXMgdXNlZCB0byBzdG9yZSB0aGUgaWQvcmVmZXJlbmNlIG9mIG9iamVjdCBhcmd1bWVudHMsIGFzIFdlYWsgbWFwcy9zZXRzIGFyZSB2ZXJ5IGxpbWl0ZWQuXG4gICAgdmFyIG1lbW9LZXkgPSBcIl9fbWVtb19fXCIgKyBjdXJyZW50TWVtb0lkKys7XG4gICAgdmFyIGxhc3RBcmdLZXlzID0gW107XG4gICAgdmFyIGNhY2hlU2l6ZSA9IChvcHRpb25zICYmIG9wdGlvbnMuY2FjaGVTaXplKSB8fCAzMDtcbiAgICB2YXIga2V5RnVuY3Rpb24gPSBvcHRpb25zICYmIG9wdGlvbnMua2V5O1xuICAgIC8vIFRoZSB1bmlxdWUgaWRzL3JlZmVyZW5jZXMgb2Ygb2JqZWN0cyBpbnNpZGUgdGhlIGFyaXR5TkNhY2hlIGNhY2hlXG4gICAgdmFyIG9iaklkID0gMDtcbiAgICB2YXIgYXJpdHkwQ2FjaGU7XG4gICAgdmFyIGFyaXR5TkNhY2hlO1xuICAgIHZhciBrZXlDYWNoZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIDAgYXJndW1lbnRzIGVkZ2UtY2FzZVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICghYXJpdHkwQ2FjaGUpXG4gICAgICAgICAgICAgICAgYXJpdHkwQ2FjaGUgPSBmdW4oKTtcbiAgICAgICAgICAgIHJldHVybiBhcml0eTBDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjdXN0b20ga2V5IGZ1bmN0aW9uXG4gICAgICAgIGVsc2UgaWYgKGtleUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBrZXlDYWNoZSA9IGtleUNhY2hlIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleUZ1bmN0aW9uLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGtleUNhY2hlW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGxhc3RBcmdLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICBsaW1pdENhY2hlU2l6ZShrZXlDYWNoZSwgbGFzdEFyZ0tleXMsIGNhY2hlU2l6ZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ga2V5Q2FjaGVba2V5XSA9IGZ1bi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTiBhcmd1bWVudHNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhcml0eU5DYWNoZSA9IGFyaXR5TkNhY2hlIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGtleSA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgICAgICAgdmFyIGFyZ0tleSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoaXNfMS5vYmplY3QoYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdLZXkgPSBhcmdbbWVtb0tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXJnS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb24gZW51bWVyYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFyZywgbWVtb0tleSwgeyB2YWx1ZTogXCJvYmpcIiArIG9iaklkKysgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdLZXkgPSBhcmdbbWVtb0tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ0tleSA9IGFyZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5ICs9IChhcmdLZXkgKyAnXycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGFyaXR5TkNhY2hlW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGxhc3RBcmdLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICBsaW1pdENhY2hlU2l6ZShhcml0eU5DYWNoZSwgbGFzdEFyZ0tleXMsIGNhY2hlU2l6ZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXJpdHlOQ2FjaGVba2V5XSA9IGZ1bi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5tZW1vaXplID0gbWVtb2l6ZTtcbmZ1bmN0aW9uIGxpbWl0Q2FjaGVTaXplKGNhY2hlLCBsYXN0QXJnS2V5cywgc2l6ZSkge1xuICAgIGlmIChsYXN0QXJnS2V5cy5sZW5ndGggPT09IHNpemUgKyAxKSB7XG4gICAgICAgIHZhciBrZXkgPSBsYXN0QXJnS2V5cy5zaGlmdCgpO1xuICAgICAgICBkZWxldGUgY2FjaGVba2V5XTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbGlmdF8xID0gcmVxdWlyZShcIi4vbGlmdFwiKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbGlmdF8xW1wiZGVmYXVsdFwiXTtcbnZhciBsaWZ0XzIgPSByZXF1aXJlKFwiLi9saWZ0XCIpO1xuZXhwb3J0cy5BcnJheU9wcyA9IGxpZnRfMi5BcnJheU9wcztcbmV4cG9ydHMuT2JqZWN0T3BzID0gbGlmdF8yLk9iamVjdE9wcztcbmV4cG9ydHMuTnVtYmVyT3BzID0gbGlmdF8yLk51bWJlck9wcztcbmV4cG9ydHMuU3RyaW5nT3BzID0gbGlmdF8yLlN0cmluZ09wcztcbmV4cG9ydHMuRGF0ZU9wcyA9IGxpZnRfMi5EYXRlT3BzO1xuZXhwb3J0cy5nZXRWYWx1ZSA9IGxpZnRfMi5nZXRWYWx1ZTtcbnZhciBpbW11cGRhdGVfMSA9IHJlcXVpcmUoXCJpbW11cGRhdGVcIik7XG5leHBvcnRzLnVwZGF0ZSA9IGltbXVwZGF0ZV8xLnVwZGF0ZTtcbmV4cG9ydHMuZGVlcFVwZGF0ZSA9IGltbXVwZGF0ZV8xLmRlZXBVcGRhdGU7XG5leHBvcnRzLkRFTEVURSA9IGltbXVwZGF0ZV8xLkRFTEVURTtcbnZhciBvcHRpb25fMSA9IHJlcXVpcmUoXCIuL29wdGlvblwiKTtcbmV4cG9ydHMuT3B0aW9uID0gb3B0aW9uXzEuT3B0aW9uO1xuZXhwb3J0cy5Ob25lID0gb3B0aW9uXzEuTm9uZTtcbmV4cG9ydHMuU29tZSA9IG9wdGlvbl8xLlNvbWU7XG52YXIgcmVzdWx0XzEgPSByZXF1aXJlKFwiLi9yZXN1bHRcIik7XG5leHBvcnRzLlJlc3VsdCA9IHJlc3VsdF8xLlJlc3VsdDtcbmV4cG9ydHMuT2sgPSByZXN1bHRfMS5PaztcbmV4cG9ydHMuRXJyID0gcmVzdWx0XzEuRXJyO1xudmFyIHJhbmdlXzEgPSByZXF1aXJlKFwiLi9hcnJheS9yYW5nZVwiKTtcbmV4cG9ydHMucmFuZ2UgPSByYW5nZV8xLnJhbmdlO1xudmFyIGZyb21BcnJheUxpa2VfMSA9IHJlcXVpcmUoXCIuL2FycmF5L2Zyb21BcnJheUxpa2VcIik7XG5leHBvcnRzLmZyb21BcnJheUxpa2UgPSBmcm9tQXJyYXlMaWtlXzEuZnJvbUFycmF5TGlrZTtcbnZhciB0dXBsZV8xID0gcmVxdWlyZShcIi4vYXJyYXkvdHVwbGVcIik7XG5leHBvcnRzLnR1cGxlID0gdHVwbGVfMS50dXBsZTtcbnZhciBzZXRfMSA9IHJlcXVpcmUoXCIuL29iamVjdC9zZXRcIik7XG5leHBvcnRzLlNldCA9IHNldF8xLlNldDtcbnZhciBtZW1vaXplXzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbi9tZW1vaXplXCIpO1xuZXhwb3J0cy5tZW1vaXplID0gbWVtb2l6ZV8xLm1lbW9pemU7XG52YXIgaXNUeXBlID0gcmVxdWlyZShcIi4vb2JqZWN0L2lzXCIpO1xuZXhwb3J0cy5pcyA9IGlzVHlwZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLkFycmF5T3BzKG9iaik7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgIHJldHVybiBuZXcgZXhwb3J0cy5EYXRlT3BzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuU3RyaW5nT3BzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuTnVtYmVyT3BzKG9iaik7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLk9iamVjdE9wcyhvYmopO1xufTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbGlmdDtcbmZ1bmN0aW9uIGdldFZhbHVlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ICYmIGlucHV0WydfaXNMaWZ0V3JhcHBlciddXG4gICAgICAgID8gaW5wdXQudmFsdWUoKVxuICAgICAgICA6IGlucHV0O1xufVxuZXhwb3J0cy5nZXRWYWx1ZSA9IGdldFZhbHVlO1xuZnVuY3Rpb24gbWFrZU9wcygpIHtcbiAgICB2YXIgT3BzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBPcHMoX3ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzTGlmdFdyYXBwZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIE9wcy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfTtcbiAgICAgICAgcmV0dXJuIE9wcztcbiAgICB9KCkpO1xuICAgIHJldHVybiBPcHM7XG59XG5leHBvcnRzLkFycmF5T3BzID0gbWFrZU9wcygpO1xuZXhwb3J0cy5PYmplY3RPcHMgPSBtYWtlT3BzKCk7XG5leHBvcnRzLk51bWJlck9wcyA9IG1ha2VPcHMoKTtcbmV4cG9ydHMuU3RyaW5nT3BzID0gbWFrZU9wcygpO1xuZXhwb3J0cy5EYXRlT3BzID0gbWFrZU9wcygpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuLyoqIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaXMgYW4gQXJyYXkgKi9cbmV4cG9ydHMuYXJyYXkgPSBBcnJheS5pc0FycmF5O1xuLyoqIFJldHVybnMgd2hldGhlciB0aGlzIG9iamVjdCBpcyBhIGZ1bmN0aW9uICovXG5mdW5jdGlvbiBmdW5jKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5leHBvcnRzLmZ1bmMgPSBmdW5jO1xuLyoqIFJldHVybnMgd2hldGhlciB0aGlzIG9iamVjdCBpcyBhIHN0cmluZyAqL1xuZnVuY3Rpb24gc3RyaW5nKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpO1xufVxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG4vKiogUmV0dXJucyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIGEgbnVtYmVyICovXG5mdW5jdGlvbiBudW1iZXIob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyk7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbi8qKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvYmplY3QgaXMgYSBib29sZWFuICovXG5mdW5jdGlvbiBib29sZWFuKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nKTtcbn1cbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XG4vKiogUmV0dXJucyB3aGV0aGVyIHRoaXMgdmFsdWUgaXMgYW4gb2JqZWN0IChlLmcgbm90IGEgcHJpbWl0aXZlOiBkYXRlcywgYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKSkgKi9cbmZ1bmN0aW9uIG9iamVjdChvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5leHBvcnRzLm9iamVjdCA9IG9iamVjdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0XzEgPSByZXF1aXJlKFwiLi4vbGlmdFwiKTtcbi8qKlxuICogQ3JlYXRlcyBhIFNldC1saWtlIG9iamVjdCAoc3RyaW5nIGtleXMsIHRydWUgdmFsdWVzKSBmcm9tIGEgbGlzdCBvZiBrZXlzXG4gKi9cbmZ1bmN0aW9uIFNldCgpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGtleXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiByZXN1bHRba2V5XSA9IHRydWU7IH0pO1xuICAgIHJldHVybiBuZXcgbGlmdF8xLk9iamVjdE9wcyhyZXN1bHQpO1xufVxuZXhwb3J0cy5TZXQgPSBTZXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbGlmdF8xID0gcmVxdWlyZShcIi4uL2xpZnRcIik7XG4vLyBUaGUgT3B0aW9uIGZhY3RvcnkgLyBzdGF0aWMgb2JqZWN0XG52YXIgT3B0aW9uT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzRGVmKHZhbHVlKSA/IFNvbWUodmFsdWUpIDogZXhwb3J0cy5Ob25lO1xufTtcbk9wdGlvbk9iamVjdC5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgaWYgKGV4cG9ydHMuT3B0aW9uLmlzT3B0aW9uKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZ2V0KCk7XG4gICAgICAgIGlmICghaXNEZWYodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTm9uZTtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gU29tZSh2YWx1ZXMpO1xufTtcbk9wdGlvbk9iamVjdC5pc09wdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICh2YWx1ZS50eXBlID09PSAnc29tZScgfHwgdmFsdWUudHlwZSA9PT0gJ25vbmUnKTtcbn07XG5mdW5jdGlvbiBtYWtlTm9uZSgpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuICAgIGZ1bmN0aW9uIHJldHVybk5vbmUoKSB7IHJldHVybiBleHBvcnRzLk5vbmU7IH1cbiAgICBzZWxmLnR5cGUgPSAnbm9uZSc7XG4gICAgc2VsZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH07XG4gICAgc2VsZi5pc0RlZmluZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICBzZWxmLmZvckVhY2ggPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgc2VsZi5tYXAgPSByZXR1cm5Ob25lO1xuICAgIHNlbGYuZmxhdE1hcCA9IHJldHVybk5vbmU7XG4gICAgc2VsZi5maWx0ZXIgPSByZXR1cm5Ob25lO1xuICAgIHNlbGYuZm9sZCA9IGZ1bmN0aW9uIChpZkVtcHR5KSB7IHJldHVybiBpZkVtcHR5KCk7IH07XG4gICAgc2VsZi5vckVsc2UgPSBmdW5jdGlvbiAoYWx0KSB7IHJldHVybiBhbHQoKTsgfTtcbiAgICBzZWxmLmdldE9yRWxzZSA9IGZ1bmN0aW9uIChhbHQpIHsgcmV0dXJuIGFsdDsgfTtcbiAgICBzZWxmLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWZ0XzFbXCJkZWZhdWx0XCJdKFtdKTsgfTtcbiAgICBzZWxmLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ05vbmUnOyB9O1xuICAgIHNlbGYudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9Tb21lKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuX1NvbWUucHJvdG90eXBlID0ge1xuICAgIHR5cGU6ICdzb21lJyxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfSxcbiAgICBpc0RlZmluZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgZm4odGhpcy52YWx1ZSk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcHRpb24obGlmdF8xLmdldFZhbHVlKGZuKHRoaXMudmFsdWUpKSk7XG4gICAgfSxcbiAgICBmbGF0TWFwOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKHRoaXMudmFsdWUpO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKHRoaXMudmFsdWUpID8gdGhpcyA6IGV4cG9ydHMuTm9uZTtcbiAgICB9LFxuICAgIGZvbGQ6IGZ1bmN0aW9uIChpZkVtcHR5LCBpZkRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGlmRGVmaW5lZCh0aGlzLnZhbHVlKTtcbiAgICB9LFxuICAgIG9yRWxzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldE9yRWxzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9LFxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxpZnRfMVtcImRlZmF1bHRcIl0oW3RoaXMudmFsdWVdKTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNvbWUoXCIgKyB0aGlzLnZhbHVlICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGlzRGVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLk9wdGlvbiA9IE9wdGlvbk9iamVjdDtcbi8qKiBDcmVhdGVzIGEgbmV3IFNvbWUgaW5zdGFuY2UgdXNpbmcgYSBub24gbnVsbGFibGUgdmFsdWUgKi9cbi8vIGV4dGVuZHMge30gdG8gcHJldmVudCBudWxsIGFuZCB1bmRlZmluZWQgYmVpbmcgcGFzc2VkXG5mdW5jdGlvbiBTb21lKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfU29tZSh2YWx1ZSk7XG59XG5leHBvcnRzLlNvbWUgPSBTb21lO1xuZXhwb3J0cy5Ob25lID0gbWFrZU5vbmUoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsaWZ0XzEgPSByZXF1aXJlKFwiLi4vbGlmdFwiKTtcbnZhciBSZXN1bHRPYmplY3QgPSB7fTtcblJlc3VsdE9iamVjdC5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIG9rVmFsdWVzID0gW107XG4gICAgdmFyIGN1cnJlbnRSZXN1bHQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRSZXN1bHRfMSA9IGFycltpXTtcbiAgICAgICAgaWYgKCFjdXJyZW50UmVzdWx0XzEuaXNPaygpKVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRfMTtcbiAgICAgICAgb2tWYWx1ZXMucHVzaChjdXJyZW50UmVzdWx0XzEuZ2V0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gT2sob2tWYWx1ZXMpO1xufTtcblJlc3VsdE9iamVjdC5pc1Jlc3VsdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICh2YWx1ZS50eXBlID09PSAnb2snIHx8IHZhbHVlLnR5cGUgPT09ICdlcnInKTtcbn07XG5mdW5jdGlvbiBfT2sodmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xufVxuX09rLnByb3RvdHlwZSA9IHtcbiAgICB0eXBlOiAnb2snLFxuICAgIGlzT2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gT2sobGlmdF8xLmdldFZhbHVlKGZuKHRoaXMuX3ZhbHVlKSkpO1xuICAgIH0sXG4gICAgbWFwRXJyb3I6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZsYXRNYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4odGhpcy5fdmFsdWUpO1xuICAgIH0sXG4gICAgZm9sZDogZnVuY3Rpb24gKGlmRXJyLCBpZk9rKSB7XG4gICAgICAgIHJldHVybiBpZk9rKHRoaXMuX3ZhbHVlKTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIk9rKFwiICsgdGhpcy5fdmFsdWUgKyBcIilcIjtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxufTtcbmZ1bmN0aW9uIF9FcnIoZXJyb3IpIHtcbiAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xufVxuX0Vyci5wcm90b3R5cGUgPSB7XG4gICAgdHlwZTogJ2VycicsXG4gICAgaXNPazogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG1hcEVycm9yOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIEVycihmbih0aGlzLl9lcnJvcikpO1xuICAgIH0sXG4gICAgZmxhdE1hcDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZm9sZDogZnVuY3Rpb24gKGlmRXJyLCBpZk9rKSB7XG4gICAgICAgIHJldHVybiBpZkVycih0aGlzLl9lcnJvcik7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJFcnIoXCIgKyB0aGlzLl9lcnJvciArIFwiKVwiO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICB9XG59O1xuZXhwb3J0cy5SZXN1bHQgPSBSZXN1bHRPYmplY3Q7XG5mdW5jdGlvbiBPayh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX09rKHZhbHVlKTtcbn1cbmV4cG9ydHMuT2sgPSBPaztcbmZ1bmN0aW9uIEVycihlcnJvcikge1xuICAgIHJldHVybiBuZXcgX0VycihlcnJvcik7XG59XG5leHBvcnRzLkVyciA9IEVycjtcbiJdfQ==
